import {
  $,
  AccessibilityHelpNLS,
  Action,
  ActionBar,
  ActionRunner,
  ActionViewItem,
  AsyncIterableObject,
  BaseActionViewItem,
  CONTEXT_ACCESSIBILITY_MODE_ENABLED,
  CSSIcon,
  CancellationToken,
  CancellationTokenSource,
  CancellationTokenSource2,
  CharacterSet,
  CodeActionProviderRegistry,
  CodeEditorWidget,
  CodeLensProviderRegistry,
  Codicon,
  Color,
  ColorProviderRegistry,
  ColorScheme,
  CommandsRegistry,
  CompletionProviderRegistry,
  Configuration,
  ContextKeyExpr,
  CopyOptions,
  CoreEditingCommands,
  CountBadge,
  CursorColumns,
  CursorMoveCommands,
  CursorState,
  DataUri,
  DeclarationProviderRegistry,
  DeferredPromise,
  DefinitionProviderRegistry,
  Delayer,
  Dimension,
  Disposable,
  DisposableStore,
  DocumentHighlightKind,
  DocumentHighlightProviderRegistry,
  DocumentRangeFormattingEditProviderRegistry,
  DocumentRangeSemanticTokensProviderRegistry,
  DocumentSymbolProviderRegistry,
  DomEmitter,
  DomScrollableElement,
  DynamicCssRules,
  EDITOR_FONT_DEFAULTS,
  EditOperation,
  EditorAction,
  EditorCommand,
  EditorContextKeys,
  EditorFontLigatures,
  EditorOptions,
  EditorState,
  EditorStateCancellationTokenSource,
  EditorZoom,
  Emitter,
  Emitter2,
  Event,
  EventHelper,
  EventType,
  EventType2,
  Extensions,
  Extensions2,
  FileAccess,
  FoldingRangeKind,
  FoldingRangeProviderRegistry,
  FormattingEdit,
  FuzzyScore,
  Gesture,
  GlobalMouseMoveMonitor,
  GoToLineNLS,
  HSVA,
  HighlightedLabel,
  HistoryInputBox,
  HoverProviderRegistry,
  IAccessibilityService,
  IBulkEditService,
  IClipboardService,
  ICodeEditorService,
  ICommandService,
  IConfigurationService,
  IContextKeyService,
  IContextMenuService,
  IContextViewService,
  IDialogService,
  IEditorProgressService,
  IEditorWorkerService,
  IInstantiationService,
  IKeybindingService,
  ILabelService,
  ILanguageConfigurationService,
  IListService,
  ILogService,
  IMarkerData,
  IMarkerDecorationsService,
  IMarkerService,
  IMenuService,
  IModeService,
  IModelService,
  INotificationService,
  IOpenerService,
  IQuickInputService,
  IStandaloneThemeService,
  IStorageService,
  ITelemetryService,
  ITextModelService,
  ITextResourceConfigurationService,
  IThemeService,
  IUndoRedoService,
  IWorkspaceContextService,
  IWorkspaceTrustManagementService,
  IconLabel,
  IdGenerator,
  IdleValue,
  ImplementationProviderRegistry,
  InMemoryClipboardMetadataManager,
  IndentAction,
  InlayHintKind,
  InlayHintsProviderRegistry,
  InlineCompletionTriggerKind,
  InlineCompletionsProviderRegistry,
  InspectTokensNLS,
  InvisibleCharacters,
  IsWindowsContext,
  Iterable,
  KeyChord,
  KeyCode,
  KeyMod,
  KeybindingsRegistry,
  LRUCache,
  LanguageConfigurationRegistry,
  LanguageFeatureRequestDelays,
  LcsDiff,
  LineDecoration,
  LineTokens,
  LinkProviderRegistry,
  LinkedEditingRangeProviderRegistry,
  LinkedList,
  List,
  MarkdownString,
  MarkerSeverity,
  MarkerSeverity2,
  MarkerTag,
  MenuId,
  MenuItemAction,
  MenuRegistry,
  MinimapPosition,
  ModelDecorationOptions,
  ModifierKeyEmitter,
  MoveOperations,
  MultiCommand,
  MultiEditorAction,
  MutableDisposable,
  NULL_STATE,
  NullOpenerService,
  OS,
  OnTypeFormattingEditProviderRegistry,
  OrthogonalEdge,
  OverviewRulerLane,
  PLAINTEXT_MODE_ID,
  Position,
  Position2,
  Progress,
  QuickCommandNLS,
  QuickHelpNLS,
  QuickOutlineNLS,
  RGBA,
  Range,
  Range2,
  RawContextKey,
  ReferenceProviderRegistry,
  Registry,
  RenameProviderRegistry,
  RenderLineInput,
  ReplaceCommand,
  ReplaceCommandThatPreservesSelection,
  ReplaceCommandThatSelectsText,
  ResourceEdit,
  ResourceMap,
  RunOnceScheduler,
  SEMANTIC_HIGHLIGHTING_SETTING_ID,
  Sash,
  Schemas,
  ScrollableElement,
  SearchParams,
  Selection,
  Selection2,
  SelectionDirection,
  SelectionRangeRegistry,
  Separator,
  ShiftCommand,
  SignatureHelpProviderRegistry,
  SignatureHelpTriggerKind,
  SimpleKeybinding,
  Sizing,
  SplitView,
  StableEditorScrollState,
  StandardKeyboardEvent,
  StandardMouseEvent,
  StopWatch,
  SubmenuAction,
  SubmenuItemAction,
  SymbolKinds,
  TabFocus,
  TernarySearchTree,
  TextModel,
  TextModelCancellationTokenSource,
  ThemeIcon,
  TimeoutTimer,
  ToggleHighContrastNLS,
  Token,
  TokenMetadata,
  TokenizationRegistry,
  TypeDefinitionProviderRegistry,
  TypeOperations,
  UILabelProvider,
  URI,
  UnicodeTextModelHighlighter,
  Uri,
  Widget,
  WillSaveStateReason,
  WordOperations,
  WordPartOperations,
  WorkbenchAsyncDataTree,
  WorkbenchListFocusContextKey,
  activeContrastBorder,
  addDisposableGenericMouseDownListner,
  addDisposableGenericMouseUpListner,
  addDisposableListener,
  addDisposableNonBubblingMouseOutListener,
  addStandardDisposableGenericMouseDownListner,
  addStandardDisposableListener,
  alert,
  alertFormattingEdits,
  anyScore,
  append,
  asArray,
  asCSSUrl,
  assertIsDefined,
  assertType,
  attachBadgeStyler,
  attachListStyler,
  basename,
  basename2,
  basenameOrAuthority,
  binarySearch,
  canceled,
  clamp,
  clearNode,
  cloneAndChange,
  coalesce,
  combinedDisposable,
  commonPrefixLength,
  commonSuffixLength,
  compare,
  compareIgnoreCase,
  completionKindFromString,
  completionKindToCssClass,
  containsRTL,
  containsUppercaseCharacter,
  contrastBorder,
  countEOL,
  createCSSRule,
  createCancelableAsyncIterable,
  createCancelablePromise,
  createDecorator,
  createElement,
  createFastDomNode,
  createMatches,
  createStringBuilder,
  createStyleSheet,
  deepClone,
  defaultGenerator,
  dirname,
  dirname2,
  disposableTimeout,
  dispose,
  editor,
  editorActiveLinkForeground,
  editorBackground,
  editorBracketMatchBackground,
  editorBracketMatchBorder,
  editorErrorBorder,
  editorErrorForeground,
  editorFindMatch,
  editorFindMatchBorder,
  editorFindMatchHighlight,
  editorFindMatchHighlightBorder,
  editorFindRangeHighlight,
  editorFindRangeHighlightBorder,
  editorForeground,
  editorHoverBackground,
  editorHoverBorder,
  editorHoverForeground,
  editorHoverHighlight,
  editorHoverStatusBarBackground,
  editorInfoBorder,
  editorInfoForeground,
  editorInlayHintBackground,
  editorInlayHintForeground,
  editorInlayHintParameterBackground,
  editorInlayHintParameterForeground,
  editorInlayHintTypeBackground,
  editorInlayHintTypeForeground,
  editorLightBulbAutoFixForeground,
  editorLightBulbForeground,
  editorSelectionBackground,
  editorSelectionHighlight,
  editorSelectionHighlightBorder,
  editorWarningBorder,
  editorWarningForeground,
  editorWidgetBackground,
  editorWidgetBorder,
  editorWidgetForeground,
  editorWidgetResizeBorder,
  editor_api_exports,
  equals,
  errorForeground,
  escape,
  escapeRegExpCharacters,
  extUri,
  extname,
  findFirstInSorted,
  first,
  firstNonWhitespaceIndex,
  flatten,
  focusBorder,
  foreground,
  format,
  formatDocumentRangesWithSelectedProvider,
  formatDocumentWithSelectedProvider,
  fuzzyScore,
  fuzzyScoreGracefulAggressive,
  getClientArea,
  getCodeEditor,
  getComputedStyle,
  getDocumentRangeSemanticTokens,
  getDomNodePagePosition,
  getLeadingWhitespace,
  getMapForWordSeparators,
  getOnTypeFormattingEdits,
  getShadowRoot,
  getTopLeftOffset,
  getTotalWidth,
  ghostTextBackground,
  ghostTextBorder,
  ghostTextForeground,
  groupBy,
  hasDocumentRangeSemanticTokensProvider,
  hasDriveLetter,
  hash,
  hide,
  iconForeground,
  illegalArgument,
  inUntrustedWorkspace,
  inputActiveOptionBackground,
  inputActiveOptionBorder,
  inputActiveOptionForeground,
  inputBackground,
  inputBorder,
  inputForeground,
  inputValidationErrorBackground,
  inputValidationErrorBorder,
  inputValidationErrorForeground,
  inputValidationInfoBackground,
  inputValidationInfoBorder,
  inputValidationInfoForeground,
  inputValidationWarningBackground,
  inputValidationWarningBorder,
  inputValidationWarningForeground,
  isArray,
  isBasicASCII,
  isCodeEditor,
  isDiffEditor,
  isDisposable,
  isEmptyMarkdownString,
  isEqual,
  isFalsyOrEmpty,
  isFalsyOrWhitespace,
  isFirefox,
  isHighSurrogate,
  isIOS,
  isInDOM,
  isInShadowDOM,
  isLinux,
  isLocationLink,
  isLowSurrogate,
  isLowerAsciiLetter,
  isMacintosh,
  isModelDecorationVisible,
  isNative,
  isNonEmptyArray,
  isNumber,
  isObject,
  isPromiseCanceledError,
  isRootOrDriveLetter,
  isSafari,
  isSemanticColoringEnabled,
  isStandalone,
  isString,
  isUndefined,
  isUpperAsciiLetter,
  isWeb,
  isWindows,
  joinPath,
  languages,
  lastNonWhitespaceIndex,
  listFocusHighlightForeground,
  listHighlightForeground,
  localize,
  markdownEscapeEscapedIcons,
  matchesContiguousSubString,
  matchesPrefix,
  matchesWords,
  minimapFindMatch,
  minimapSelectionOccurrenceHighlight,
  minimapUnicodeHighlight,
  mixin,
  noBreakWhitespace,
  nullTokenize,
  nullTokenize2,
  onDidChangeZoomLevel,
  onUnexpectedError,
  onUnexpectedExternalError,
  once,
  oneOf,
  or,
  originalFSPath,
  overviewRulerFindMatchForeground,
  overviewRulerRangeHighlight,
  overviewRulerSelectionHighlightForeground,
  overviewRulerUnicodeHighlightForeground,
  parse,
  parseHrefAndDimensions,
  prepend,
  problemsErrorIconForeground,
  problemsInfoIconForeground,
  problemsWarningIconForeground,
  quickInputListFocusBackground,
  quickInputListFocusForeground,
  quickInputListFocusIconForeground,
  quickSelect,
  raceCancellation,
  registerColor,
  registerEditorAction,
  registerEditorCommand,
  registerEditorContribution,
  registerIcon,
  registerInstantiatedEditorAction,
  registerModelAndPositionCommand,
  registerModelCommand,
  registerMultiEditorAction,
  registerSingleton,
  registerThemingParticipant,
  removeCSSRulesContainingSelector,
  removeMarkdownEscapes,
  renderFormattedText,
  renderLabelWithIcons,
  renderViewLine,
  reset,
  resolvePath,
  runWhenIdle,
  sep,
  severity_default,
  show,
  size,
  splitLines,
  standardMouseMoveMerger,
  status,
  stripIcons,
  stripWildcards,
  textCodeBlockBackground,
  textLinkActiveForeground,
  textLinkForeground,
  themeColorFromId,
  timeout,
  toDisposable,
  toMultilineTokens2,
  tokenizeToString,
  toolbarHoverBackground,
  trackFocus,
  transparent,
  trim,
  unicodeHighlightConfigKeys,
  widgetClose,
  widgetShadow,
  withNullAsUndefined
} from "./chunk-LA37COEH.js";
import "./chunk-AW43RHKU.js";

// node_modules/monaco-editor/esm/vs/language/typescript/monaco.contribution.js
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var typescriptVersion = "4.4.4";
var monaco_editor_core_exports = {};
__markAsModule(monaco_editor_core_exports);
__reExport(monaco_editor_core_exports, editor_api_exports);
var ModuleKind;
(function(ModuleKind2) {
  ModuleKind2[ModuleKind2["None"] = 0] = "None";
  ModuleKind2[ModuleKind2["CommonJS"] = 1] = "CommonJS";
  ModuleKind2[ModuleKind2["AMD"] = 2] = "AMD";
  ModuleKind2[ModuleKind2["UMD"] = 3] = "UMD";
  ModuleKind2[ModuleKind2["System"] = 4] = "System";
  ModuleKind2[ModuleKind2["ES2015"] = 5] = "ES2015";
  ModuleKind2[ModuleKind2["ESNext"] = 99] = "ESNext";
})(ModuleKind || (ModuleKind = {}));
var JsxEmit;
(function(JsxEmit2) {
  JsxEmit2[JsxEmit2["None"] = 0] = "None";
  JsxEmit2[JsxEmit2["Preserve"] = 1] = "Preserve";
  JsxEmit2[JsxEmit2["React"] = 2] = "React";
  JsxEmit2[JsxEmit2["ReactNative"] = 3] = "ReactNative";
  JsxEmit2[JsxEmit2["ReactJSX"] = 4] = "ReactJSX";
  JsxEmit2[JsxEmit2["ReactJSXDev"] = 5] = "ReactJSXDev";
})(JsxEmit || (JsxEmit = {}));
var NewLineKind;
(function(NewLineKind2) {
  NewLineKind2[NewLineKind2["CarriageReturnLineFeed"] = 0] = "CarriageReturnLineFeed";
  NewLineKind2[NewLineKind2["LineFeed"] = 1] = "LineFeed";
})(NewLineKind || (NewLineKind = {}));
var ScriptTarget;
(function(ScriptTarget2) {
  ScriptTarget2[ScriptTarget2["ES3"] = 0] = "ES3";
  ScriptTarget2[ScriptTarget2["ES5"] = 1] = "ES5";
  ScriptTarget2[ScriptTarget2["ES2015"] = 2] = "ES2015";
  ScriptTarget2[ScriptTarget2["ES2016"] = 3] = "ES2016";
  ScriptTarget2[ScriptTarget2["ES2017"] = 4] = "ES2017";
  ScriptTarget2[ScriptTarget2["ES2018"] = 5] = "ES2018";
  ScriptTarget2[ScriptTarget2["ES2019"] = 6] = "ES2019";
  ScriptTarget2[ScriptTarget2["ES2020"] = 7] = "ES2020";
  ScriptTarget2[ScriptTarget2["ESNext"] = 99] = "ESNext";
  ScriptTarget2[ScriptTarget2["JSON"] = 100] = "JSON";
  ScriptTarget2[ScriptTarget2["Latest"] = 99] = "Latest";
})(ScriptTarget || (ScriptTarget = {}));
var ModuleResolutionKind;
(function(ModuleResolutionKind2) {
  ModuleResolutionKind2[ModuleResolutionKind2["Classic"] = 1] = "Classic";
  ModuleResolutionKind2[ModuleResolutionKind2["NodeJs"] = 2] = "NodeJs";
})(ModuleResolutionKind || (ModuleResolutionKind = {}));
var LanguageServiceDefaultsImpl = class {
  constructor(compilerOptions, diagnosticsOptions, workerOptions, inlayHintsOptions) {
    this._onDidChange = new monaco_editor_core_exports.Emitter();
    this._onDidExtraLibsChange = new monaco_editor_core_exports.Emitter();
    this._extraLibs = Object.create(null);
    this._removedExtraLibs = Object.create(null);
    this._eagerModelSync = false;
    this.setCompilerOptions(compilerOptions);
    this.setDiagnosticsOptions(diagnosticsOptions);
    this.setWorkerOptions(workerOptions);
    this.setInlayHintsOptions(inlayHintsOptions);
    this._onDidExtraLibsChangeTimeout = -1;
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get onDidExtraLibsChange() {
    return this._onDidExtraLibsChange.event;
  }
  get workerOptions() {
    return this._workerOptions;
  }
  get inlayHintsOptions() {
    return this._inlayHintsOptions;
  }
  getExtraLibs() {
    return this._extraLibs;
  }
  addExtraLib(content, _filePath) {
    let filePath;
    if (typeof _filePath === "undefined") {
      filePath = `ts:extralib-${Math.random().toString(36).substring(2, 15)}`;
    } else {
      filePath = _filePath;
    }
    if (this._extraLibs[filePath] && this._extraLibs[filePath].content === content) {
      return {
        dispose: () => {
        }
      };
    }
    let myVersion = 1;
    if (this._removedExtraLibs[filePath]) {
      myVersion = this._removedExtraLibs[filePath] + 1;
    }
    if (this._extraLibs[filePath]) {
      myVersion = this._extraLibs[filePath].version + 1;
    }
    this._extraLibs[filePath] = {
      content,
      version: myVersion
    };
    this._fireOnDidExtraLibsChangeSoon();
    return {
      dispose: () => {
        let extraLib = this._extraLibs[filePath];
        if (!extraLib) {
          return;
        }
        if (extraLib.version !== myVersion) {
          return;
        }
        delete this._extraLibs[filePath];
        this._removedExtraLibs[filePath] = myVersion;
        this._fireOnDidExtraLibsChangeSoon();
      }
    };
  }
  setExtraLibs(libs) {
    for (const filePath in this._extraLibs) {
      this._removedExtraLibs[filePath] = this._extraLibs[filePath].version;
    }
    this._extraLibs = Object.create(null);
    if (libs && libs.length > 0) {
      for (const lib of libs) {
        const filePath = lib.filePath || `ts:extralib-${Math.random().toString(36).substring(2, 15)}`;
        const content = lib.content;
        let myVersion = 1;
        if (this._removedExtraLibs[filePath]) {
          myVersion = this._removedExtraLibs[filePath] + 1;
        }
        this._extraLibs[filePath] = {
          content,
          version: myVersion
        };
      }
    }
    this._fireOnDidExtraLibsChangeSoon();
  }
  _fireOnDidExtraLibsChangeSoon() {
    if (this._onDidExtraLibsChangeTimeout !== -1) {
      return;
    }
    this._onDidExtraLibsChangeTimeout = window.setTimeout(() => {
      this._onDidExtraLibsChangeTimeout = -1;
      this._onDidExtraLibsChange.fire(void 0);
    }, 0);
  }
  getCompilerOptions() {
    return this._compilerOptions;
  }
  setCompilerOptions(options) {
    this._compilerOptions = options || Object.create(null);
    this._onDidChange.fire(void 0);
  }
  getDiagnosticsOptions() {
    return this._diagnosticsOptions;
  }
  setDiagnosticsOptions(options) {
    this._diagnosticsOptions = options || Object.create(null);
    this._onDidChange.fire(void 0);
  }
  setWorkerOptions(options) {
    this._workerOptions = options || Object.create(null);
    this._onDidChange.fire(void 0);
  }
  setInlayHintsOptions(options) {
    this._inlayHintsOptions = options || Object.create(null);
    this._onDidChange.fire(void 0);
  }
  setMaximumWorkerIdleTime(value) {
  }
  setEagerModelSync(value) {
    this._eagerModelSync = value;
  }
  getEagerModelSync() {
    return this._eagerModelSync;
  }
};
var typescriptVersion2 = typescriptVersion;
var typescriptDefaults = new LanguageServiceDefaultsImpl({ allowNonTsExtensions: true, target: 99 }, { noSemanticValidation: false, noSyntaxValidation: false, onlyVisible: false }, {}, {});
var javascriptDefaults = new LanguageServiceDefaultsImpl({ allowNonTsExtensions: true, allowJs: true, target: 99 }, { noSemanticValidation: true, noSyntaxValidation: false, onlyVisible: false }, {}, {});
var getTypeScriptWorker = () => {
  return getMode().then((mode) => mode.getTypeScriptWorker());
};
var getJavaScriptWorker = () => {
  return getMode().then((mode) => mode.getJavaScriptWorker());
};
monaco_editor_core_exports.languages.typescript = {
  ModuleKind,
  JsxEmit,
  NewLineKind,
  ScriptTarget,
  ModuleResolutionKind,
  typescriptVersion: typescriptVersion2,
  typescriptDefaults,
  javascriptDefaults,
  getTypeScriptWorker,
  getJavaScriptWorker
};
function getMode() {
  if (false) {
    return new Promise((resolve, reject) => {
      __require(["vs/language/typescript/tsMode"], resolve, reject);
    });
  } else {
    return import("./tsMode-27HRSWRW.js");
  }
}
monaco_editor_core_exports.languages.onLanguage("typescript", () => {
  return getMode().then((mode) => mode.setupTypeScript(typescriptDefaults));
});
monaco_editor_core_exports.languages.onLanguage("javascript", () => {
  return getMode().then((mode) => mode.setupJavaScript(javascriptDefaults));
});

// node_modules/monaco-editor/esm/vs/language/css/monaco.contribution.js
var __defProp2 = Object.defineProperty;
var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames2 = Object.getOwnPropertyNames;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __markAsModule2 = (target) => __defProp2(target, "__esModule", { value: true });
var __reExport2 = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames2(module2))
      if (!__hasOwnProp2.call(target, key) && key !== "default")
        __defProp2(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc2(module2, key)) || desc.enumerable });
  }
  return target;
};
var monaco_editor_core_exports2 = {};
__markAsModule2(monaco_editor_core_exports2);
__reExport2(monaco_editor_core_exports2, editor_api_exports);
var LanguageServiceDefaultsImpl2 = class {
  constructor(languageId, options, modeConfiguration) {
    this._onDidChange = new monaco_editor_core_exports2.Emitter();
    this._languageId = languageId;
    this.setOptions(options);
    this.setModeConfiguration(modeConfiguration);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get languageId() {
    return this._languageId;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  get diagnosticsOptions() {
    return this.options;
  }
  get options() {
    return this._options;
  }
  setOptions(options) {
    this._options = options || Object.create(null);
    this._onDidChange.fire(this);
  }
  setDiagnosticsOptions(options) {
    this.setOptions(options);
  }
  setModeConfiguration(modeConfiguration) {
    this._modeConfiguration = modeConfiguration || Object.create(null);
    this._onDidChange.fire(this);
  }
};
var optionsDefault = {
  validate: true,
  lint: {
    compatibleVendorPrefixes: "ignore",
    vendorPrefix: "warning",
    duplicateProperties: "warning",
    emptyRules: "warning",
    importStatement: "ignore",
    boxModel: "ignore",
    universalSelector: "ignore",
    zeroUnits: "ignore",
    fontFaceProperties: "warning",
    hexColorLength: "error",
    argumentsInColorFunction: "error",
    unknownProperties: "warning",
    ieHack: "ignore",
    unknownVendorSpecificProperties: "ignore",
    propertyIgnoredDueToDisplay: "warning",
    important: "ignore",
    float: "ignore",
    idSelector: "ignore"
  },
  data: { useDefaultDataProvider: true }
};
var modeConfigurationDefault = {
  completionItems: true,
  hovers: true,
  documentSymbols: true,
  definitions: true,
  references: true,
  documentHighlights: true,
  rename: true,
  colors: true,
  foldingRanges: true,
  diagnostics: true,
  selectionRanges: true
};
var cssDefaults = new LanguageServiceDefaultsImpl2("css", optionsDefault, modeConfigurationDefault);
var scssDefaults = new LanguageServiceDefaultsImpl2("scss", optionsDefault, modeConfigurationDefault);
var lessDefaults = new LanguageServiceDefaultsImpl2("less", optionsDefault, modeConfigurationDefault);
monaco_editor_core_exports2.languages.css = { cssDefaults, lessDefaults, scssDefaults };
function getMode2() {
  if (false) {
    return new Promise((resolve, reject) => {
      __require(["vs/language/css/cssMode"], resolve, reject);
    });
  } else {
    return import("./cssMode-23O3CELV.js");
  }
}
monaco_editor_core_exports2.languages.onLanguage("less", () => {
  getMode2().then((mode) => mode.setupMode(lessDefaults));
});
monaco_editor_core_exports2.languages.onLanguage("scss", () => {
  getMode2().then((mode) => mode.setupMode(scssDefaults));
});
monaco_editor_core_exports2.languages.onLanguage("css", () => {
  getMode2().then((mode) => mode.setupMode(cssDefaults));
});

// node_modules/monaco-editor/esm/vs/language/json/monaco.contribution.js
var __defProp3 = Object.defineProperty;
var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames3 = Object.getOwnPropertyNames;
var __hasOwnProp3 = Object.prototype.hasOwnProperty;
var __markAsModule3 = (target) => __defProp3(target, "__esModule", { value: true });
var __reExport3 = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames3(module2))
      if (!__hasOwnProp3.call(target, key) && key !== "default")
        __defProp3(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc3(module2, key)) || desc.enumerable });
  }
  return target;
};
var monaco_editor_core_exports3 = {};
__markAsModule3(monaco_editor_core_exports3);
__reExport3(monaco_editor_core_exports3, editor_api_exports);
var LanguageServiceDefaultsImpl3 = class {
  constructor(languageId, diagnosticsOptions, modeConfiguration) {
    this._onDidChange = new monaco_editor_core_exports3.Emitter();
    this._languageId = languageId;
    this.setDiagnosticsOptions(diagnosticsOptions);
    this.setModeConfiguration(modeConfiguration);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get languageId() {
    return this._languageId;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  get diagnosticsOptions() {
    return this._diagnosticsOptions;
  }
  setDiagnosticsOptions(options) {
    this._diagnosticsOptions = options || Object.create(null);
    this._onDidChange.fire(this);
  }
  setModeConfiguration(modeConfiguration) {
    this._modeConfiguration = modeConfiguration || Object.create(null);
    this._onDidChange.fire(this);
  }
};
var diagnosticDefault = {
  validate: true,
  allowComments: true,
  schemas: [],
  enableSchemaRequest: false,
  schemaRequest: "warning",
  schemaValidation: "warning",
  comments: "error",
  trailingCommas: "error"
};
var modeConfigurationDefault2 = {
  documentFormattingEdits: true,
  documentRangeFormattingEdits: true,
  completionItems: true,
  hovers: true,
  documentSymbols: true,
  tokens: true,
  colors: true,
  foldingRanges: true,
  diagnostics: true,
  selectionRanges: true
};
var jsonDefaults = new LanguageServiceDefaultsImpl3("json", diagnosticDefault, modeConfigurationDefault2);
monaco_editor_core_exports3.languages.json = { jsonDefaults };
function getMode3() {
  if (false) {
    return new Promise((resolve, reject) => {
      __require(["vs/language/json/jsonMode"], resolve, reject);
    });
  } else {
    return import("./jsonMode-6A6FKA2A.js");
  }
}
monaco_editor_core_exports3.languages.register({
  id: "json",
  extensions: [".json", ".bowerrc", ".jshintrc", ".jscsrc", ".eslintrc", ".babelrc", ".har"],
  aliases: ["JSON", "json"],
  mimetypes: ["application/json"]
});
monaco_editor_core_exports3.languages.onLanguage("json", () => {
  getMode3().then((mode) => mode.setupMode(jsonDefaults));
});

// node_modules/monaco-editor/esm/vs/language/html/monaco.contribution.js
var __defProp4 = Object.defineProperty;
var __getOwnPropDesc4 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames4 = Object.getOwnPropertyNames;
var __hasOwnProp4 = Object.prototype.hasOwnProperty;
var __markAsModule4 = (target) => __defProp4(target, "__esModule", { value: true });
var __reExport4 = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames4(module2))
      if (!__hasOwnProp4.call(target, key) && key !== "default")
        __defProp4(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc4(module2, key)) || desc.enumerable });
  }
  return target;
};
var monaco_editor_core_exports4 = {};
__markAsModule4(monaco_editor_core_exports4);
__reExport4(monaco_editor_core_exports4, editor_api_exports);
var LanguageServiceDefaultsImpl4 = class {
  constructor(languageId, options, modeConfiguration) {
    this._onDidChange = new monaco_editor_core_exports4.Emitter();
    this._languageId = languageId;
    this.setOptions(options);
    this.setModeConfiguration(modeConfiguration);
  }
  get onDidChange() {
    return this._onDidChange.event;
  }
  get languageId() {
    return this._languageId;
  }
  get options() {
    return this._options;
  }
  get modeConfiguration() {
    return this._modeConfiguration;
  }
  setOptions(options) {
    this._options = options || Object.create(null);
    this._onDidChange.fire(this);
  }
  setModeConfiguration(modeConfiguration) {
    this._modeConfiguration = modeConfiguration || Object.create(null);
    this._onDidChange.fire(this);
  }
};
var formatDefaults = {
  tabSize: 4,
  insertSpaces: false,
  wrapLineLength: 120,
  unformatted: 'default": "a, abbr, acronym, b, bdo, big, br, button, cite, code, dfn, em, i, img, input, kbd, label, map, object, q, samp, select, small, span, strong, sub, sup, textarea, tt, var',
  contentUnformatted: "pre",
  indentInnerHtml: false,
  preserveNewLines: true,
  maxPreserveNewLines: void 0,
  indentHandlebars: false,
  endWithNewline: false,
  extraLiners: "head, body, /html",
  wrapAttributes: "auto"
};
var optionsDefault2 = {
  format: formatDefaults,
  suggest: {},
  data: { useDefaultDataProvider: true }
};
function getConfigurationDefault(languageId) {
  return {
    completionItems: true,
    hovers: true,
    documentSymbols: true,
    links: true,
    documentHighlights: true,
    rename: true,
    colors: true,
    foldingRanges: true,
    selectionRanges: true,
    diagnostics: languageId === htmlLanguageId,
    documentFormattingEdits: languageId === htmlLanguageId,
    documentRangeFormattingEdits: languageId === htmlLanguageId
  };
}
var htmlLanguageId = "html";
var handlebarsLanguageId = "handlebars";
var razorLanguageId = "razor";
var htmlLanguageService = registerHTMLLanguageService(htmlLanguageId, optionsDefault2, getConfigurationDefault(htmlLanguageId));
var htmlDefaults = htmlLanguageService.defaults;
var handlebarLanguageService = registerHTMLLanguageService(handlebarsLanguageId, optionsDefault2, getConfigurationDefault(handlebarsLanguageId));
var handlebarDefaults = handlebarLanguageService.defaults;
var razorLanguageService = registerHTMLLanguageService(razorLanguageId, optionsDefault2, getConfigurationDefault(razorLanguageId));
var razorDefaults = razorLanguageService.defaults;
monaco_editor_core_exports4.languages.html = {
  htmlDefaults,
  razorDefaults,
  handlebarDefaults,
  htmlLanguageService,
  handlebarLanguageService,
  razorLanguageService,
  registerHTMLLanguageService
};
function getMode4() {
  if (false) {
    return new Promise((resolve, reject) => {
      __require(["vs/language/html/htmlMode"], resolve, reject);
    });
  } else {
    return import("./htmlMode-J4BYKZO2.js");
  }
}
function registerHTMLLanguageService(languageId, options = optionsDefault2, modeConfiguration = getConfigurationDefault(languageId)) {
  const defaults = new LanguageServiceDefaultsImpl4(languageId, options, modeConfiguration);
  let mode;
  const onLanguageListener = monaco_editor_core_exports4.languages.onLanguage(languageId, async () => {
    mode = (await getMode4()).setupMode(defaults);
  });
  return {
    defaults,
    dispose() {
      onLanguageListener.dispose();
      mode == null ? void 0 : mode.dispose();
      mode = void 0;
    }
  };
}

// node_modules/monaco-editor/esm/vs/basic-languages/_.contribution.js
var __defProp5 = Object.defineProperty;
var __getOwnPropDesc5 = Object.getOwnPropertyDescriptor;
var __getOwnPropNames5 = Object.getOwnPropertyNames;
var __hasOwnProp5 = Object.prototype.hasOwnProperty;
var __markAsModule5 = (target) => __defProp5(target, "__esModule", { value: true });
var __reExport5 = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames5(module2))
      if (!__hasOwnProp5.call(target, key) && key !== "default")
        __defProp5(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc5(module2, key)) || desc.enumerable });
  }
  return target;
};
var monaco_editor_core_exports5 = {};
__markAsModule5(monaco_editor_core_exports5);
__reExport5(monaco_editor_core_exports5, editor_api_exports);
var languageDefinitions = {};
var lazyLanguageLoaders = {};
var LazyLanguageLoader = class {
  static getOrCreate(languageId) {
    if (!lazyLanguageLoaders[languageId]) {
      lazyLanguageLoaders[languageId] = new LazyLanguageLoader(languageId);
    }
    return lazyLanguageLoaders[languageId];
  }
  constructor(languageId) {
    this._languageId = languageId;
    this._loadingTriggered = false;
    this._lazyLoadPromise = new Promise((resolve, reject) => {
      this._lazyLoadPromiseResolve = resolve;
      this._lazyLoadPromiseReject = reject;
    });
  }
  whenLoaded() {
    return this._lazyLoadPromise;
  }
  load() {
    if (!this._loadingTriggered) {
      this._loadingTriggered = true;
      languageDefinitions[this._languageId].loader().then((mod) => this._lazyLoadPromiseResolve(mod), (err) => this._lazyLoadPromiseReject(err));
    }
    return this._lazyLoadPromise;
  }
};
function registerLanguage(def) {
  const languageId = def.id;
  languageDefinitions[languageId] = def;
  monaco_editor_core_exports5.languages.register(def);
  const lazyLanguageLoader = LazyLanguageLoader.getOrCreate(languageId);
  monaco_editor_core_exports5.languages.setMonarchTokensProvider(languageId, lazyLanguageLoader.whenLoaded().then((mod) => mod.language));
  monaco_editor_core_exports5.languages.onLanguage(languageId, () => {
    lazyLanguageLoader.load().then((mod) => {
      monaco_editor_core_exports5.languages.setLanguageConfiguration(languageId, mod.conf);
    });
  });
}

// node_modules/monaco-editor/esm/vs/basic-languages/abap/abap.contribution.js
registerLanguage({
  id: "abap",
  extensions: [".abap"],
  aliases: ["abap", "ABAP"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/abap/abap"], resolve, reject);
      });
    } else {
      return import("./abap-2MC3IZY7.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/apex/apex.contribution.js
registerLanguage({
  id: "apex",
  extensions: [".cls"],
  aliases: ["Apex", "apex"],
  mimetypes: ["text/x-apex-source", "text/x-apex"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/apex/apex"], resolve, reject);
      });
    } else {
      return import("./apex-DVXVUVF7.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/azcli/azcli.contribution.js
registerLanguage({
  id: "azcli",
  extensions: [".azcli"],
  aliases: ["Azure CLI", "azcli"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/azcli/azcli"], resolve, reject);
      });
    } else {
      return import("./azcli-4EB7XM7V.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/bat/bat.contribution.js
registerLanguage({
  id: "bat",
  extensions: [".bat", ".cmd"],
  aliases: ["Batch", "bat"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/bat/bat"], resolve, reject);
      });
    } else {
      return import("./bat-2SDT24FU.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/bicep/bicep.contribution.js
registerLanguage({
  id: "bicep",
  extensions: [".bicep"],
  aliases: ["Bicep"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/bicep/bicep"], resolve, reject);
      });
    } else {
      return import("./bicep-HEHTZ6C2.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/cameligo/cameligo.contribution.js
registerLanguage({
  id: "cameligo",
  extensions: [".mligo"],
  aliases: ["Cameligo"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/cameligo/cameligo"], resolve, reject);
      });
    } else {
      return import("./cameligo-XB52YT6S.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/clojure/clojure.contribution.js
registerLanguage({
  id: "clojure",
  extensions: [".clj", ".cljs", ".cljc", ".edn"],
  aliases: ["clojure", "Clojure"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/clojure/clojure"], resolve, reject);
      });
    } else {
      return import("./clojure-VV55TTGB.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/coffee/coffee.contribution.js
registerLanguage({
  id: "coffeescript",
  extensions: [".coffee"],
  aliases: ["CoffeeScript", "coffeescript", "coffee"],
  mimetypes: ["text/x-coffeescript", "text/coffeescript"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/coffee/coffee"], resolve, reject);
      });
    } else {
      return import("./coffee-QNOAXQIK.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/cpp/cpp.contribution.js
registerLanguage({
  id: "c",
  extensions: [".c", ".h"],
  aliases: ["C", "c"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/cpp/cpp"], resolve, reject);
      });
    } else {
      return import("./cpp-C6LM55QX.js");
    }
  }
});
registerLanguage({
  id: "cpp",
  extensions: [".cpp", ".cc", ".cxx", ".hpp", ".hh", ".hxx"],
  aliases: ["C++", "Cpp", "cpp"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/cpp/cpp"], resolve, reject);
      });
    } else {
      return import("./cpp-C6LM55QX.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/csharp/csharp.contribution.js
registerLanguage({
  id: "csharp",
  extensions: [".cs", ".csx", ".cake"],
  aliases: ["C#", "csharp"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/csharp/csharp"], resolve, reject);
      });
    } else {
      return import("./csharp-OBXZ5MTY.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/csp/csp.contribution.js
registerLanguage({
  id: "csp",
  extensions: [],
  aliases: ["CSP", "csp"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/csp/csp"], resolve, reject);
      });
    } else {
      return import("./csp-DGKOX6UQ.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/css/css.contribution.js
registerLanguage({
  id: "css",
  extensions: [".css"],
  aliases: ["CSS", "css"],
  mimetypes: ["text/css"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/css/css"], resolve, reject);
      });
    } else {
      return import("./css-XJX6NTGF.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/dart/dart.contribution.js
registerLanguage({
  id: "dart",
  extensions: [".dart"],
  aliases: ["Dart", "dart"],
  mimetypes: ["text/x-dart-source", "text/x-dart"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/dart/dart"], resolve, reject);
      });
    } else {
      return import("./dart-REU5MWTX.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/dockerfile/dockerfile.contribution.js
registerLanguage({
  id: "dockerfile",
  extensions: [".dockerfile"],
  filenames: ["Dockerfile"],
  aliases: ["Dockerfile"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/dockerfile/dockerfile"], resolve, reject);
      });
    } else {
      return import("./dockerfile-M4TEXZ7I.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/ecl/ecl.contribution.js
registerLanguage({
  id: "ecl",
  extensions: [".ecl"],
  aliases: ["ECL", "Ecl", "ecl"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/ecl/ecl"], resolve, reject);
      });
    } else {
      return import("./ecl-XITDMNW2.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/elixir/elixir.contribution.js
registerLanguage({
  id: "elixir",
  extensions: [".ex", ".exs"],
  aliases: ["Elixir", "elixir", "ex"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/elixir/elixir"], resolve, reject);
      });
    } else {
      return import("./elixir-JNZT36AX.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/flow9/flow9.contribution.js
registerLanguage({
  id: "flow9",
  extensions: [".flow"],
  aliases: ["Flow9", "Flow", "flow9", "flow"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/flow9/flow9"], resolve, reject);
      });
    } else {
      return import("./flow9-7JH6OL2H.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/fsharp/fsharp.contribution.js
registerLanguage({
  id: "fsharp",
  extensions: [".fs", ".fsi", ".ml", ".mli", ".fsx", ".fsscript"],
  aliases: ["F#", "FSharp", "fsharp"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/fsharp/fsharp"], resolve, reject);
      });
    } else {
      return import("./fsharp-XZ6KJRVA.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/go/go.contribution.js
registerLanguage({
  id: "go",
  extensions: [".go"],
  aliases: ["Go"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/go/go"], resolve, reject);
      });
    } else {
      return import("./go-CY2W33GT.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/graphql/graphql.contribution.js
registerLanguage({
  id: "graphql",
  extensions: [".graphql", ".gql"],
  aliases: ["GraphQL", "graphql", "gql"],
  mimetypes: ["application/graphql"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/graphql/graphql"], resolve, reject);
      });
    } else {
      return import("./graphql-3KVYXSVJ.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/handlebars/handlebars.contribution.js
registerLanguage({
  id: "handlebars",
  extensions: [".handlebars", ".hbs"],
  aliases: ["Handlebars", "handlebars", "hbs"],
  mimetypes: ["text/x-handlebars-template"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/handlebars/handlebars"], resolve, reject);
      });
    } else {
      return import("./handlebars-VAIFSJMC.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/hcl/hcl.contribution.js
registerLanguage({
  id: "hcl",
  extensions: [".tf", ".tfvars", ".hcl"],
  aliases: ["Terraform", "tf", "HCL", "hcl"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/hcl/hcl"], resolve, reject);
      });
    } else {
      return import("./hcl-ZTR7R5CI.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/html/html.contribution.js
registerLanguage({
  id: "html",
  extensions: [".html", ".htm", ".shtml", ".xhtml", ".mdoc", ".jsp", ".asp", ".aspx", ".jshtm"],
  aliases: ["HTML", "htm", "html", "xhtml"],
  mimetypes: ["text/html", "text/x-jshtm", "text/template", "text/ng-template"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/html/html"], resolve, reject);
      });
    } else {
      return import("./html-XSYRV5VF.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/ini/ini.contribution.js
registerLanguage({
  id: "ini",
  extensions: [".ini", ".properties", ".gitconfig"],
  filenames: ["config", ".gitattributes", ".gitconfig", ".editorconfig"],
  aliases: ["Ini", "ini"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/ini/ini"], resolve, reject);
      });
    } else {
      return import("./ini-H2EY5PP3.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/java/java.contribution.js
registerLanguage({
  id: "java",
  extensions: [".java", ".jav"],
  aliases: ["Java", "java"],
  mimetypes: ["text/x-java-source", "text/x-java"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/java/java"], resolve, reject);
      });
    } else {
      return import("./java-CBO2UITO.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/javascript/javascript.contribution.js
registerLanguage({
  id: "javascript",
  extensions: [".js", ".es6", ".jsx", ".mjs"],
  firstLine: "^#!.*\\bnode",
  filenames: ["jakefile"],
  aliases: ["JavaScript", "javascript", "js"],
  mimetypes: ["text/javascript"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/javascript/javascript"], resolve, reject);
      });
    } else {
      return import("./javascript-GBPKZGHU.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/julia/julia.contribution.js
registerLanguage({
  id: "julia",
  extensions: [".jl"],
  aliases: ["julia", "Julia"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/julia/julia"], resolve, reject);
      });
    } else {
      return import("./julia-Y7MWCKBA.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/kotlin/kotlin.contribution.js
registerLanguage({
  id: "kotlin",
  extensions: [".kt"],
  aliases: ["Kotlin", "kotlin"],
  mimetypes: ["text/x-kotlin-source", "text/x-kotlin"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/kotlin/kotlin"], resolve, reject);
      });
    } else {
      return import("./kotlin-JZ7MFV3G.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/less/less.contribution.js
registerLanguage({
  id: "less",
  extensions: [".less"],
  aliases: ["Less", "less"],
  mimetypes: ["text/x-less", "text/less"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/less/less"], resolve, reject);
      });
    } else {
      return import("./less-BG7NYDGC.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/lexon/lexon.contribution.js
registerLanguage({
  id: "lexon",
  extensions: [".lex"],
  aliases: ["Lexon"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/lexon/lexon"], resolve, reject);
      });
    } else {
      return import("./lexon-HT4PIL6B.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/lua/lua.contribution.js
registerLanguage({
  id: "lua",
  extensions: [".lua"],
  aliases: ["Lua", "lua"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/lua/lua"], resolve, reject);
      });
    } else {
      return import("./lua-47YTMAG2.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/liquid/liquid.contribution.js
registerLanguage({
  id: "liquid",
  extensions: [".liquid", ".html.liquid"],
  aliases: ["Liquid", "liquid"],
  mimetypes: ["application/liquid"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/liquid/liquid"], resolve, reject);
      });
    } else {
      return import("./liquid-J6NO2RLO.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/m3/m3.contribution.js
registerLanguage({
  id: "m3",
  extensions: [".m3", ".i3", ".mg", ".ig"],
  aliases: ["Modula-3", "Modula3", "modula3", "m3"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/m3/m3"], resolve, reject);
      });
    } else {
      return import("./m3-5XCDX6QH.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/markdown/markdown.contribution.js
registerLanguage({
  id: "markdown",
  extensions: [".md", ".markdown", ".mdown", ".mkdn", ".mkd", ".mdwn", ".mdtxt", ".mdtext"],
  aliases: ["Markdown", "markdown"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/markdown/markdown"], resolve, reject);
      });
    } else {
      return import("./markdown-GFCMAI7F.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/mips/mips.contribution.js
registerLanguage({
  id: "mips",
  extensions: [".s"],
  aliases: ["MIPS", "MIPS-V"],
  mimetypes: ["text/x-mips", "text/mips", "text/plaintext"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/mips/mips"], resolve, reject);
      });
    } else {
      return import("./mips-GZJP66SD.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/msdax/msdax.contribution.js
registerLanguage({
  id: "msdax",
  extensions: [".dax", ".msdax"],
  aliases: ["DAX", "MSDAX"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/msdax/msdax"], resolve, reject);
      });
    } else {
      return import("./msdax-IZ732ABQ.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/mysql/mysql.contribution.js
registerLanguage({
  id: "mysql",
  extensions: [],
  aliases: ["MySQL", "mysql"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/mysql/mysql"], resolve, reject);
      });
    } else {
      return import("./mysql-U57X4EB7.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/objective-c/objective-c.contribution.js
registerLanguage({
  id: "objective-c",
  extensions: [".m"],
  aliases: ["Objective-C"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/objective-c/objective-c"], resolve, reject);
      });
    } else {
      return import("./objective-c-O4FKFUOS.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pascal/pascal.contribution.js
registerLanguage({
  id: "pascal",
  extensions: [".pas", ".p", ".pp"],
  aliases: ["Pascal", "pas"],
  mimetypes: ["text/x-pascal-source", "text/x-pascal"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/pascal/pascal"], resolve, reject);
      });
    } else {
      return import("./pascal-EVQ3ER5J.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pascaligo/pascaligo.contribution.js
registerLanguage({
  id: "pascaligo",
  extensions: [".ligo"],
  aliases: ["Pascaligo", "ligo"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/pascaligo/pascaligo"], resolve, reject);
      });
    } else {
      return import("./pascaligo-AR4SW2M4.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/perl/perl.contribution.js
registerLanguage({
  id: "perl",
  extensions: [".pl"],
  aliases: ["Perl", "pl"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/perl/perl"], resolve, reject);
      });
    } else {
      return import("./perl-HD5SQZB6.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pgsql/pgsql.contribution.js
registerLanguage({
  id: "pgsql",
  extensions: [],
  aliases: ["PostgreSQL", "postgres", "pg", "postgre"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/pgsql/pgsql"], resolve, reject);
      });
    } else {
      return import("./pgsql-ABFGMMKC.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/php/php.contribution.js
registerLanguage({
  id: "php",
  extensions: [".php", ".php4", ".php5", ".phtml", ".ctp"],
  aliases: ["PHP", "php"],
  mimetypes: ["application/x-php"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/php/php"], resolve, reject);
      });
    } else {
      return import("./php-BQJWQ5DW.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pla/pla.contribution.js
registerLanguage({
  id: "pla",
  extensions: [".pla"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/pla/pla"], resolve, reject);
      });
    } else {
      return import("./pla-ISZNIDNB.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/postiats/postiats.contribution.js
registerLanguage({
  id: "postiats",
  extensions: [".dats", ".sats", ".hats"],
  aliases: ["ATS", "ATS/Postiats"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/postiats/postiats"], resolve, reject);
      });
    } else {
      return import("./postiats-TCOD7XJF.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/powerquery/powerquery.contribution.js
registerLanguage({
  id: "powerquery",
  extensions: [".pq", ".pqm"],
  aliases: ["PQ", "M", "Power Query", "Power Query M"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/powerquery/powerquery"], resolve, reject);
      });
    } else {
      return import("./powerquery-BRJYYNKC.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/powershell/powershell.contribution.js
registerLanguage({
  id: "powershell",
  extensions: [".ps1", ".psm1", ".psd1"],
  aliases: ["PowerShell", "powershell", "ps", "ps1"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/powershell/powershell"], resolve, reject);
      });
    } else {
      return import("./powershell-6TQJ54LO.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/protobuf/protobuf.contribution.js
registerLanguage({
  id: "proto",
  extensions: [".proto"],
  aliases: ["protobuf", "Protocol Buffers"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/protobuf/protobuf"], resolve, reject);
      });
    } else {
      return import("./protobuf-KB2GGCUM.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/pug/pug.contribution.js
registerLanguage({
  id: "pug",
  extensions: [".jade", ".pug"],
  aliases: ["Pug", "Jade", "jade"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/pug/pug"], resolve, reject);
      });
    } else {
      return import("./pug-ZVIHC5HL.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/python/python.contribution.js
registerLanguage({
  id: "python",
  extensions: [".py", ".rpy", ".pyw", ".cpy", ".gyp", ".gypi"],
  aliases: ["Python", "py"],
  firstLine: "^#!/.*\\bpython[0-9.-]*\\b",
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/python/python"], resolve, reject);
      });
    } else {
      return import("./python-MQSBVQN3.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/qsharp/qsharp.contribution.js
registerLanguage({
  id: "qsharp",
  extensions: [".qs"],
  aliases: ["Q#", "qsharp"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/qsharp/qsharp"], resolve, reject);
      });
    } else {
      return import("./qsharp-I3BHTPKS.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/r/r.contribution.js
registerLanguage({
  id: "r",
  extensions: [".r", ".rhistory", ".rmd", ".rprofile", ".rt"],
  aliases: ["R", "r"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/r/r"], resolve, reject);
      });
    } else {
      return import("./r-MPYXGZ7M.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/razor/razor.contribution.js
registerLanguage({
  id: "razor",
  extensions: [".cshtml"],
  aliases: ["Razor", "razor"],
  mimetypes: ["text/x-cshtml"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/razor/razor"], resolve, reject);
      });
    } else {
      return import("./razor-QYYES3L5.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/redis/redis.contribution.js
registerLanguage({
  id: "redis",
  extensions: [".redis"],
  aliases: ["redis"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/redis/redis"], resolve, reject);
      });
    } else {
      return import("./redis-22OF55TS.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/redshift/redshift.contribution.js
registerLanguage({
  id: "redshift",
  extensions: [],
  aliases: ["Redshift", "redshift"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/redshift/redshift"], resolve, reject);
      });
    } else {
      return import("./redshift-JRQFKJ7S.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/restructuredtext/restructuredtext.contribution.js
registerLanguage({
  id: "restructuredtext",
  extensions: [".rst"],
  aliases: ["reStructuredText", "restructuredtext"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/restructuredtext/restructuredtext"], resolve, reject);
      });
    } else {
      return import("./restructuredtext-FPWZIIOI.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/ruby/ruby.contribution.js
registerLanguage({
  id: "ruby",
  extensions: [".rb", ".rbx", ".rjs", ".gemspec", ".pp"],
  filenames: ["rakefile", "Gemfile"],
  aliases: ["Ruby", "rb"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/ruby/ruby"], resolve, reject);
      });
    } else {
      return import("./ruby-2HFIN5AP.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/rust/rust.contribution.js
registerLanguage({
  id: "rust",
  extensions: [".rs", ".rlib"],
  aliases: ["Rust", "rust"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/rust/rust"], resolve, reject);
      });
    } else {
      return import("./rust-SWBZPW6K.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/sb/sb.contribution.js
registerLanguage({
  id: "sb",
  extensions: [".sb"],
  aliases: ["Small Basic", "sb"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/sb/sb"], resolve, reject);
      });
    } else {
      return import("./sb-XHX55I4V.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/scala/scala.contribution.js
registerLanguage({
  id: "scala",
  extensions: [".scala", ".sc", ".sbt"],
  aliases: ["Scala", "scala", "SBT", "Sbt", "sbt", "Dotty", "dotty"],
  mimetypes: ["text/x-scala-source", "text/x-scala", "text/x-sbt", "text/x-dotty"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/scala/scala"], resolve, reject);
      });
    } else {
      return import("./scala-QHGXGKRK.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/scheme/scheme.contribution.js
registerLanguage({
  id: "scheme",
  extensions: [".scm", ".ss", ".sch", ".rkt"],
  aliases: ["scheme", "Scheme"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/scheme/scheme"], resolve, reject);
      });
    } else {
      return import("./scheme-M2TRYLG3.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/scss/scss.contribution.js
registerLanguage({
  id: "scss",
  extensions: [".scss"],
  aliases: ["Sass", "sass", "scss"],
  mimetypes: ["text/x-scss", "text/scss"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/scss/scss"], resolve, reject);
      });
    } else {
      return import("./scss-6CKF2DOX.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/shell/shell.contribution.js
registerLanguage({
  id: "shell",
  extensions: [".sh", ".bash"],
  aliases: ["Shell", "sh"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/shell/shell"], resolve, reject);
      });
    } else {
      return import("./shell-6QO3KVCG.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/solidity/solidity.contribution.js
registerLanguage({
  id: "sol",
  extensions: [".sol"],
  aliases: ["sol", "solidity", "Solidity"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/solidity/solidity"], resolve, reject);
      });
    } else {
      return import("./solidity-OK4OQU73.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/sophia/sophia.contribution.js
registerLanguage({
  id: "aes",
  extensions: [".aes"],
  aliases: ["aes", "sophia", "Sophia"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/sophia/sophia"], resolve, reject);
      });
    } else {
      return import("./sophia-J74YMZPO.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/sparql/sparql.contribution.js
registerLanguage({
  id: "sparql",
  extensions: [".rq"],
  aliases: ["sparql", "SPARQL"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/sparql/sparql"], resolve, reject);
      });
    } else {
      return import("./sparql-MRCYR7OP.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/sql/sql.contribution.js
registerLanguage({
  id: "sql",
  extensions: [".sql"],
  aliases: ["SQL"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/sql/sql"], resolve, reject);
      });
    } else {
      return import("./sql-3FUJ56IU.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/st/st.contribution.js
registerLanguage({
  id: "st",
  extensions: [".st", ".iecst", ".iecplc", ".lc3lib"],
  aliases: ["StructuredText", "scl", "stl"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/st/st"], resolve, reject);
      });
    } else {
      return import("./st-CVOZQEZH.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/swift/swift.contribution.js
registerLanguage({
  id: "swift",
  aliases: ["Swift", "swift"],
  extensions: [".swift"],
  mimetypes: ["text/swift"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/swift/swift"], resolve, reject);
      });
    } else {
      return import("./swift-B6BM6SVK.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/systemverilog/systemverilog.contribution.js
registerLanguage({
  id: "systemverilog",
  extensions: [".sv", ".svh"],
  aliases: ["SV", "sv", "SystemVerilog", "systemverilog"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/systemverilog/systemverilog"], resolve, reject);
      });
    } else {
      return import("./systemverilog-RIHWV52N.js");
    }
  }
});
registerLanguage({
  id: "verilog",
  extensions: [".v", ".vh"],
  aliases: ["V", "v", "Verilog", "verilog"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/systemverilog/systemverilog"], resolve, reject);
      });
    } else {
      return import("./systemverilog-RIHWV52N.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/tcl/tcl.contribution.js
registerLanguage({
  id: "tcl",
  extensions: [".tcl"],
  aliases: ["tcl", "Tcl", "tcltk", "TclTk", "tcl/tk", "Tcl/Tk"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/tcl/tcl"], resolve, reject);
      });
    } else {
      return import("./tcl-QCXQKHIF.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/twig/twig.contribution.js
registerLanguage({
  id: "twig",
  extensions: [".twig"],
  aliases: ["Twig", "twig"],
  mimetypes: ["text/x-twig"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/twig/twig"], resolve, reject);
      });
    } else {
      return import("./twig-Y2VWG54C.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/typescript/typescript.contribution.js
registerLanguage({
  id: "typescript",
  extensions: [".ts", ".tsx"],
  aliases: ["TypeScript", "ts", "typescript"],
  mimetypes: ["text/typescript"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/typescript/typescript"], resolve, reject);
      });
    } else {
      return import("./typescript-B2GVCW4J.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/vb/vb.contribution.js
registerLanguage({
  id: "vb",
  extensions: [".vb"],
  aliases: ["Visual Basic", "vb"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/vb/vb"], resolve, reject);
      });
    } else {
      return import("./vb-XFCC75CG.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/xml/xml.contribution.js
registerLanguage({
  id: "xml",
  extensions: [
    ".xml",
    ".dtd",
    ".ascx",
    ".csproj",
    ".config",
    ".wxi",
    ".wxl",
    ".wxs",
    ".xaml",
    ".svg",
    ".svgz",
    ".opf",
    ".xsl"
  ],
  firstLine: "(\\<\\?xml.*)|(\\<svg)|(\\<\\!doctype\\s+svg)",
  aliases: ["XML", "xml"],
  mimetypes: ["text/xml", "application/xml", "application/xaml+xml", "application/xml-dtd"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/xml/xml"], resolve, reject);
      });
    } else {
      return import("./xml-PJHYE73B.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/basic-languages/yaml/yaml.contribution.js
registerLanguage({
  id: "yaml",
  extensions: [".yaml", ".yml"],
  aliases: ["YAML", "yaml", "YML", "yml"],
  mimetypes: ["application/x-yaml", "text/x-yaml"],
  loader: () => {
    if (false) {
      return new Promise((resolve, reject) => {
        __require(["vs/basic-languages/yaml/yaml"], resolve, reject);
      });
    } else {
      return import("./yaml-FULPKN2G.js");
    }
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/anchorSelect/anchorSelect.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/anchorSelect/anchorSelect.css";
var __decorate = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SelectionAnchorSet = new RawContextKey("selectionAnchorSet", false);
var SelectionAnchorController = class SelectionAnchorController2 {
  constructor(editor2, contextKeyService) {
    this.editor = editor2;
    this.selectionAnchorSetContextKey = SelectionAnchorSet.bindTo(contextKeyService);
    this.modelChangeListener = editor2.onDidChangeModel(() => this.selectionAnchorSetContextKey.reset());
  }
  static get(editor2) {
    return editor2.getContribution(SelectionAnchorController2.ID);
  }
  setSelectionAnchor() {
    if (this.editor.hasModel()) {
      const position = this.editor.getPosition();
      const previousDecorations = this.decorationId ? [this.decorationId] : [];
      const newDecorationId = this.editor.deltaDecorations(previousDecorations, [{
        range: Selection.fromPositions(position, position),
        options: {
          description: "selection-anchor",
          stickiness: 1,
          hoverMessage: new MarkdownString().appendText(localize("selectionAnchor", "Selection Anchor")),
          className: "selection-anchor"
        }
      }]);
      this.decorationId = newDecorationId[0];
      this.selectionAnchorSetContextKey.set(!!this.decorationId);
      alert(localize("anchorSet", "Anchor set at {0}:{1}", position.lineNumber, position.column));
    }
  }
  goToSelectionAnchor() {
    if (this.editor.hasModel() && this.decorationId) {
      const anchorPosition = this.editor.getModel().getDecorationRange(this.decorationId);
      if (anchorPosition) {
        this.editor.setPosition(anchorPosition.getStartPosition());
      }
    }
  }
  selectFromAnchorToCursor() {
    if (this.editor.hasModel() && this.decorationId) {
      const start = this.editor.getModel().getDecorationRange(this.decorationId);
      if (start) {
        const end = this.editor.getPosition();
        this.editor.setSelection(Selection.fromPositions(start.getStartPosition(), end));
        this.cancelSelectionAnchor();
      }
    }
  }
  cancelSelectionAnchor() {
    if (this.decorationId) {
      this.editor.deltaDecorations([this.decorationId], []);
      this.decorationId = void 0;
      this.selectionAnchorSetContextKey.set(false);
    }
  }
  dispose() {
    this.cancelSelectionAnchor();
    this.modelChangeListener.dispose();
  }
};
SelectionAnchorController.ID = "editor.contrib.selectionAnchorController";
SelectionAnchorController = __decorate([
  __param(1, IContextKeyService)
], SelectionAnchorController);
var SetSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.setSelectionAnchor",
      label: localize("setSelectionAnchor", "Set Selection Anchor"),
      alias: "Set Selection Anchor",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 32),
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    return __awaiter(this, void 0, void 0, function* () {
      const controller = SelectionAnchorController.get(editor2);
      controller.setSelectionAnchor();
    });
  }
};
var GoToSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.goToSelectionAnchor",
      label: localize("goToSelectionAnchor", "Go to Selection Anchor"),
      alias: "Go to Selection Anchor",
      precondition: SelectionAnchorSet
    });
  }
  run(_accessor, editor2) {
    return __awaiter(this, void 0, void 0, function* () {
      const controller = SelectionAnchorController.get(editor2);
      controller.goToSelectionAnchor();
    });
  }
};
var SelectFromAnchorToCursor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.selectFromAnchorToCursor",
      label: localize("selectFromAnchorToCursor", "Select from Anchor to Cursor"),
      alias: "Select from Anchor to Cursor",
      precondition: SelectionAnchorSet,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 41),
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    return __awaiter(this, void 0, void 0, function* () {
      const controller = SelectionAnchorController.get(editor2);
      controller.selectFromAnchorToCursor();
    });
  }
};
var CancelSelectionAnchor = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.cancelSelectionAnchor",
      label: localize("cancelSelectionAnchor", "Cancel Selection Anchor"),
      alias: "Cancel Selection Anchor",
      precondition: SelectionAnchorSet,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 9,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    return __awaiter(this, void 0, void 0, function* () {
      const controller = SelectionAnchorController.get(editor2);
      controller.cancelSelectionAnchor();
    });
  }
};
registerEditorContribution(SelectionAnchorController.ID, SelectionAnchorController);
registerEditorAction(SetSelectionAnchor);
registerEditorAction(GoToSelectionAnchor);
registerEditorAction(SelectFromAnchorToCursor);
registerEditorAction(CancelSelectionAnchor);

// node_modules/monaco-editor/esm/vs/editor/contrib/bracketMatching/bracketMatching.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/bracketMatching/bracketMatching.css";
var overviewRulerBracketMatchForeground = registerColor("editorOverviewRuler.bracketMatchForeground", { dark: "#A0A0A0", light: "#A0A0A0", hc: "#A0A0A0" }, localize("overviewRulerBracketMatchForeground", "Overview ruler marker color for matching brackets."));
var JumpToBracketAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.jumpToBracket",
      label: localize("smartSelect.jumpBracket", "Go to Bracket"),
      alias: "Go to Bracket",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 88,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    let controller = BracketMatchingController.get(editor2);
    if (!controller) {
      return;
    }
    controller.jumpToBracket();
  }
};
var SelectToBracketAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.selectToBracket",
      label: localize("smartSelect.selectToBracket", "Select to Bracket"),
      alias: "Select to Bracket",
      precondition: void 0,
      description: {
        description: `Select to Bracket`,
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              "selectBrackets": {
                type: "boolean",
                default: true
              }
            }
          }
        }]
      }
    });
  }
  run(accessor, editor2, args) {
    const controller = BracketMatchingController.get(editor2);
    if (!controller) {
      return;
    }
    let selectBrackets = true;
    if (args && args.selectBrackets === false) {
      selectBrackets = false;
    }
    controller.selectToBracket(selectBrackets);
  }
};
var BracketsData = class {
  constructor(position, brackets, options) {
    this.position = position;
    this.brackets = brackets;
    this.options = options;
  }
};
var BracketMatchingController = class extends Disposable {
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._lastBracketsData = [];
    this._lastVersionId = 0;
    this._decorations = [];
    this._updateBracketsSoon = this._register(new RunOnceScheduler(() => this._updateBrackets(), 50));
    this._matchBrackets = this._editor.getOption(63);
    this._updateBracketsSoon.schedule();
    this._register(editor2.onDidChangeCursorPosition((e) => {
      if (this._matchBrackets === "never") {
        return;
      }
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this._lastBracketsData = [];
      this._decorations = [];
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeModelLanguageConfiguration((e) => {
      this._lastBracketsData = [];
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (e.hasChanged(63)) {
        this._matchBrackets = this._editor.getOption(63);
        this._decorations = this._editor.deltaDecorations(this._decorations, []);
        this._lastBracketsData = [];
        this._lastVersionId = 0;
        this._updateBracketsSoon.schedule();
      }
    }));
    this._register(editor2.onDidBlurEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    }));
    this._register(editor2.onDidFocusEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    }));
  }
  static get(editor2) {
    return editor2.getContribution(BracketMatchingController.ID);
  }
  jumpToBracket() {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const newSelections = this._editor.getSelections().map((selection) => {
      const position = selection.getStartPosition();
      const brackets = model.bracketPairs.matchBracket(position);
      let newCursorPosition = null;
      if (brackets) {
        if (brackets[0].containsPosition(position)) {
          newCursorPosition = brackets[1].getStartPosition();
        } else if (brackets[1].containsPosition(position)) {
          newCursorPosition = brackets[0].getStartPosition();
        }
      } else {
        const enclosingBrackets = model.bracketPairs.findEnclosingBrackets(position);
        if (enclosingBrackets) {
          newCursorPosition = enclosingBrackets[0].getStartPosition();
        } else {
          const nextBracket = model.bracketPairs.findNextBracket(position);
          if (nextBracket && nextBracket.range) {
            newCursorPosition = nextBracket.range.getStartPosition();
          }
        }
      }
      if (newCursorPosition) {
        return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
      }
      return new Selection(position.lineNumber, position.column, position.lineNumber, position.column);
    });
    this._editor.setSelections(newSelections);
    this._editor.revealRange(newSelections[0]);
  }
  selectToBracket(selectBrackets) {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const newSelections = [];
    this._editor.getSelections().forEach((selection) => {
      const position = selection.getStartPosition();
      let brackets = model.bracketPairs.matchBracket(position);
      if (!brackets) {
        brackets = model.bracketPairs.findEnclosingBrackets(position);
        if (!brackets) {
          const nextBracket = model.bracketPairs.findNextBracket(position);
          if (nextBracket && nextBracket.range) {
            brackets = model.bracketPairs.matchBracket(nextBracket.range.getStartPosition());
          }
        }
      }
      let selectFrom = null;
      let selectTo = null;
      if (brackets) {
        brackets.sort(Range.compareRangesUsingStarts);
        const [open, close] = brackets;
        selectFrom = selectBrackets ? open.getStartPosition() : open.getEndPosition();
        selectTo = selectBrackets ? close.getEndPosition() : close.getStartPosition();
        if (close.containsPosition(position)) {
          const tmp = selectFrom;
          selectFrom = selectTo;
          selectTo = tmp;
        }
      }
      if (selectFrom && selectTo) {
        newSelections.push(new Selection(selectFrom.lineNumber, selectFrom.column, selectTo.lineNumber, selectTo.column));
      }
    });
    if (newSelections.length > 0) {
      this._editor.setSelections(newSelections);
      this._editor.revealRange(newSelections[0]);
    }
  }
  _updateBrackets() {
    if (this._matchBrackets === "never") {
      return;
    }
    this._recomputeBrackets();
    let newDecorations = [], newDecorationsLen = 0;
    for (const bracketData of this._lastBracketsData) {
      let brackets = bracketData.brackets;
      if (brackets) {
        newDecorations[newDecorationsLen++] = { range: brackets[0], options: bracketData.options };
        newDecorations[newDecorationsLen++] = { range: brackets[1], options: bracketData.options };
      }
    }
    this._decorations = this._editor.deltaDecorations(this._decorations, newDecorations);
  }
  _recomputeBrackets() {
    if (!this._editor.hasModel() || !this._editor.hasWidgetFocus()) {
      this._lastBracketsData = [];
      this._lastVersionId = 0;
      return;
    }
    const selections = this._editor.getSelections();
    if (selections.length > 100) {
      this._lastBracketsData = [];
      this._lastVersionId = 0;
      return;
    }
    const model = this._editor.getModel();
    const versionId = model.getVersionId();
    let previousData = [];
    if (this._lastVersionId === versionId) {
      previousData = this._lastBracketsData;
    }
    let positions = [], positionsLen = 0;
    for (let i = 0, len = selections.length; i < len; i++) {
      let selection = selections[i];
      if (selection.isEmpty()) {
        positions[positionsLen++] = selection.getStartPosition();
      }
    }
    if (positions.length > 1) {
      positions.sort(Position.compare);
    }
    let newData = [], newDataLen = 0;
    let previousIndex = 0, previousLen = previousData.length;
    for (let i = 0, len = positions.length; i < len; i++) {
      let position = positions[i];
      while (previousIndex < previousLen && previousData[previousIndex].position.isBefore(position)) {
        previousIndex++;
      }
      if (previousIndex < previousLen && previousData[previousIndex].position.equals(position)) {
        newData[newDataLen++] = previousData[previousIndex];
      } else {
        let brackets = model.bracketPairs.matchBracket(position);
        let options = BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER;
        if (!brackets && this._matchBrackets === "always") {
          brackets = model.bracketPairs.findEnclosingBrackets(position, 20);
          options = BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER;
        }
        newData[newDataLen++] = new BracketsData(position, brackets, options);
      }
    }
    this._lastBracketsData = newData;
    this._lastVersionId = versionId;
  }
};
BracketMatchingController.ID = "editor.contrib.bracketMatchingController";
BracketMatchingController._DECORATION_OPTIONS_WITH_OVERVIEW_RULER = ModelDecorationOptions.register({
  description: "bracket-match-overview",
  stickiness: 1,
  className: "bracket-match",
  overviewRuler: {
    color: themeColorFromId(overviewRulerBracketMatchForeground),
    position: OverviewRulerLane.Center
  }
});
BracketMatchingController._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER = ModelDecorationOptions.register({
  description: "bracket-match-no-overview",
  stickiness: 1,
  className: "bracket-match"
});
registerEditorContribution(BracketMatchingController.ID, BracketMatchingController);
registerEditorAction(SelectToBracketAction);
registerEditorAction(JumpToBracketAction);
registerThemingParticipant((theme, collector) => {
  const bracketMatchBackground = theme.getColor(editorBracketMatchBackground);
  if (bracketMatchBackground) {
    collector.addRule(`.monaco-editor .bracket-match { background-color: ${bracketMatchBackground}; }`);
  }
  const bracketMatchBorder = theme.getColor(editorBracketMatchBorder);
  if (bracketMatchBorder) {
    collector.addRule(`.monaco-editor .bracket-match { border: 1px solid ${bracketMatchBorder}; }`);
  }
});
MenuRegistry.appendMenuItem(MenuId.MenubarGoMenu, {
  group: "5_infile_nav",
  command: {
    id: "editor.action.jumpToBracket",
    title: localize({ key: "miGoToBracket", comment: ["&& denotes a mnemonic"] }, "Go to &&Bracket")
  },
  order: 2
});

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/moveCaretCommand.js
var MoveCaretCommand = class {
  constructor(selection, isMovingLeft) {
    this._selection = selection;
    this._isMovingLeft = isMovingLeft;
  }
  getEditOperations(model, builder) {
    if (this._selection.startLineNumber !== this._selection.endLineNumber || this._selection.isEmpty()) {
      return;
    }
    const lineNumber = this._selection.startLineNumber;
    const startColumn = this._selection.startColumn;
    const endColumn = this._selection.endColumn;
    if (this._isMovingLeft && startColumn === 1) {
      return;
    }
    if (!this._isMovingLeft && endColumn === model.getLineMaxColumn(lineNumber)) {
      return;
    }
    if (this._isMovingLeft) {
      const rangeBefore = new Range(lineNumber, startColumn - 1, lineNumber, startColumn);
      const charBefore = model.getValueInRange(rangeBefore);
      builder.addEditOperation(rangeBefore, null);
      builder.addEditOperation(new Range(lineNumber, endColumn, lineNumber, endColumn), charBefore);
    } else {
      const rangeAfter = new Range(lineNumber, endColumn, lineNumber, endColumn + 1);
      const charAfter = model.getValueInRange(rangeAfter);
      builder.addEditOperation(rangeAfter, null);
      builder.addEditOperation(new Range(lineNumber, startColumn, lineNumber, startColumn), charAfter);
    }
  }
  computeCursorState(model, helper) {
    if (this._isMovingLeft) {
      return new Selection(this._selection.startLineNumber, this._selection.startColumn - 1, this._selection.endLineNumber, this._selection.endColumn - 1);
    } else {
      return new Selection(this._selection.startLineNumber, this._selection.startColumn + 1, this._selection.endLineNumber, this._selection.endColumn + 1);
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/caretOperations.js
var MoveCaretAction = class extends EditorAction {
  constructor(left, opts) {
    super(opts);
    this.left = left;
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    let commands = [];
    let selections = editor2.getSelections();
    for (const selection of selections) {
      commands.push(new MoveCaretCommand(selection, this.left));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var MoveCaretLeftAction = class extends MoveCaretAction {
  constructor() {
    super(true, {
      id: "editor.action.moveCarretLeftAction",
      label: localize("caret.moveLeft", "Move Selected Text Left"),
      alias: "Move Selected Text Left",
      precondition: EditorContextKeys.writable
    });
  }
};
var MoveCaretRightAction = class extends MoveCaretAction {
  constructor() {
    super(false, {
      id: "editor.action.moveCarretRightAction",
      label: localize("caret.moveRight", "Move Selected Text Right"),
      alias: "Move Selected Text Right",
      precondition: EditorContextKeys.writable
    });
  }
};
registerEditorAction(MoveCaretLeftAction);
registerEditorAction(MoveCaretRightAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/caretOperations/transpose.js
var TransposeLettersAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.transposeLetters",
      label: localize("transposeLetters.label", "Transpose Letters"),
      alias: "Transpose Letters",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: {
          primary: 256 | 50
        },
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    let model = editor2.getModel();
    let commands = [];
    let selections = editor2.getSelections();
    for (let selection of selections) {
      if (!selection.isEmpty()) {
        continue;
      }
      let lineNumber = selection.startLineNumber;
      let column = selection.startColumn;
      let lastColumn = model.getLineMaxColumn(lineNumber);
      if (lineNumber === 1 && (column === 1 || column === 2 && lastColumn === 2)) {
        continue;
      }
      let endPosition = column === lastColumn ? selection.getPosition() : MoveOperations.rightPosition(model, selection.getPosition().lineNumber, selection.getPosition().column);
      let middlePosition = MoveOperations.leftPosition(model, endPosition);
      let beginPosition = MoveOperations.leftPosition(model, middlePosition);
      let leftChar = model.getValueInRange(Range.fromPositions(beginPosition, middlePosition));
      let rightChar = model.getValueInRange(Range.fromPositions(middlePosition, endPosition));
      let replaceRange = Range.fromPositions(beginPosition, endPosition);
      commands.push(new ReplaceCommand(replaceRange, rightChar + leftChar));
    }
    if (commands.length > 0) {
      editor2.pushUndoStop();
      editor2.executeCommands(this.id, commands);
      editor2.pushUndoStop();
    }
  }
};
registerEditorAction(TransposeLettersAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/clipboard/clipboard.js
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CLIPBOARD_CONTEXT_MENU_GROUP = "9_cutcopypaste";
var supportsCut = isNative || document.queryCommandSupported("cut");
var supportsCopy = isNative || document.queryCommandSupported("copy");
var supportsPaste = typeof navigator.clipboard === "undefined" || isFirefox ? document.queryCommandSupported("paste") : true;
function registerCommand(command) {
  command.register();
  return command;
}
var CutAction = supportsCut ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardCutAction",
  precondition: void 0,
  kbOpts: isNative ? {
    primary: 2048 | 54,
    win: { primary: 2048 | 54, secondary: [1024 | 20] },
    weight: 100
  } : void 0,
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({ key: "miCut", comment: ["&& denotes a mnemonic"] }, "Cu&&t"),
    order: 1
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.cutLabel", "Cut"),
    when: EditorContextKeys.writable,
    order: 1
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.cutLabel", "Cut"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.cutLabel", "Cut"),
    when: EditorContextKeys.writable,
    order: 1
  }]
})) : void 0;
var CopyAction = supportsCopy ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardCopyAction",
  precondition: void 0,
  kbOpts: isNative ? {
    primary: 2048 | 33,
    win: { primary: 2048 | 33, secondary: [2048 | 19] },
    weight: 100
  } : void 0,
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({ key: "miCopy", comment: ["&& denotes a mnemonic"] }, "&&Copy"),
    order: 2
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 2
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.copyLabel", "Copy"),
    order: 2
  }]
})) : void 0;
MenuRegistry.appendMenuItem(MenuId.MenubarEditMenu, { submenu: MenuId.MenubarCopy, title: { value: localize("copy as", "Copy As"), original: "Copy As" }, group: "2_ccp", order: 3 });
MenuRegistry.appendMenuItem(MenuId.EditorContext, { submenu: MenuId.EditorContextCopy, title: { value: localize("copy as", "Copy As"), original: "Copy As" }, group: CLIPBOARD_CONTEXT_MENU_GROUP, order: 3 });
var PasteAction = supportsPaste ? registerCommand(new MultiCommand({
  id: "editor.action.clipboardPasteAction",
  precondition: void 0,
  kbOpts: isNative ? {
    primary: 2048 | 52,
    win: { primary: 2048 | 52, secondary: [1024 | 19] },
    linux: { primary: 2048 | 52, secondary: [1024 | 19] },
    weight: 100
  } : void 0,
  menuOpts: [{
    menuId: MenuId.MenubarEditMenu,
    group: "2_ccp",
    title: localize({ key: "miPaste", comment: ["&& denotes a mnemonic"] }, "&&Paste"),
    order: 4
  }, {
    menuId: MenuId.EditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    when: EditorContextKeys.writable,
    order: 4
  }, {
    menuId: MenuId.CommandPalette,
    group: "",
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    order: 1
  }, {
    menuId: MenuId.SimpleEditorContext,
    group: CLIPBOARD_CONTEXT_MENU_GROUP,
    title: localize("actions.clipboard.pasteLabel", "Paste"),
    when: EditorContextKeys.writable,
    order: 4
  }]
})) : void 0;
var ExecCommandCopyWithSyntaxHighlightingAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.clipboardCopyWithSyntaxHighlightingAction",
      label: localize("actions.clipboard.copyWithSyntaxHighlightingLabel", "Copy With Syntax Highlighting"),
      alias: "Copy With Syntax Highlighting",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const emptySelectionClipboard = editor2.getOption(32);
    if (!emptySelectionClipboard && editor2.getSelection().isEmpty()) {
      return;
    }
    CopyOptions.forceCopyWithSyntaxHighlighting = true;
    editor2.focus();
    document.execCommand("copy");
    CopyOptions.forceCopyWithSyntaxHighlighting = false;
  }
};
function registerExecCommandImpl(target, browserCommand) {
  if (!target) {
    return;
  }
  target.addImplementation(1e4, "code-editor", (accessor, args) => {
    const focusedEditor = accessor.get(ICodeEditorService).getFocusedCodeEditor();
    if (focusedEditor && focusedEditor.hasTextFocus()) {
      const emptySelectionClipboard = focusedEditor.getOption(32);
      const selection = focusedEditor.getSelection();
      if (selection && selection.isEmpty() && !emptySelectionClipboard) {
        return true;
      }
      document.execCommand(browserCommand);
      return true;
    }
    return false;
  });
  target.addImplementation(0, "generic-dom", (accessor, args) => {
    document.execCommand(browserCommand);
    return true;
  });
}
registerExecCommandImpl(CutAction, "cut");
registerExecCommandImpl(CopyAction, "copy");
if (PasteAction) {
  PasteAction.addImplementation(1e4, "code-editor", (accessor, args) => {
    const codeEditorService = accessor.get(ICodeEditorService);
    const clipboardService = accessor.get(IClipboardService);
    const focusedEditor = codeEditorService.getFocusedCodeEditor();
    if (focusedEditor && focusedEditor.hasTextFocus()) {
      const result = document.execCommand("paste");
      if (!result && isWeb) {
        return (() => __awaiter2(void 0, void 0, void 0, function* () {
          const clipboardText = yield clipboardService.readText();
          if (clipboardText !== "") {
            const metadata = InMemoryClipboardMetadataManager.INSTANCE.get(clipboardText);
            let pasteOnNewLine = false;
            let multicursorText = null;
            let mode = null;
            if (metadata) {
              pasteOnNewLine = focusedEditor.getOption(32) && !!metadata.isFromEmptySelection;
              multicursorText = typeof metadata.multicursorText !== "undefined" ? metadata.multicursorText : null;
              mode = metadata.mode;
            }
            focusedEditor.trigger("keyboard", "paste", {
              text: clipboardText,
              pasteOnNewLine,
              multicursorText,
              mode
            });
          }
        }))();
      }
      return true;
    }
    return false;
  });
  PasteAction.addImplementation(0, "generic-dom", (accessor, args) => {
    document.execCommand("paste");
    return true;
  });
}
if (supportsCopy) {
  registerEditorAction(ExecCommandCopyWithSyntaxHighlightingAction);
}

// node_modules/monaco-editor/esm/vs/base/common/lazy.js
var Lazy = class {
  constructor(executor) {
    this.executor = executor;
    this._didRun = false;
  }
  getValue() {
    if (!this._didRun) {
      try {
        this._value = this.executor();
      } catch (err) {
        this._error = err;
      } finally {
        this._didRun = true;
      }
    }
    if (this._error) {
      throw this._error;
    }
    return this._value;
  }
  get rawValue() {
    return this._value;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/types.js
var CodeActionKind = class {
  constructor(value) {
    this.value = value;
  }
  equals(other) {
    return this.value === other.value;
  }
  contains(other) {
    return this.equals(other) || this.value === "" || other.value.startsWith(this.value + CodeActionKind.sep);
  }
  intersects(other) {
    return this.contains(other) || other.contains(this);
  }
  append(part) {
    return new CodeActionKind(this.value + CodeActionKind.sep + part);
  }
};
CodeActionKind.sep = ".";
CodeActionKind.None = new CodeActionKind("@@none@@");
CodeActionKind.Empty = new CodeActionKind("");
CodeActionKind.QuickFix = new CodeActionKind("quickfix");
CodeActionKind.Refactor = new CodeActionKind("refactor");
CodeActionKind.Source = new CodeActionKind("source");
CodeActionKind.SourceOrganizeImports = CodeActionKind.Source.append("organizeImports");
CodeActionKind.SourceFixAll = CodeActionKind.Source.append("fixAll");
function mayIncludeActionsOfKind(filter, providedKind) {
  if (filter.include && !filter.include.intersects(providedKind)) {
    return false;
  }
  if (filter.excludes) {
    if (filter.excludes.some((exclude) => excludesAction(providedKind, exclude, filter.include))) {
      return false;
    }
  }
  if (!filter.includeSourceActions && CodeActionKind.Source.contains(providedKind)) {
    return false;
  }
  return true;
}
function filtersAction(filter, action) {
  const actionKind = action.kind ? new CodeActionKind(action.kind) : void 0;
  if (filter.include) {
    if (!actionKind || !filter.include.contains(actionKind)) {
      return false;
    }
  }
  if (filter.excludes) {
    if (actionKind && filter.excludes.some((exclude) => excludesAction(actionKind, exclude, filter.include))) {
      return false;
    }
  }
  if (!filter.includeSourceActions) {
    if (actionKind && CodeActionKind.Source.contains(actionKind)) {
      return false;
    }
  }
  if (filter.onlyIncludePreferredActions) {
    if (!action.isPreferred) {
      return false;
    }
  }
  return true;
}
function excludesAction(providedKind, exclude, include) {
  if (!exclude.contains(providedKind)) {
    return false;
  }
  if (include && exclude.contains(include)) {
    return false;
  }
  return true;
}
var CodeActionCommandArgs = class {
  constructor(kind, apply2, preferred) {
    this.kind = kind;
    this.apply = apply2;
    this.preferred = preferred;
  }
  static fromUser(arg, defaults) {
    if (!arg || typeof arg !== "object") {
      return new CodeActionCommandArgs(defaults.kind, defaults.apply, false);
    }
    return new CodeActionCommandArgs(CodeActionCommandArgs.getKindFromUser(arg, defaults.kind), CodeActionCommandArgs.getApplyFromUser(arg, defaults.apply), CodeActionCommandArgs.getPreferredUser(arg));
  }
  static getApplyFromUser(arg, defaultAutoApply) {
    switch (typeof arg.apply === "string" ? arg.apply.toLowerCase() : "") {
      case "first":
        return "first";
      case "never":
        return "never";
      case "ifsingle":
        return "ifSingle";
      default:
        return defaultAutoApply;
    }
  }
  static getKindFromUser(arg, defaultKind) {
    return typeof arg.kind === "string" ? new CodeActionKind(arg.kind) : defaultKind;
  }
  static getPreferredUser(arg) {
    return typeof arg.preferred === "boolean" ? arg.preferred : false;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeAction.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var codeActionCommandId = "editor.action.codeAction";
var refactorCommandId = "editor.action.refactor";
var sourceActionCommandId = "editor.action.sourceAction";
var organizeImportsCommandId = "editor.action.organizeImports";
var fixAllCommandId = "editor.action.fixAll";
var CodeActionItem = class {
  constructor(action, provider) {
    this.action = action;
    this.provider = provider;
  }
  resolve(token) {
    var _a5;
    return __awaiter3(this, void 0, void 0, function* () {
      if (((_a5 = this.provider) === null || _a5 === void 0 ? void 0 : _a5.resolveCodeAction) && !this.action.edit) {
        let action;
        try {
          action = yield this.provider.resolveCodeAction(this.action, token);
        } catch (err) {
          onUnexpectedExternalError(err);
        }
        if (action) {
          this.action.edit = action.edit;
        }
      }
      return this;
    });
  }
};
var ManagedCodeActionSet = class extends Disposable {
  constructor(actions, documentation, disposables) {
    super();
    this.documentation = documentation;
    this._register(disposables);
    this.allActions = [...actions].sort(ManagedCodeActionSet.codeActionsComparator);
    this.validActions = this.allActions.filter(({ action }) => !action.disabled);
  }
  static codeActionsComparator({ action: a }, { action: b }) {
    if (a.isPreferred && !b.isPreferred) {
      return -1;
    } else if (!a.isPreferred && b.isPreferred) {
      return 1;
    }
    if (isNonEmptyArray(a.diagnostics)) {
      if (isNonEmptyArray(b.diagnostics)) {
        return a.diagnostics[0].message.localeCompare(b.diagnostics[0].message);
      } else {
        return -1;
      }
    } else if (isNonEmptyArray(b.diagnostics)) {
      return 1;
    } else {
      return 0;
    }
  }
  get hasAutoFix() {
    return this.validActions.some(({ action: fix }) => !!fix.kind && CodeActionKind.QuickFix.contains(new CodeActionKind(fix.kind)) && !!fix.isPreferred);
  }
};
var emptyCodeActionsResponse = { actions: [], documentation: void 0 };
function getCodeActions(model, rangeOrSelection, trigger, progress, token) {
  var _a5;
  const filter = trigger.filter || {};
  const codeActionContext = {
    only: (_a5 = filter.include) === null || _a5 === void 0 ? void 0 : _a5.value,
    trigger: trigger.type
  };
  const cts = new TextModelCancellationTokenSource(model, token);
  const providers = getCodeActionProviders(model, filter);
  const disposables = new DisposableStore();
  const promises = providers.map((provider) => __awaiter3(this, void 0, void 0, function* () {
    try {
      progress.report(provider);
      const providedCodeActions = yield provider.provideCodeActions(model, rangeOrSelection, codeActionContext, cts.token);
      if (providedCodeActions) {
        disposables.add(providedCodeActions);
      }
      if (cts.token.isCancellationRequested) {
        return emptyCodeActionsResponse;
      }
      const filteredActions = ((providedCodeActions === null || providedCodeActions === void 0 ? void 0 : providedCodeActions.actions) || []).filter((action) => action && filtersAction(filter, action));
      const documentation = getDocumentation(provider, filteredActions, filter.include);
      return {
        actions: filteredActions.map((action) => new CodeActionItem(action, provider)),
        documentation
      };
    } catch (err) {
      if (isPromiseCanceledError(err)) {
        throw err;
      }
      onUnexpectedExternalError(err);
      return emptyCodeActionsResponse;
    }
  }));
  const listener = CodeActionProviderRegistry.onDidChange(() => {
    const newProviders = CodeActionProviderRegistry.all(model);
    if (!equals(newProviders, providers)) {
      cts.cancel();
    }
  });
  return Promise.all(promises).then((actions) => {
    const allActions = flatten(actions.map((x) => x.actions));
    const allDocumentation = coalesce(actions.map((x) => x.documentation));
    return new ManagedCodeActionSet(allActions, allDocumentation, disposables);
  }).finally(() => {
    listener.dispose();
    cts.dispose();
  });
}
function getCodeActionProviders(model, filter) {
  return CodeActionProviderRegistry.all(model).filter((provider) => {
    if (!provider.providedCodeActionKinds) {
      return true;
    }
    return provider.providedCodeActionKinds.some((kind) => mayIncludeActionsOfKind(filter, new CodeActionKind(kind)));
  });
}
function getDocumentation(provider, providedCodeActions, only) {
  if (!provider.documentation) {
    return void 0;
  }
  const documentation = provider.documentation.map((entry) => ({ kind: new CodeActionKind(entry.kind), command: entry.command }));
  if (only) {
    let currentBest;
    for (const entry of documentation) {
      if (entry.kind.contains(only)) {
        if (!currentBest) {
          currentBest = entry;
        } else {
          if (currentBest.kind.contains(entry.kind)) {
            currentBest = entry;
          }
        }
      }
    }
    if (currentBest) {
      return currentBest === null || currentBest === void 0 ? void 0 : currentBest.command;
    }
  }
  for (const action of providedCodeActions) {
    if (!action.kind) {
      continue;
    }
    for (const entry of documentation) {
      if (entry.kind.contains(new CodeActionKind(action.kind))) {
        return entry.command;
      }
    }
  }
  return void 0;
}
CommandsRegistry.registerCommand("_executeCodeActionProvider", function(accessor, resource, rangeOrSelection, kind, itemResolveCount) {
  return __awaiter3(this, void 0, void 0, function* () {
    if (!(resource instanceof URI)) {
      throw illegalArgument();
    }
    const model = accessor.get(IModelService).getModel(resource);
    if (!model) {
      throw illegalArgument();
    }
    const validatedRangeOrSelection = Selection.isISelection(rangeOrSelection) ? Selection.liftSelection(rangeOrSelection) : Range.isIRange(rangeOrSelection) ? model.validateRange(rangeOrSelection) : void 0;
    if (!validatedRangeOrSelection) {
      throw illegalArgument();
    }
    const include = typeof kind === "string" ? new CodeActionKind(kind) : void 0;
    const codeActionSet = yield getCodeActions(model, validatedRangeOrSelection, { type: 1, filter: { includeSourceActions: true, include } }, Progress.None, CancellationToken.None);
    const resolving = [];
    const resolveCount = Math.min(codeActionSet.validActions.length, typeof itemResolveCount === "number" ? itemResolveCount : 0);
    for (let i = 0; i < resolveCount; i++) {
      resolving.push(codeActionSet.validActions[i].resolve(CancellationToken.None));
    }
    try {
      yield Promise.all(resolving);
      return codeActionSet.validActions.map((item) => item.action);
    } finally {
      setTimeout(() => codeActionSet.dispose(), 100);
    }
  });
});

// node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/message/messageController.css";
var __decorate2 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MessageController = class MessageController2 {
  constructor(editor2, contextKeyService) {
    this._messageWidget = new MutableDisposable();
    this._messageListeners = new DisposableStore();
    this._editor = editor2;
    this._visible = MessageController2.MESSAGE_VISIBLE.bindTo(contextKeyService);
    this._editorListener = this._editor.onDidAttemptReadOnlyEdit(() => this._onDidAttemptReadOnlyEdit());
  }
  static get(editor2) {
    return editor2.getContribution(MessageController2.ID);
  }
  dispose() {
    this._editorListener.dispose();
    this._messageListeners.dispose();
    this._messageWidget.dispose();
    this._visible.reset();
  }
  showMessage(message, position) {
    alert(message);
    this._visible.set(true);
    this._messageWidget.clear();
    this._messageListeners.clear();
    this._messageWidget.value = new MessageWidget(this._editor, position, message);
    this._messageListeners.add(this._editor.onDidBlurEditorText(() => this.closeMessage()));
    this._messageListeners.add(this._editor.onDidChangeCursorPosition(() => this.closeMessage()));
    this._messageListeners.add(this._editor.onDidDispose(() => this.closeMessage()));
    this._messageListeners.add(this._editor.onDidChangeModel(() => this.closeMessage()));
    this._messageListeners.add(new TimeoutTimer(() => this.closeMessage(), 3e3));
    let bounds;
    this._messageListeners.add(this._editor.onMouseMove((e) => {
      if (!e.target.position) {
        return;
      }
      if (!bounds) {
        bounds = new Range(position.lineNumber - 3, 1, e.target.position.lineNumber + 3, 1);
      } else if (!bounds.containsPosition(e.target.position)) {
        this.closeMessage();
      }
    }));
  }
  closeMessage() {
    this._visible.reset();
    this._messageListeners.clear();
    if (this._messageWidget.value) {
      this._messageListeners.add(MessageWidget.fadeOut(this._messageWidget.value));
    }
  }
  _onDidAttemptReadOnlyEdit() {
    if (this._editor.hasModel()) {
      this.showMessage(localize("editor.readonly", "Cannot edit in read-only editor"), this._editor.getPosition());
    }
  }
};
MessageController.ID = "editor.contrib.messageController";
MessageController.MESSAGE_VISIBLE = new RawContextKey("messageVisible", false, localize("messageVisible", "Whether the editor is currently showing an inline message"));
MessageController = __decorate2([
  __param2(1, IContextKeyService)
], MessageController);
var MessageCommand = EditorCommand.bindToContribution(MessageController.get);
registerEditorCommand(new MessageCommand({
  id: "leaveEditorMessage",
  precondition: MessageController.MESSAGE_VISIBLE,
  handler: (c) => c.closeMessage(),
  kbOpts: {
    weight: 100 + 30,
    primary: 9
  }
}));
var MessageWidget = class {
  constructor(editor2, { lineNumber, column }, text2) {
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this._editor = editor2;
    this._editor.revealLinesInCenterIfOutsideViewport(lineNumber, lineNumber, 0);
    this._position = { lineNumber, column: column - 1 };
    this._domNode = document.createElement("div");
    this._domNode.classList.add("monaco-editor-overlaymessage");
    const anchorTop = document.createElement("div");
    anchorTop.classList.add("anchor", "top");
    this._domNode.appendChild(anchorTop);
    const message = document.createElement("div");
    message.classList.add("message");
    message.textContent = text2;
    this._domNode.appendChild(message);
    const anchorBottom = document.createElement("div");
    anchorBottom.classList.add("anchor", "below");
    this._domNode.appendChild(anchorBottom);
    this._editor.addContentWidget(this);
    this._domNode.classList.add("fadeIn");
  }
  static fadeOut(messageWidget) {
    let handle;
    const dispose2 = () => {
      messageWidget.dispose();
      clearTimeout(handle);
      messageWidget.getDomNode().removeEventListener("animationend", dispose2);
    };
    handle = setTimeout(dispose2, 110);
    messageWidget.getDomNode().addEventListener("animationend", dispose2);
    messageWidget.getDomNode().classList.add("fadeOut");
    return { dispose: dispose2 };
  }
  dispose() {
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "messageoverlay";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return { position: this._position, preference: [1, 2] };
  }
  afterRender(position) {
    this._domNode.classList.toggle("below", position === 2);
  }
};
registerEditorContribution(MessageController.ID, MessageController);

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionMenu.js
var __decorate3 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CodeActionAction = class extends Action {
  constructor(action, callback) {
    super(action.command ? action.command.id : action.title, stripNewlines(action.title), void 0, !action.disabled, callback);
    this.action = action;
  }
};
function stripNewlines(str) {
  return str.replace(/\r\n|\r|\n/g, " ");
}
var CodeActionMenu = class CodeActionMenu2 extends Disposable {
  constructor(_editor, _delegate, _contextMenuService, keybindingService) {
    super();
    this._editor = _editor;
    this._delegate = _delegate;
    this._contextMenuService = _contextMenuService;
    this._visible = false;
    this._showingActions = this._register(new MutableDisposable());
    this._keybindingResolver = new CodeActionKeybindingResolver({
      getKeybindings: () => keybindingService.getKeybindings()
    });
  }
  get isVisible() {
    return this._visible;
  }
  show(trigger, codeActions, at, options) {
    return __awaiter4(this, void 0, void 0, function* () {
      const actionsToShow = options.includeDisabledActions ? codeActions.allActions : codeActions.validActions;
      if (!actionsToShow.length) {
        this._visible = false;
        return;
      }
      if (!this._editor.getDomNode()) {
        this._visible = false;
        throw canceled();
      }
      this._visible = true;
      this._showingActions.value = codeActions;
      const menuActions = this.getMenuActions(trigger, actionsToShow, codeActions.documentation);
      const anchor = Position.isIPosition(at) ? this._toCoords(at) : at || { x: 0, y: 0 };
      const resolver = this._keybindingResolver.getResolver();
      const useShadowDOM = this._editor.getOption(114);
      this._contextMenuService.showContextMenu({
        domForShadowRoot: useShadowDOM ? this._editor.getDomNode() : void 0,
        getAnchor: () => anchor,
        getActions: () => menuActions,
        onHide: () => {
          this._visible = false;
          this._editor.focus();
        },
        autoSelectFirstItem: true,
        getKeyBinding: (action) => action instanceof CodeActionAction ? resolver(action.action) : void 0
      });
    });
  }
  getMenuActions(trigger, actionsToShow, documentation) {
    var _a5, _b2;
    const toCodeActionAction = (item) => new CodeActionAction(item.action, () => this._delegate.onSelectCodeAction(item));
    const result = actionsToShow.map(toCodeActionAction);
    const allDocumentation = [...documentation];
    const model = this._editor.getModel();
    if (model && result.length) {
      for (const provider of CodeActionProviderRegistry.all(model)) {
        if (provider._getAdditionalMenuItems) {
          allDocumentation.push(...provider._getAdditionalMenuItems({ trigger: trigger.type, only: (_b2 = (_a5 = trigger.filter) === null || _a5 === void 0 ? void 0 : _a5.include) === null || _b2 === void 0 ? void 0 : _b2.value }, actionsToShow.map((item) => item.action)));
        }
      }
    }
    if (allDocumentation.length) {
      result.push(new Separator(), ...allDocumentation.map((command) => toCodeActionAction(new CodeActionItem({
        title: command.title,
        command
      }, void 0))));
    }
    return result;
  }
  _toCoords(position) {
    if (!this._editor.hasModel()) {
      return { x: 0, y: 0 };
    }
    this._editor.revealPosition(position, 1);
    this._editor.render();
    const cursorCoords = this._editor.getScrolledVisiblePosition(position);
    const editorCoords = getDomNodePagePosition(this._editor.getDomNode());
    const x = editorCoords.left + cursorCoords.left;
    const y = editorCoords.top + cursorCoords.top + cursorCoords.height;
    return { x, y };
  }
};
CodeActionMenu = __decorate3([
  __param3(2, IContextMenuService),
  __param3(3, IKeybindingService)
], CodeActionMenu);
var CodeActionKeybindingResolver = class {
  constructor(_keybindingProvider) {
    this._keybindingProvider = _keybindingProvider;
  }
  getResolver() {
    const allCodeActionBindings = new Lazy(() => this._keybindingProvider.getKeybindings().filter((item) => CodeActionKeybindingResolver.codeActionCommands.indexOf(item.command) >= 0).filter((item) => item.resolvedKeybinding).map((item) => {
      let commandArgs = item.commandArgs;
      if (item.command === organizeImportsCommandId) {
        commandArgs = { kind: CodeActionKind.SourceOrganizeImports.value };
      } else if (item.command === fixAllCommandId) {
        commandArgs = { kind: CodeActionKind.SourceFixAll.value };
      }
      return Object.assign({ resolvedKeybinding: item.resolvedKeybinding }, CodeActionCommandArgs.fromUser(commandArgs, {
        kind: CodeActionKind.None,
        apply: "never"
      }));
    }));
    return (action) => {
      if (action.kind) {
        const binding = this.bestKeybindingForCodeAction(action, allCodeActionBindings.getValue());
        return binding === null || binding === void 0 ? void 0 : binding.resolvedKeybinding;
      }
      return void 0;
    };
  }
  bestKeybindingForCodeAction(action, candidates) {
    if (!action.kind) {
      return void 0;
    }
    const kind = new CodeActionKind(action.kind);
    return candidates.filter((candidate) => candidate.kind.contains(kind)).filter((candidate) => {
      if (candidate.preferred) {
        return action.isPreferred;
      }
      return true;
    }).reduceRight((currentBest, candidate) => {
      if (!currentBest) {
        return candidate;
      }
      return currentBest.kind.contains(candidate.kind) ? candidate : currentBest;
    }, void 0);
  }
};
CodeActionKeybindingResolver.codeActionCommands = [
  refactorCommandId,
  codeActionCommandId,
  sourceActionCommandId,
  organizeImportsCommandId,
  fixAllCommandId
];

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/lightBulbWidget.css";
var __decorate4 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var LightBulbState;
(function(LightBulbState2) {
  LightBulbState2.Hidden = { type: 0 };
  class Showing {
    constructor(actions, trigger, editorPosition, widgetPosition) {
      this.actions = actions;
      this.trigger = trigger;
      this.editorPosition = editorPosition;
      this.widgetPosition = widgetPosition;
      this.type = 1;
    }
  }
  LightBulbState2.Showing = Showing;
})(LightBulbState || (LightBulbState = {}));
var LightBulbWidget = class LightBulbWidget2 extends Disposable {
  constructor(_editor, _quickFixActionId, _preferredFixActionId, _keybindingService) {
    super();
    this._editor = _editor;
    this._quickFixActionId = _quickFixActionId;
    this._preferredFixActionId = _preferredFixActionId;
    this._keybindingService = _keybindingService;
    this._onClick = this._register(new Emitter());
    this.onClick = this._onClick.event;
    this._state = LightBulbState.Hidden;
    this._domNode = document.createElement("div");
    this._domNode.className = Codicon.lightBulb.classNames;
    this._editor.addContentWidget(this);
    this._register(this._editor.onDidChangeModelContent((_) => {
      const editorModel = this._editor.getModel();
      if (this.state.type !== 1 || !editorModel || this.state.editorPosition.lineNumber >= editorModel.getLineCount()) {
        this.hide();
      }
    }));
    Gesture.ignoreTarget(this._domNode);
    this._register(addStandardDisposableGenericMouseDownListner(this._domNode, (e) => {
      if (this.state.type !== 1) {
        return;
      }
      this._editor.focus();
      e.preventDefault();
      const { top, height } = getDomNodePagePosition(this._domNode);
      const lineHeight = this._editor.getOption(58);
      let pad = Math.floor(lineHeight / 3);
      if (this.state.widgetPosition.position !== null && this.state.widgetPosition.position.lineNumber < this.state.editorPosition.lineNumber) {
        pad += lineHeight;
      }
      this._onClick.fire({
        x: e.posx,
        y: top + height + pad,
        actions: this.state.actions,
        trigger: this.state.trigger
      });
    }));
    this._register(addDisposableListener(this._domNode, "mouseenter", (e) => {
      if ((e.buttons & 1) !== 1) {
        return;
      }
      this.hide();
      const monitor = new GlobalMouseMoveMonitor();
      monitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, () => {
      }, () => {
        monitor.dispose();
      });
    }));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(56) && !this._editor.getOption(56).enabled) {
        this.hide();
      }
    }));
    this._updateLightBulbTitleAndIcon();
    this._register(this._keybindingService.onDidUpdateKeybindings(this._updateLightBulbTitleAndIcon, this));
  }
  dispose() {
    super.dispose();
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "LightBulbWidget";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._state.type === 1 ? this._state.widgetPosition : null;
  }
  update(actions, trigger, atPosition) {
    if (actions.validActions.length <= 0) {
      return this.hide();
    }
    const options = this._editor.getOptions();
    if (!options.get(56).enabled) {
      return this.hide();
    }
    const model = this._editor.getModel();
    if (!model) {
      return this.hide();
    }
    const { lineNumber, column } = model.validatePosition(atPosition);
    const tabSize = model.getOptions().tabSize;
    const fontInfo = options.get(43);
    const lineContent = model.getLineContent(lineNumber);
    const indent = TextModel.computeIndentLevel(lineContent, tabSize);
    const lineHasSpace = fontInfo.spaceWidth * indent > 22;
    const isFolded = (lineNumber2) => {
      return lineNumber2 > 2 && this._editor.getTopForLineNumber(lineNumber2) === this._editor.getTopForLineNumber(lineNumber2 - 1);
    };
    let effectiveLineNumber = lineNumber;
    if (!lineHasSpace) {
      if (lineNumber > 1 && !isFolded(lineNumber - 1)) {
        effectiveLineNumber -= 1;
      } else if (!isFolded(lineNumber + 1)) {
        effectiveLineNumber += 1;
      } else if (column * fontInfo.spaceWidth < 22) {
        return this.hide();
      }
    }
    this.state = new LightBulbState.Showing(actions, trigger, atPosition, {
      position: { lineNumber: effectiveLineNumber, column: 1 },
      preference: LightBulbWidget2._posPref
    });
    this._editor.layoutContentWidget(this);
  }
  hide() {
    this.state = LightBulbState.Hidden;
    this._editor.layoutContentWidget(this);
  }
  get state() {
    return this._state;
  }
  set state(value) {
    this._state = value;
    this._updateLightBulbTitleAndIcon();
  }
  _updateLightBulbTitleAndIcon() {
    if (this.state.type === 1 && this.state.actions.hasAutoFix) {
      this._domNode.classList.remove(...Codicon.lightBulb.classNamesArray);
      this._domNode.classList.add(...Codicon.lightbulbAutofix.classNamesArray);
      const preferredKb = this._keybindingService.lookupKeybinding(this._preferredFixActionId);
      if (preferredKb) {
        this.title = localize("preferredcodeActionWithKb", "Show Code Actions. Preferred Quick Fix Available ({0})", preferredKb.getLabel());
        return;
      }
    }
    this._domNode.classList.remove(...Codicon.lightbulbAutofix.classNamesArray);
    this._domNode.classList.add(...Codicon.lightBulb.classNamesArray);
    const kb = this._keybindingService.lookupKeybinding(this._quickFixActionId);
    if (kb) {
      this.title = localize("codeActionWithKb", "Show Code Actions ({0})", kb.getLabel());
    } else {
      this.title = localize("codeAction", "Show Code Actions");
    }
  }
  set title(value) {
    this._domNode.title = value;
  }
};
LightBulbWidget._posPref = [0];
LightBulbWidget = __decorate4([
  __param4(3, IKeybindingService)
], LightBulbWidget);
registerThemingParticipant((theme, collector) => {
  var _a5;
  const editorBackgroundColor = (_a5 = theme.getColor(editorBackground)) === null || _a5 === void 0 ? void 0 : _a5.transparent(0.7);
  const editorLightBulbForegroundColor = theme.getColor(editorLightBulbForeground);
  if (editorLightBulbForegroundColor) {
    collector.addRule(`
		.monaco-editor .contentWidgets ${Codicon.lightBulb.cssSelector} {
			color: ${editorLightBulbForegroundColor};
			background-color: ${editorBackgroundColor};
		}`);
  }
  const editorLightBulbAutoFixForegroundColor = theme.getColor(editorLightBulbAutoFixForeground);
  if (editorLightBulbAutoFixForegroundColor) {
    collector.addRule(`
		.monaco-editor .contentWidgets ${Codicon.lightbulbAutofix.cssSelector} {
			color: ${editorLightBulbAutoFixForegroundColor};
			background-color: ${editorBackgroundColor};
		}`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionUi.js
var __decorate5 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CodeActionUi_disposed;
var CodeActionUi = class CodeActionUi2 extends Disposable {
  constructor(_editor, quickFixActionId, preferredFixActionId, delegate, instantiationService) {
    super();
    this._editor = _editor;
    this.delegate = delegate;
    this._activeCodeActions = this._register(new MutableDisposable());
    _CodeActionUi_disposed.set(this, false);
    this._codeActionWidget = new Lazy(() => {
      return this._register(instantiationService.createInstance(CodeActionMenu, this._editor, {
        onSelectCodeAction: (action) => __awaiter5(this, void 0, void 0, function* () {
          this.delegate.applyCodeAction(action, true);
        })
      }));
    });
    this._lightBulbWidget = new Lazy(() => {
      const widget = this._register(instantiationService.createInstance(LightBulbWidget, this._editor, quickFixActionId, preferredFixActionId));
      this._register(widget.onClick((e) => this.showCodeActionList(e.trigger, e.actions, e, { includeDisabledActions: false })));
      return widget;
    });
  }
  dispose() {
    __classPrivateFieldSet(this, _CodeActionUi_disposed, true, "f");
    super.dispose();
  }
  update(newState) {
    var _a5, _b2, _c2;
    return __awaiter5(this, void 0, void 0, function* () {
      if (newState.type !== 1) {
        (_a5 = this._lightBulbWidget.rawValue) === null || _a5 === void 0 ? void 0 : _a5.hide();
        return;
      }
      let actions;
      try {
        actions = yield newState.actions;
      } catch (e) {
        onUnexpectedError(e);
        return;
      }
      if (__classPrivateFieldGet(this, _CodeActionUi_disposed, "f")) {
        return;
      }
      this._lightBulbWidget.getValue().update(actions, newState.trigger, newState.position);
      if (newState.trigger.type === 1) {
        if ((_b2 = newState.trigger.filter) === null || _b2 === void 0 ? void 0 : _b2.include) {
          const validActionToApply = this.tryGetValidActionToApply(newState.trigger, actions);
          if (validActionToApply) {
            try {
              this._lightBulbWidget.getValue().hide();
              yield this.delegate.applyCodeAction(validActionToApply, false);
            } finally {
              actions.dispose();
            }
            return;
          }
          if (newState.trigger.context) {
            const invalidAction = this.getInvalidActionThatWouldHaveBeenApplied(newState.trigger, actions);
            if (invalidAction && invalidAction.action.disabled) {
              MessageController.get(this._editor).showMessage(invalidAction.action.disabled, newState.trigger.context.position);
              actions.dispose();
              return;
            }
          }
        }
        const includeDisabledActions = !!((_c2 = newState.trigger.filter) === null || _c2 === void 0 ? void 0 : _c2.include);
        if (newState.trigger.context) {
          if (!actions.allActions.length || !includeDisabledActions && !actions.validActions.length) {
            MessageController.get(this._editor).showMessage(newState.trigger.context.notAvailableMessage, newState.trigger.context.position);
            this._activeCodeActions.value = actions;
            actions.dispose();
            return;
          }
        }
        this._activeCodeActions.value = actions;
        this._codeActionWidget.getValue().show(newState.trigger, actions, newState.position, { includeDisabledActions });
      } else {
        if (this._codeActionWidget.getValue().isVisible) {
          actions.dispose();
        } else {
          this._activeCodeActions.value = actions;
        }
      }
    });
  }
  getInvalidActionThatWouldHaveBeenApplied(trigger, actions) {
    if (!actions.allActions.length) {
      return void 0;
    }
    if (trigger.autoApply === "first" && actions.validActions.length === 0 || trigger.autoApply === "ifSingle" && actions.allActions.length === 1) {
      return actions.allActions.find(({ action }) => action.disabled);
    }
    return void 0;
  }
  tryGetValidActionToApply(trigger, actions) {
    if (!actions.validActions.length) {
      return void 0;
    }
    if (trigger.autoApply === "first" && actions.validActions.length > 0 || trigger.autoApply === "ifSingle" && actions.validActions.length === 1) {
      return actions.validActions[0];
    }
    return void 0;
  }
  showCodeActionList(trigger, actions, at, options) {
    return __awaiter5(this, void 0, void 0, function* () {
      this._codeActionWidget.getValue().show(trigger, actions, at, options);
    });
  }
};
_CodeActionUi_disposed = new WeakMap();
CodeActionUi = __decorate5([
  __param5(4, IInstantiationService)
], CodeActionUi);

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionModel.js
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _CodeActionModel_isDisposed;
var SUPPORTED_CODE_ACTIONS = new RawContextKey("supportedCodeAction", "");
var CodeActionOracle = class extends Disposable {
  constructor(_editor, _markerService, _signalChange, _delay = 250) {
    super();
    this._editor = _editor;
    this._markerService = _markerService;
    this._signalChange = _signalChange;
    this._delay = _delay;
    this._autoTriggerTimer = this._register(new TimeoutTimer());
    this._register(this._markerService.onMarkerChanged((e) => this._onMarkerChanges(e)));
    this._register(this._editor.onDidChangeCursorPosition(() => this._onCursorChange()));
  }
  trigger(trigger) {
    const selection = this._getRangeOfSelectionUnlessWhitespaceEnclosed(trigger);
    return this._createEventAndSignalChange(trigger, selection);
  }
  _onMarkerChanges(resources2) {
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    if (resources2.some((resource) => isEqual(resource, model.uri))) {
      this._autoTriggerTimer.cancelAndSet(() => {
        this.trigger({ type: 2 });
      }, this._delay);
    }
  }
  _onCursorChange() {
    this._autoTriggerTimer.cancelAndSet(() => {
      this.trigger({ type: 2 });
    }, this._delay);
  }
  _getRangeOfMarker(selection) {
    const model = this._editor.getModel();
    if (!model) {
      return void 0;
    }
    for (const marker of this._markerService.read({ resource: model.uri })) {
      const markerRange = model.validateRange(marker);
      if (Range.intersectRanges(markerRange, selection)) {
        return Range.lift(markerRange);
      }
    }
    return void 0;
  }
  _getRangeOfSelectionUnlessWhitespaceEnclosed(trigger) {
    if (!this._editor.hasModel()) {
      return void 0;
    }
    const model = this._editor.getModel();
    const selection = this._editor.getSelection();
    if (selection.isEmpty() && trigger.type === 2) {
      const { lineNumber, column } = selection.getPosition();
      const line = model.getLineContent(lineNumber);
      if (line.length === 0) {
        return void 0;
      } else if (column === 1) {
        if (/\s/.test(line[0])) {
          return void 0;
        }
      } else if (column === model.getLineMaxColumn(lineNumber)) {
        if (/\s/.test(line[line.length - 1])) {
          return void 0;
        }
      } else {
        if (/\s/.test(line[column - 2]) && /\s/.test(line[column - 1])) {
          return void 0;
        }
      }
    }
    return selection;
  }
  _createEventAndSignalChange(trigger, selection) {
    const model = this._editor.getModel();
    if (!selection || !model) {
      this._signalChange(void 0);
      return void 0;
    }
    const markerRange = this._getRangeOfMarker(selection);
    const position = markerRange ? markerRange.getStartPosition() : selection.getStartPosition();
    const e = {
      trigger,
      selection,
      position
    };
    this._signalChange(e);
    return e;
  }
};
var CodeActionsState;
(function(CodeActionsState2) {
  CodeActionsState2.Empty = { type: 0 };
  class Triggered {
    constructor(trigger, rangeOrSelection, position, _cancellablePromise) {
      this.trigger = trigger;
      this.rangeOrSelection = rangeOrSelection;
      this.position = position;
      this._cancellablePromise = _cancellablePromise;
      this.type = 1;
      this.actions = _cancellablePromise.catch((e) => {
        if (isPromiseCanceledError(e)) {
          return emptyCodeActionSet;
        }
        throw e;
      });
    }
    cancel() {
      this._cancellablePromise.cancel();
    }
  }
  CodeActionsState2.Triggered = Triggered;
})(CodeActionsState || (CodeActionsState = {}));
var emptyCodeActionSet = {
  allActions: [],
  validActions: [],
  dispose: () => {
  },
  documentation: [],
  hasAutoFix: false
};
var CodeActionModel = class extends Disposable {
  constructor(_editor, _markerService, contextKeyService, _progressService) {
    super();
    this._editor = _editor;
    this._markerService = _markerService;
    this._progressService = _progressService;
    this._codeActionOracle = this._register(new MutableDisposable());
    this._state = CodeActionsState.Empty;
    this._onDidChangeState = this._register(new Emitter());
    this.onDidChangeState = this._onDidChangeState.event;
    _CodeActionModel_isDisposed.set(this, false);
    this._supportedCodeActions = SUPPORTED_CODE_ACTIONS.bindTo(contextKeyService);
    this._register(this._editor.onDidChangeModel(() => this._update()));
    this._register(this._editor.onDidChangeModelLanguage(() => this._update()));
    this._register(CodeActionProviderRegistry.onDidChange(() => this._update()));
    this._update();
  }
  dispose() {
    if (__classPrivateFieldGet2(this, _CodeActionModel_isDisposed, "f")) {
      return;
    }
    __classPrivateFieldSet2(this, _CodeActionModel_isDisposed, true, "f");
    super.dispose();
    this.setState(CodeActionsState.Empty, true);
  }
  _update() {
    if (__classPrivateFieldGet2(this, _CodeActionModel_isDisposed, "f")) {
      return;
    }
    this._codeActionOracle.value = void 0;
    this.setState(CodeActionsState.Empty);
    const model = this._editor.getModel();
    if (model && CodeActionProviderRegistry.has(model) && !this._editor.getOption(80)) {
      const supportedActions = [];
      for (const provider of CodeActionProviderRegistry.all(model)) {
        if (Array.isArray(provider.providedCodeActionKinds)) {
          supportedActions.push(...provider.providedCodeActionKinds);
        }
      }
      this._supportedCodeActions.set(supportedActions.join(" "));
      this._codeActionOracle.value = new CodeActionOracle(this._editor, this._markerService, (trigger) => {
        var _a5;
        if (!trigger) {
          this.setState(CodeActionsState.Empty);
          return;
        }
        const actions = createCancelablePromise((token) => getCodeActions(model, trigger.selection, trigger.trigger, Progress.None, token));
        if (trigger.trigger.type === 1) {
          (_a5 = this._progressService) === null || _a5 === void 0 ? void 0 : _a5.showWhile(actions, 250);
        }
        this.setState(new CodeActionsState.Triggered(trigger.trigger, trigger.selection, trigger.position, actions));
      }, void 0);
      this._codeActionOracle.value.trigger({ type: 2 });
    } else {
      this._supportedCodeActions.reset();
    }
  }
  trigger(trigger) {
    if (this._codeActionOracle.value) {
      this._codeActionOracle.value.trigger(trigger);
    }
  }
  setState(newState, skipNotify) {
    if (newState === this._state) {
      return;
    }
    if (this._state.type === 1) {
      this._state.cancel();
    }
    this._state = newState;
    if (!skipNotify && !__classPrivateFieldGet2(this, _CodeActionModel_isDisposed, "f")) {
      this._onDidChangeState.fire(newState);
    }
  }
};
_CodeActionModel_isDisposed = new WeakMap();

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionCommands.js
var __decorate6 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param6 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function contextKeyForSupportedActions(kind) {
  return ContextKeyExpr.regex(SUPPORTED_CODE_ACTIONS.keys()[0], new RegExp("(\\s|^)" + escapeRegExpCharacters(kind.value) + "\\b"));
}
var argsSchema = {
  type: "object",
  defaultSnippets: [{ body: { kind: "" } }],
  properties: {
    "kind": {
      type: "string",
      description: localize("args.schema.kind", "Kind of the code action to run.")
    },
    "apply": {
      type: "string",
      description: localize("args.schema.apply", "Controls when the returned actions are applied."),
      default: "ifSingle",
      enum: ["first", "ifSingle", "never"],
      enumDescriptions: [
        localize("args.schema.apply.first", "Always apply the first returned code action."),
        localize("args.schema.apply.ifSingle", "Apply the first returned code action if it is the only one."),
        localize("args.schema.apply.never", "Do not apply the returned code actions.")
      ]
    },
    "preferred": {
      type: "boolean",
      default: false,
      description: localize("args.schema.preferred", "Controls if only preferred code actions should be returned.")
    }
  }
};
var QuickFixController = class QuickFixController2 extends Disposable {
  constructor(editor2, markerService, contextKeyService, progressService, _instantiationService) {
    super();
    this._instantiationService = _instantiationService;
    this._editor = editor2;
    this._model = this._register(new CodeActionModel(this._editor, markerService, contextKeyService, progressService));
    this._register(this._model.onDidChangeState((newState) => this.update(newState)));
    this._ui = new Lazy(() => this._register(new CodeActionUi(editor2, QuickFixAction.Id, AutoFixAction.Id, {
      applyCodeAction: (action, retrigger) => __awaiter6(this, void 0, void 0, function* () {
        try {
          yield this._applyCodeAction(action);
        } finally {
          if (retrigger) {
            this._trigger({ type: 2, filter: {} });
          }
        }
      })
    }, this._instantiationService)));
  }
  static get(editor2) {
    return editor2.getContribution(QuickFixController2.ID);
  }
  update(newState) {
    this._ui.getValue().update(newState);
  }
  showCodeActions(trigger, actions, at) {
    return this._ui.getValue().showCodeActionList(trigger, actions, at, { includeDisabledActions: false });
  }
  manualTriggerAtCurrentPosition(notAvailableMessage, filter, autoApply) {
    if (!this._editor.hasModel()) {
      return;
    }
    MessageController.get(this._editor).closeMessage();
    const triggerPosition = this._editor.getPosition();
    this._trigger({ type: 1, filter, autoApply, context: { notAvailableMessage, position: triggerPosition } });
  }
  _trigger(trigger) {
    return this._model.trigger(trigger);
  }
  _applyCodeAction(action) {
    return this._instantiationService.invokeFunction(applyCodeAction, action, this._editor);
  }
};
QuickFixController.ID = "editor.contrib.quickFixController";
QuickFixController = __decorate6([
  __param6(1, IMarkerService),
  __param6(2, IContextKeyService),
  __param6(3, IEditorProgressService),
  __param6(4, IInstantiationService)
], QuickFixController);
function applyCodeAction(accessor, item, editor2) {
  return __awaiter6(this, void 0, void 0, function* () {
    const bulkEditService = accessor.get(IBulkEditService);
    const commandService = accessor.get(ICommandService);
    const telemetryService = accessor.get(ITelemetryService);
    const notificationService = accessor.get(INotificationService);
    telemetryService.publicLog2("codeAction.applyCodeAction", {
      codeActionTitle: item.action.title,
      codeActionKind: item.action.kind,
      codeActionIsPreferred: !!item.action.isPreferred
    });
    yield item.resolve(CancellationToken.None);
    if (item.action.edit) {
      yield bulkEditService.apply(ResourceEdit.convert(item.action.edit), { editor: editor2, label: item.action.title });
    }
    if (item.action.command) {
      try {
        yield commandService.executeCommand(item.action.command.id, ...item.action.command.arguments || []);
      } catch (err) {
        const message = asMessage(err);
        notificationService.error(typeof message === "string" ? message : localize("applyCodeActionFailed", "An unknown error occurred while applying the code action"));
      }
    }
  });
}
function asMessage(err) {
  if (typeof err === "string") {
    return err;
  } else if (err instanceof Error && typeof err.message === "string") {
    return err.message;
  } else {
    return void 0;
  }
}
function triggerCodeActionsForEditorSelection(editor2, notAvailableMessage, filter, autoApply) {
  if (editor2.hasModel()) {
    const controller = QuickFixController.get(editor2);
    if (controller) {
      controller.manualTriggerAtCurrentPosition(notAvailableMessage, filter, autoApply);
    }
  }
}
var QuickFixAction = class extends EditorAction {
  constructor() {
    super({
      id: QuickFixAction.Id,
      label: localize("quickfix.trigger.label", "Quick Fix..."),
      alias: "Quick Fix...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 84,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("editor.action.quickFix.noneMessage", "No code actions available"), void 0, void 0);
  }
};
QuickFixAction.Id = "editor.action.quickFix";
var CodeActionCommand = class extends EditorCommand {
  constructor() {
    super({
      id: codeActionCommandId,
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      description: {
        description: "Trigger a code action",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  runEditorCommand(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind.Empty,
      apply: "ifSingle"
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.codeAction.noneMessage.preferred.kind", "No preferred code actions for '{0}' available", userArgs.kind) : localize("editor.action.codeAction.noneMessage.kind", "No code actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.codeAction.noneMessage.preferred", "No preferred code actions available") : localize("editor.action.codeAction.noneMessage", "No code actions available"), {
      include: args.kind,
      includeSourceActions: true,
      onlyIncludePreferredActions: args.preferred
    }, args.apply);
  }
};
var RefactorAction = class extends EditorAction {
  constructor() {
    super({
      id: refactorCommandId,
      label: localize("refactor.label", "Refactor..."),
      alias: "Refactor...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 48,
        mac: {
          primary: 256 | 1024 | 48
        },
        weight: 100
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 2,
        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Refactor))
      },
      description: {
        description: "Refactor...",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  run(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind.Refactor,
      apply: "never"
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.refactor.noneMessage.preferred.kind", "No preferred refactorings for '{0}' available", userArgs.kind) : localize("editor.action.refactor.noneMessage.kind", "No refactorings for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.refactor.noneMessage.preferred", "No preferred refactorings available") : localize("editor.action.refactor.noneMessage", "No refactorings available"), {
      include: CodeActionKind.Refactor.contains(args.kind) ? args.kind : CodeActionKind.None,
      onlyIncludePreferredActions: args.preferred
    }, args.apply);
  }
};
var SourceAction = class extends EditorAction {
  constructor() {
    super({
      id: sourceActionCommandId,
      label: localize("source.label", "Source Action..."),
      alias: "Source Action...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCodeActionsProvider),
      contextMenuOpts: {
        group: "1_modification",
        order: 2.1,
        when: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.Source))
      },
      description: {
        description: "Source Action...",
        args: [{ name: "args", schema: argsSchema }]
      }
    });
  }
  run(_accessor, editor2, userArgs) {
    const args = CodeActionCommandArgs.fromUser(userArgs, {
      kind: CodeActionKind.Source,
      apply: "never"
    });
    return triggerCodeActionsForEditorSelection(editor2, typeof (userArgs === null || userArgs === void 0 ? void 0 : userArgs.kind) === "string" ? args.preferred ? localize("editor.action.source.noneMessage.preferred.kind", "No preferred source actions for '{0}' available", userArgs.kind) : localize("editor.action.source.noneMessage.kind", "No source actions for '{0}' available", userArgs.kind) : args.preferred ? localize("editor.action.source.noneMessage.preferred", "No preferred source actions available") : localize("editor.action.source.noneMessage", "No source actions available"), {
      include: CodeActionKind.Source.contains(args.kind) ? args.kind : CodeActionKind.None,
      includeSourceActions: true,
      onlyIncludePreferredActions: args.preferred
    }, args.apply);
  }
};
var OrganizeImportsAction = class extends EditorAction {
  constructor() {
    super({
      id: organizeImportsCommandId,
      label: localize("organizeImports.label", "Organize Imports"),
      alias: "Organize Imports",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceOrganizeImports)),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 45,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("editor.action.organize.noneMessage", "No organize imports action available"), { include: CodeActionKind.SourceOrganizeImports, includeSourceActions: true }, "ifSingle");
  }
};
var FixAllAction = class extends EditorAction {
  constructor() {
    super({
      id: fixAllCommandId,
      label: localize("fixAll.label", "Fix All"),
      alias: "Fix All",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.SourceFixAll))
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("fixAll.noneMessage", "No fix all action available"), { include: CodeActionKind.SourceFixAll, includeSourceActions: true }, "ifSingle");
  }
};
var AutoFixAction = class extends EditorAction {
  constructor() {
    super({
      id: AutoFixAction.Id,
      label: localize("autoFix.label", "Auto Fix..."),
      alias: "Auto Fix...",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, contextKeyForSupportedActions(CodeActionKind.QuickFix)),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 84,
        mac: {
          primary: 2048 | 512 | 84
        },
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    return triggerCodeActionsForEditorSelection(editor2, localize("editor.action.autoFix.noneMessage", "No auto fixes available"), {
      include: CodeActionKind.QuickFix,
      onlyIncludePreferredActions: true
    }, "ifSingle");
  }
};
AutoFixAction.Id = "editor.action.autoFix";

// node_modules/monaco-editor/esm/vs/editor/contrib/codeAction/codeActionContributions.js
registerEditorContribution(QuickFixController.ID, QuickFixController);
registerEditorAction(QuickFixAction);
registerEditorAction(RefactorAction);
registerEditorAction(SourceAction);
registerEditorAction(OrganizeImportsAction);
registerEditorAction(AutoFixAction);
registerEditorAction(FixAllAction);
registerEditorCommand(new CodeActionCommand());

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelens.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CodeLensModel = class {
  constructor() {
    this.lenses = [];
    this._disposables = new DisposableStore();
  }
  dispose() {
    this._disposables.dispose();
  }
  add(list, provider) {
    this._disposables.add(list);
    for (const symbol of list.lenses) {
      this.lenses.push({ symbol, provider });
    }
  }
};
function getCodeLensModel(model, token) {
  return __awaiter7(this, void 0, void 0, function* () {
    const provider = CodeLensProviderRegistry.ordered(model);
    const providerRanks = new Map();
    const result = new CodeLensModel();
    const promises = provider.map((provider2, i) => __awaiter7(this, void 0, void 0, function* () {
      providerRanks.set(provider2, i);
      try {
        const list = yield Promise.resolve(provider2.provideCodeLenses(model, token));
        if (list) {
          result.add(list, provider2);
        }
      } catch (err) {
        onUnexpectedExternalError(err);
      }
    }));
    yield Promise.all(promises);
    result.lenses = result.lenses.sort((a, b) => {
      if (a.symbol.range.startLineNumber < b.symbol.range.startLineNumber) {
        return -1;
      } else if (a.symbol.range.startLineNumber > b.symbol.range.startLineNumber) {
        return 1;
      } else if (providerRanks.get(a.provider) < providerRanks.get(b.provider)) {
        return -1;
      } else if (providerRanks.get(a.provider) > providerRanks.get(b.provider)) {
        return 1;
      } else if (a.symbol.range.startColumn < b.symbol.range.startColumn) {
        return -1;
      } else if (a.symbol.range.startColumn > b.symbol.range.startColumn) {
        return 1;
      } else {
        return 0;
      }
    });
    return result;
  });
}
CommandsRegistry.registerCommand("_executeCodeLensProvider", function(accessor, ...args) {
  let [uri, itemResolveCount] = args;
  assertType(URI.isUri(uri));
  assertType(typeof itemResolveCount === "number" || !itemResolveCount);
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    throw illegalArgument();
  }
  const result = [];
  const disposables = new DisposableStore();
  return getCodeLensModel(model, CancellationToken.None).then((value) => {
    disposables.add(value);
    let resolve = [];
    for (const item of value.lenses) {
      if (itemResolveCount === void 0 || itemResolveCount === null || Boolean(item.symbol.command)) {
        result.push(item.symbol);
      } else if (itemResolveCount-- > 0 && item.provider.resolveCodeLens) {
        resolve.push(Promise.resolve(item.provider.resolveCodeLens(model, item.symbol, CancellationToken.None)).then((symbol) => result.push(symbol || item.symbol)));
      }
    }
    return Promise.all(resolve);
  }).then(() => {
    return result;
  }).finally(() => {
    setTimeout(() => disposables.dispose(), 100);
  });
});

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codeLensCache.js
var __decorate7 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ICodeLensCache = createDecorator("ICodeLensCache");
var CacheItem = class {
  constructor(lineCount, data) {
    this.lineCount = lineCount;
    this.data = data;
  }
};
var CodeLensCache = class CodeLensCache2 {
  constructor(storageService) {
    this._fakeProvider = new class {
      provideCodeLenses() {
        throw new Error("not supported");
      }
    }();
    this._cache = new LRUCache(20, 0.75);
    const oldkey = "codelens/cache";
    runWhenIdle(() => storageService.remove(oldkey, 1));
    const key = "codelens/cache2";
    const raw = storageService.get(key, 1, "{}");
    this._deserialize(raw);
    once(storageService.onWillSaveState)((e) => {
      if (e.reason === WillSaveStateReason.SHUTDOWN) {
        storageService.store(key, this._serialize(), 1, 1);
      }
    });
  }
  put(model, data) {
    const copyItems = data.lenses.map((item2) => {
      var _a5;
      return {
        range: item2.symbol.range,
        command: item2.symbol.command && { id: "", title: (_a5 = item2.symbol.command) === null || _a5 === void 0 ? void 0 : _a5.title }
      };
    });
    const copyModel = new CodeLensModel();
    copyModel.add({ lenses: copyItems, dispose: () => {
    } }, this._fakeProvider);
    const item = new CacheItem(model.getLineCount(), copyModel);
    this._cache.set(model.uri.toString(), item);
  }
  get(model) {
    const item = this._cache.get(model.uri.toString());
    return item && item.lineCount === model.getLineCount() ? item.data : void 0;
  }
  delete(model) {
    this._cache.delete(model.uri.toString());
  }
  _serialize() {
    const data = Object.create(null);
    for (const [key, value] of this._cache) {
      const lines = new Set();
      for (const d of value.data.lenses) {
        lines.add(d.symbol.range.startLineNumber);
      }
      data[key] = {
        lineCount: value.lineCount,
        lines: [...lines.values()]
      };
    }
    return JSON.stringify(data);
  }
  _deserialize(raw) {
    try {
      const data = JSON.parse(raw);
      for (const key in data) {
        const element = data[key];
        const lenses = [];
        for (const line of element.lines) {
          lenses.push({ range: new Range(line, 1, line, 11) });
        }
        const model = new CodeLensModel();
        model.add({ lenses, dispose() {
        } }, this._fakeProvider);
        this._cache.set(key, new CacheItem(element.lineCount, model));
      }
    } catch (_a5) {
    }
  }
};
CodeLensCache = __decorate7([
  __param7(0, IStorageService)
], CodeLensCache);
registerSingleton(ICodeLensCache, CodeLensCache);

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelensWidget.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelensWidget.css";
var CodeLensViewZone = class {
  constructor(afterLineNumber, heightInPx, onHeight) {
    this.afterLineNumber = afterLineNumber;
    this.heightInPx = heightInPx;
    this._onHeight = onHeight;
    this.suppressMouseDown = true;
    this.domNode = document.createElement("div");
  }
  onComputedHeight(height) {
    if (this._lastHeight === void 0) {
      this._lastHeight = height;
    } else if (this._lastHeight !== height) {
      this._lastHeight = height;
      this._onHeight();
    }
  }
  isVisible() {
    return this._lastHeight !== 0 && this.domNode.hasAttribute("monaco-visible-view-zone");
  }
};
var CodeLensContentWidget = class {
  constructor(editor2, className, line) {
    this.allowEditorOverflow = false;
    this.suppressMouseDown = true;
    this._commands = new Map();
    this._isEmpty = true;
    this._editor = editor2;
    this._id = `codelens.widget-${CodeLensContentWidget._idPool++}`;
    this.updatePosition(line);
    this._domNode = document.createElement("span");
    this._domNode.className = `codelens-decoration ${className}`;
  }
  withCommands(lenses, animate) {
    this._commands.clear();
    let children = [];
    let hasSymbol = false;
    for (let i = 0; i < lenses.length; i++) {
      const lens = lenses[i];
      if (!lens) {
        continue;
      }
      hasSymbol = true;
      if (lens.command) {
        const title = renderLabelWithIcons(lens.command.title.trim());
        if (lens.command.id) {
          children.push($("a", { id: String(i), title: lens.command.tooltip }, ...title));
          this._commands.set(String(i), lens.command);
        } else {
          children.push($("span", { title: lens.command.tooltip }, ...title));
        }
        if (i + 1 < lenses.length) {
          children.push($("span", void 0, "\xA0|\xA0"));
        }
      }
    }
    if (!hasSymbol) {
      reset(this._domNode, $("span", void 0, "no commands"));
    } else {
      reset(this._domNode, ...children);
      if (this._isEmpty && animate) {
        this._domNode.classList.add("fadein");
      }
      this._isEmpty = false;
    }
  }
  getCommand(link) {
    return link.parentElement === this._domNode ? this._commands.get(link.id) : void 0;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  updatePosition(line) {
    const column = this._editor.getModel().getLineFirstNonWhitespaceColumn(line);
    this._widgetPosition = {
      position: { lineNumber: line, column },
      preference: [1]
    };
  }
  getPosition() {
    return this._widgetPosition || null;
  }
};
CodeLensContentWidget._idPool = 0;
var CodeLensHelper = class {
  constructor() {
    this._removeDecorations = [];
    this._addDecorations = [];
    this._addDecorationsCallbacks = [];
  }
  addDecoration(decoration2, callback) {
    this._addDecorations.push(decoration2);
    this._addDecorationsCallbacks.push(callback);
  }
  removeDecoration(decorationId) {
    this._removeDecorations.push(decorationId);
  }
  commit(changeAccessor) {
    let resultingDecorations = changeAccessor.deltaDecorations(this._removeDecorations, this._addDecorations);
    for (let i = 0, len = resultingDecorations.length; i < len; i++) {
      this._addDecorationsCallbacks[i](resultingDecorations[i]);
    }
  }
};
var CodeLensWidget = class {
  constructor(data, editor2, className, helper, viewZoneChangeAccessor, heightInPx, updateCallback) {
    this._isDisposed = false;
    this._editor = editor2;
    this._className = className;
    this._data = data;
    this._decorationIds = [];
    let range;
    let lenses = [];
    this._data.forEach((codeLensData, i) => {
      if (codeLensData.symbol.command) {
        lenses.push(codeLensData.symbol);
      }
      helper.addDecoration({
        range: codeLensData.symbol.range,
        options: ModelDecorationOptions.EMPTY
      }, (id) => this._decorationIds[i] = id);
      if (!range) {
        range = Range.lift(codeLensData.symbol.range);
      } else {
        range = Range.plusRange(range, codeLensData.symbol.range);
      }
    });
    this._viewZone = new CodeLensViewZone(range.startLineNumber - 1, heightInPx, updateCallback);
    this._viewZoneId = viewZoneChangeAccessor.addZone(this._viewZone);
    if (lenses.length > 0) {
      this._createContentWidgetIfNecessary();
      this._contentWidget.withCommands(lenses, false);
    }
  }
  _createContentWidgetIfNecessary() {
    if (!this._contentWidget) {
      this._contentWidget = new CodeLensContentWidget(this._editor, this._className, this._viewZone.afterLineNumber + 1);
      this._editor.addContentWidget(this._contentWidget);
    } else {
      this._editor.layoutContentWidget(this._contentWidget);
    }
  }
  dispose(helper, viewZoneChangeAccessor) {
    this._decorationIds.forEach(helper.removeDecoration, helper);
    this._decorationIds = [];
    if (viewZoneChangeAccessor) {
      viewZoneChangeAccessor.removeZone(this._viewZoneId);
    }
    if (this._contentWidget) {
      this._editor.removeContentWidget(this._contentWidget);
      this._contentWidget = void 0;
    }
    this._isDisposed = true;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isValid() {
    return this._decorationIds.some((id, i) => {
      const range = this._editor.getModel().getDecorationRange(id);
      const symbol = this._data[i].symbol;
      return !!(range && Range.isEmpty(symbol.range) === range.isEmpty());
    });
  }
  updateCodeLensSymbols(data, helper) {
    this._decorationIds.forEach(helper.removeDecoration, helper);
    this._decorationIds = [];
    this._data = data;
    this._data.forEach((codeLensData, i) => {
      helper.addDecoration({
        range: codeLensData.symbol.range,
        options: ModelDecorationOptions.EMPTY
      }, (id) => this._decorationIds[i] = id);
    });
  }
  updateHeight(height, viewZoneChangeAccessor) {
    this._viewZone.heightInPx = height;
    viewZoneChangeAccessor.layoutZone(this._viewZoneId);
    if (this._contentWidget) {
      this._editor.layoutContentWidget(this._contentWidget);
    }
  }
  computeIfNecessary(model) {
    if (!this._viewZone.isVisible()) {
      return null;
    }
    for (let i = 0; i < this._decorationIds.length; i++) {
      const range = model.getDecorationRange(this._decorationIds[i]);
      if (range) {
        this._data[i].symbol.range = range;
      }
    }
    return this._data;
  }
  updateCommands(symbols) {
    this._createContentWidgetIfNecessary();
    this._contentWidget.withCommands(symbols, true);
    for (let i = 0; i < this._data.length; i++) {
      const resolved = symbols[i];
      if (resolved) {
        const { symbol } = this._data[i];
        symbol.command = resolved.command || symbol.command;
      }
    }
  }
  getCommand(link) {
    var _a5;
    return (_a5 = this._contentWidget) === null || _a5 === void 0 ? void 0 : _a5.getCommand(link);
  }
  getLineNumber() {
    const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
    if (range) {
      return range.startLineNumber;
    }
    return -1;
  }
  update(viewZoneChangeAccessor) {
    if (this.isValid()) {
      const range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
      if (range) {
        this._viewZone.afterLineNumber = range.startLineNumber - 1;
        viewZoneChangeAccessor.layoutZone(this._viewZoneId);
        if (this._contentWidget) {
          this._contentWidget.updatePosition(range.startLineNumber);
          this._editor.layoutContentWidget(this._contentWidget);
        }
      }
    }
  }
  getItems() {
    return this._data;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/codelens/codelensController.js
var __decorate8 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CodeLensContribution = class CodeLensContribution2 {
  constructor(_editor, _commandService, _notificationService, _codeLensCache) {
    this._editor = _editor;
    this._commandService = _commandService;
    this._notificationService = _notificationService;
    this._codeLensCache = _codeLensCache;
    this._disposables = new DisposableStore();
    this._localToDispose = new DisposableStore();
    this._lenses = [];
    this._getCodeLensModelDelays = new LanguageFeatureRequestDelays(CodeLensProviderRegistry, 250, 2500);
    this._oldCodeLensModels = new DisposableStore();
    this._resolveCodeLensesDelays = new LanguageFeatureRequestDelays(CodeLensProviderRegistry, 250, 2500);
    this._resolveCodeLensesScheduler = new RunOnceScheduler(() => this._resolveCodeLensesInViewport(), this._resolveCodeLensesDelays.min);
    this._disposables.add(this._editor.onDidChangeModel(() => this._onModelChange()));
    this._disposables.add(this._editor.onDidChangeModelLanguage(() => this._onModelChange()));
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(43) || e.hasChanged(16) || e.hasChanged(15)) {
        this._updateLensStyle();
      }
      if (e.hasChanged(14)) {
        this._onModelChange();
      }
    }));
    this._disposables.add(CodeLensProviderRegistry.onDidChange(this._onModelChange, this));
    this._onModelChange();
    this._styleClassName = "_" + hash(this._editor.getId()).toString(16);
    this._styleElement = createStyleSheet(isInShadowDOM(this._editor.getContainerDomNode()) ? this._editor.getContainerDomNode() : void 0);
    this._updateLensStyle();
  }
  dispose() {
    var _a5;
    this._localDispose();
    this._disposables.dispose();
    this._oldCodeLensModels.dispose();
    (_a5 = this._currentCodeLensModel) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    this._styleElement.remove();
  }
  _getLayoutInfo() {
    let fontSize = this._editor.getOption(16);
    let codeLensHeight;
    if (!fontSize || fontSize < 5) {
      fontSize = this._editor.getOption(45) * 0.9 | 0;
      codeLensHeight = this._editor.getOption(58);
    } else {
      codeLensHeight = fontSize * Math.max(1.3, this._editor.getOption(58) / this._editor.getOption(45)) | 0;
    }
    return { codeLensHeight, fontSize };
  }
  _updateLensStyle() {
    const { codeLensHeight, fontSize } = this._getLayoutInfo();
    const fontFamily = this._editor.getOption(15);
    const editorFontInfo = this._editor.getOption(43);
    const fontFamilyVar = `--codelens-font-family${this._styleClassName}`;
    const fontFeaturesVar = `--codelens-font-features${this._styleClassName}`;
    let newStyle = `
		.monaco-editor .codelens-decoration.${this._styleClassName} { line-height: ${codeLensHeight}px; font-size: ${fontSize}px; padding-right: ${Math.round(fontSize * 0.5)}px; font-feature-settings: var(${fontFeaturesVar}) }
		.monaco-editor .codelens-decoration.${this._styleClassName} span.codicon { line-height: ${codeLensHeight}px; font-size: ${fontSize}px; }
		`;
    if (fontFamily) {
      newStyle += `.monaco-editor .codelens-decoration.${this._styleClassName} { font-family: var(${fontFamilyVar}), ${EDITOR_FONT_DEFAULTS.fontFamily}}`;
    }
    this._styleElement.textContent = newStyle;
    this._editor.getContainerDomNode().style.setProperty(fontFamilyVar, fontFamily !== null && fontFamily !== void 0 ? fontFamily : "inherit");
    this._editor.getContainerDomNode().style.setProperty(fontFeaturesVar, editorFontInfo.fontFeatureSettings);
    this._editor.changeViewZones((accessor) => {
      for (let lens of this._lenses) {
        lens.updateHeight(codeLensHeight, accessor);
      }
    });
  }
  _localDispose() {
    var _a5, _b2, _c2;
    (_a5 = this._getCodeLensModelPromise) === null || _a5 === void 0 ? void 0 : _a5.cancel();
    this._getCodeLensModelPromise = void 0;
    (_b2 = this._resolveCodeLensesPromise) === null || _b2 === void 0 ? void 0 : _b2.cancel();
    this._resolveCodeLensesPromise = void 0;
    this._localToDispose.clear();
    this._oldCodeLensModels.clear();
    (_c2 = this._currentCodeLensModel) === null || _c2 === void 0 ? void 0 : _c2.dispose();
  }
  _onModelChange() {
    this._localDispose();
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    if (!this._editor.getOption(14)) {
      return;
    }
    const cachedLenses = this._codeLensCache.get(model);
    if (cachedLenses) {
      this._renderCodeLensSymbols(cachedLenses);
    }
    if (!CodeLensProviderRegistry.has(model)) {
      if (cachedLenses) {
        this._localToDispose.add(disposableTimeout(() => {
          const cachedLensesNow = this._codeLensCache.get(model);
          if (cachedLenses === cachedLensesNow) {
            this._codeLensCache.delete(model);
            this._onModelChange();
          }
        }, 30 * 1e3));
      }
      return;
    }
    for (const provider of CodeLensProviderRegistry.all(model)) {
      if (typeof provider.onDidChange === "function") {
        let registration = provider.onDidChange(() => scheduler.schedule());
        this._localToDispose.add(registration);
      }
    }
    const scheduler = new RunOnceScheduler(() => {
      var _a5;
      const t1 = Date.now();
      (_a5 = this._getCodeLensModelPromise) === null || _a5 === void 0 ? void 0 : _a5.cancel();
      this._getCodeLensModelPromise = createCancelablePromise((token) => getCodeLensModel(model, token));
      this._getCodeLensModelPromise.then((result) => {
        if (this._currentCodeLensModel) {
          this._oldCodeLensModels.add(this._currentCodeLensModel);
        }
        this._currentCodeLensModel = result;
        this._codeLensCache.put(model, result);
        const newDelay = this._getCodeLensModelDelays.update(model, Date.now() - t1);
        scheduler.delay = newDelay;
        this._renderCodeLensSymbols(result);
        this._resolveCodeLensesInViewportSoon();
      }, onUnexpectedError);
    }, this._getCodeLensModelDelays.get(model));
    this._localToDispose.add(scheduler);
    this._localToDispose.add(toDisposable(() => this._resolveCodeLensesScheduler.cancel()));
    this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      this._editor.changeDecorations((decorationsAccessor) => {
        this._editor.changeViewZones((viewZonesAccessor) => {
          let toDispose = [];
          let lastLensLineNumber = -1;
          this._lenses.forEach((lens) => {
            if (!lens.isValid() || lastLensLineNumber === lens.getLineNumber()) {
              toDispose.push(lens);
            } else {
              lens.update(viewZonesAccessor);
              lastLensLineNumber = lens.getLineNumber();
            }
          });
          let helper = new CodeLensHelper();
          toDispose.forEach((l) => {
            l.dispose(helper, viewZonesAccessor);
            this._lenses.splice(this._lenses.indexOf(l), 1);
          });
          helper.commit(decorationsAccessor);
        });
      });
      scheduler.schedule();
    }));
    this._localToDispose.add(this._editor.onDidFocusEditorWidget(() => {
      scheduler.schedule();
    }));
    this._localToDispose.add(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged && this._lenses.length > 0) {
        this._resolveCodeLensesInViewportSoon();
      }
    }));
    this._localToDispose.add(this._editor.onDidLayoutChange(() => {
      this._resolveCodeLensesInViewportSoon();
    }));
    this._localToDispose.add(toDisposable(() => {
      if (this._editor.getModel()) {
        const scrollState = StableEditorScrollState.capture(this._editor);
        this._editor.changeDecorations((decorationsAccessor) => {
          this._editor.changeViewZones((viewZonesAccessor) => {
            this._disposeAllLenses(decorationsAccessor, viewZonesAccessor);
          });
        });
        scrollState.restore(this._editor);
      } else {
        this._disposeAllLenses(void 0, void 0);
      }
    }));
    this._localToDispose.add(this._editor.onMouseDown((e) => {
      if (e.target.type !== 9) {
        return;
      }
      let target = e.target.element;
      if ((target === null || target === void 0 ? void 0 : target.tagName) === "SPAN") {
        target = target.parentElement;
      }
      if ((target === null || target === void 0 ? void 0 : target.tagName) === "A") {
        for (const lens of this._lenses) {
          let command = lens.getCommand(target);
          if (command) {
            this._commandService.executeCommand(command.id, ...command.arguments || []).catch((err) => this._notificationService.error(err));
            break;
          }
        }
      }
    }));
    scheduler.schedule();
  }
  _disposeAllLenses(decChangeAccessor, viewZoneChangeAccessor) {
    const helper = new CodeLensHelper();
    for (const lens of this._lenses) {
      lens.dispose(helper, viewZoneChangeAccessor);
    }
    if (decChangeAccessor) {
      helper.commit(decChangeAccessor);
    }
    this._lenses.length = 0;
  }
  _renderCodeLensSymbols(symbols) {
    if (!this._editor.hasModel()) {
      return;
    }
    let maxLineNumber = this._editor.getModel().getLineCount();
    let groups = [];
    let lastGroup;
    for (let symbol of symbols.lenses) {
      let line = symbol.symbol.range.startLineNumber;
      if (line < 1 || line > maxLineNumber) {
        continue;
      } else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {
        lastGroup.push(symbol);
      } else {
        lastGroup = [symbol];
        groups.push(lastGroup);
      }
    }
    const scrollState = StableEditorScrollState.capture(this._editor);
    const layoutInfo = this._getLayoutInfo();
    this._editor.changeDecorations((decorationsAccessor) => {
      this._editor.changeViewZones((viewZoneAccessor) => {
        const helper = new CodeLensHelper();
        let codeLensIndex = 0;
        let groupsIndex = 0;
        while (groupsIndex < groups.length && codeLensIndex < this._lenses.length) {
          let symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;
          let codeLensLineNumber = this._lenses[codeLensIndex].getLineNumber();
          if (codeLensLineNumber < symbolsLineNumber) {
            this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
            this._lenses.splice(codeLensIndex, 1);
          } else if (codeLensLineNumber === symbolsLineNumber) {
            this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);
            groupsIndex++;
            codeLensIndex++;
          } else {
            this._lenses.splice(codeLensIndex, 0, new CodeLensWidget(groups[groupsIndex], this._editor, this._styleClassName, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
            codeLensIndex++;
            groupsIndex++;
          }
        }
        while (codeLensIndex < this._lenses.length) {
          this._lenses[codeLensIndex].dispose(helper, viewZoneAccessor);
          this._lenses.splice(codeLensIndex, 1);
        }
        while (groupsIndex < groups.length) {
          this._lenses.push(new CodeLensWidget(groups[groupsIndex], this._editor, this._styleClassName, helper, viewZoneAccessor, layoutInfo.codeLensHeight, () => this._resolveCodeLensesInViewportSoon()));
          groupsIndex++;
        }
        helper.commit(decorationsAccessor);
      });
    });
    scrollState.restore(this._editor);
  }
  _resolveCodeLensesInViewportSoon() {
    const model = this._editor.getModel();
    if (model) {
      this._resolveCodeLensesScheduler.schedule();
    }
  }
  _resolveCodeLensesInViewport() {
    var _a5;
    (_a5 = this._resolveCodeLensesPromise) === null || _a5 === void 0 ? void 0 : _a5.cancel();
    this._resolveCodeLensesPromise = void 0;
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    const toResolve = [];
    const lenses = [];
    this._lenses.forEach((lens) => {
      const request = lens.computeIfNecessary(model);
      if (request) {
        toResolve.push(request);
        lenses.push(lens);
      }
    });
    if (toResolve.length === 0) {
      return;
    }
    const t1 = Date.now();
    const resolvePromise = createCancelablePromise((token) => {
      const promises = toResolve.map((request, i) => {
        const resolvedSymbols = new Array(request.length);
        const promises2 = request.map((request2, i2) => {
          if (!request2.symbol.command && typeof request2.provider.resolveCodeLens === "function") {
            return Promise.resolve(request2.provider.resolveCodeLens(model, request2.symbol, token)).then((symbol) => {
              resolvedSymbols[i2] = symbol;
            }, onUnexpectedExternalError);
          } else {
            resolvedSymbols[i2] = request2.symbol;
            return Promise.resolve(void 0);
          }
        });
        return Promise.all(promises2).then(() => {
          if (!token.isCancellationRequested && !lenses[i].isDisposed()) {
            lenses[i].updateCommands(resolvedSymbols);
          }
        });
      });
      return Promise.all(promises);
    });
    this._resolveCodeLensesPromise = resolvePromise;
    this._resolveCodeLensesPromise.then(() => {
      const newDelay = this._resolveCodeLensesDelays.update(model, Date.now() - t1);
      this._resolveCodeLensesScheduler.delay = newDelay;
      if (this._currentCodeLensModel) {
        this._codeLensCache.put(model, this._currentCodeLensModel);
      }
      this._oldCodeLensModels.clear();
      if (resolvePromise === this._resolveCodeLensesPromise) {
        this._resolveCodeLensesPromise = void 0;
      }
    }, (err) => {
      onUnexpectedError(err);
      if (resolvePromise === this._resolveCodeLensesPromise) {
        this._resolveCodeLensesPromise = void 0;
      }
    });
  }
  getLenses() {
    return this._lenses;
  }
};
CodeLensContribution.ID = "css.editor.codeLens";
CodeLensContribution = __decorate8([
  __param8(1, ICommandService),
  __param8(2, INotificationService),
  __param8(3, ICodeLensCache)
], CodeLensContribution);
registerEditorContribution(CodeLensContribution.ID, CodeLensContribution);
registerEditorAction(class ShowLensesInCurrentLine extends EditorAction {
  constructor() {
    super({
      id: "codelens.showLensesInCurrentLine",
      precondition: EditorContextKeys.hasCodeLensProvider,
      label: localize("showLensOnLine", "Show CodeLens Commands For Current Line"),
      alias: "Show CodeLens Commands For Current Line"
    });
  }
  run(accessor, editor2) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!editor2.hasModel()) {
        return;
      }
      const quickInputService = accessor.get(IQuickInputService);
      const commandService = accessor.get(ICommandService);
      const notificationService = accessor.get(INotificationService);
      const lineNumber = editor2.getSelection().positionLineNumber;
      const codelensController = editor2.getContribution(CodeLensContribution.ID);
      const items = [];
      for (let lens of codelensController.getLenses()) {
        if (lens.getLineNumber() === lineNumber) {
          for (let item2 of lens.getItems()) {
            const { command } = item2.symbol;
            if (command) {
              items.push({
                label: command.title,
                command
              });
            }
          }
        }
      }
      if (items.length === 0) {
        return;
      }
      const item = yield quickInputService.pick(items, { canPickMany: false });
      if (!item) {
        return;
      }
      try {
        yield commandService.executeCommand(item.command.id, ...item.command.arguments || []);
      } catch (err) {
        notificationService.error(err);
      }
    });
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/color.js
function getColors(model, token) {
  const colors = [];
  const providers = ColorProviderRegistry.ordered(model).reverse();
  const promises = providers.map((provider) => Promise.resolve(provider.provideDocumentColors(model, token)).then((result) => {
    if (Array.isArray(result)) {
      for (let colorInfo of result) {
        colors.push({ colorInfo, provider });
      }
    }
  }));
  return Promise.all(promises).then(() => colors);
}
function getColorPresentations(model, colorInfo, provider, token) {
  return Promise.resolve(provider.provideColorPresentations(model, colorInfo, token));
}
CommandsRegistry.registerCommand("_executeDocumentColorProvider", function(accessor, ...args) {
  const [resource] = args;
  if (!(resource instanceof URI)) {
    throw illegalArgument();
  }
  const model = accessor.get(IModelService).getModel(resource);
  if (!model) {
    throw illegalArgument();
  }
  const rawCIs = [];
  const providers = ColorProviderRegistry.ordered(model).reverse();
  const promises = providers.map((provider) => Promise.resolve(provider.provideDocumentColors(model, CancellationToken.None)).then((result) => {
    if (Array.isArray(result)) {
      for (let ci of result) {
        rawCIs.push({ range: ci.range, color: [ci.color.red, ci.color.green, ci.color.blue, ci.color.alpha] });
      }
    }
  }));
  return Promise.all(promises).then(() => rawCIs);
});
CommandsRegistry.registerCommand("_executeColorPresentationProvider", function(accessor, ...args) {
  const [color, context] = args;
  const { uri, range } = context;
  if (!(uri instanceof URI) || !Array.isArray(color) || color.length !== 4 || !Range.isIRange(range)) {
    throw illegalArgument();
  }
  const [red, green, blue, alpha] = color;
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    throw illegalArgument();
  }
  const colorInfo = {
    range,
    color: { red, green, blue, alpha }
  };
  const presentations = [];
  const providers = ColorProviderRegistry.ordered(model).reverse();
  const promises = providers.map((provider) => Promise.resolve(provider.provideColorPresentations(model, colorInfo, CancellationToken.None)).then((result) => {
    if (Array.isArray(result)) {
      presentations.push(...result);
    }
  }));
  return Promise.all(promises).then(() => presentations);
});

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorDetector.js
var __decorate9 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MAX_DECORATORS = 500;
var ColorDetector = class ColorDetector2 extends Disposable {
  constructor(_editor, _configurationService) {
    super();
    this._editor = _editor;
    this._configurationService = _configurationService;
    this._localToDispose = this._register(new DisposableStore());
    this._decorationsIds = [];
    this._colorDatas = new Map();
    this._colorDecoratorIds = new Set();
    this._ruleFactory = new DynamicCssRules(this._editor);
    this._colorDecorationClassRefs = this._register(new DisposableStore());
    this._register(_editor.onDidChangeModel(() => {
      this._isEnabled = this.isEnabled();
      this.onModelChanged();
    }));
    this._register(_editor.onDidChangeModelLanguage(() => this.onModelChanged()));
    this._register(ColorProviderRegistry.onDidChange(() => this.onModelChanged()));
    this._register(_editor.onDidChangeConfiguration(() => {
      let prevIsEnabled = this._isEnabled;
      this._isEnabled = this.isEnabled();
      if (prevIsEnabled !== this._isEnabled) {
        if (this._isEnabled) {
          this.onModelChanged();
        } else {
          this.removeAllDecorations();
        }
      }
    }));
    this._timeoutTimer = null;
    this._computePromise = null;
    this._isEnabled = this.isEnabled();
    this.onModelChanged();
  }
  isEnabled() {
    const model = this._editor.getModel();
    if (!model) {
      return false;
    }
    const languageId = model.getLanguageId();
    const deprecatedConfig = this._configurationService.getValue(languageId);
    if (deprecatedConfig && typeof deprecatedConfig === "object") {
      const colorDecorators = deprecatedConfig["colorDecorators"];
      if (colorDecorators && colorDecorators["enable"] !== void 0 && !colorDecorators["enable"]) {
        return colorDecorators["enable"];
      }
    }
    return this._editor.getOption(17);
  }
  static get(editor2) {
    return editor2.getContribution(this.ID);
  }
  dispose() {
    this.stop();
    this.removeAllDecorations();
    super.dispose();
  }
  onModelChanged() {
    this.stop();
    if (!this._isEnabled) {
      return;
    }
    const model = this._editor.getModel();
    if (!model || !ColorProviderRegistry.has(model)) {
      return;
    }
    this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      if (!this._timeoutTimer) {
        this._timeoutTimer = new TimeoutTimer();
        this._timeoutTimer.cancelAndSet(() => {
          this._timeoutTimer = null;
          this.beginCompute();
        }, ColorDetector2.RECOMPUTE_TIME);
      }
    }));
    this.beginCompute();
  }
  beginCompute() {
    this._computePromise = createCancelablePromise((token) => {
      const model = this._editor.getModel();
      if (!model) {
        return Promise.resolve([]);
      }
      return getColors(model, token);
    });
    this._computePromise.then((colorInfos) => {
      this.updateDecorations(colorInfos);
      this.updateColorDecorators(colorInfos);
      this._computePromise = null;
    }, onUnexpectedError);
  }
  stop() {
    if (this._timeoutTimer) {
      this._timeoutTimer.cancel();
      this._timeoutTimer = null;
    }
    if (this._computePromise) {
      this._computePromise.cancel();
      this._computePromise = null;
    }
    this._localToDispose.clear();
  }
  updateDecorations(colorDatas) {
    const decorations = colorDatas.map((c) => ({
      range: {
        startLineNumber: c.colorInfo.range.startLineNumber,
        startColumn: c.colorInfo.range.startColumn,
        endLineNumber: c.colorInfo.range.endLineNumber,
        endColumn: c.colorInfo.range.endColumn
      },
      options: ModelDecorationOptions.EMPTY
    }));
    this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, decorations);
    this._colorDatas = new Map();
    this._decorationsIds.forEach((id, i) => this._colorDatas.set(id, colorDatas[i]));
  }
  updateColorDecorators(colorData) {
    this._colorDecorationClassRefs.clear();
    let decorations = [];
    for (let i = 0; i < colorData.length && decorations.length < MAX_DECORATORS; i++) {
      const { red, green, blue, alpha } = colorData[i].colorInfo.color;
      const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
      let color = `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`;
      const ref = this._colorDecorationClassRefs.add(this._ruleFactory.createClassNameRef({
        backgroundColor: color
      }));
      decorations.push({
        range: {
          startLineNumber: colorData[i].colorInfo.range.startLineNumber,
          startColumn: colorData[i].colorInfo.range.startColumn,
          endLineNumber: colorData[i].colorInfo.range.endLineNumber,
          endColumn: colorData[i].colorInfo.range.endColumn
        },
        options: {
          description: "colorDetector",
          before: {
            content: noBreakWhitespace,
            inlineClassName: `${ref.className} colorpicker-color-decoration`,
            inlineClassNameAffectsLetterSpacing: true
          }
        }
      });
    }
    this._colorDecoratorIds = new Set(this._editor.deltaDecorations([...this._colorDecoratorIds], decorations));
  }
  removeAllDecorations() {
    this._decorationsIds = this._editor.deltaDecorations(this._decorationsIds, []);
    this._colorDecoratorIds = new Set(this._editor.deltaDecorations([...this._colorDecoratorIds], []));
    this._colorDecorationClassRefs.clear();
  }
  getColorData(position) {
    const model = this._editor.getModel();
    if (!model) {
      return null;
    }
    const decorations = model.getDecorationsInRange(Range.fromPositions(position, position)).filter((d) => this._colorDatas.has(d.id));
    if (decorations.length === 0) {
      return null;
    }
    return this._colorDatas.get(decorations[0].id);
  }
  isColorDecorationId(decorationId) {
    return this._colorDecoratorIds.has(decorationId);
  }
};
ColorDetector.ID = "editor.contrib.colorDetector";
ColorDetector.RECOMPUTE_TIME = 1e3;
ColorDetector = __decorate9([
  __param9(1, IConfigurationService)
], ColorDetector);
registerEditorContribution(ColorDetector.ID, ColorDetector);

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/clickLinkGesture.js
function hasModifier(e, modifier) {
  return !!e[modifier];
}
var ClickLinkMouseEvent = class {
  constructor(source, opts) {
    this.target = source.target;
    this.hasTriggerModifier = hasModifier(source.event, opts.triggerModifier);
    this.hasSideBySideModifier = hasModifier(source.event, opts.triggerSideBySideModifier);
    this.isNoneOrSingleMouseDown = source.event.detail <= 1;
  }
};
var ClickLinkKeyboardEvent = class {
  constructor(source, opts) {
    this.keyCodeIsTriggerKey = source.keyCode === opts.triggerKey;
    this.keyCodeIsSideBySideKey = source.keyCode === opts.triggerSideBySideKey;
    this.hasTriggerModifier = hasModifier(source, opts.triggerModifier);
  }
};
var ClickLinkOptions = class {
  constructor(triggerKey, triggerModifier, triggerSideBySideKey, triggerSideBySideModifier) {
    this.triggerKey = triggerKey;
    this.triggerModifier = triggerModifier;
    this.triggerSideBySideKey = triggerSideBySideKey;
    this.triggerSideBySideModifier = triggerSideBySideModifier;
  }
  equals(other) {
    return this.triggerKey === other.triggerKey && this.triggerModifier === other.triggerModifier && this.triggerSideBySideKey === other.triggerSideBySideKey && this.triggerSideBySideModifier === other.triggerSideBySideModifier;
  }
};
function createOptions(multiCursorModifier) {
  if (multiCursorModifier === "altKey") {
    if (isMacintosh) {
      return new ClickLinkOptions(57, "metaKey", 6, "altKey");
    }
    return new ClickLinkOptions(5, "ctrlKey", 6, "altKey");
  }
  if (isMacintosh) {
    return new ClickLinkOptions(6, "altKey", 57, "metaKey");
  }
  return new ClickLinkOptions(6, "altKey", 5, "ctrlKey");
}
var ClickLinkGesture = class extends Disposable {
  constructor(editor2) {
    super();
    this._onMouseMoveOrRelevantKeyDown = this._register(new Emitter());
    this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event;
    this._onExecute = this._register(new Emitter());
    this.onExecute = this._onExecute.event;
    this._onCancel = this._register(new Emitter());
    this.onCancel = this._onCancel.event;
    this._editor = editor2;
    this._opts = createOptions(this._editor.getOption(69));
    this._lastMouseMoveEvent = null;
    this._hasTriggerKeyOnMouseDown = false;
    this._lineNumberOnMouseDown = 0;
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(69)) {
        const newOpts = createOptions(this._editor.getOption(69));
        if (this._opts.equals(newOpts)) {
          return;
        }
        this._opts = newOpts;
        this._lastMouseMoveEvent = null;
        this._hasTriggerKeyOnMouseDown = false;
        this._lineNumberOnMouseDown = 0;
        this._onCancel.fire();
      }
    }));
    this._register(this._editor.onMouseMove((e) => this._onEditorMouseMove(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(new ClickLinkMouseEvent(e, this._opts))));
    this._register(this._editor.onKeyDown((e) => this._onEditorKeyDown(new ClickLinkKeyboardEvent(e, this._opts))));
    this._register(this._editor.onKeyUp((e) => this._onEditorKeyUp(new ClickLinkKeyboardEvent(e, this._opts))));
    this._register(this._editor.onMouseDrag(() => this._resetHandler()));
    this._register(this._editor.onDidChangeCursorSelection((e) => this._onDidChangeCursorSelection(e)));
    this._register(this._editor.onDidChangeModel((e) => this._resetHandler()));
    this._register(this._editor.onDidChangeModelContent(() => this._resetHandler()));
    this._register(this._editor.onDidScrollChange((e) => {
      if (e.scrollTopChanged || e.scrollLeftChanged) {
        this._resetHandler();
      }
    }));
  }
  _onDidChangeCursorSelection(e) {
    if (e.selection && e.selection.startColumn !== e.selection.endColumn) {
      this._resetHandler();
    }
  }
  _onEditorMouseMove(mouseEvent) {
    this._lastMouseMoveEvent = mouseEvent;
    this._onMouseMoveOrRelevantKeyDown.fire([mouseEvent, null]);
  }
  _onEditorMouseDown(mouseEvent) {
    this._hasTriggerKeyOnMouseDown = mouseEvent.hasTriggerModifier;
    this._lineNumberOnMouseDown = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;
  }
  _onEditorMouseUp(mouseEvent) {
    const currentLineNumber = mouseEvent.target.position ? mouseEvent.target.position.lineNumber : 0;
    if (this._hasTriggerKeyOnMouseDown && this._lineNumberOnMouseDown && this._lineNumberOnMouseDown === currentLineNumber) {
      this._onExecute.fire(mouseEvent);
    }
  }
  _onEditorKeyDown(e) {
    if (this._lastMouseMoveEvent && (e.keyCodeIsTriggerKey || e.keyCodeIsSideBySideKey && e.hasTriggerModifier)) {
      this._onMouseMoveOrRelevantKeyDown.fire([this._lastMouseMoveEvent, e]);
    } else if (e.hasTriggerModifier) {
      this._onCancel.fire();
    }
  }
  _onEditorKeyUp(e) {
    if (e.keyCodeIsTriggerKey) {
      this._onCancel.fire();
    }
  }
  _resetHandler() {
    this._lastMouseMoveEvent = null;
    this._hasTriggerKeyOnMouseDown = false;
    this._onCancel.fire();
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/peekView/peekView.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/peekView/media/peekViewWidget.css";

// node_modules/monaco-editor/esm/vs/editor/browser/widget/embeddedCodeEditorWidget.js
var __decorate10 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param10 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var EmbeddedCodeEditorWidget = class EmbeddedCodeEditorWidget2 extends CodeEditorWidget {
  constructor(domElement, options, parentEditor, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService) {
    super(domElement, Object.assign(Object.assign({}, parentEditor.getRawOptions()), { overflowWidgetsDomNode: parentEditor.getOverflowWidgetsDomNode() }), {}, instantiationService, codeEditorService, commandService, contextKeyService, themeService, notificationService, accessibilityService);
    this._parentEditor = parentEditor;
    this._overwriteOptions = options;
    super.updateOptions(this._overwriteOptions);
    this._register(parentEditor.onDidChangeConfiguration((e) => this._onParentConfigurationChanged(e)));
  }
  getParentEditor() {
    return this._parentEditor;
  }
  _onParentConfigurationChanged(e) {
    super.updateOptions(this._parentEditor.getRawOptions());
    super.updateOptions(this._overwriteOptions);
  }
  updateOptions(newOptions) {
    mixin(this._overwriteOptions, newOptions, true);
    super.updateOptions(this._overwriteOptions);
  }
};
EmbeddedCodeEditorWidget = __decorate10([
  __param10(3, IInstantiationService),
  __param10(4, ICodeEditorService),
  __param10(5, ICommandService),
  __param10(6, IContextKeyService),
  __param10(7, IThemeService),
  __param10(8, INotificationService),
  __param10(9, IAccessibilityService)
], EmbeddedCodeEditorWidget);

// node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/zoneWidget/zoneWidget.css";
var defaultColor = new Color(new RGBA(0, 122, 204));
var defaultOptions = {
  showArrow: true,
  showFrame: true,
  className: "",
  frameColor: defaultColor,
  arrowColor: defaultColor,
  keepEditorSelection: false
};
var WIDGET_ID = "vs.editor.contrib.zoneWidget";
var ViewZoneDelegate = class {
  constructor(domNode, afterLineNumber, afterColumn, heightInLines, onDomNodeTop, onComputedHeight) {
    this.id = "";
    this.domNode = domNode;
    this.afterLineNumber = afterLineNumber;
    this.afterColumn = afterColumn;
    this.heightInLines = heightInLines;
    this._onDomNodeTop = onDomNodeTop;
    this._onComputedHeight = onComputedHeight;
  }
  onDomNodeTop(top) {
    this._onDomNodeTop(top);
  }
  onComputedHeight(height) {
    this._onComputedHeight(height);
  }
};
var OverlayWidgetDelegate = class {
  constructor(id, domNode) {
    this._id = id;
    this._domNode = domNode;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return null;
  }
};
var Arrow = class {
  constructor(_editor) {
    this._editor = _editor;
    this._ruleName = Arrow._IdGenerator.nextId();
    this._decorations = [];
    this._color = null;
    this._height = -1;
  }
  dispose() {
    this.hide();
    removeCSSRulesContainingSelector(this._ruleName);
  }
  set color(value) {
    if (this._color !== value) {
      this._color = value;
      this._updateStyle();
    }
  }
  set height(value) {
    if (this._height !== value) {
      this._height = value;
      this._updateStyle();
    }
  }
  _updateStyle() {
    removeCSSRulesContainingSelector(this._ruleName);
    createCSSRule(`.monaco-editor ${this._ruleName}`, `border-style: solid; border-color: transparent; border-bottom-color: ${this._color}; border-width: ${this._height}px; bottom: -${this._height}px; margin-left: -${this._height}px; `);
  }
  show(where) {
    if (where.column === 1) {
      where = { lineNumber: where.lineNumber, column: 2 };
    }
    this._decorations = this._editor.deltaDecorations(this._decorations, [{ range: Range.fromPositions(where), options: { description: "zone-widget-arrow", className: this._ruleName, stickiness: 1 } }]);
  }
  hide() {
    this._editor.deltaDecorations(this._decorations, []);
  }
};
Arrow._IdGenerator = new IdGenerator(".arrow-decoration-");
var ZoneWidget = class {
  constructor(editor2, options = {}) {
    this._arrow = null;
    this._overlayWidget = null;
    this._resizeSash = null;
    this._positionMarkerId = [];
    this._viewZone = null;
    this._disposables = new DisposableStore();
    this.container = null;
    this._isShowing = false;
    this.editor = editor2;
    this.options = deepClone(options);
    mixin(this.options, defaultOptions, false);
    this.domNode = document.createElement("div");
    if (!this.options.isAccessible) {
      this.domNode.setAttribute("aria-hidden", "true");
      this.domNode.setAttribute("role", "presentation");
    }
    this._disposables.add(this.editor.onDidLayoutChange((info) => {
      const width = this._getWidth(info);
      this.domNode.style.width = width + "px";
      this.domNode.style.left = this._getLeft(info) + "px";
      this._onWidth(width);
    }));
  }
  dispose() {
    if (this._overlayWidget) {
      this.editor.removeOverlayWidget(this._overlayWidget);
      this._overlayWidget = null;
    }
    if (this._viewZone) {
      this.editor.changeViewZones((accessor) => {
        if (this._viewZone) {
          accessor.removeZone(this._viewZone.id);
        }
        this._viewZone = null;
      });
    }
    this.editor.deltaDecorations(this._positionMarkerId, []);
    this._positionMarkerId = [];
    this._disposables.dispose();
  }
  create() {
    this.domNode.classList.add("zone-widget");
    if (this.options.className) {
      this.domNode.classList.add(this.options.className);
    }
    this.container = document.createElement("div");
    this.container.classList.add("zone-widget-container");
    this.domNode.appendChild(this.container);
    if (this.options.showArrow) {
      this._arrow = new Arrow(this.editor);
      this._disposables.add(this._arrow);
    }
    this._fillContainer(this.container);
    this._initSash();
    this._applyStyles();
  }
  style(styles) {
    if (styles.frameColor) {
      this.options.frameColor = styles.frameColor;
    }
    if (styles.arrowColor) {
      this.options.arrowColor = styles.arrowColor;
    }
    this._applyStyles();
  }
  _applyStyles() {
    if (this.container && this.options.frameColor) {
      let frameColor = this.options.frameColor.toString();
      this.container.style.borderTopColor = frameColor;
      this.container.style.borderBottomColor = frameColor;
    }
    if (this._arrow && this.options.arrowColor) {
      let arrowColor = this.options.arrowColor.toString();
      this._arrow.color = arrowColor;
    }
  }
  _getWidth(info) {
    return info.width - info.minimap.minimapWidth - info.verticalScrollbarWidth;
  }
  _getLeft(info) {
    if (info.minimap.minimapWidth > 0 && info.minimap.minimapLeft === 0) {
      return info.minimap.minimapWidth;
    }
    return 0;
  }
  _onViewZoneTop(top) {
    this.domNode.style.top = top + "px";
  }
  _onViewZoneHeight(height) {
    this.domNode.style.height = `${height}px`;
    if (this.container) {
      let containerHeight = height - this._decoratingElementsHeight();
      this.container.style.height = `${containerHeight}px`;
      const layoutInfo = this.editor.getLayoutInfo();
      this._doLayout(containerHeight, this._getWidth(layoutInfo));
    }
    if (this._resizeSash) {
      this._resizeSash.layout();
    }
  }
  get position() {
    const [id] = this._positionMarkerId;
    if (!id) {
      return void 0;
    }
    const model = this.editor.getModel();
    if (!model) {
      return void 0;
    }
    const range = model.getDecorationRange(id);
    if (!range) {
      return void 0;
    }
    return range.getStartPosition();
  }
  show(rangeOrPos, heightInLines) {
    const range = Range.isIRange(rangeOrPos) ? Range.lift(rangeOrPos) : Range.fromPositions(rangeOrPos);
    this._isShowing = true;
    this._showImpl(range, heightInLines);
    this._isShowing = false;
    this._positionMarkerId = this.editor.deltaDecorations(this._positionMarkerId, [{ range, options: ModelDecorationOptions.EMPTY }]);
  }
  hide() {
    if (this._viewZone) {
      this.editor.changeViewZones((accessor) => {
        if (this._viewZone) {
          accessor.removeZone(this._viewZone.id);
        }
      });
      this._viewZone = null;
    }
    if (this._overlayWidget) {
      this.editor.removeOverlayWidget(this._overlayWidget);
      this._overlayWidget = null;
    }
    if (this._arrow) {
      this._arrow.hide();
    }
  }
  _decoratingElementsHeight() {
    let lineHeight = this.editor.getOption(58);
    let result = 0;
    if (this.options.showArrow) {
      let arrowHeight = Math.round(lineHeight / 3);
      result += 2 * arrowHeight;
    }
    if (this.options.showFrame) {
      let frameThickness = Math.round(lineHeight / 9);
      result += 2 * frameThickness;
    }
    return result;
  }
  _showImpl(where, heightInLines) {
    const position = where.getStartPosition();
    const layoutInfo = this.editor.getLayoutInfo();
    const width = this._getWidth(layoutInfo);
    this.domNode.style.width = `${width}px`;
    this.domNode.style.left = this._getLeft(layoutInfo) + "px";
    const viewZoneDomNode = document.createElement("div");
    viewZoneDomNode.style.overflow = "hidden";
    const lineHeight = this.editor.getOption(58);
    const maxHeightInLines = Math.max(12, this.editor.getLayoutInfo().height / lineHeight * 0.8);
    heightInLines = Math.min(heightInLines, maxHeightInLines);
    let arrowHeight = 0;
    let frameThickness = 0;
    if (this._arrow && this.options.showArrow) {
      arrowHeight = Math.round(lineHeight / 3);
      this._arrow.height = arrowHeight;
      this._arrow.show(position);
    }
    if (this.options.showFrame) {
      frameThickness = Math.round(lineHeight / 9);
    }
    this.editor.changeViewZones((accessor) => {
      if (this._viewZone) {
        accessor.removeZone(this._viewZone.id);
      }
      if (this._overlayWidget) {
        this.editor.removeOverlayWidget(this._overlayWidget);
        this._overlayWidget = null;
      }
      this.domNode.style.top = "-1000px";
      this._viewZone = new ViewZoneDelegate(viewZoneDomNode, position.lineNumber, position.column, heightInLines, (top) => this._onViewZoneTop(top), (height) => this._onViewZoneHeight(height));
      this._viewZone.id = accessor.addZone(this._viewZone);
      this._overlayWidget = new OverlayWidgetDelegate(WIDGET_ID + this._viewZone.id, this.domNode);
      this.editor.addOverlayWidget(this._overlayWidget);
    });
    if (this.container && this.options.showFrame) {
      const width2 = this.options.frameWidth ? this.options.frameWidth : frameThickness;
      this.container.style.borderTopWidth = width2 + "px";
      this.container.style.borderBottomWidth = width2 + "px";
    }
    let containerHeight = heightInLines * lineHeight - this._decoratingElementsHeight();
    if (this.container) {
      this.container.style.top = arrowHeight + "px";
      this.container.style.height = containerHeight + "px";
      this.container.style.overflow = "hidden";
    }
    this._doLayout(containerHeight, width);
    if (!this.options.keepEditorSelection) {
      this.editor.setSelection(where);
    }
    const model = this.editor.getModel();
    if (model) {
      const revealLine = where.endLineNumber + 1;
      if (revealLine <= model.getLineCount()) {
        this.revealLine(revealLine, false);
      } else {
        this.revealLine(model.getLineCount(), true);
      }
    }
  }
  revealLine(lineNumber, isLastLine) {
    if (isLastLine) {
      this.editor.revealLineInCenter(lineNumber, 0);
    } else {
      this.editor.revealLine(lineNumber, 0);
    }
  }
  setCssClass(className, classToReplace) {
    if (!this.container) {
      return;
    }
    if (classToReplace) {
      this.container.classList.remove(classToReplace);
    }
    this.container.classList.add(className);
  }
  _onWidth(widthInPixel) {
  }
  _doLayout(heightInPixel, widthInPixel) {
  }
  _relayout(newHeightInLines) {
    if (this._viewZone && this._viewZone.heightInLines !== newHeightInLines) {
      this.editor.changeViewZones((accessor) => {
        if (this._viewZone) {
          this._viewZone.heightInLines = newHeightInLines;
          accessor.layoutZone(this._viewZone.id);
        }
      });
    }
  }
  _initSash() {
    if (this._resizeSash) {
      return;
    }
    this._resizeSash = this._disposables.add(new Sash(this.domNode, this, { orientation: 1 }));
    if (!this.options.isResizeable) {
      this._resizeSash.state = 0;
    }
    let data;
    this._disposables.add(this._resizeSash.onDidStart((e) => {
      if (this._viewZone) {
        data = {
          startY: e.startY,
          heightInLines: this._viewZone.heightInLines
        };
      }
    }));
    this._disposables.add(this._resizeSash.onDidEnd(() => {
      data = void 0;
    }));
    this._disposables.add(this._resizeSash.onDidChange((evt) => {
      if (data) {
        let lineDelta = (evt.currentY - data.startY) / this.editor.getOption(58);
        let roundedLineDelta = lineDelta < 0 ? Math.ceil(lineDelta) : Math.floor(lineDelta);
        let newHeightInLines = data.heightInLines + roundedLineDelta;
        if (newHeightInLines > 5 && newHeightInLines < 35) {
          this._relayout(newHeightInLines);
        }
      }
    }));
  }
  getHorizontalSashLeft() {
    return 0;
  }
  getHorizontalSashTop() {
    return (this.domNode.style.height === null ? 0 : parseInt(this.domNode.style.height)) - this._decoratingElementsHeight() / 2;
  }
  getHorizontalSashWidth() {
    const layoutInfo = this.editor.getLayoutInfo();
    return layoutInfo.width - layoutInfo.minimap.minimapWidth;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css";
var BaseDropdown = class extends ActionRunner {
  constructor(container, options) {
    super();
    this._onDidChangeVisibility = this._register(new Emitter());
    this.onDidChangeVisibility = this._onDidChangeVisibility.event;
    this._element = append(container, $(".monaco-dropdown"));
    this._label = append(this._element, $(".dropdown-label"));
    let labelRenderer = options.labelRenderer;
    if (!labelRenderer) {
      labelRenderer = (container2) => {
        container2.textContent = options.label || "";
        return null;
      };
    }
    for (const event of [EventType.CLICK, EventType.MOUSE_DOWN, EventType2.Tap]) {
      this._register(addDisposableListener(this.element, event, (e) => EventHelper.stop(e, true)));
    }
    for (const event of [EventType.MOUSE_DOWN, EventType2.Tap]) {
      this._register(addDisposableListener(this._label, event, (e) => {
        if (e instanceof MouseEvent && e.detail > 1) {
          return;
        }
        if (this.visible) {
          this.hide();
        } else {
          this.show();
        }
      }));
    }
    this._register(addDisposableListener(this._label, EventType.KEY_UP, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(3) || event.equals(10)) {
        EventHelper.stop(e, true);
        if (this.visible) {
          this.hide();
        } else {
          this.show();
        }
      }
    }));
    const cleanupFn = labelRenderer(this._label);
    if (cleanupFn) {
      this._register(cleanupFn);
    }
    this._register(Gesture.addTarget(this._label));
  }
  get element() {
    return this._element;
  }
  show() {
    if (!this.visible) {
      this.visible = true;
      this._onDidChangeVisibility.fire(true);
    }
  }
  hide() {
    if (this.visible) {
      this.visible = false;
      this._onDidChangeVisibility.fire(false);
    }
  }
  dispose() {
    super.dispose();
    this.hide();
    if (this.boxContainer) {
      this.boxContainer.remove();
      this.boxContainer = void 0;
    }
    if (this.contents) {
      this.contents.remove();
      this.contents = void 0;
    }
    if (this._label) {
      this._label.remove();
      this._label = void 0;
    }
  }
};
var DropdownMenu = class extends BaseDropdown {
  constructor(container, options) {
    super(container, options);
    this._actions = [];
    this._contextMenuProvider = options.contextMenuProvider;
    this.actions = options.actions || [];
    this.actionProvider = options.actionProvider;
    this.menuClassName = options.menuClassName || "";
    this.menuAsChild = !!options.menuAsChild;
  }
  set menuOptions(options) {
    this._menuOptions = options;
  }
  get menuOptions() {
    return this._menuOptions;
  }
  get actions() {
    if (this.actionProvider) {
      return this.actionProvider.getActions();
    }
    return this._actions;
  }
  set actions(actions) {
    this._actions = actions;
  }
  show() {
    super.show();
    this.element.classList.add("active");
    this._contextMenuProvider.showContextMenu({
      getAnchor: () => this.element,
      getActions: () => this.actions,
      getActionsContext: () => this.menuOptions ? this.menuOptions.context : null,
      getActionViewItem: (action) => this.menuOptions && this.menuOptions.actionViewItemProvider ? this.menuOptions.actionViewItemProvider(action) : void 0,
      getKeyBinding: (action) => this.menuOptions && this.menuOptions.getKeyBinding ? this.menuOptions.getKeyBinding(action) : void 0,
      getMenuClassName: () => this.menuClassName,
      onHide: () => this.onHide(),
      actionRunner: this.menuOptions ? this.menuOptions.actionRunner : void 0,
      anchorAlignment: this.menuOptions ? this.menuOptions.anchorAlignment : 0,
      domForShadowRoot: this.menuAsChild ? this.element : void 0
    });
  }
  hide() {
    super.hide();
  }
  onHide() {
    this.hide();
    this.element.classList.remove("active");
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdownActionViewItem.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/base/browser/ui/dropdown/dropdown.css";
var DropdownMenuActionViewItem = class extends BaseActionViewItem {
  constructor(action, menuActionsOrProvider, contextMenuProvider, options = Object.create(null)) {
    super(null, action, options);
    this.actionItem = null;
    this._onDidChangeVisibility = this._register(new Emitter());
    this.menuActionsOrProvider = menuActionsOrProvider;
    this.contextMenuProvider = contextMenuProvider;
    this.options = options;
    if (this.options.actionRunner) {
      this.actionRunner = this.options.actionRunner;
    }
  }
  render(container) {
    this.actionItem = container;
    const labelRenderer = (el) => {
      this.element = append(el, $("a.action-label"));
      let classNames = [];
      if (typeof this.options.classNames === "string") {
        classNames = this.options.classNames.split(/\s+/g).filter((s) => !!s);
      } else if (this.options.classNames) {
        classNames = this.options.classNames;
      }
      if (!classNames.find((c) => c === "icon")) {
        classNames.push("codicon");
      }
      this.element.classList.add(...classNames);
      this.element.setAttribute("role", "button");
      this.element.setAttribute("aria-haspopup", "true");
      this.element.setAttribute("aria-expanded", "false");
      this.element.title = this._action.label || "";
      return null;
    };
    const isActionsArray = Array.isArray(this.menuActionsOrProvider);
    const options = {
      contextMenuProvider: this.contextMenuProvider,
      labelRenderer,
      menuAsChild: this.options.menuAsChild,
      actions: isActionsArray ? this.menuActionsOrProvider : void 0,
      actionProvider: isActionsArray ? void 0 : this.menuActionsOrProvider
    };
    this.dropdownMenu = this._register(new DropdownMenu(container, options));
    this._register(this.dropdownMenu.onDidChangeVisibility((visible) => {
      var _a5;
      (_a5 = this.element) === null || _a5 === void 0 ? void 0 : _a5.setAttribute("aria-expanded", `${visible}`);
      this._onDidChangeVisibility.fire(visible);
    }));
    this.dropdownMenu.menuOptions = {
      actionViewItemProvider: this.options.actionViewItemProvider,
      actionRunner: this.actionRunner,
      getKeyBinding: this.options.keybindingProvider,
      context: this._context
    };
    if (this.options.anchorAlignmentProvider) {
      const that = this;
      this.dropdownMenu.menuOptions = Object.assign(Object.assign({}, this.dropdownMenu.menuOptions), { get anchorAlignment() {
        return that.options.anchorAlignmentProvider();
      } });
    }
    this.updateEnabled();
  }
  setActionContext(newContext) {
    super.setActionContext(newContext);
    if (this.dropdownMenu) {
      if (this.dropdownMenu.menuOptions) {
        this.dropdownMenu.menuOptions.context = newContext;
      } else {
        this.dropdownMenu.menuOptions = { context: newContext };
      }
    }
  }
  updateEnabled() {
    var _a5, _b2;
    const disabled = !this.getAction().enabled;
    (_a5 = this.actionItem) === null || _a5 === void 0 ? void 0 : _a5.classList.toggle("disabled", disabled);
    (_b2 = this.element) === null || _b2 === void 0 ? void 0 : _b2.classList.toggle("disabled", disabled);
  }
};

// node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.css";
var __decorate11 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param11 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function createAndFillInActionBarActions(menu, options, target, primaryGroup, primaryMaxCount, shouldInlineSubmenu, useSeparatorsInPrimaryActions) {
  const groups = menu.getActions(options);
  const isPrimaryAction = typeof primaryGroup === "string" ? (actionGroup) => actionGroup === primaryGroup : primaryGroup;
  fillInActions(groups, target, false, isPrimaryAction, primaryMaxCount, shouldInlineSubmenu, useSeparatorsInPrimaryActions);
  return asDisposable(groups);
}
function asDisposable(groups) {
  const disposables = new DisposableStore();
  for (const [, actions] of groups) {
    for (const action of actions) {
      disposables.add(action);
    }
  }
  return disposables;
}
function fillInActions(groups, target, useAlternativeActions, isPrimaryAction = (actionGroup) => actionGroup === "navigation", primaryMaxCount = Number.MAX_SAFE_INTEGER, shouldInlineSubmenu = () => false, useSeparatorsInPrimaryActions = false) {
  let primaryBucket;
  let secondaryBucket;
  if (Array.isArray(target)) {
    primaryBucket = target;
    secondaryBucket = target;
  } else {
    primaryBucket = target.primary;
    secondaryBucket = target.secondary;
  }
  const submenuInfo = new Set();
  for (const [group, actions] of groups) {
    let target2;
    if (isPrimaryAction(group)) {
      target2 = primaryBucket;
      if (target2.length > 0 && useSeparatorsInPrimaryActions) {
        target2.push(new Separator());
      }
    } else {
      target2 = secondaryBucket;
      if (target2.length > 0) {
        target2.push(new Separator());
      }
    }
    for (let action of actions) {
      if (useAlternativeActions) {
        action = action instanceof MenuItemAction && action.alt ? action.alt : action;
      }
      const newLen = target2.push(action);
      if (action instanceof SubmenuAction) {
        submenuInfo.add({ group, action, index: newLen - 1 });
      }
    }
  }
  for (const { group, action, index } of submenuInfo) {
    const target2 = isPrimaryAction(group) ? primaryBucket : secondaryBucket;
    const submenuActions = action.actions;
    if ((submenuActions.length <= 1 || target2.length + submenuActions.length - 2 <= primaryMaxCount) && shouldInlineSubmenu(action, group, target2.length)) {
      target2.splice(index, 1, ...submenuActions);
    }
  }
  if (primaryBucket !== secondaryBucket && primaryBucket.length > primaryMaxCount) {
    const overflow = primaryBucket.splice(primaryMaxCount, primaryBucket.length - primaryMaxCount);
    secondaryBucket.unshift(...overflow, new Separator());
  }
}
var MenuEntryActionViewItem = class MenuEntryActionViewItem2 extends ActionViewItem {
  constructor(_action, options, _keybindingService, _notificationService, _contextKeyService) {
    super(void 0, _action, { icon: !!(_action.class || _action.item.icon), label: !_action.class && !_action.item.icon, draggable: options === null || options === void 0 ? void 0 : options.draggable });
    this._keybindingService = _keybindingService;
    this._notificationService = _notificationService;
    this._contextKeyService = _contextKeyService;
    this._wantsAltCommand = false;
    this._itemClassDispose = this._register(new MutableDisposable());
    this._altKey = ModifierKeyEmitter.getInstance();
  }
  get _menuItemAction() {
    return this._action;
  }
  get _commandAction() {
    return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;
  }
  onClick(event) {
    return __awaiter9(this, void 0, void 0, function* () {
      event.preventDefault();
      event.stopPropagation();
      try {
        yield this.actionRunner.run(this._commandAction, this._context);
      } catch (err) {
        this._notificationService.error(err);
      }
    });
  }
  render(container) {
    super.render(container);
    container.classList.add("menu-entry");
    this._updateItemClass(this._menuItemAction.item);
    let mouseOver = false;
    let alternativeKeyDown = this._altKey.keyStatus.altKey || (isWindows || isLinux) && this._altKey.keyStatus.shiftKey;
    const updateAltState = () => {
      const wantsAltCommand = mouseOver && alternativeKeyDown;
      if (wantsAltCommand !== this._wantsAltCommand) {
        this._wantsAltCommand = wantsAltCommand;
        this.updateLabel();
        this.updateTooltip();
        this.updateClass();
      }
    };
    if (this._menuItemAction.alt) {
      this._register(this._altKey.event((value) => {
        alternativeKeyDown = value.altKey || (isWindows || isLinux) && value.shiftKey;
        updateAltState();
      }));
    }
    this._register(addDisposableListener(container, "mouseleave", (_) => {
      mouseOver = false;
      updateAltState();
    }));
    this._register(addDisposableListener(container, "mouseenter", (_) => {
      mouseOver = true;
      updateAltState();
    }));
  }
  updateLabel() {
    if (this.options.label && this.label) {
      this.label.textContent = this._commandAction.label;
    }
  }
  updateTooltip() {
    if (this.label) {
      const keybinding = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService);
      const keybindingLabel = keybinding && keybinding.getLabel();
      const tooltip = this._commandAction.tooltip || this._commandAction.label;
      let title = keybindingLabel ? localize("titleAndKb", "{0} ({1})", tooltip, keybindingLabel) : tooltip;
      if (!this._wantsAltCommand && this._menuItemAction.alt) {
        const altTooltip = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label;
        const altKeybinding = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService);
        const altKeybindingLabel = altKeybinding && altKeybinding.getLabel();
        const altTitleSection = altKeybindingLabel ? localize("titleAndKb", "{0} ({1})", altTooltip, altKeybindingLabel) : altTooltip;
        title += `
[${UILabelProvider.modifierLabels[OS].altKey}] ${altTitleSection}`;
      }
      this.label.title = title;
    }
  }
  updateClass() {
    if (this.options.icon) {
      if (this._commandAction !== this._menuItemAction) {
        if (this._menuItemAction.alt) {
          this._updateItemClass(this._menuItemAction.alt.item);
        }
      } else if (this._menuItemAction.alt) {
        this._updateItemClass(this._menuItemAction.item);
      }
    }
  }
  _updateItemClass(item) {
    var _a5;
    this._itemClassDispose.value = void 0;
    const { element, label } = this;
    if (!element || !label) {
      return;
    }
    const icon = this._commandAction.checked && ((_a5 = item.toggled) === null || _a5 === void 0 ? void 0 : _a5.icon) ? item.toggled.icon : item.icon;
    if (!icon) {
      return;
    }
    if (ThemeIcon.isThemeIcon(icon)) {
      const iconClasses = ThemeIcon.asClassNameArray(icon);
      label.classList.add(...iconClasses);
      this._itemClassDispose.value = toDisposable(() => {
        label.classList.remove(...iconClasses);
      });
    } else {
      if (icon.light) {
        label.style.setProperty("--menu-entry-icon-light", asCSSUrl(icon.light));
      }
      if (icon.dark) {
        label.style.setProperty("--menu-entry-icon-dark", asCSSUrl(icon.dark));
      }
      label.classList.add("icon");
      this._itemClassDispose.value = toDisposable(() => {
        label.classList.remove("icon");
        label.style.removeProperty("--menu-entry-icon-light");
        label.style.removeProperty("--menu-entry-icon-dark");
      });
    }
  }
};
MenuEntryActionViewItem = __decorate11([
  __param11(2, IKeybindingService),
  __param11(3, INotificationService),
  __param11(4, IContextKeyService)
], MenuEntryActionViewItem);
var SubmenuEntryActionViewItem = class SubmenuEntryActionViewItem2 extends DropdownMenuActionViewItem {
  constructor(action, options, contextMenuService) {
    var _a5, _b2;
    const dropdownOptions = Object.assign({}, options !== null && options !== void 0 ? options : Object.create(null), {
      menuAsChild: (_a5 = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a5 !== void 0 ? _a5 : false,
      classNames: (_b2 = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b2 !== void 0 ? _b2 : ThemeIcon.isThemeIcon(action.item.icon) ? ThemeIcon.asClassName(action.item.icon) : void 0
    });
    super(action, { getActions: () => action.actions }, contextMenuService, dropdownOptions);
  }
  render(container) {
    super.render(container);
    if (this.element) {
      container.classList.add("menu-entry");
      const { icon } = this._action.item;
      if (icon && !ThemeIcon.isThemeIcon(icon)) {
        this.element.classList.add("icon");
        if (icon.light) {
          this.element.style.setProperty("--menu-entry-icon-light", asCSSUrl(icon.light));
        }
        if (icon.dark) {
          this.element.style.setProperty("--menu-entry-icon-dark", asCSSUrl(icon.dark));
        }
      }
    }
  }
};
SubmenuEntryActionViewItem = __decorate11([
  __param11(2, IContextMenuService)
], SubmenuEntryActionViewItem);
var DropdownWithDefaultActionViewItem = class DropdownWithDefaultActionViewItem2 extends BaseActionViewItem {
  constructor(submenuAction, options, _keybindingService, _notificationService, _contextMenuService, _menuService, _instaService, _storageService) {
    var _a5, _b2, _c2;
    super(null, submenuAction);
    this._keybindingService = _keybindingService;
    this._notificationService = _notificationService;
    this._contextMenuService = _contextMenuService;
    this._menuService = _menuService;
    this._instaService = _instaService;
    this._storageService = _storageService;
    this._container = null;
    this._storageKey = `${submenuAction.item.submenu._debugName}_lastActionId`;
    let defaultAction;
    let defaultActionId = _storageService.get(this._storageKey, 1);
    if (defaultActionId) {
      defaultAction = submenuAction.actions.find((a) => defaultActionId === a.id);
    }
    if (!defaultAction) {
      defaultAction = submenuAction.actions[0];
    }
    this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, defaultAction, void 0);
    const dropdownOptions = Object.assign({}, options !== null && options !== void 0 ? options : Object.create(null), {
      menuAsChild: (_a5 = options === null || options === void 0 ? void 0 : options.menuAsChild) !== null && _a5 !== void 0 ? _a5 : true,
      classNames: (_b2 = options === null || options === void 0 ? void 0 : options.classNames) !== null && _b2 !== void 0 ? _b2 : ["codicon", "codicon-chevron-down"],
      actionRunner: (_c2 = options === null || options === void 0 ? void 0 : options.actionRunner) !== null && _c2 !== void 0 ? _c2 : new ActionRunner()
    });
    this._dropdown = new DropdownMenuActionViewItem(submenuAction, submenuAction.actions, this._contextMenuService, dropdownOptions);
    this._dropdown.actionRunner.onDidRun((e) => {
      if (e.action instanceof MenuItemAction) {
        this.update(e.action);
      }
    });
  }
  update(lastAction) {
    this._storageService.store(this._storageKey, lastAction.id, 1, 0);
    this._defaultAction.dispose();
    this._defaultAction = this._instaService.createInstance(MenuEntryActionViewItem, lastAction, void 0);
    this._defaultAction.actionRunner = new class extends ActionRunner {
      runAction(action, context) {
        return __awaiter9(this, void 0, void 0, function* () {
          yield action.run(void 0);
        });
      }
    }();
    if (this._container) {
      this._defaultAction.render(prepend(this._container, $(".action-container")));
    }
  }
  setActionContext(newContext) {
    super.setActionContext(newContext);
    this._defaultAction.setActionContext(newContext);
    this._dropdown.setActionContext(newContext);
  }
  render(container) {
    this._container = container;
    super.render(this._container);
    this._container.classList.add("monaco-dropdown-with-default");
    const primaryContainer = $(".action-container");
    this._defaultAction.render(append(this._container, primaryContainer));
    this._register(addDisposableListener(primaryContainer, EventType.KEY_DOWN, (e) => {
      const event = new StandardKeyboardEvent(e);
      if (event.equals(17)) {
        this._defaultAction.element.tabIndex = -1;
        this._dropdown.focus();
        event.stopPropagation();
      }
    }));
    const dropdownContainer = $(".dropdown-action-container");
    this._dropdown.render(append(this._container, dropdownContainer));
    this._register(addDisposableListener(dropdownContainer, EventType.KEY_DOWN, (e) => {
      var _a5;
      const event = new StandardKeyboardEvent(e);
      if (event.equals(15)) {
        this._defaultAction.element.tabIndex = 0;
        this._dropdown.setFocusable(false);
        (_a5 = this._defaultAction.element) === null || _a5 === void 0 ? void 0 : _a5.focus();
        event.stopPropagation();
      }
    }));
  }
  focus(fromRight) {
    if (fromRight) {
      this._dropdown.focus();
    } else {
      this._defaultAction.element.tabIndex = 0;
      this._defaultAction.element.focus();
    }
  }
  blur() {
    this._defaultAction.element.tabIndex = -1;
    this._dropdown.blur();
    this._container.blur();
  }
  setFocusable(focusable) {
    if (focusable) {
      this._defaultAction.element.tabIndex = 0;
    } else {
      this._defaultAction.element.tabIndex = -1;
      this._dropdown.setFocusable(false);
    }
  }
  dispose() {
    this._defaultAction.dispose();
    this._dropdown.dispose();
    super.dispose();
  }
};
DropdownWithDefaultActionViewItem = __decorate11([
  __param11(2, IKeybindingService),
  __param11(3, INotificationService),
  __param11(4, IContextMenuService),
  __param11(5, IMenuService),
  __param11(6, IInstantiationService),
  __param11(7, IStorageService)
], DropdownWithDefaultActionViewItem);
function createActionViewItem(instaService, action, options) {
  if (action instanceof MenuItemAction) {
    return instaService.createInstance(MenuEntryActionViewItem, action, void 0);
  } else if (action instanceof SubmenuItemAction) {
    if (action.item.rememberDefaultAction) {
      return instaService.createInstance(DropdownWithDefaultActionViewItem, action, options);
    } else {
      return instaService.createInstance(SubmenuEntryActionViewItem, action, options);
    }
  } else {
    return void 0;
  }
}

// node_modules/monaco-editor/esm/vs/editor/contrib/peekView/peekView.js
var __decorate12 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param12 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var IPeekViewService = createDecorator("IPeekViewService");
registerSingleton(IPeekViewService, class {
  constructor() {
    this._widgets = new Map();
  }
  addExclusiveWidget(editor2, widget) {
    const existing = this._widgets.get(editor2);
    if (existing) {
      existing.listener.dispose();
      existing.widget.dispose();
    }
    const remove = () => {
      const data = this._widgets.get(editor2);
      if (data && data.widget === widget) {
        data.listener.dispose();
        this._widgets.delete(editor2);
      }
    };
    this._widgets.set(editor2, { widget, listener: widget.onDidClose(remove) });
  }
});
var PeekContext;
(function(PeekContext2) {
  PeekContext2.inPeekEditor = new RawContextKey("inReferenceSearchEditor", true, localize("inReferenceSearchEditor", "Whether the current code editor is embedded inside peek"));
  PeekContext2.notInPeekEditor = PeekContext2.inPeekEditor.toNegated();
})(PeekContext || (PeekContext = {}));
var PeekContextController = class PeekContextController2 {
  constructor(editor2, contextKeyService) {
    if (editor2 instanceof EmbeddedCodeEditorWidget) {
      PeekContext.inPeekEditor.bindTo(contextKeyService);
    }
  }
  dispose() {
  }
};
PeekContextController.ID = "editor.contrib.referenceController";
PeekContextController = __decorate12([
  __param12(1, IContextKeyService)
], PeekContextController);
registerEditorContribution(PeekContextController.ID, PeekContextController);
function getOuterEditor(accessor) {
  let editor2 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
  if (editor2 instanceof EmbeddedCodeEditorWidget) {
    return editor2.getParentEditor();
  }
  return editor2;
}
var defaultOptions2 = {
  headerBackgroundColor: Color.white,
  primaryHeadingColor: Color.fromHex("#333333"),
  secondaryHeadingColor: Color.fromHex("#6c6c6cb3")
};
var PeekViewWidget = class PeekViewWidget2 extends ZoneWidget {
  constructor(editor2, options, instantiationService) {
    super(editor2, options);
    this.instantiationService = instantiationService;
    this._onDidClose = new Emitter();
    this.onDidClose = this._onDidClose.event;
    mixin(this.options, defaultOptions2, false);
  }
  dispose() {
    if (!this.disposed) {
      this.disposed = true;
      super.dispose();
      this._onDidClose.fire(this);
    }
  }
  style(styles) {
    let options = this.options;
    if (styles.headerBackgroundColor) {
      options.headerBackgroundColor = styles.headerBackgroundColor;
    }
    if (styles.primaryHeadingColor) {
      options.primaryHeadingColor = styles.primaryHeadingColor;
    }
    if (styles.secondaryHeadingColor) {
      options.secondaryHeadingColor = styles.secondaryHeadingColor;
    }
    super.style(styles);
  }
  _applyStyles() {
    super._applyStyles();
    let options = this.options;
    if (this._headElement && options.headerBackgroundColor) {
      this._headElement.style.backgroundColor = options.headerBackgroundColor.toString();
    }
    if (this._primaryHeading && options.primaryHeadingColor) {
      this._primaryHeading.style.color = options.primaryHeadingColor.toString();
    }
    if (this._secondaryHeading && options.secondaryHeadingColor) {
      this._secondaryHeading.style.color = options.secondaryHeadingColor.toString();
    }
    if (this._bodyElement && options.frameColor) {
      this._bodyElement.style.borderColor = options.frameColor.toString();
    }
  }
  _fillContainer(container) {
    this.setCssClass("peekview-widget");
    this._headElement = $(".head");
    this._bodyElement = $(".body");
    this._fillHead(this._headElement);
    this._fillBody(this._bodyElement);
    container.appendChild(this._headElement);
    container.appendChild(this._bodyElement);
  }
  _fillHead(container, noCloseAction) {
    const titleElement = $(".peekview-title");
    if (this.options.supportOnTitleClick) {
      titleElement.classList.add("clickable");
      addStandardDisposableListener(titleElement, "click", (event) => this._onTitleClick(event));
    }
    append(this._headElement, titleElement);
    this._fillTitleIcon(titleElement);
    this._primaryHeading = $("span.filename");
    this._secondaryHeading = $("span.dirname");
    this._metaHeading = $("span.meta");
    append(titleElement, this._primaryHeading, this._secondaryHeading, this._metaHeading);
    const actionsContainer = $(".peekview-actions");
    append(this._headElement, actionsContainer);
    const actionBarOptions = this._getActionBarOptions();
    this._actionbarWidget = new ActionBar(actionsContainer, actionBarOptions);
    this._disposables.add(this._actionbarWidget);
    if (!noCloseAction) {
      this._actionbarWidget.push(new Action("peekview.close", localize("label.close", "Close"), Codicon.close.classNames, true, () => {
        this.dispose();
        return Promise.resolve();
      }), { label: false, icon: true });
    }
  }
  _fillTitleIcon(container) {
  }
  _getActionBarOptions() {
    return {
      actionViewItemProvider: createActionViewItem.bind(void 0, this.instantiationService),
      orientation: 0
    };
  }
  _onTitleClick(event) {
  }
  setTitle(primaryHeading, secondaryHeading) {
    if (this._primaryHeading && this._secondaryHeading) {
      this._primaryHeading.innerText = primaryHeading;
      this._primaryHeading.setAttribute("title", primaryHeading);
      if (secondaryHeading) {
        this._secondaryHeading.innerText = secondaryHeading;
      } else {
        clearNode(this._secondaryHeading);
      }
    }
  }
  setMetaTitle(value) {
    if (this._metaHeading) {
      if (value) {
        this._metaHeading.innerText = value;
        show(this._metaHeading);
      } else {
        hide(this._metaHeading);
      }
    }
  }
  _doLayout(heightInPixel, widthInPixel) {
    if (!this._isShowing && heightInPixel < 0) {
      this.dispose();
      return;
    }
    const headHeight = Math.ceil(this.editor.getOption(58) * 1.2);
    const bodyHeight = Math.round(heightInPixel - (headHeight + 2));
    this._doLayoutHead(headHeight, widthInPixel);
    this._doLayoutBody(bodyHeight, widthInPixel);
  }
  _doLayoutHead(heightInPixel, widthInPixel) {
    if (this._headElement) {
      this._headElement.style.height = `${heightInPixel}px`;
      this._headElement.style.lineHeight = this._headElement.style.height;
    }
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    if (this._bodyElement) {
      this._bodyElement.style.height = `${heightInPixel}px`;
    }
  }
};
PeekViewWidget = __decorate12([
  __param12(2, IInstantiationService)
], PeekViewWidget);
var peekViewTitleBackground = registerColor("peekViewTitle.background", { dark: transparent(editorInfoForeground, 0.1), light: transparent(editorInfoForeground, 0.1), hc: null }, localize("peekViewTitleBackground", "Background color of the peek view title area."));
var peekViewTitleForeground = registerColor("peekViewTitleLabel.foreground", { dark: Color.white, light: Color.black, hc: Color.white }, localize("peekViewTitleForeground", "Color of the peek view title."));
var peekViewTitleInfoForeground = registerColor("peekViewTitleDescription.foreground", { dark: "#ccccccb3", light: "#616161", hc: "#FFFFFF99" }, localize("peekViewTitleInfoForeground", "Color of the peek view title info."));
var peekViewBorder = registerColor("peekView.border", { dark: editorInfoForeground, light: editorInfoForeground, hc: contrastBorder }, localize("peekViewBorder", "Color of the peek view borders and arrow."));
var peekViewResultsBackground = registerColor("peekViewResult.background", { dark: "#252526", light: "#F3F3F3", hc: Color.black }, localize("peekViewResultsBackground", "Background color of the peek view result list."));
var peekViewResultsMatchForeground = registerColor("peekViewResult.lineForeground", { dark: "#bbbbbb", light: "#646465", hc: Color.white }, localize("peekViewResultsMatchForeground", "Foreground color for line nodes in the peek view result list."));
var peekViewResultsFileForeground = registerColor("peekViewResult.fileForeground", { dark: Color.white, light: "#1E1E1E", hc: Color.white }, localize("peekViewResultsFileForeground", "Foreground color for file nodes in the peek view result list."));
var peekViewResultsSelectionBackground = registerColor("peekViewResult.selectionBackground", { dark: "#3399ff33", light: "#3399ff33", hc: null }, localize("peekViewResultsSelectionBackground", "Background color of the selected entry in the peek view result list."));
var peekViewResultsSelectionForeground = registerColor("peekViewResult.selectionForeground", { dark: Color.white, light: "#6C6C6C", hc: Color.white }, localize("peekViewResultsSelectionForeground", "Foreground color of the selected entry in the peek view result list."));
var peekViewEditorBackground = registerColor("peekViewEditor.background", { dark: "#001F33", light: "#F2F8FC", hc: Color.black }, localize("peekViewEditorBackground", "Background color of the peek view editor."));
var peekViewEditorGutterBackground = registerColor("peekViewEditorGutter.background", { dark: peekViewEditorBackground, light: peekViewEditorBackground, hc: peekViewEditorBackground }, localize("peekViewEditorGutterBackground", "Background color of the gutter in the peek view editor."));
var peekViewResultsMatchHighlight = registerColor("peekViewResult.matchHighlightBackground", { dark: "#ea5c004d", light: "#ea5c004d", hc: null }, localize("peekViewResultsMatchHighlight", "Match highlight color in the peek view result list."));
var peekViewEditorMatchHighlight = registerColor("peekViewEditor.matchHighlightBackground", { dark: "#ff8f0099", light: "#f5d802de", hc: null }, localize("peekViewEditorMatchHighlight", "Match highlight color in the peek view editor."));
var peekViewEditorMatchHighlightBorder = registerColor("peekViewEditor.matchHighlightBorder", { dark: null, light: null, hc: activeContrastBorder }, localize("peekViewEditorMatchHighlightBorder", "Match highlight border in the peek view editor."));

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/referencesModel.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var OneReference = class {
  constructor(isProviderFirst, parent, link, _rangeCallback) {
    this.isProviderFirst = isProviderFirst;
    this.parent = parent;
    this.link = link;
    this._rangeCallback = _rangeCallback;
    this.id = defaultGenerator.nextId();
  }
  get uri() {
    return this.link.uri;
  }
  get range() {
    var _a5, _b2;
    return (_b2 = (_a5 = this._range) !== null && _a5 !== void 0 ? _a5 : this.link.targetSelectionRange) !== null && _b2 !== void 0 ? _b2 : this.link.range;
  }
  set range(value) {
    this._range = value;
    this._rangeCallback(this);
  }
  get ariaMessage() {
    var _a5;
    const preview = (_a5 = this.parent.getPreview(this)) === null || _a5 === void 0 ? void 0 : _a5.preview(this.range);
    if (!preview) {
      return localize("aria.oneReference", "symbol in {0} on line {1} at column {2}", basename2(this.uri), this.range.startLineNumber, this.range.startColumn);
    } else {
      return localize({ key: "aria.oneReference.preview", comment: ["Placeholders are: 0: filename, 1:line number, 2: column number, 3: preview snippet of source code"] }, "symbol in {0} on line {1} at column {2}, {3}", basename2(this.uri), this.range.startLineNumber, this.range.startColumn, preview.value);
    }
  }
};
var FilePreview = class {
  constructor(_modelReference) {
    this._modelReference = _modelReference;
  }
  dispose() {
    this._modelReference.dispose();
  }
  preview(range, n = 8) {
    const model = this._modelReference.object.textEditorModel;
    if (!model) {
      return void 0;
    }
    const { startLineNumber, startColumn, endLineNumber, endColumn } = range;
    const word = model.getWordUntilPosition({ lineNumber: startLineNumber, column: startColumn - n });
    const beforeRange = new Range(startLineNumber, word.startColumn, startLineNumber, startColumn);
    const afterRange = new Range(endLineNumber, endColumn, endLineNumber, 1073741824);
    const before = model.getValueInRange(beforeRange).replace(/^\s+/, "");
    const inside = model.getValueInRange(range);
    const after = model.getValueInRange(afterRange).replace(/\s+$/, "");
    return {
      value: before + inside + after,
      highlight: { start: before.length, end: before.length + inside.length }
    };
  }
};
var FileReferences = class {
  constructor(parent, uri) {
    this.parent = parent;
    this.uri = uri;
    this.children = [];
    this._previews = new ResourceMap();
  }
  dispose() {
    dispose(this._previews.values());
    this._previews.clear();
  }
  getPreview(child) {
    return this._previews.get(child.uri);
  }
  get ariaMessage() {
    const len = this.children.length;
    if (len === 1) {
      return localize("aria.fileReferences.1", "1 symbol in {0}, full path {1}", basename2(this.uri), this.uri.fsPath);
    } else {
      return localize("aria.fileReferences.N", "{0} symbols in {1}, full path {2}", len, basename2(this.uri), this.uri.fsPath);
    }
  }
  resolve(textModelResolverService) {
    return __awaiter10(this, void 0, void 0, function* () {
      if (this._previews.size !== 0) {
        return this;
      }
      for (let child of this.children) {
        if (this._previews.has(child.uri)) {
          continue;
        }
        try {
          const ref = yield textModelResolverService.createModelReference(child.uri);
          this._previews.set(child.uri, new FilePreview(ref));
        } catch (err) {
          onUnexpectedError(err);
        }
      }
      return this;
    });
  }
};
var ReferencesModel = class {
  constructor(links, title) {
    this.groups = [];
    this.references = [];
    this._onDidChangeReferenceRange = new Emitter();
    this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event;
    this._links = links;
    this._title = title;
    const [providersFirst] = links;
    links.sort(ReferencesModel._compareReferences);
    let current;
    for (let link of links) {
      if (!current || !extUri.isEqual(current.uri, link.uri, true)) {
        current = new FileReferences(this, link.uri);
        this.groups.push(current);
      }
      if (current.children.length === 0 || ReferencesModel._compareReferences(link, current.children[current.children.length - 1]) !== 0) {
        const oneRef = new OneReference(providersFirst === link, current, link, (ref) => this._onDidChangeReferenceRange.fire(ref));
        this.references.push(oneRef);
        current.children.push(oneRef);
      }
    }
  }
  dispose() {
    dispose(this.groups);
    this._onDidChangeReferenceRange.dispose();
    this.groups.length = 0;
  }
  clone() {
    return new ReferencesModel(this._links, this._title);
  }
  get title() {
    return this._title;
  }
  get isEmpty() {
    return this.groups.length === 0;
  }
  get ariaMessage() {
    if (this.isEmpty) {
      return localize("aria.result.0", "No results found");
    } else if (this.references.length === 1) {
      return localize("aria.result.1", "Found 1 symbol in {0}", this.references[0].uri.fsPath);
    } else if (this.groups.length === 1) {
      return localize("aria.result.n1", "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath);
    } else {
      return localize("aria.result.nm", "Found {0} symbols in {1} files", this.references.length, this.groups.length);
    }
  }
  nextOrPreviousReference(reference, next) {
    let { parent } = reference;
    let idx = parent.children.indexOf(reference);
    let childCount = parent.children.length;
    let groupCount = parent.parent.groups.length;
    if (groupCount === 1 || next && idx + 1 < childCount || !next && idx > 0) {
      if (next) {
        idx = (idx + 1) % childCount;
      } else {
        idx = (idx + childCount - 1) % childCount;
      }
      return parent.children[idx];
    }
    idx = parent.parent.groups.indexOf(parent);
    if (next) {
      idx = (idx + 1) % groupCount;
      return parent.parent.groups[idx].children[0];
    } else {
      idx = (idx + groupCount - 1) % groupCount;
      return parent.parent.groups[idx].children[parent.parent.groups[idx].children.length - 1];
    }
  }
  nearestReference(resource, position) {
    const nearest = this.references.map((ref, idx) => {
      return {
        idx,
        prefixLen: commonPrefixLength(ref.uri.toString(), resource.toString()),
        offsetDist: Math.abs(ref.range.startLineNumber - position.lineNumber) * 100 + Math.abs(ref.range.startColumn - position.column)
      };
    }).sort((a, b) => {
      if (a.prefixLen > b.prefixLen) {
        return -1;
      } else if (a.prefixLen < b.prefixLen) {
        return 1;
      } else if (a.offsetDist < b.offsetDist) {
        return -1;
      } else if (a.offsetDist > b.offsetDist) {
        return 1;
      } else {
        return 0;
      }
    })[0];
    if (nearest) {
      return this.references[nearest.idx];
    }
    return void 0;
  }
  referenceAt(resource, position) {
    for (const ref of this.references) {
      if (ref.uri.toString() === resource.toString()) {
        if (Range.containsPosition(ref.range, position)) {
          return ref;
        }
      }
    }
    return void 0;
  }
  firstReference() {
    for (const ref of this.references) {
      if (ref.isProviderFirst) {
        return ref;
      }
    }
    return this.references[0];
  }
  static _compareReferences(a, b) {
    return extUri.compare(a.uri, b.uri) || Range.compareRangesUsingStarts(a.range, b.range);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.css";

// node_modules/monaco-editor/esm/vs/base/common/labels.js
function getBaseLabel(resource) {
  if (!resource) {
    return void 0;
  }
  if (typeof resource === "string") {
    resource = URI.file(resource);
  }
  const base = basename2(resource) || (resource.scheme === Schemas.file ? resource.fsPath : resource.path);
  if (isWindows && isRootOrDriveLetter(base)) {
    return normalizeDriveLetter(base);
  }
  return base;
}
function normalizeDriveLetter(path2, continueAsWindows) {
  if (hasDriveLetter(path2, continueAsWindows)) {
    return path2.charAt(0).toUpperCase() + path2.slice(1);
  }
  return path2;
}
var normalizedUserHomeCached = Object.create(null);

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesTree.js
var __decorate13 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param13 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DataSource = class DataSource2 {
  constructor(_resolverService) {
    this._resolverService = _resolverService;
  }
  hasChildren(element) {
    if (element instanceof ReferencesModel) {
      return true;
    }
    if (element instanceof FileReferences) {
      return true;
    }
    return false;
  }
  getChildren(element) {
    if (element instanceof ReferencesModel) {
      return element.groups;
    }
    if (element instanceof FileReferences) {
      return element.resolve(this._resolverService).then((val) => {
        return val.children;
      });
    }
    throw new Error("bad tree");
  }
};
DataSource = __decorate13([
  __param13(0, ITextModelService)
], DataSource);
var Delegate = class {
  getHeight() {
    return 23;
  }
  getTemplateId(element) {
    if (element instanceof FileReferences) {
      return FileReferencesRenderer.id;
    } else {
      return OneReferenceRenderer.id;
    }
  }
};
var StringRepresentationProvider = class StringRepresentationProvider2 {
  constructor(_keybindingService) {
    this._keybindingService = _keybindingService;
  }
  getKeyboardNavigationLabel(element) {
    var _a5;
    if (element instanceof OneReference) {
      const parts = (_a5 = element.parent.getPreview(element)) === null || _a5 === void 0 ? void 0 : _a5.preview(element.range);
      if (parts) {
        return parts.value;
      }
    }
    return basename2(element.uri);
  }
};
StringRepresentationProvider = __decorate13([
  __param13(0, IKeybindingService)
], StringRepresentationProvider);
var IdentityProvider = class {
  getId(element) {
    return element instanceof OneReference ? element.id : element.uri;
  }
};
var FileReferencesTemplate = class FileReferencesTemplate2 extends Disposable {
  constructor(container, _uriLabel, themeService) {
    super();
    this._uriLabel = _uriLabel;
    const parent = document.createElement("div");
    parent.classList.add("reference-file");
    this.file = this._register(new IconLabel(parent, { supportHighlights: true }));
    this.badge = new CountBadge(append(parent, $(".count")));
    this._register(attachBadgeStyler(this.badge, themeService));
    container.appendChild(parent);
  }
  set(element, matches) {
    let parent = dirname2(element.uri);
    this.file.setLabel(getBaseLabel(element.uri), this._uriLabel.getUriLabel(parent, { relative: true }), { title: this._uriLabel.getUriLabel(element.uri), matches });
    const len = element.children.length;
    this.badge.setCount(len);
    if (len > 1) {
      this.badge.setTitleFormat(localize("referencesCount", "{0} references", len));
    } else {
      this.badge.setTitleFormat(localize("referenceCount", "{0} reference", len));
    }
  }
};
FileReferencesTemplate = __decorate13([
  __param13(1, ILabelService),
  __param13(2, IThemeService)
], FileReferencesTemplate);
var FileReferencesRenderer = class FileReferencesRenderer2 {
  constructor(_instantiationService) {
    this._instantiationService = _instantiationService;
    this.templateId = FileReferencesRenderer2.id;
  }
  renderTemplate(container) {
    return this._instantiationService.createInstance(FileReferencesTemplate, container);
  }
  renderElement(node, index, template) {
    template.set(node.element, createMatches(node.filterData));
  }
  disposeTemplate(templateData) {
    templateData.dispose();
  }
};
FileReferencesRenderer.id = "FileReferencesRenderer";
FileReferencesRenderer = __decorate13([
  __param13(0, IInstantiationService)
], FileReferencesRenderer);
var OneReferenceTemplate = class {
  constructor(container) {
    this.label = new HighlightedLabel(container);
  }
  set(element, score) {
    var _a5;
    const preview = (_a5 = element.parent.getPreview(element)) === null || _a5 === void 0 ? void 0 : _a5.preview(element.range);
    if (!preview || !preview.value) {
      this.label.set(`${basename2(element.uri)}:${element.range.startLineNumber + 1}:${element.range.startColumn + 1}`);
    } else {
      const { value, highlight } = preview;
      if (score && !FuzzyScore.isDefault(score)) {
        this.label.element.classList.toggle("referenceMatch", false);
        this.label.set(value, createMatches(score));
      } else {
        this.label.element.classList.toggle("referenceMatch", true);
        this.label.set(value, [highlight]);
      }
    }
  }
};
var OneReferenceRenderer = class {
  constructor() {
    this.templateId = OneReferenceRenderer.id;
  }
  renderTemplate(container) {
    return new OneReferenceTemplate(container);
  }
  renderElement(node, index, templateData) {
    templateData.set(node.element, node.filterData);
  }
  disposeTemplate() {
  }
};
OneReferenceRenderer.id = "OneReferenceRenderer";
var AccessibilityProvider = class {
  getWidgetAriaLabel() {
    return localize("treeAriaLabel", "References");
  }
  getAriaLabel(element) {
    return element.ariaMessage;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesWidget.js
var __decorate14 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param14 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DecorationsManager = class {
  constructor(_editor, _model) {
    this._editor = _editor;
    this._model = _model;
    this._decorations = new Map();
    this._decorationIgnoreSet = new Set();
    this._callOnDispose = new DisposableStore();
    this._callOnModelChange = new DisposableStore();
    this._callOnDispose.add(this._editor.onDidChangeModel(() => this._onModelChanged()));
    this._onModelChanged();
  }
  dispose() {
    this._callOnModelChange.dispose();
    this._callOnDispose.dispose();
    this.removeDecorations();
  }
  _onModelChanged() {
    this._callOnModelChange.clear();
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    for (let ref of this._model.references) {
      if (ref.uri.toString() === model.uri.toString()) {
        this._addDecorations(ref.parent);
        return;
      }
    }
  }
  _addDecorations(reference) {
    if (!this._editor.hasModel()) {
      return;
    }
    this._callOnModelChange.add(this._editor.getModel().onDidChangeDecorations(() => this._onDecorationChanged()));
    const newDecorations = [];
    const newDecorationsActualIndex = [];
    for (let i = 0, len = reference.children.length; i < len; i++) {
      let oneReference = reference.children[i];
      if (this._decorationIgnoreSet.has(oneReference.id)) {
        continue;
      }
      if (oneReference.uri.toString() !== this._editor.getModel().uri.toString()) {
        continue;
      }
      newDecorations.push({
        range: oneReference.range,
        options: DecorationsManager.DecorationOptions
      });
      newDecorationsActualIndex.push(i);
    }
    const decorations = this._editor.deltaDecorations([], newDecorations);
    for (let i = 0; i < decorations.length; i++) {
      this._decorations.set(decorations[i], reference.children[newDecorationsActualIndex[i]]);
    }
  }
  _onDecorationChanged() {
    const toRemove = [];
    const model = this._editor.getModel();
    if (!model) {
      return;
    }
    for (let [decorationId, reference] of this._decorations) {
      const newRange = model.getDecorationRange(decorationId);
      if (!newRange) {
        continue;
      }
      let ignore = false;
      if (Range.equalsRange(newRange, reference.range)) {
        continue;
      }
      if (Range.spansMultipleLines(newRange)) {
        ignore = true;
      } else {
        const lineLength = reference.range.endColumn - reference.range.startColumn;
        const newLineLength = newRange.endColumn - newRange.startColumn;
        if (lineLength !== newLineLength) {
          ignore = true;
        }
      }
      if (ignore) {
        this._decorationIgnoreSet.add(reference.id);
        toRemove.push(decorationId);
      } else {
        reference.range = newRange;
      }
    }
    for (let i = 0, len = toRemove.length; i < len; i++) {
      this._decorations.delete(toRemove[i]);
    }
    this._editor.deltaDecorations(toRemove, []);
  }
  removeDecorations() {
    this._editor.deltaDecorations([...this._decorations.keys()], []);
    this._decorations.clear();
  }
};
DecorationsManager.DecorationOptions = ModelDecorationOptions.register({
  description: "reference-decoration",
  stickiness: 1,
  className: "reference-decoration"
});
var LayoutData = class {
  constructor() {
    this.ratio = 0.7;
    this.heightInLines = 18;
  }
  static fromJSON(raw) {
    let ratio;
    let heightInLines;
    try {
      const data = JSON.parse(raw);
      ratio = data.ratio;
      heightInLines = data.heightInLines;
    } catch (_a5) {
    }
    return {
      ratio: ratio || 0.7,
      heightInLines: heightInLines || 18
    };
  }
};
var ReferencesTree = class extends WorkbenchAsyncDataTree {
};
var ReferenceWidget = class ReferenceWidget2 extends PeekViewWidget {
  constructor(editor2, _defaultTreeKeyboardSupport, layoutData, themeService, _textModelResolverService, _instantiationService, _peekViewService, _uriLabel, _undoRedoService, _keybindingService, _modeService, _languageConfigurationService) {
    super(editor2, { showFrame: false, showArrow: true, isResizeable: true, isAccessible: true, supportOnTitleClick: true }, _instantiationService);
    this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
    this.layoutData = layoutData;
    this._textModelResolverService = _textModelResolverService;
    this._instantiationService = _instantiationService;
    this._peekViewService = _peekViewService;
    this._uriLabel = _uriLabel;
    this._undoRedoService = _undoRedoService;
    this._keybindingService = _keybindingService;
    this._modeService = _modeService;
    this._languageConfigurationService = _languageConfigurationService;
    this._disposeOnNewModel = new DisposableStore();
    this._callOnDispose = new DisposableStore();
    this._onDidSelectReference = new Emitter();
    this.onDidSelectReference = this._onDidSelectReference.event;
    this._dim = new Dimension(0, 0);
    this._applyTheme(themeService.getColorTheme());
    this._callOnDispose.add(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
    this._peekViewService.addExclusiveWidget(editor2, this);
    this.create();
  }
  dispose() {
    this.setModel(void 0);
    this._callOnDispose.dispose();
    this._disposeOnNewModel.dispose();
    dispose(this._preview);
    dispose(this._previewNotAvailableMessage);
    dispose(this._tree);
    dispose(this._previewModelReference);
    this._splitView.dispose();
    super.dispose();
  }
  _applyTheme(theme) {
    const borderColor = theme.getColor(peekViewBorder) || Color.transparent;
    this.style({
      arrowColor: borderColor,
      frameColor: borderColor,
      headerBackgroundColor: theme.getColor(peekViewTitleBackground) || Color.transparent,
      primaryHeadingColor: theme.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
    });
  }
  show(where) {
    this.editor.revealRangeInCenterIfOutsideViewport(where, 0);
    super.show(where, this.layoutData.heightInLines || 18);
  }
  focusOnReferenceTree() {
    this._tree.domFocus();
  }
  focusOnPreviewEditor() {
    this._preview.focus();
  }
  isPreviewEditorFocused() {
    return this._preview.hasTextFocus();
  }
  _onTitleClick(e) {
    if (this._preview && this._preview.getModel()) {
      this._onDidSelectReference.fire({
        element: this._getFocusedReference(),
        kind: e.ctrlKey || e.metaKey || e.altKey ? "side" : "open",
        source: "title"
      });
    }
  }
  _fillBody(containerElement) {
    this.setCssClass("reference-zone-widget");
    this._messageContainer = append(containerElement, $("div.messages"));
    hide(this._messageContainer);
    this._splitView = new SplitView(containerElement, { orientation: 1 });
    this._previewContainer = append(containerElement, $("div.preview.inline"));
    let options = {
      scrollBeyondLastLine: false,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: true,
        verticalHasArrows: false,
        horizontalHasArrows: false,
        alwaysConsumeMouseWheel: false
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: true,
      minimap: {
        enabled: false
      }
    };
    this._preview = this._instantiationService.createInstance(EmbeddedCodeEditorWidget, this._previewContainer, options, this.editor);
    hide(this._previewContainer);
    this._previewNotAvailableMessage = new TextModel(localize("missingPreviewMessage", "no preview available"), TextModel.DEFAULT_CREATION_OPTIONS, null, null, this._undoRedoService, this._modeService, this._languageConfigurationService);
    this._treeContainer = append(containerElement, $("div.ref-tree.inline"));
    const treeOptions = {
      keyboardSupport: this._defaultTreeKeyboardSupport,
      accessibilityProvider: new AccessibilityProvider(),
      keyboardNavigationLabelProvider: this._instantiationService.createInstance(StringRepresentationProvider),
      identityProvider: new IdentityProvider(),
      openOnSingleClick: true,
      selectionNavigation: true,
      overrideStyles: {
        listBackground: peekViewResultsBackground
      }
    };
    if (this._defaultTreeKeyboardSupport) {
      this._callOnDispose.add(addStandardDisposableListener(this._treeContainer, "keydown", (e) => {
        if (e.equals(9)) {
          this._keybindingService.dispatchEvent(e, e.target);
          e.stopPropagation();
        }
      }, true));
    }
    this._tree = this._instantiationService.createInstance(ReferencesTree, "ReferencesWidget", this._treeContainer, new Delegate(), [
      this._instantiationService.createInstance(FileReferencesRenderer),
      this._instantiationService.createInstance(OneReferenceRenderer)
    ], this._instantiationService.createInstance(DataSource), treeOptions);
    this._splitView.addView({
      onDidChange: Event.None,
      element: this._previewContainer,
      minimumSize: 200,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        this._preview.layout({ height: this._dim.height, width });
      }
    }, Sizing.Distribute);
    this._splitView.addView({
      onDidChange: Event.None,
      element: this._treeContainer,
      minimumSize: 100,
      maximumSize: Number.MAX_VALUE,
      layout: (width) => {
        this._treeContainer.style.height = `${this._dim.height}px`;
        this._treeContainer.style.width = `${width}px`;
        this._tree.layout(this._dim.height, width);
      }
    }, Sizing.Distribute);
    this._disposables.add(this._splitView.onDidSashChange(() => {
      if (this._dim.width) {
        this.layoutData.ratio = this._splitView.getViewSize(0) / this._dim.width;
      }
    }, void 0));
    let onEvent = (element, kind) => {
      if (element instanceof OneReference) {
        if (kind === "show") {
          this._revealReference(element, false);
        }
        this._onDidSelectReference.fire({ element, kind, source: "tree" });
      }
    };
    this._tree.onDidOpen((e) => {
      if (e.sideBySide) {
        onEvent(e.element, "side");
      } else if (e.editorOptions.pinned) {
        onEvent(e.element, "goto");
      } else {
        onEvent(e.element, "show");
      }
    });
    hide(this._treeContainer);
  }
  _onWidth(width) {
    if (this._dim) {
      this._doLayoutBody(this._dim.height, width);
    }
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    super._doLayoutBody(heightInPixel, widthInPixel);
    this._dim = new Dimension(widthInPixel, heightInPixel);
    this.layoutData.heightInLines = this._viewZone ? this._viewZone.heightInLines : this.layoutData.heightInLines;
    this._splitView.layout(widthInPixel);
    this._splitView.resizeView(0, widthInPixel * this.layoutData.ratio);
  }
  setSelection(selection) {
    return this._revealReference(selection, true).then(() => {
      if (!this._model) {
        return;
      }
      this._tree.setSelection([selection]);
      this._tree.setFocus([selection]);
    });
  }
  setModel(newModel) {
    this._disposeOnNewModel.clear();
    this._model = newModel;
    if (this._model) {
      return this._onNewModel();
    }
    return Promise.resolve();
  }
  _onNewModel() {
    if (!this._model) {
      return Promise.resolve(void 0);
    }
    if (this._model.isEmpty) {
      this.setTitle("");
      this._messageContainer.innerText = localize("noResults", "No results");
      show(this._messageContainer);
      return Promise.resolve(void 0);
    }
    hide(this._messageContainer);
    this._decorationsManager = new DecorationsManager(this._preview, this._model);
    this._disposeOnNewModel.add(this._decorationsManager);
    this._disposeOnNewModel.add(this._model.onDidChangeReferenceRange((reference) => this._tree.rerender(reference)));
    this._disposeOnNewModel.add(this._preview.onMouseDown((e) => {
      const { event, target } = e;
      if (event.detail !== 2) {
        return;
      }
      const element = this._getFocusedReference();
      if (!element) {
        return;
      }
      this._onDidSelectReference.fire({
        element: { uri: element.uri, range: target.range },
        kind: event.ctrlKey || event.metaKey || event.altKey ? "side" : "open",
        source: "editor"
      });
    }));
    this.container.classList.add("results-loaded");
    show(this._treeContainer);
    show(this._previewContainer);
    this._splitView.layout(this._dim.width);
    this.focusOnReferenceTree();
    return this._tree.setInput(this._model.groups.length === 1 ? this._model.groups[0] : this._model);
  }
  _getFocusedReference() {
    const [element] = this._tree.getFocus();
    if (element instanceof OneReference) {
      return element;
    } else if (element instanceof FileReferences) {
      if (element.children.length > 0) {
        return element.children[0];
      }
    }
    return void 0;
  }
  revealReference(reference) {
    return __awaiter11(this, void 0, void 0, function* () {
      yield this._revealReference(reference, false);
      this._onDidSelectReference.fire({ element: reference, kind: "goto", source: "tree" });
    });
  }
  _revealReference(reference, revealParent) {
    return __awaiter11(this, void 0, void 0, function* () {
      if (this._revealedReference === reference) {
        return;
      }
      this._revealedReference = reference;
      if (reference.uri.scheme !== Schemas.inMemory) {
        this.setTitle(basenameOrAuthority(reference.uri), this._uriLabel.getUriLabel(dirname2(reference.uri)));
      } else {
        this.setTitle(localize("peekView.alternateTitle", "References"));
      }
      const promise = this._textModelResolverService.createModelReference(reference.uri);
      if (this._tree.getInput() === reference.parent) {
        this._tree.reveal(reference);
      } else {
        if (revealParent) {
          this._tree.reveal(reference.parent);
        }
        yield this._tree.expand(reference.parent);
        this._tree.reveal(reference);
      }
      const ref = yield promise;
      if (!this._model) {
        ref.dispose();
        return;
      }
      dispose(this._previewModelReference);
      const model = ref.object;
      if (model) {
        const scrollType = this._preview.getModel() === model.textEditorModel ? 0 : 1;
        const sel = Range.lift(reference.range).collapseToStart();
        this._previewModelReference = ref;
        this._preview.setModel(model.textEditorModel);
        this._preview.setSelection(sel);
        this._preview.revealRangeInCenter(sel, scrollType);
      } else {
        this._preview.setModel(this._previewNotAvailableMessage);
        ref.dispose();
      }
    });
  }
};
ReferenceWidget = __decorate14([
  __param14(3, IThemeService),
  __param14(4, ITextModelService),
  __param14(5, IInstantiationService),
  __param14(6, IPeekViewService),
  __param14(7, ILabelService),
  __param14(8, IUndoRedoService),
  __param14(9, IKeybindingService),
  __param14(10, IModeService),
  __param14(11, ILanguageConfigurationService)
], ReferenceWidget);

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/peek/referencesController.js
var __decorate15 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param15 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ctxReferenceSearchVisible = new RawContextKey("referenceSearchVisible", false, localize("referenceSearchVisible", "Whether reference peek is visible, like 'Peek References' or 'Peek Definition'"));
var ReferencesController = class ReferencesController2 {
  constructor(_defaultTreeKeyboardSupport, _editor, contextKeyService, _editorService, _notificationService, _instantiationService, _storageService, _configurationService) {
    this._defaultTreeKeyboardSupport = _defaultTreeKeyboardSupport;
    this._editor = _editor;
    this._editorService = _editorService;
    this._notificationService = _notificationService;
    this._instantiationService = _instantiationService;
    this._storageService = _storageService;
    this._configurationService = _configurationService;
    this._disposables = new DisposableStore();
    this._requestIdPool = 0;
    this._ignoreModelChangeEvent = false;
    this._referenceSearchVisible = ctxReferenceSearchVisible.bindTo(contextKeyService);
  }
  static get(editor2) {
    return editor2.getContribution(ReferencesController2.ID);
  }
  dispose() {
    var _a5, _b2;
    this._referenceSearchVisible.reset();
    this._disposables.dispose();
    (_a5 = this._widget) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    (_b2 = this._model) === null || _b2 === void 0 ? void 0 : _b2.dispose();
    this._widget = void 0;
    this._model = void 0;
  }
  toggleWidget(range, modelPromise, peekMode) {
    let widgetPosition;
    if (this._widget) {
      widgetPosition = this._widget.position;
    }
    this.closeWidget();
    if (!!widgetPosition && range.containsPosition(widgetPosition)) {
      return;
    }
    this._peekMode = peekMode;
    this._referenceSearchVisible.set(true);
    this._disposables.add(this._editor.onDidChangeModelLanguage(() => {
      this.closeWidget();
    }));
    this._disposables.add(this._editor.onDidChangeModel(() => {
      if (!this._ignoreModelChangeEvent) {
        this.closeWidget();
      }
    }));
    const storageKey = "peekViewLayout";
    const data = LayoutData.fromJSON(this._storageService.get(storageKey, 0, "{}"));
    this._widget = this._instantiationService.createInstance(ReferenceWidget, this._editor, this._defaultTreeKeyboardSupport, data);
    this._widget.setTitle(localize("labelLoading", "Loading..."));
    this._widget.show(range);
    this._disposables.add(this._widget.onDidClose(() => {
      modelPromise.cancel();
      if (this._widget) {
        this._storageService.store(storageKey, JSON.stringify(this._widget.layoutData), 0, 1);
        this._widget = void 0;
      }
      this.closeWidget();
    }));
    this._disposables.add(this._widget.onDidSelectReference((event) => {
      let { element, kind } = event;
      if (!element) {
        return;
      }
      switch (kind) {
        case "open":
          if (event.source !== "editor" || !this._configurationService.getValue("editor.stablePeek")) {
            this.openReference(element, false, false);
          }
          break;
        case "side":
          this.openReference(element, true, false);
          break;
        case "goto":
          if (peekMode) {
            this._gotoReference(element);
          } else {
            this.openReference(element, false, true);
          }
          break;
      }
    }));
    const requestId = ++this._requestIdPool;
    modelPromise.then((model) => {
      var _a5;
      if (requestId !== this._requestIdPool || !this._widget) {
        model.dispose();
        return void 0;
      }
      (_a5 = this._model) === null || _a5 === void 0 ? void 0 : _a5.dispose();
      this._model = model;
      return this._widget.setModel(this._model).then(() => {
        if (this._widget && this._model && this._editor.hasModel()) {
          if (!this._model.isEmpty) {
            this._widget.setMetaTitle(localize("metaTitle.N", "{0} ({1})", this._model.title, this._model.references.length));
          } else {
            this._widget.setMetaTitle("");
          }
          let uri = this._editor.getModel().uri;
          let pos = new Position(range.startLineNumber, range.startColumn);
          let selection = this._model.nearestReference(uri, pos);
          if (selection) {
            return this._widget.setSelection(selection).then(() => {
              if (this._widget && this._editor.getOption(76) === "editor") {
                this._widget.focusOnPreviewEditor();
              }
            });
          }
        }
        return void 0;
      });
    }, (error) => {
      this._notificationService.error(error);
    });
  }
  changeFocusBetweenPreviewAndReferences() {
    if (!this._widget) {
      return;
    }
    if (this._widget.isPreviewEditorFocused()) {
      this._widget.focusOnReferenceTree();
    } else {
      this._widget.focusOnPreviewEditor();
    }
  }
  goToNextOrPreviousReference(fwd) {
    return __awaiter12(this, void 0, void 0, function* () {
      if (!this._editor.hasModel() || !this._model || !this._widget) {
        return;
      }
      const currentPosition = this._widget.position;
      if (!currentPosition) {
        return;
      }
      const source = this._model.nearestReference(this._editor.getModel().uri, currentPosition);
      if (!source) {
        return;
      }
      const target = this._model.nextOrPreviousReference(source, fwd);
      const editorFocus = this._editor.hasTextFocus();
      const previewEditorFocus = this._widget.isPreviewEditorFocused();
      yield this._widget.setSelection(target);
      yield this._gotoReference(target);
      if (editorFocus) {
        this._editor.focus();
      } else if (this._widget && previewEditorFocus) {
        this._widget.focusOnPreviewEditor();
      }
    });
  }
  revealReference(reference) {
    return __awaiter12(this, void 0, void 0, function* () {
      if (!this._editor.hasModel() || !this._model || !this._widget) {
        return;
      }
      yield this._widget.revealReference(reference);
    });
  }
  closeWidget(focusEditor = true) {
    var _a5, _b2;
    (_a5 = this._widget) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    (_b2 = this._model) === null || _b2 === void 0 ? void 0 : _b2.dispose();
    this._referenceSearchVisible.reset();
    this._disposables.clear();
    this._widget = void 0;
    this._model = void 0;
    if (focusEditor) {
      this._editor.focus();
    }
    this._requestIdPool += 1;
  }
  _gotoReference(ref) {
    if (this._widget) {
      this._widget.hide();
    }
    this._ignoreModelChangeEvent = true;
    const range = Range.lift(ref.range).collapseToStart();
    return this._editorService.openCodeEditor({
      resource: ref.uri,
      options: { selection: range }
    }, this._editor).then((openedEditor) => {
      var _a5;
      this._ignoreModelChangeEvent = false;
      if (!openedEditor || !this._widget) {
        this.closeWidget();
        return;
      }
      if (this._editor === openedEditor) {
        this._widget.show(range);
        this._widget.focusOnReferenceTree();
      } else {
        const other = ReferencesController2.get(openedEditor);
        const model = this._model.clone();
        this.closeWidget();
        openedEditor.focus();
        other.toggleWidget(range, createCancelablePromise((_) => Promise.resolve(model)), (_a5 = this._peekMode) !== null && _a5 !== void 0 ? _a5 : false);
      }
    }, (err) => {
      this._ignoreModelChangeEvent = false;
      onUnexpectedError(err);
    });
  }
  openReference(ref, sideBySide, pinned) {
    if (!sideBySide) {
      this.closeWidget();
    }
    const { uri, range } = ref;
    this._editorService.openCodeEditor({
      resource: uri,
      options: { selection: range, pinned }
    }, this._editor, sideBySide);
  }
};
ReferencesController.ID = "editor.contrib.referencesController";
ReferencesController = __decorate15([
  __param15(2, IContextKeyService),
  __param15(3, ICodeEditorService),
  __param15(4, INotificationService),
  __param15(5, IInstantiationService),
  __param15(6, IStorageService),
  __param15(7, IConfigurationService)
], ReferencesController);
function withController(accessor, fn) {
  const outerEditor = getOuterEditor(accessor);
  if (!outerEditor) {
    return;
  }
  let controller = ReferencesController.get(outerEditor);
  if (controller) {
    fn(controller);
  }
}
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "togglePeekWidgetFocus",
  weight: 100,
  primary: KeyChord(2048 | 41, 60),
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.changeFocusBetweenPreviewAndReferences();
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "goToNextReference",
  weight: 100 - 10,
  primary: 62,
  secondary: [70],
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.goToNextOrPreviousReference(true);
    });
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "goToPreviousReference",
  weight: 100 - 10,
  primary: 1024 | 62,
  secondary: [1024 | 70],
  when: ContextKeyExpr.or(ctxReferenceSearchVisible, PeekContext.inPeekEditor),
  handler(accessor) {
    withController(accessor, (controller) => {
      controller.goToNextOrPreviousReference(false);
    });
  }
});
CommandsRegistry.registerCommandAlias("goToNextReferenceFromEmbeddedEditor", "goToNextReference");
CommandsRegistry.registerCommandAlias("goToPreviousReferenceFromEmbeddedEditor", "goToPreviousReference");
CommandsRegistry.registerCommandAlias("closeReferenceSearchEditor", "closeReferenceSearch");
CommandsRegistry.registerCommand("closeReferenceSearch", (accessor) => withController(accessor, (controller) => controller.closeWidget()));
KeybindingsRegistry.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 100 - 101,
  primary: 9,
  secondary: [1024 | 9],
  when: ContextKeyExpr.and(PeekContext.inPeekEditor, ContextKeyExpr.not("config.editor.stablePeek"))
});
KeybindingsRegistry.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 200 + 50,
  primary: 9,
  secondary: [1024 | 9],
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, ContextKeyExpr.not("config.editor.stablePeek"))
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "revealReference",
  weight: 200,
  primary: 3,
  mac: {
    primary: 3,
    secondary: [2048 | 18]
  },
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey),
  handler(accessor) {
    var _a5;
    const listService = accessor.get(IListService);
    const focus = (_a5 = listService.lastFocusedList) === null || _a5 === void 0 ? void 0 : _a5.getFocus();
    if (Array.isArray(focus) && focus[0] instanceof OneReference) {
      withController(accessor, (controller) => controller.revealReference(focus[0]));
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "openReferenceToSide",
  weight: 100,
  primary: 2048 | 3,
  mac: {
    primary: 256 | 3
  },
  when: ContextKeyExpr.and(ctxReferenceSearchVisible, WorkbenchListFocusContextKey),
  handler(accessor) {
    var _a5;
    const listService = accessor.get(IListService);
    const focus = (_a5 = listService.lastFocusedList) === null || _a5 === void 0 ? void 0 : _a5.getFocus();
    if (Array.isArray(focus) && focus[0] instanceof OneReference) {
      withController(accessor, (controller) => controller.openReference(focus[0], true, true));
    }
  }
});
CommandsRegistry.registerCommand("openReference", (accessor) => {
  var _a5;
  const listService = accessor.get(IListService);
  const focus = (_a5 = listService.lastFocusedList) === null || _a5 === void 0 ? void 0 : _a5.getFocus();
  if (Array.isArray(focus) && focus[0] instanceof OneReference) {
    withController(accessor, (controller) => controller.openReference(focus[0], false, true));
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/symbolNavigation.js
var __decorate16 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param16 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ctxHasSymbols = new RawContextKey("hasSymbols", false, localize("hasSymbols", "Whether there are symbol locations that can be navigated via keyboard-only."));
var ISymbolNavigationService = createDecorator("ISymbolNavigationService");
var SymbolNavigationService = class SymbolNavigationService2 {
  constructor(contextKeyService, _editorService, _notificationService, _keybindingService) {
    this._editorService = _editorService;
    this._notificationService = _notificationService;
    this._keybindingService = _keybindingService;
    this._currentModel = void 0;
    this._currentIdx = -1;
    this._ignoreEditorChange = false;
    this._ctxHasSymbols = ctxHasSymbols.bindTo(contextKeyService);
  }
  reset() {
    var _a5, _b2;
    this._ctxHasSymbols.reset();
    (_a5 = this._currentState) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    (_b2 = this._currentMessage) === null || _b2 === void 0 ? void 0 : _b2.dispose();
    this._currentModel = void 0;
    this._currentIdx = -1;
  }
  put(anchor) {
    const refModel = anchor.parent.parent;
    if (refModel.references.length <= 1) {
      this.reset();
      return;
    }
    this._currentModel = refModel;
    this._currentIdx = refModel.references.indexOf(anchor);
    this._ctxHasSymbols.set(true);
    this._showMessage();
    const editorState = new EditorState2(this._editorService);
    const listener = editorState.onDidChange((_) => {
      if (this._ignoreEditorChange) {
        return;
      }
      const editor2 = this._editorService.getActiveCodeEditor();
      if (!editor2) {
        return;
      }
      const model = editor2.getModel();
      const position = editor2.getPosition();
      if (!model || !position) {
        return;
      }
      let seenUri = false;
      let seenPosition = false;
      for (const reference of refModel.references) {
        if (isEqual(reference.uri, model.uri)) {
          seenUri = true;
          seenPosition = seenPosition || Range.containsPosition(reference.range, position);
        } else if (seenUri) {
          break;
        }
      }
      if (!seenUri || !seenPosition) {
        this.reset();
      }
    });
    this._currentState = combinedDisposable(editorState, listener);
  }
  revealNext(source) {
    if (!this._currentModel) {
      return Promise.resolve();
    }
    this._currentIdx += 1;
    this._currentIdx %= this._currentModel.references.length;
    const reference = this._currentModel.references[this._currentIdx];
    this._showMessage();
    this._ignoreEditorChange = true;
    return this._editorService.openCodeEditor({
      resource: reference.uri,
      options: {
        selection: Range.collapseToStart(reference.range),
        selectionRevealType: 3
      }
    }, source).finally(() => {
      this._ignoreEditorChange = false;
    });
  }
  _showMessage() {
    var _a5;
    (_a5 = this._currentMessage) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    const kb = this._keybindingService.lookupKeybinding("editor.gotoNextSymbolFromResult");
    const message = kb ? localize("location.kb", "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, kb.getLabel()) : localize("location", "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
    this._currentMessage = this._notificationService.status(message);
  }
};
SymbolNavigationService = __decorate16([
  __param16(0, IContextKeyService),
  __param16(1, ICodeEditorService),
  __param16(2, INotificationService),
  __param16(3, IKeybindingService)
], SymbolNavigationService);
registerSingleton(ISymbolNavigationService, SymbolNavigationService, true);
registerEditorCommand(new class extends EditorCommand {
  constructor() {
    super({
      id: "editor.gotoNextSymbolFromResult",
      precondition: ctxHasSymbols,
      kbOpts: {
        weight: 100,
        primary: 70
      }
    });
  }
  runEditorCommand(accessor, editor2) {
    return accessor.get(ISymbolNavigationService).revealNext(editor2);
  }
}());
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "editor.gotoNextSymbolFromResult.cancel",
  weight: 100,
  when: ctxHasSymbols,
  primary: 9,
  handler(accessor) {
    accessor.get(ISymbolNavigationService).reset();
  }
});
var EditorState2 = class EditorState3 {
  constructor(editorService) {
    this._listener = new Map();
    this._disposables = new DisposableStore();
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._disposables.add(editorService.onCodeEditorRemove(this._onDidRemoveEditor, this));
    this._disposables.add(editorService.onCodeEditorAdd(this._onDidAddEditor, this));
    editorService.listCodeEditors().forEach(this._onDidAddEditor, this);
  }
  dispose() {
    this._disposables.dispose();
    this._onDidChange.dispose();
    dispose(this._listener.values());
  }
  _onDidAddEditor(editor2) {
    this._listener.set(editor2, combinedDisposable(editor2.onDidChangeCursorPosition((_) => this._onDidChange.fire({ editor: editor2 })), editor2.onDidChangeModelContent((_) => this._onDidChange.fire({ editor: editor2 }))));
  }
  _onDidRemoveEditor(editor2) {
    var _a5;
    (_a5 = this._listener.get(editor2)) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    this._listener.delete(editor2);
  }
};
EditorState2 = __decorate16([
  __param16(0, ICodeEditorService)
], EditorState2);

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/goToSymbol.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getLocationLinks(model, position, registry, provide) {
  const provider = registry.ordered(model);
  const promises = provider.map((provider2) => {
    return Promise.resolve(provide(provider2, model, position)).then(void 0, (err) => {
      onUnexpectedExternalError(err);
      return void 0;
    });
  });
  return Promise.all(promises).then((values) => {
    const result = [];
    for (let value of values) {
      if (Array.isArray(value)) {
        result.push(...value);
      } else if (value) {
        result.push(value);
      }
    }
    return result;
  });
}
function getDefinitionsAtPosition(model, position, token) {
  return getLocationLinks(model, position, DefinitionProviderRegistry, (provider, model2, position2) => {
    return provider.provideDefinition(model2, position2, token);
  });
}
function getDeclarationsAtPosition(model, position, token) {
  return getLocationLinks(model, position, DeclarationProviderRegistry, (provider, model2, position2) => {
    return provider.provideDeclaration(model2, position2, token);
  });
}
function getImplementationsAtPosition(model, position, token) {
  return getLocationLinks(model, position, ImplementationProviderRegistry, (provider, model2, position2) => {
    return provider.provideImplementation(model2, position2, token);
  });
}
function getTypeDefinitionsAtPosition(model, position, token) {
  return getLocationLinks(model, position, TypeDefinitionProviderRegistry, (provider, model2, position2) => {
    return provider.provideTypeDefinition(model2, position2, token);
  });
}
function getReferencesAtPosition(model, position, compact, token) {
  return getLocationLinks(model, position, ReferenceProviderRegistry, (provider, model2, position2) => __awaiter13(this, void 0, void 0, function* () {
    const result = yield provider.provideReferences(model2, position2, { includeDeclaration: true }, token);
    if (!compact || !result || result.length !== 2) {
      return result;
    }
    const resultWithoutDeclaration = yield provider.provideReferences(model2, position2, { includeDeclaration: false }, token);
    if (resultWithoutDeclaration && resultWithoutDeclaration.length === 1) {
      return resultWithoutDeclaration;
    }
    return result;
  }));
}
function _sortedAndDeduped(callback) {
  return __awaiter13(this, void 0, void 0, function* () {
    const rawLinks = yield callback();
    const model = new ReferencesModel(rawLinks, "");
    const modelLinks = model.references.map((ref) => ref.link);
    model.dispose();
    return modelLinks;
  });
}
registerModelAndPositionCommand("_executeDefinitionProvider", (model, position) => _sortedAndDeduped(() => getDefinitionsAtPosition(model, position, CancellationToken.None)));
registerModelAndPositionCommand("_executeDeclarationProvider", (model, position) => _sortedAndDeduped(() => getDeclarationsAtPosition(model, position, CancellationToken.None)));
registerModelAndPositionCommand("_executeImplementationProvider", (model, position) => _sortedAndDeduped(() => getImplementationsAtPosition(model, position, CancellationToken.None)));
registerModelAndPositionCommand("_executeTypeDefinitionProvider", (model, position) => _sortedAndDeduped(() => getTypeDefinitionsAtPosition(model, position, CancellationToken.None)));
registerModelAndPositionCommand("_executeReferenceProvider", (model, position) => _sortedAndDeduped(() => getReferencesAtPosition(model, position, false, CancellationToken.None)));

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/goToCommands.js
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a;
var _b;
var _c;
var _d;
var _e;
var _f;
var _g;
var _h;
MenuRegistry.appendMenuItem(MenuId.EditorContext, {
  submenu: MenuId.EditorContextPeek,
  title: localize("peek.submenu", "Peek"),
  group: "navigation",
  order: 100
});
var _goToActionIds = new Set();
function registerGoToAction(ctor) {
  const result = new ctor();
  registerInstantiatedEditorAction(result);
  _goToActionIds.add(result.id);
  return result;
}
var SymbolNavigationAction = class extends EditorAction {
  constructor(configuration, opts) {
    super(opts);
    this._configuration = configuration;
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return Promise.resolve(void 0);
    }
    const notificationService = accessor.get(INotificationService);
    const editorService = accessor.get(ICodeEditorService);
    const progressService = accessor.get(IEditorProgressService);
    const symbolNavService = accessor.get(ISymbolNavigationService);
    const model = editor2.getModel();
    const pos = editor2.getPosition();
    const cts = new EditorStateCancellationTokenSource(editor2, 1 | 4);
    const promise = raceCancellation(this._getLocationModel(model, pos, cts.token), cts.token).then((references) => __awaiter14(this, void 0, void 0, function* () {
      if (!references || cts.token.isCancellationRequested) {
        return;
      }
      alert(references.ariaMessage);
      let altAction;
      if (references.referenceAt(model.uri, pos)) {
        const altActionId = this._getAlternativeCommand(editor2);
        if (altActionId !== this.id && _goToActionIds.has(altActionId)) {
          altAction = editor2.getAction(altActionId);
        }
      }
      const referenceCount = references.references.length;
      if (referenceCount === 0) {
        if (!this._configuration.muteMessage) {
          const info = model.getWordAtPosition(pos);
          MessageController.get(editor2).showMessage(this._getNoResultFoundMessage(info), pos);
        }
      } else if (referenceCount === 1 && altAction) {
        altAction.run();
      } else {
        return this._onResult(editorService, symbolNavService, editor2, references);
      }
    }), (err) => {
      notificationService.error(err);
    }).finally(() => {
      cts.dispose();
    });
    progressService.showWhile(promise, 250);
    return promise;
  }
  _onResult(editorService, symbolNavService, editor2, model) {
    return __awaiter14(this, void 0, void 0, function* () {
      const gotoLocation = this._getGoToPreference(editor2);
      if (!(editor2 instanceof EmbeddedCodeEditorWidget) && (this._configuration.openInPeek || gotoLocation === "peek" && model.references.length > 1)) {
        this._openInPeek(editor2, model);
      } else {
        const next = model.firstReference();
        const peek = model.references.length > 1 && gotoLocation === "gotoAndPeek";
        const targetEditor = yield this._openReference(editor2, editorService, next, this._configuration.openToSide, !peek);
        if (peek && targetEditor) {
          this._openInPeek(targetEditor, model);
        } else {
          model.dispose();
        }
        if (gotoLocation === "goto") {
          symbolNavService.put(next);
        }
      }
    });
  }
  _openReference(editor2, editorService, reference, sideBySide, highlight) {
    return __awaiter14(this, void 0, void 0, function* () {
      let range = void 0;
      if (isLocationLink(reference)) {
        range = reference.targetSelectionRange;
      }
      if (!range) {
        range = reference.range;
      }
      if (!range) {
        return void 0;
      }
      const targetEditor = yield editorService.openCodeEditor({
        resource: reference.uri,
        options: {
          selection: Range.collapseToStart(range),
          selectionRevealType: 3
        }
      }, editor2, sideBySide);
      if (!targetEditor) {
        return void 0;
      }
      if (highlight) {
        const modelNow = targetEditor.getModel();
        const ids = targetEditor.deltaDecorations([], [{ range, options: { description: "symbol-navigate-action-highlight", className: "symbolHighlight" } }]);
        setTimeout(() => {
          if (targetEditor.getModel() === modelNow) {
            targetEditor.deltaDecorations(ids, []);
          }
        }, 350);
      }
      return targetEditor;
    });
  }
  _openInPeek(target, model) {
    let controller = ReferencesController.get(target);
    if (controller && target.hasModel()) {
      controller.toggleWidget(target.getSelection(), createCancelablePromise((_) => Promise.resolve(model)), this._configuration.openInPeek);
    } else {
      model.dispose();
    }
  }
};
var DefinitionAction = class extends SymbolNavigationAction {
  _getLocationModel(model, position, token) {
    return __awaiter14(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getDefinitionsAtPosition(model, position, token), localize("def.title", "Definitions"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("noResultWord", "No definition found for '{0}'", info.word) : localize("generic.noResults", "No definition found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(50).alternativeDefinitionCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(50).multipleDefinitions;
  }
};
var goToDefinitionKb = isWeb && !isStandalone ? 2048 | 70 : 70;
registerGoToAction((_a = class GoToDefinitionAction extends DefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToDefinitionAction.id,
      label: localize("actions.goToDecl.label", "Go to Definition"),
      alias: "Go to Definition",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: goToDefinitionKb,
        weight: 100
      },
      contextMenuOpts: {
        group: "navigation",
        order: 1.1
      }
    });
    CommandsRegistry.registerCommandAlias("editor.action.goToDeclaration", GoToDefinitionAction.id);
  }
}, _a.id = "editor.action.revealDefinition", _a));
registerGoToAction((_b = class OpenDefinitionToSideAction extends DefinitionAction {
  constructor() {
    super({
      openToSide: true,
      openInPeek: false,
      muteMessage: false
    }, {
      id: OpenDefinitionToSideAction.id,
      label: localize("actions.goToDeclToSide.label", "Open Definition to the Side"),
      alias: "Open Definition to the Side",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, goToDefinitionKb),
        weight: 100
      }
    });
    CommandsRegistry.registerCommandAlias("editor.action.openDeclarationToTheSide", OpenDefinitionToSideAction.id);
  }
}, _b.id = "editor.action.revealDefinitionAside", _b));
registerGoToAction((_c = class PeekDefinitionAction extends DefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: PeekDefinitionAction.id,
      label: localize("actions.previewDecl.label", "Peek Definition"),
      alias: "Peek Definition",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 70,
        linux: { primary: 2048 | 1024 | 68 },
        weight: 100
      },
      contextMenuOpts: {
        menuId: MenuId.EditorContextPeek,
        group: "peek",
        order: 2
      }
    });
    CommandsRegistry.registerCommandAlias("editor.action.previewDeclaration", PeekDefinitionAction.id);
  }
}, _c.id = "editor.action.peekDefinition", _c));
var DeclarationAction = class extends SymbolNavigationAction {
  _getLocationModel(model, position, token) {
    return __awaiter14(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getDeclarationsAtPosition(model, position, token), localize("decl.title", "Declarations"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("decl.noResultWord", "No declaration found for '{0}'", info.word) : localize("decl.generic.noResults", "No declaration found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(50).alternativeDeclarationCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(50).multipleDeclarations;
  }
};
registerGoToAction((_d = class GoToDeclarationAction extends DeclarationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToDeclarationAction.id,
      label: localize("actions.goToDeclaration.label", "Go to Declaration"),
      alias: "Go to Declaration",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      contextMenuOpts: {
        group: "navigation",
        order: 1.3
      }
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("decl.noResultWord", "No declaration found for '{0}'", info.word) : localize("decl.generic.noResults", "No declaration found");
  }
}, _d.id = "editor.action.revealDeclaration", _d));
registerGoToAction(class PeekDeclarationAction extends DeclarationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: "editor.action.peekDeclaration",
      label: localize("actions.peekDecl.label", "Peek Declaration"),
      alias: "Peek Declaration",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasDeclarationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      contextMenuOpts: {
        menuId: MenuId.EditorContextPeek,
        group: "peek",
        order: 3
      }
    });
  }
});
var TypeDefinitionAction = class extends SymbolNavigationAction {
  _getLocationModel(model, position, token) {
    return __awaiter14(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getTypeDefinitionsAtPosition(model, position, token), localize("typedef.title", "Type Definitions"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("goToTypeDefinition.noResultWord", "No type definition found for '{0}'", info.word) : localize("goToTypeDefinition.generic.noResults", "No type definition found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(50).alternativeTypeDefinitionCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(50).multipleTypeDefinitions;
  }
};
registerGoToAction((_e = class GoToTypeDefinitionAction extends TypeDefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToTypeDefinitionAction.ID,
      label: localize("actions.goToTypeDefinition.label", "Go to Type Definition"),
      alias: "Go to Type Definition",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        weight: 100
      },
      contextMenuOpts: {
        group: "navigation",
        order: 1.4
      }
    });
  }
}, _e.ID = "editor.action.goToTypeDefinition", _e));
registerGoToAction((_f = class PeekTypeDefinitionAction extends TypeDefinitionAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: PeekTypeDefinitionAction.ID,
      label: localize("actions.peekTypeDefinition.label", "Peek Type Definition"),
      alias: "Peek Type Definition",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasTypeDefinitionProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      contextMenuOpts: {
        menuId: MenuId.EditorContextPeek,
        group: "peek",
        order: 4
      }
    });
  }
}, _f.ID = "editor.action.peekTypeDefinition", _f));
var ImplementationAction = class extends SymbolNavigationAction {
  _getLocationModel(model, position, token) {
    return __awaiter14(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getImplementationsAtPosition(model, position, token), localize("impl.title", "Implementations"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && info.word ? localize("goToImplementation.noResultWord", "No implementation found for '{0}'", info.word) : localize("goToImplementation.generic.noResults", "No implementation found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(50).alternativeImplementationCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(50).multipleImplementations;
  }
};
registerGoToAction((_g = class GoToImplementationAction extends ImplementationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: GoToImplementationAction.ID,
      label: localize("actions.goToImplementation.label", "Go to Implementations"),
      alias: "Go to Implementations",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 70,
        weight: 100
      },
      contextMenuOpts: {
        group: "navigation",
        order: 1.45
      }
    });
  }
}, _g.ID = "editor.action.goToImplementation", _g));
registerGoToAction((_h = class PeekImplementationAction extends ImplementationAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: PeekImplementationAction.ID,
      label: localize("actions.peekImplementation.label", "Peek Implementations"),
      alias: "Peek Implementations",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasImplementationProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 70,
        weight: 100
      },
      contextMenuOpts: {
        menuId: MenuId.EditorContextPeek,
        group: "peek",
        order: 5
      }
    });
  }
}, _h.ID = "editor.action.peekImplementation", _h));
var ReferencesAction = class extends SymbolNavigationAction {
  _getNoResultFoundMessage(info) {
    return info ? localize("references.no", "No references found for '{0}'", info.word) : localize("references.noGeneric", "No references found");
  }
  _getAlternativeCommand(editor2) {
    return editor2.getOption(50).alternativeReferenceCommand;
  }
  _getGoToPreference(editor2) {
    return editor2.getOption(50).multipleReferences;
  }
};
registerGoToAction(class GoToReferencesAction extends ReferencesAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: false,
      muteMessage: false
    }, {
      id: "editor.action.goToReferences",
      label: localize("goToReferences.label", "Go to References"),
      alias: "Go to References",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 70,
        weight: 100
      },
      contextMenuOpts: {
        group: "navigation",
        order: 1.45
      }
    });
  }
  _getLocationModel(model, position, token) {
    return __awaiter14(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getReferencesAtPosition(model, position, true, token), localize("ref.title", "References"));
    });
  }
});
registerGoToAction(class PeekReferencesAction extends ReferencesAction {
  constructor() {
    super({
      openToSide: false,
      openInPeek: true,
      muteMessage: false
    }, {
      id: "editor.action.referenceSearch.trigger",
      label: localize("references.action.label", "Peek References"),
      alias: "Peek References",
      precondition: ContextKeyExpr.and(EditorContextKeys.hasReferenceProvider, PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated()),
      contextMenuOpts: {
        menuId: MenuId.EditorContextPeek,
        group: "peek",
        order: 6
      }
    });
  }
  _getLocationModel(model, position, token) {
    return __awaiter14(this, void 0, void 0, function* () {
      return new ReferencesModel(yield getReferencesAtPosition(model, position, false, token), localize("ref.title", "References"));
    });
  }
});
var GenericGoToLocationAction = class extends SymbolNavigationAction {
  constructor(config, _references, _gotoMultipleBehaviour) {
    super(config, {
      id: "editor.action.goToLocation",
      label: localize("label.generic", "Go to Any Symbol"),
      alias: "Go to Any Symbol",
      precondition: ContextKeyExpr.and(PeekContext.notInPeekEditor, EditorContextKeys.isInWalkThroughSnippet.toNegated())
    });
    this._references = _references;
    this._gotoMultipleBehaviour = _gotoMultipleBehaviour;
  }
  _getLocationModel(_model, _position, _token) {
    return __awaiter14(this, void 0, void 0, function* () {
      return new ReferencesModel(this._references, localize("generic.title", "Locations"));
    });
  }
  _getNoResultFoundMessage(info) {
    return info && localize("generic.noResult", "No results for '{0}'", info.word) || "";
  }
  _getGoToPreference(editor2) {
    var _a5;
    return (_a5 = this._gotoMultipleBehaviour) !== null && _a5 !== void 0 ? _a5 : editor2.getOption(50).multipleReferences;
  }
  _getAlternativeCommand() {
    return "";
  }
};
CommandsRegistry.registerCommand({
  id: "editor.action.goToLocations",
  description: {
    description: "Go to locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: URI },
      { name: "position", description: "The position at which to start", constraint: Position.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto" },
      { name: "noResultsMessage", description: "Human readable message that shows when locations is empty." }
    ]
  },
  handler: (accessor, resource, position, references, multiple, noResultsMessage, openInPeek) => __awaiter14(void 0, void 0, void 0, function* () {
    assertType(URI.isUri(resource));
    assertType(Position.isIPosition(position));
    assertType(Array.isArray(references));
    assertType(typeof multiple === "undefined" || typeof multiple === "string");
    assertType(typeof openInPeek === "undefined" || typeof openInPeek === "boolean");
    const editorService = accessor.get(ICodeEditorService);
    const editor2 = yield editorService.openCodeEditor({ resource }, editorService.getFocusedCodeEditor());
    if (isCodeEditor(editor2)) {
      editor2.setPosition(position);
      editor2.revealPositionInCenterIfOutsideViewport(position, 0);
      return editor2.invokeWithinContext((accessor2) => {
        const command = new class extends GenericGoToLocationAction {
          _getNoResultFoundMessage(info) {
            return noResultsMessage || super._getNoResultFoundMessage(info);
          }
        }({
          muteMessage: !Boolean(noResultsMessage),
          openInPeek: Boolean(openInPeek),
          openToSide: false
        }, references, multiple);
        accessor2.get(IInstantiationService).invokeFunction(command.run.bind(command), editor2);
      });
    }
  })
});
CommandsRegistry.registerCommand({
  id: "editor.action.peekLocations",
  description: {
    description: "Peek locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: URI },
      { name: "position", description: "The position at which to start", constraint: Position.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto" }
    ]
  },
  handler: (accessor, resource, position, references, multiple) => __awaiter14(void 0, void 0, void 0, function* () {
    accessor.get(ICommandService).executeCommand("editor.action.goToLocations", resource, position, references, multiple, void 0, true);
  })
});
CommandsRegistry.registerCommand({
  id: "editor.action.findReferences",
  handler: (accessor, resource, position) => {
    assertType(URI.isUri(resource));
    assertType(Position.isIPosition(position));
    const codeEditorService = accessor.get(ICodeEditorService);
    return codeEditorService.openCodeEditor({ resource }, codeEditorService.getFocusedCodeEditor()).then((control) => {
      if (!isCodeEditor(control) || !control.hasModel()) {
        return void 0;
      }
      const controller = ReferencesController.get(control);
      if (!controller) {
        return void 0;
      }
      const references = createCancelablePromise((token) => getReferencesAtPosition(control.getModel(), Position.lift(position), false, token).then((references2) => new ReferencesModel(references2, localize("ref.title", "References"))));
      const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
      return Promise.resolve(controller.toggleWidget(range, references, false));
    });
  }
});
CommandsRegistry.registerCommandAlias("editor.action.showReferences", "editor.action.peekLocations");
MenuRegistry.appendMenuItems([
  {
    id: MenuId.MenubarGoMenu,
    item: {
      command: {
        id: "editor.action.revealDefinition",
        title: localize({ key: "miGotoDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Definition")
      },
      group: "4_symbol_nav",
      order: 2
    }
  },
  {
    id: MenuId.MenubarGoMenu,
    item: {
      command: {
        id: "editor.action.revealDeclaration",
        title: localize({ key: "miGotoDeclaration", comment: ["&& denotes a mnemonic"] }, "Go to &&Declaration")
      },
      group: "4_symbol_nav",
      order: 3
    }
  },
  {
    id: MenuId.MenubarGoMenu,
    item: {
      command: {
        id: "editor.action.goToTypeDefinition",
        title: localize({ key: "miGotoTypeDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Type Definition")
      },
      group: "4_symbol_nav",
      order: 3
    }
  },
  {
    id: MenuId.MenubarGoMenu,
    item: {
      command: {
        id: "editor.action.goToImplementation",
        title: localize({ key: "miGotoImplementation", comment: ["&& denotes a mnemonic"] }, "Go to &&Implementations")
      },
      group: "4_symbol_nav",
      order: 4
    }
  },
  {
    id: MenuId.MenubarGoMenu,
    item: {
      command: {
        id: "editor.action.goToReferences",
        title: localize({ key: "miGotoReference", comment: ["&& denotes a mnemonic"] }, "Go to &&References")
      },
      group: "4_symbol_nav",
      order: 5
    }
  }
]);

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoSymbol/link/goToDefinitionAtPosition.js
var __decorate17 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param17 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var GotoDefinitionAtPositionEditorContribution = class GotoDefinitionAtPositionEditorContribution2 {
  constructor(editor2, textModelResolverService, modeService) {
    this.textModelResolverService = textModelResolverService;
    this.modeService = modeService;
    this.toUnhook = new DisposableStore();
    this.toUnhookForKeyboard = new DisposableStore();
    this.linkDecorations = [];
    this.currentWordAtPosition = null;
    this.previousPromise = null;
    this.editor = editor2;
    let linkGesture = new ClickLinkGesture(editor2);
    this.toUnhook.add(linkGesture);
    this.toUnhook.add(linkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
      this.startFindDefinitionFromMouse(mouseEvent, withNullAsUndefined(keyboardEvent));
    }));
    this.toUnhook.add(linkGesture.onExecute((mouseEvent) => {
      if (this.isEnabled(mouseEvent)) {
        this.gotoDefinition(mouseEvent.target.position, mouseEvent.hasSideBySideModifier).then(() => {
          this.removeLinkDecorations();
        }, (error) => {
          this.removeLinkDecorations();
          onUnexpectedError(error);
        });
      }
    }));
    this.toUnhook.add(linkGesture.onCancel(() => {
      this.removeLinkDecorations();
      this.currentWordAtPosition = null;
    }));
  }
  static get(editor2) {
    return editor2.getContribution(GotoDefinitionAtPositionEditorContribution2.ID);
  }
  startFindDefinitionFromCursor(position) {
    return this.startFindDefinition(position).then(() => {
      this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
        this.currentWordAtPosition = null;
        this.removeLinkDecorations();
        this.toUnhookForKeyboard.clear();
      }));
      this.toUnhookForKeyboard.add(this.editor.onKeyDown((e) => {
        if (e) {
          this.currentWordAtPosition = null;
          this.removeLinkDecorations();
          this.toUnhookForKeyboard.clear();
        }
      }));
    });
  }
  startFindDefinitionFromMouse(mouseEvent, withKey) {
    if (mouseEvent.target.type === 9 && this.linkDecorations.length > 0) {
      return;
    }
    if (!this.editor.hasModel() || !this.isEnabled(mouseEvent, withKey)) {
      this.currentWordAtPosition = null;
      this.removeLinkDecorations();
      return;
    }
    const position = mouseEvent.target.position;
    this.startFindDefinition(position);
  }
  startFindDefinition(position) {
    var _a5;
    this.toUnhookForKeyboard.clear();
    const word = position ? (_a5 = this.editor.getModel()) === null || _a5 === void 0 ? void 0 : _a5.getWordAtPosition(position) : null;
    if (!word) {
      this.currentWordAtPosition = null;
      this.removeLinkDecorations();
      return Promise.resolve(0);
    }
    if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === word.startColumn && this.currentWordAtPosition.endColumn === word.endColumn && this.currentWordAtPosition.word === word.word) {
      return Promise.resolve(0);
    }
    this.currentWordAtPosition = word;
    let state = new EditorState(this.editor, 4 | 1 | 2 | 8);
    if (this.previousPromise) {
      this.previousPromise.cancel();
      this.previousPromise = null;
    }
    this.previousPromise = createCancelablePromise((token) => this.findDefinition(position, token));
    return this.previousPromise.then((results) => {
      if (!results || !results.length || !state.validate(this.editor)) {
        this.removeLinkDecorations();
        return;
      }
      if (results.length > 1) {
        this.addDecoration(new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn), new MarkdownString().appendText(localize("multipleResults", "Click to show {0} definitions.", results.length)));
      } else {
        let result = results[0];
        if (!result.uri) {
          return;
        }
        this.textModelResolverService.createModelReference(result.uri).then((ref) => {
          if (!ref.object || !ref.object.textEditorModel) {
            ref.dispose();
            return;
          }
          const { object: { textEditorModel } } = ref;
          const { startLineNumber } = result.range;
          if (startLineNumber < 1 || startLineNumber > textEditorModel.getLineCount()) {
            ref.dispose();
            return;
          }
          const previewValue = this.getPreviewValue(textEditorModel, startLineNumber, result);
          let wordRange;
          if (result.originSelectionRange) {
            wordRange = Range.lift(result.originSelectionRange);
          } else {
            wordRange = new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
          }
          const languageId = this.modeService.getModeIdByFilepathOrFirstLine(textEditorModel.uri);
          this.addDecoration(wordRange, new MarkdownString().appendCodeblock(languageId ? languageId : "", previewValue));
          ref.dispose();
        });
      }
    }).then(void 0, onUnexpectedError);
  }
  getPreviewValue(textEditorModel, startLineNumber, result) {
    let rangeToUse = result.targetSelectionRange ? result.range : this.getPreviewRangeBasedOnBrackets(textEditorModel, startLineNumber);
    const numberOfLinesInRange = rangeToUse.endLineNumber - rangeToUse.startLineNumber;
    if (numberOfLinesInRange >= GotoDefinitionAtPositionEditorContribution2.MAX_SOURCE_PREVIEW_LINES) {
      rangeToUse = this.getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber);
    }
    const previewValue = this.stripIndentationFromPreviewRange(textEditorModel, startLineNumber, rangeToUse);
    return previewValue;
  }
  stripIndentationFromPreviewRange(textEditorModel, startLineNumber, previewRange) {
    const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    let minIndent = startIndent;
    for (let endLineNumber = startLineNumber + 1; endLineNumber < previewRange.endLineNumber; endLineNumber++) {
      const endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
      minIndent = Math.min(minIndent, endIndent);
    }
    const previewValue = textEditorModel.getValueInRange(previewRange).replace(new RegExp(`^\\s{${minIndent - 1}}`, "gm"), "").trim();
    return previewValue;
  }
  getPreviewRangeBasedOnIndentation(textEditorModel, startLineNumber) {
    const startIndent = textEditorModel.getLineFirstNonWhitespaceColumn(startLineNumber);
    const maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionAtPositionEditorContribution2.MAX_SOURCE_PREVIEW_LINES);
    let endLineNumber = startLineNumber + 1;
    for (; endLineNumber < maxLineNumber; endLineNumber++) {
      let endIndent = textEditorModel.getLineFirstNonWhitespaceColumn(endLineNumber);
      if (startIndent === endIndent) {
        break;
      }
    }
    return new Range(startLineNumber, 1, endLineNumber + 1, 1);
  }
  getPreviewRangeBasedOnBrackets(textEditorModel, startLineNumber) {
    const maxLineNumber = Math.min(textEditorModel.getLineCount(), startLineNumber + GotoDefinitionAtPositionEditorContribution2.MAX_SOURCE_PREVIEW_LINES);
    const brackets = [];
    let ignoreFirstEmpty = true;
    let currentBracket = textEditorModel.bracketPairs.findNextBracket(new Position(startLineNumber, 1));
    while (currentBracket !== null) {
      if (brackets.length === 0) {
        brackets.push(currentBracket);
      } else {
        const lastBracket = brackets[brackets.length - 1];
        if (lastBracket.open[0] === currentBracket.open[0] && lastBracket.isOpen && !currentBracket.isOpen) {
          brackets.pop();
        } else {
          brackets.push(currentBracket);
        }
        if (brackets.length === 0) {
          if (ignoreFirstEmpty) {
            ignoreFirstEmpty = false;
          } else {
            return new Range(startLineNumber, 1, currentBracket.range.endLineNumber + 1, 1);
          }
        }
      }
      const maxColumn = textEditorModel.getLineMaxColumn(startLineNumber);
      let nextLineNumber = currentBracket.range.endLineNumber;
      let nextColumn = currentBracket.range.endColumn;
      if (maxColumn === currentBracket.range.endColumn) {
        nextLineNumber++;
        nextColumn = 1;
      }
      if (nextLineNumber > maxLineNumber) {
        return new Range(startLineNumber, 1, maxLineNumber + 1, 1);
      }
      currentBracket = textEditorModel.bracketPairs.findNextBracket(new Position(nextLineNumber, nextColumn));
    }
    return new Range(startLineNumber, 1, maxLineNumber + 1, 1);
  }
  addDecoration(range, hoverMessage) {
    const newDecorations = {
      range,
      options: {
        description: "goto-definition-link",
        inlineClassName: "goto-definition-link",
        hoverMessage
      }
    };
    this.linkDecorations = this.editor.deltaDecorations(this.linkDecorations, [newDecorations]);
  }
  removeLinkDecorations() {
    if (this.linkDecorations.length > 0) {
      this.linkDecorations = this.editor.deltaDecorations(this.linkDecorations, []);
    }
  }
  isEnabled(mouseEvent, withKey) {
    return this.editor.hasModel() && mouseEvent.isNoneOrSingleMouseDown && mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || (withKey ? withKey.keyCodeIsTriggerKey : false)) && DefinitionProviderRegistry.has(this.editor.getModel());
  }
  findDefinition(position, token) {
    const model = this.editor.getModel();
    if (!model) {
      return Promise.resolve(null);
    }
    return getDefinitionsAtPosition(model, position, token);
  }
  gotoDefinition(position, openToSide) {
    this.editor.setPosition(position);
    return this.editor.invokeWithinContext((accessor) => {
      const canPeek = !openToSide && this.editor.getOption(77) && !this.isInPeekEditor(accessor);
      const action = new DefinitionAction({ openToSide, openInPeek: canPeek, muteMessage: true }, { alias: "", label: "", id: "", precondition: void 0 });
      return action.run(accessor, this.editor);
    });
  }
  isInPeekEditor(accessor) {
    const contextKeyService = accessor.get(IContextKeyService);
    return PeekContext.inPeekEditor.getValue(contextKeyService);
  }
  dispose() {
    this.toUnhook.dispose();
  }
};
GotoDefinitionAtPositionEditorContribution.ID = "editor.contrib.gotodefinitionatposition";
GotoDefinitionAtPositionEditorContribution.MAX_SOURCE_PREVIEW_LINES = 8;
GotoDefinitionAtPositionEditorContribution = __decorate17([
  __param17(1, ITextModelService),
  __param17(2, IModeService)
], GotoDefinitionAtPositionEditorContribution);
registerEditorContribution(GotoDefinitionAtPositionEditorContribution.ID, GotoDefinitionAtPositionEditorContribution);
registerThemingParticipant((theme, collector) => {
  const activeLinkForeground = theme.getColor(editorActiveLinkForeground);
  if (activeLinkForeground) {
    collector.addRule(`.monaco-editor .goto-definition-link { color: ${activeLinkForeground} !important; }`);
  }
});

// node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hoverWidget.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/base/browser/ui/hover/hover.css";
var $2 = $;
var HoverWidget = class extends Disposable {
  constructor() {
    super();
    this.containerDomNode = document.createElement("div");
    this.containerDomNode.className = "monaco-hover";
    this.containerDomNode.tabIndex = 0;
    this.containerDomNode.setAttribute("role", "tooltip");
    this.contentsDomNode = document.createElement("div");
    this.contentsDomNode.className = "monaco-hover-content";
    this._scrollbar = this._register(new DomScrollableElement(this.contentsDomNode, {
      consumeMouseWheelIfScrollbarIsNeeded: true
    }));
    this.containerDomNode.appendChild(this._scrollbar.getDomNode());
  }
  onContentsChanged() {
    this._scrollbar.scanDomNode();
  }
};
var HoverAction = class extends Disposable {
  constructor(parent, actionOptions, keybindingLabel) {
    super();
    this.actionContainer = append(parent, $2("div.action-container"));
    this.action = append(this.actionContainer, $2("a.action"));
    this.action.setAttribute("role", "button");
    if (actionOptions.iconClass) {
      append(this.action, $2(`span.icon.${actionOptions.iconClass}`));
    }
    const label = append(this.action, $2("span"));
    label.textContent = keybindingLabel ? `${actionOptions.label} (${keybindingLabel})` : actionOptions.label;
    this._register(addDisposableListener(this.actionContainer, EventType.MOUSE_DOWN, (e) => {
      e.stopPropagation();
      e.preventDefault();
      actionOptions.run(this.actionContainer);
    }));
    this.setEnabled(true);
  }
  static render(parent, actionOptions, keybindingLabel) {
    return new HoverAction(parent, actionOptions, keybindingLabel);
  }
  setEnabled(enabled) {
    if (enabled) {
      this.actionContainer.classList.remove("disabled");
      this.actionContainer.removeAttribute("aria-disabled");
    } else {
      this.actionContainer.classList.add("disabled");
      this.actionContainer.setAttribute("aria-disabled", "true");
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPickerModel.js
var ColorPickerModel = class {
  constructor(color, availableColorPresentations, presentationIndex) {
    this.presentationIndex = presentationIndex;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    this._onDidChangeColor = new Emitter();
    this.onDidChangeColor = this._onDidChangeColor.event;
    this._onDidChangePresentation = new Emitter();
    this.onDidChangePresentation = this._onDidChangePresentation.event;
    this.originalColor = color;
    this._color = color;
    this._colorPresentations = availableColorPresentations;
  }
  get color() {
    return this._color;
  }
  set color(color) {
    if (this._color.equals(color)) {
      return;
    }
    this._color = color;
    this._onDidChangeColor.fire(color);
  }
  get presentation() {
    return this.colorPresentations[this.presentationIndex];
  }
  get colorPresentations() {
    return this._colorPresentations;
  }
  set colorPresentations(colorPresentations) {
    this._colorPresentations = colorPresentations;
    if (this.presentationIndex > colorPresentations.length - 1) {
      this.presentationIndex = 0;
    }
    this._onDidChangePresentation.fire(this.presentation);
  }
  selectNextColorPresentation() {
    this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length;
    this.flushColor();
    this._onDidChangePresentation.fire(this.presentation);
  }
  guessColorPresentation(color, originalText) {
    for (let i = 0; i < this.colorPresentations.length; i++) {
      if (originalText.toLowerCase() === this.colorPresentations[i].label) {
        this.presentationIndex = i;
        this._onDidChangePresentation.fire(this.presentation);
        break;
      }
    }
  }
  flushColor() {
    this._onColorFlushed.fire(this._color);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPickerWidget.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorPicker.css";
var $3 = $;
var ColorPickerHeader = class extends Disposable {
  constructor(container, model, themeService) {
    super();
    this.model = model;
    this.domNode = $3(".colorpicker-header");
    append(container, this.domNode);
    this.pickedColorNode = append(this.domNode, $3(".picked-color"));
    const tooltip = localize("clickToToggleColorOptions", "Click to toggle color options (rgb/hsl/hex)");
    this.pickedColorNode.setAttribute("title", tooltip);
    const colorBox = append(this.domNode, $3(".original-color"));
    colorBox.style.backgroundColor = Color.Format.CSS.format(this.model.originalColor) || "";
    this.backgroundColor = themeService.getColorTheme().getColor(editorHoverBackground) || Color.white;
    this._register(registerThemingParticipant((theme, collector) => {
      this.backgroundColor = theme.getColor(editorHoverBackground) || Color.white;
    }));
    this._register(addDisposableListener(this.pickedColorNode, EventType.CLICK, () => this.model.selectNextColorPresentation()));
    this._register(addDisposableListener(colorBox, EventType.CLICK, () => {
      this.model.color = this.model.originalColor;
      this.model.flushColor();
    }));
    this._register(model.onDidChangeColor(this.onDidChangeColor, this));
    this._register(model.onDidChangePresentation(this.onDidChangePresentation, this));
    this.pickedColorNode.style.backgroundColor = Color.Format.CSS.format(model.color) || "";
    this.pickedColorNode.classList.toggle("light", model.color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : model.color.isLighter());
    this.onDidChangeColor(this.model.color);
  }
  onDidChangeColor(color) {
    this.pickedColorNode.style.backgroundColor = Color.Format.CSS.format(color) || "";
    this.pickedColorNode.classList.toggle("light", color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : color.isLighter());
    this.onDidChangePresentation();
  }
  onDidChangePresentation() {
    this.pickedColorNode.textContent = this.model.presentation ? this.model.presentation.label : "";
    this.pickedColorNode.prepend($3(".codicon.codicon-color-mode"));
  }
};
var ColorPickerBody = class extends Disposable {
  constructor(container, model, pixelRatio) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this.domNode = $3(".colorpicker-body");
    append(container, this.domNode);
    this.saturationBox = new SaturationBox(this.domNode, this.model, this.pixelRatio);
    this._register(this.saturationBox);
    this._register(this.saturationBox.onDidChange(this.onDidSaturationValueChange, this));
    this._register(this.saturationBox.onColorFlushed(this.flushColor, this));
    this.opacityStrip = new OpacityStrip(this.domNode, this.model);
    this._register(this.opacityStrip);
    this._register(this.opacityStrip.onDidChange(this.onDidOpacityChange, this));
    this._register(this.opacityStrip.onColorFlushed(this.flushColor, this));
    this.hueStrip = new HueStrip(this.domNode, this.model);
    this._register(this.hueStrip);
    this._register(this.hueStrip.onDidChange(this.onDidHueChange, this));
    this._register(this.hueStrip.onColorFlushed(this.flushColor, this));
  }
  flushColor() {
    this.model.flushColor();
  }
  onDidSaturationValueChange({ s, v }) {
    const hsva = this.model.color.hsva;
    this.model.color = new Color(new HSVA(hsva.h, s, v, hsva.a));
  }
  onDidOpacityChange(a) {
    const hsva = this.model.color.hsva;
    this.model.color = new Color(new HSVA(hsva.h, hsva.s, hsva.v, a));
  }
  onDidHueChange(value) {
    const hsva = this.model.color.hsva;
    const h = (1 - value) * 360;
    this.model.color = new Color(new HSVA(h === 360 ? 0 : h, hsva.s, hsva.v, hsva.a));
  }
  layout() {
    this.saturationBox.layout();
    this.opacityStrip.layout();
    this.hueStrip.layout();
  }
};
var SaturationBox = class extends Disposable {
  constructor(container, model, pixelRatio) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    this.domNode = $3(".saturation-wrap");
    append(container, this.domNode);
    this.canvas = document.createElement("canvas");
    this.canvas.className = "saturation-box";
    append(this.domNode, this.canvas);
    this.selection = $3(".saturation-selection");
    append(this.domNode, this.selection);
    this.layout();
    this._register(addDisposableGenericMouseDownListner(this.domNode, (e) => this.onMouseDown(e)));
    this._register(this.model.onDidChangeColor(this.onDidChangeColor, this));
    this.monitor = null;
  }
  onMouseDown(e) {
    this.monitor = this._register(new GlobalMouseMoveMonitor());
    const origin = getDomNodePagePosition(this.domNode);
    if (e.target !== this.selection) {
      this.onDidChangePosition(e.offsetX, e.offsetY);
    }
    this.monitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, (event) => this.onDidChangePosition(event.posx - origin.left, event.posy - origin.top), () => null);
    const mouseUpListener = addDisposableGenericMouseUpListner(document, () => {
      this._onColorFlushed.fire();
      mouseUpListener.dispose();
      if (this.monitor) {
        this.monitor.stopMonitoring(true);
        this.monitor = null;
      }
    }, true);
  }
  onDidChangePosition(left, top) {
    const s = Math.max(0, Math.min(1, left / this.width));
    const v = Math.max(0, Math.min(1, 1 - top / this.height));
    this.paintSelection(s, v);
    this._onDidChange.fire({ s, v });
  }
  layout() {
    this.width = this.domNode.offsetWidth;
    this.height = this.domNode.offsetHeight;
    this.canvas.width = this.width * this.pixelRatio;
    this.canvas.height = this.height * this.pixelRatio;
    this.paint();
    const hsva = this.model.color.hsva;
    this.paintSelection(hsva.s, hsva.v);
  }
  paint() {
    const hsva = this.model.color.hsva;
    const saturatedColor = new Color(new HSVA(hsva.h, 1, 1, 1));
    const ctx = this.canvas.getContext("2d");
    const whiteGradient = ctx.createLinearGradient(0, 0, this.canvas.width, 0);
    whiteGradient.addColorStop(0, "rgba(255, 255, 255, 1)");
    whiteGradient.addColorStop(0.5, "rgba(255, 255, 255, 0.5)");
    whiteGradient.addColorStop(1, "rgba(255, 255, 255, 0)");
    const blackGradient = ctx.createLinearGradient(0, 0, 0, this.canvas.height);
    blackGradient.addColorStop(0, "rgba(0, 0, 0, 0)");
    blackGradient.addColorStop(1, "rgba(0, 0, 0, 1)");
    ctx.rect(0, 0, this.canvas.width, this.canvas.height);
    ctx.fillStyle = Color.Format.CSS.format(saturatedColor);
    ctx.fill();
    ctx.fillStyle = whiteGradient;
    ctx.fill();
    ctx.fillStyle = blackGradient;
    ctx.fill();
  }
  paintSelection(s, v) {
    this.selection.style.left = `${s * this.width}px`;
    this.selection.style.top = `${this.height - v * this.height}px`;
  }
  onDidChangeColor() {
    if (this.monitor && this.monitor.isMonitoring()) {
      return;
    }
    this.paint();
  }
};
var Strip = class extends Disposable {
  constructor(container, model) {
    super();
    this.model = model;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._onColorFlushed = new Emitter();
    this.onColorFlushed = this._onColorFlushed.event;
    this.domNode = append(container, $3(".strip"));
    this.overlay = append(this.domNode, $3(".overlay"));
    this.slider = append(this.domNode, $3(".slider"));
    this.slider.style.top = `0px`;
    this._register(addDisposableGenericMouseDownListner(this.domNode, (e) => this.onMouseDown(e)));
    this.layout();
  }
  layout() {
    this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
    const value = this.getValue(this.model.color);
    this.updateSliderPosition(value);
  }
  onMouseDown(e) {
    const monitor = this._register(new GlobalMouseMoveMonitor());
    const origin = getDomNodePagePosition(this.domNode);
    this.domNode.classList.add("grabbing");
    if (e.target !== this.slider) {
      this.onDidChangeTop(e.offsetY);
    }
    monitor.startMonitoring(e.target, e.buttons, standardMouseMoveMerger, (event) => this.onDidChangeTop(event.posy - origin.top), () => null);
    const mouseUpListener = addDisposableGenericMouseUpListner(document, () => {
      this._onColorFlushed.fire();
      mouseUpListener.dispose();
      monitor.stopMonitoring(true);
      this.domNode.classList.remove("grabbing");
    }, true);
  }
  onDidChangeTop(top) {
    const value = Math.max(0, Math.min(1, 1 - top / this.height));
    this.updateSliderPosition(value);
    this._onDidChange.fire(value);
  }
  updateSliderPosition(value) {
    this.slider.style.top = `${(1 - value) * this.height}px`;
  }
};
var OpacityStrip = class extends Strip {
  constructor(container, model) {
    super(container, model);
    this.domNode.classList.add("opacity-strip");
    this._register(model.onDidChangeColor(this.onDidChangeColor, this));
    this.onDidChangeColor(this.model.color);
  }
  onDidChangeColor(color) {
    const { r, g, b } = color.rgba;
    const opaque = new Color(new RGBA(r, g, b, 1));
    const transparent2 = new Color(new RGBA(r, g, b, 0));
    this.overlay.style.background = `linear-gradient(to bottom, ${opaque} 0%, ${transparent2} 100%)`;
  }
  getValue(color) {
    return color.hsva.a;
  }
};
var HueStrip = class extends Strip {
  constructor(container, model) {
    super(container, model);
    this.domNode.classList.add("hue-strip");
  }
  getValue(color) {
    return 1 - color.hsva.h / 360;
  }
};
var ColorPickerWidget = class extends Widget {
  constructor(container, model, pixelRatio, themeService) {
    super();
    this.model = model;
    this.pixelRatio = pixelRatio;
    this._register(onDidChangeZoomLevel(() => this.layout()));
    const element = $3(".colorpicker-widget");
    container.appendChild(element);
    const header = new ColorPickerHeader(element, this.model, themeService);
    this.body = new ColorPickerBody(element, this.model, this.pixelRatio);
    this._register(header);
    this._register(this.body);
  }
  layout() {
    this.body.layout();
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/colorHoverParticipant.js
var __decorate18 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param18 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ColorHover = class {
  constructor(owner, range, model, provider) {
    this.owner = owner;
    this.range = range;
    this.model = model;
    this.provider = provider;
    this.forceShowAtRange = true;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
};
var ColorHoverParticipant = class ColorHoverParticipant2 {
  constructor(_editor, _hover, _themeService) {
    this._editor = _editor;
    this._hover = _hover;
    this._themeService = _themeService;
  }
  computeSync(anchor, lineDecorations) {
    return [];
  }
  computeAsync(anchor, lineDecorations, token) {
    return AsyncIterableObject.fromPromise(this._computeAsync(anchor, lineDecorations, token));
  }
  _computeAsync(anchor, lineDecorations, token) {
    return __awaiter15(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return [];
      }
      const colorDetector = ColorDetector.get(this._editor);
      for (const d of lineDecorations) {
        if (!colorDetector.isColorDecorationId(d.id)) {
          continue;
        }
        const colorData = colorDetector.getColorData(d.range.getStartPosition());
        if (colorData) {
          const colorHover = yield this._createColorHover(this._editor.getModel(), colorData.colorInfo, colorData.provider);
          return [colorHover];
        }
      }
      return [];
    });
  }
  _createColorHover(editorModel, colorInfo, provider) {
    return __awaiter15(this, void 0, void 0, function* () {
      const originalText = editorModel.getValueInRange(colorInfo.range);
      const { red, green, blue, alpha } = colorInfo.color;
      const rgba = new RGBA(Math.round(red * 255), Math.round(green * 255), Math.round(blue * 255), alpha);
      const color = new Color(rgba);
      const colorPresentations = yield getColorPresentations(editorModel, colorInfo, provider, CancellationToken.None);
      const model = new ColorPickerModel(color, [], 0);
      model.colorPresentations = colorPresentations || [];
      model.guessColorPresentation(color, originalText);
      return new ColorHover(this, Range.lift(colorInfo.range), model, provider);
    });
  }
  renderHoverParts(hoverParts, fragment, statusBar) {
    if (hoverParts.length === 0 || !this._editor.hasModel()) {
      return Disposable.None;
    }
    const disposables = new DisposableStore();
    const colorHover = hoverParts[0];
    const editorModel = this._editor.getModel();
    const model = colorHover.model;
    const widget = disposables.add(new ColorPickerWidget(fragment, model, this._editor.getOption(128), this._themeService));
    let range = new Range(colorHover.range.startLineNumber, colorHover.range.startColumn, colorHover.range.endLineNumber, colorHover.range.endColumn);
    const updateEditorModel = () => {
      let textEdits;
      let newRange;
      if (model.presentation.textEdit) {
        textEdits = [model.presentation.textEdit];
        newRange = new Range(model.presentation.textEdit.range.startLineNumber, model.presentation.textEdit.range.startColumn, model.presentation.textEdit.range.endLineNumber, model.presentation.textEdit.range.endColumn);
        const trackedRange = this._editor.getModel()._setTrackedRange(null, newRange, 3);
        this._editor.pushUndoStop();
        this._editor.executeEdits("colorpicker", textEdits);
        newRange = this._editor.getModel()._getTrackedRange(trackedRange) || newRange;
      } else {
        textEdits = [{ identifier: null, range, text: model.presentation.label, forceMoveMarkers: false }];
        newRange = range.setEndPosition(range.endLineNumber, range.startColumn + model.presentation.label.length);
        this._editor.pushUndoStop();
        this._editor.executeEdits("colorpicker", textEdits);
      }
      if (model.presentation.additionalTextEdits) {
        textEdits = [...model.presentation.additionalTextEdits];
        this._editor.executeEdits("colorpicker", textEdits);
        this._hover.hide();
      }
      this._editor.pushUndoStop();
      range = newRange;
    };
    const updateColorPresentations = (color) => {
      return getColorPresentations(editorModel, {
        range,
        color: {
          red: color.rgba.r / 255,
          green: color.rgba.g / 255,
          blue: color.rgba.b / 255,
          alpha: color.rgba.a
        }
      }, colorHover.provider, CancellationToken.None).then((colorPresentations) => {
        model.colorPresentations = colorPresentations || [];
      });
    };
    disposables.add(model.onColorFlushed((color) => {
      updateColorPresentations(color).then(updateEditorModel);
    }));
    disposables.add(model.onDidChangeColor(updateColorPresentations));
    this._hover.setColorPicker(widget);
    return disposables;
  }
};
ColorHoverParticipant = __decorate18([
  __param18(2, IThemeService)
], ColorHoverParticipant);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/hoverOperation.js
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __asyncValues = function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
};
var HoverOperation = class {
  constructor(computer, success, error, progress, hoverTime) {
    this._computer = computer;
    this._state = 0;
    this._hoverTime = hoverTime;
    this._firstWaitScheduler = new RunOnceScheduler(() => this._triggerAsyncComputation(), 0);
    this._secondWaitScheduler = new RunOnceScheduler(() => this._triggerSyncComputation(), 0);
    this._loadingMessageScheduler = new RunOnceScheduler(() => this._showLoadingMessage(), 0);
    this._asyncIterable = null;
    this._asyncIterableDone = false;
    this._completeCallback = success;
    this._errorCallback = error;
    this._progressCallback = progress;
  }
  setHoverTime(hoverTime) {
    this._hoverTime = hoverTime;
  }
  _firstWaitTime() {
    return this._hoverTime / 2;
  }
  _secondWaitTime() {
    return this._hoverTime / 2;
  }
  _loadingMessageTime() {
    return 3 * this._hoverTime;
  }
  _triggerAsyncComputation() {
    this._state = 2;
    this._secondWaitScheduler.schedule(this._secondWaitTime());
    if (this._computer.computeAsync) {
      this._asyncIterableDone = false;
      this._asyncIterable = createCancelableAsyncIterable((token) => this._computer.computeAsync(token));
      (() => __awaiter16(this, void 0, void 0, function* () {
        var e_1, _a5;
        try {
          try {
            for (var _b2 = __asyncValues(this._asyncIterable), _c2; _c2 = yield _b2.next(), !_c2.done; ) {
              const item = _c2.value;
              if (item) {
                this._computer.onResult([item], false);
                this._onProgress();
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c2 && !_c2.done && (_a5 = _b2.return))
                yield _a5.call(_b2);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          this._asyncIterableDone = true;
          this._withAsyncResult();
        } catch (e) {
          this._onError(e);
        }
      }))();
    } else {
      this._asyncIterableDone = true;
    }
  }
  _triggerSyncComputation() {
    if (this._computer.computeSync) {
      this._computer.onResult(this._computer.computeSync(), true);
    }
    if (this._asyncIterableDone) {
      this._state = 0;
      this._onComplete();
    } else {
      this._state = 3;
      this._onProgress();
    }
  }
  _showLoadingMessage() {
    if (this._state === 3) {
      this._state = 4;
      this._onProgress();
    }
  }
  _withAsyncResult() {
    if (this._state === 3 || this._state === 4) {
      this._state = 0;
      this._onComplete();
    }
  }
  _onComplete() {
    this._completeCallback(this._computer.getResult());
  }
  _onError(error) {
    if (this._errorCallback) {
      this._errorCallback(error);
    } else {
      onUnexpectedError(error);
    }
  }
  _onProgress() {
    if (this._state === 4) {
      this._progressCallback(this._computer.getResultWithLoadingMessage());
    } else {
      this._progressCallback(this._computer.getResult());
    }
  }
  start(mode) {
    if (mode === 0) {
      if (this._state === 0) {
        this._state = 1;
        this._firstWaitScheduler.schedule(this._firstWaitTime());
        this._loadingMessageScheduler.schedule(this._loadingMessageTime());
      }
    } else {
      switch (this._state) {
        case 0:
          this._triggerAsyncComputation();
          this._secondWaitScheduler.cancel();
          this._triggerSyncComputation();
          break;
        case 2:
          this._secondWaitScheduler.cancel();
          this._triggerSyncComputation();
          break;
      }
    }
  }
  cancel() {
    this._firstWaitScheduler.cancel();
    this._secondWaitScheduler.cancel();
    this._loadingMessageScheduler.cancel();
    if (this._asyncIterable) {
      this._asyncIterable.cancel();
      this._asyncIterable = null;
    }
    this._state = 0;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/hoverTypes.js
var HoverRangeAnchor = class {
  constructor(priority, range) {
    this.priority = priority;
    this.range = range;
    this.type = 1;
  }
  equals(other) {
    return other.type === 1 && this.range.equalsRange(other.range);
  }
  canAdoptVisibleHover(lastAnchor, showAtPosition) {
    return lastAnchor.type === 1 && showAtPosition.lineNumber === this.range.startLineNumber;
  }
};
var HoverForeignElementAnchor = class {
  constructor(priority, owner, range) {
    this.priority = priority;
    this.owner = owner;
    this.range = range;
    this.type = 2;
  }
  equals(other) {
    return other.type === 2 && this.owner === other.owner;
  }
  canAdoptVisibleHover(lastAnchor, showAtPosition) {
    return lastAnchor.type === 2 && this.owner === lastAnchor.owner;
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/dompurify/dompurify.js
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var hasOwnProperty = Object.hasOwnProperty;
var setPrototypeOf = Object.setPrototypeOf;
var isFrozen = Object.isFrozen;
var getPrototypeOf = Object.getPrototypeOf;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze;
var seal = Object.seal;
var create = Object.create;
var _ref = typeof Reflect !== "undefined" && Reflect;
var apply = _ref.apply;
var construct = _ref.construct;
if (!apply) {
  apply = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze2(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal2(x) {
    return x;
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set, array) {
  if (setPrototypeOf) {
    setPrototypeOf(set, null);
  }
  var l = array.length;
  while (l--) {
    var element = array[l];
    if (typeof element === "string") {
      var lcElement = stringToLowerCase(element);
      if (lcElement !== element) {
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
function clone(object) {
  var newObject = create(null);
  var property = void 0;
  for (property in object) {
    if (apply(hasOwnProperty, object, [property])) {
      newObject[property] = object[property];
    }
  }
  return newObject;
}
function lookupGetter(object, prop) {
  while (object !== null) {
    var desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue(element) {
    console.warn("fallback value for", element);
    return null;
  }
  return fallbackValue;
}
var html = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text = freeze(["#text"]);
var html$1 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
var svg$1 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl$1 = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm);
var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g);
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
function _toConsumableArray$1(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
  if ((typeof trustedTypes === "undefined" ? "undefined" : _typeof(trustedTypes)) !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  var suffix = null;
  var ATTR_NAME = "data-tt-policy-suffix";
  if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document2.currentScript.getAttribute(ATTR_NAME);
  }
  var policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html$$1) {
        return html$$1;
      }
    });
  } catch (_) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  var DOMPurify = function DOMPurify2(root) {
    return createDOMPurify(root);
  };
  DOMPurify.version = "2.3.1";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  var originalDocument = window2.document;
  var document2 = window2.document;
  var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node = window2.Node, Element = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, Text2 = window2.Text, Comment = window2.Comment, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
  var ElementPrototype = Element.prototype;
  var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  var getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    var template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML("") : "";
  var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};
  try {
    documentMode = clone(document2).documentMode ? document2.documentMode : {};
  } catch (_) {
  }
  var hooks = {};
  DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
  var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR, ERB_EXPR$$1 = ERB_EXPR, DATA_ATTR$$1 = DATA_ATTR, ARIA_ATTR$$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;
  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));
  var FORBID_TAGS = null;
  var FORBID_ATTR = null;
  var ALLOW_ARIA_ATTR = true;
  var ALLOW_DATA_ATTR = true;
  var ALLOW_UNKNOWN_PROTOCOLS = false;
  var SAFE_FOR_TEMPLATES = false;
  var WHOLE_DOCUMENT = false;
  var SET_CONFIG = false;
  var FORCE_BODY = false;
  var RETURN_DOM = false;
  var RETURN_DOM_FRAGMENT = false;
  var RETURN_DOM_IMPORT = true;
  var RETURN_TRUSTED_TYPE = false;
  var SANITIZE_DOM = true;
  var KEEP_CONTENT = true;
  var IN_PLACE = false;
  var USE_PROFILES = {};
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  var CONFIG = null;
  var formElement = document2.createElement("form");
  var _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || (typeof cfg === "undefined" ? "undefined" : _typeof(cfg)) !== "object") {
      cfg = {};
    }
    cfg = clone(cfg);
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html);
        addToSet(ALLOWED_ATTR, html$1);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$1);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl);
        addToSet(ALLOWED_ATTR, mathMl$1);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  var ALL_SVG_TAGS = addToSet({}, svg);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet({}, mathMl);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  var _checkValidNamespace = function _checkValidNamespace2(element) {
    var parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: "template"
      };
    }
    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      var commonSvgAndHTMLElements = addToSet({}, ["title", "style", "font", "a", "script"]);
      return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    return false;
  };
  var _forceRemove = function _forceRemove2(node) {
    arrayPush(DOMPurify.removed, { element: node });
    try {
      node.parentNode.removeChild(node);
    } catch (_) {
      try {
        node.outerHTML = emptyHTML;
      } catch (_2) {
        node.remove();
      }
    }
  };
  var _removeAttribute = function _removeAttribute2(name, node) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node.getAttributeNode(name),
        from: node
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node
      });
    }
    node.removeAttribute(name);
    if (name === "is" && !ALLOWED_ATTR[name]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node);
        } catch (_) {
        }
      } else {
        try {
          node.setAttribute(name, "");
        } catch (_) {
        }
      }
    }
  };
  var _initDocument = function _initDocument2(dirty) {
    var doc = void 0;
    var leadingWhitespace = void 0;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser2().parseFromString(dirtyPayload, "text/html");
      } catch (_) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
      } catch (_) {
      }
    }
    var body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  var _createIterator = function _createIterator2(root) {
    return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
  };
  var _isClobbered = function _isClobbered2(elm) {
    if (elm instanceof Text2 || elm instanceof Comment) {
      return false;
    }
    if (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function") {
      return true;
    }
    return false;
  };
  var _isNode = function _isNode2(object) {
    return (typeof Node === "undefined" ? "undefined" : _typeof(Node)) === "object" ? object instanceof Node : object && (typeof object === "undefined" ? "undefined" : _typeof(object)) === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string";
  };
  var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], function(hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  var _sanitizeElements = function _sanitizeElements2(currentNode) {
    var content = void 0;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
      _forceRemove(currentNode);
      return true;
    }
    var tagName = stringToLowerCase(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          var childCount = childNodes.length;
          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$$1, " ");
      content = stringReplace(content, ERB_EXPR$$1, " ");
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
        currentNode.textContent = content;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName))
      ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName))
      ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      return false;
    } else if (URI_SAFE_ATTRIBUTES[lcName])
      ;
    else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
      ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
      ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, "")))
      ;
    else if (!value)
      ;
    else {
      return false;
    }
    return true;
  };
  var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    var attr = void 0;
    var value = void 0;
    var lcName = void 0;
    var l = void 0;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    var attributes = currentNode.attributes;
    if (!attributes) {
      return;
    }
    var hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;
    while (l--) {
      attr = attributes[l];
      var _attr = attr, name = _attr.name, namespaceURI = _attr.namespaceURI;
      value = stringTrim(attr.value);
      lcName = stringToLowerCase(name);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$$1, " ");
        value = stringReplace(value, ERB_EXPR$$1, " ");
      }
      var lcTag = currentNode.nodeName.toLowerCase();
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name, value);
        } else {
          currentNode.setAttribute(name, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    var shadowNode = void 0;
    var shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty, cfg) {
    var body = void 0;
    var importedNode = void 0;
    var currentNode = void 0;
    var oldNode = void 0;
    var returnNode = void 0;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString !== "function") {
        throw typeErrorCreate("toString is not a function");
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      }
    }
    if (!DOMPurify.isSupported) {
      if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
        if (typeof dirty === "string") {
          return window2.toStaticHTML(dirty);
        }
        if (_isNode(dirty)) {
          return window2.toStaticHTML(dirty.outerHTML);
        }
      }
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE)
      ;
    else if (dirty instanceof Node) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : emptyHTML;
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
      oldNode = currentNode;
    }
    oldNode = null;
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (RETURN_DOM_IMPORT) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    var lcTag = stringToLowerCase(tag);
    var lcName = stringToLowerCase(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();
var version = purify.version;
var isSupported = purify.isSupported;
var sanitize = purify.sanitize;
var setConfig = purify.setConfig;
var clearConfig = purify.clearConfig;
var isValidAttribute = purify.isValidAttribute;
var addHook = purify.addHook;
var removeHook = purify.removeHook;
var removeHooks = purify.removeHooks;
var removeAllHooks = purify.removeAllHooks;

// node_modules/monaco-editor/esm/vs/base/common/marked/marked.js
var __marked_exports;
(function() {
  function define(factory) {
    __marked_exports = factory();
  }
  define.amd = true;
  (function(global, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.marked = factory());
  })(this, function() {
    "use strict";
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it)
        return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        return function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var defaults$5 = { exports: {} };
    function getDefaults$1() {
      return {
        baseUrl: null,
        breaks: false,
        extensions: null,
        gfm: true,
        headerIds: true,
        headerPrefix: "",
        highlight: null,
        langPrefix: "language-",
        mangle: true,
        pedantic: false,
        renderer: null,
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartLists: false,
        smartypants: false,
        tokenizer: null,
        walkTokens: null,
        xhtml: false
      };
    }
    function changeDefaults$1(newDefaults) {
      defaults$5.exports.defaults = newDefaults;
    }
    defaults$5.exports = {
      defaults: getDefaults$1(),
      getDefaults: getDefaults$1,
      changeDefaults: changeDefaults$1
    };
    var escapeTest = /[&<>"']/;
    var escapeReplace = /[&<>"']/g;
    var escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    var escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
    var escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var getEscapeReplacement = function getEscapeReplacement2(ch) {
      return escapeReplacements[ch];
    };
    function escape$2(html2, encode) {
      if (encode) {
        if (escapeTest.test(html2)) {
          return html2.replace(escapeReplace, getEscapeReplacement);
        }
      } else {
        if (escapeTestNoEncode.test(html2)) {
          return html2.replace(escapeReplaceNoEncode, getEscapeReplacement);
        }
      }
      return html2;
    }
    var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    function unescape$1(html2) {
      return html2.replace(unescapeTest, function(_, n) {
        n = n.toLowerCase();
        if (n === "colon")
          return ":";
        if (n.charAt(0) === "#") {
          return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
        }
        return "";
      });
    }
    var caret = /(^|[^\[])\^/g;
    function edit$1(regex, opt) {
      regex = regex.source || regex;
      opt = opt || "";
      var obj = {
        replace: function replace(name, val) {
          val = val.source || val;
          val = val.replace(caret, "$1");
          regex = regex.replace(name, val);
          return obj;
        },
        getRegex: function getRegex() {
          return new RegExp(regex, opt);
        }
      };
      return obj;
    }
    var nonWordAndColonTest = /[^\w:]/g;
    var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    function cleanUrl$1(sanitize2, base, href) {
      if (sanitize2) {
        var prot;
        try {
          prot = decodeURIComponent(unescape$1(href)).replace(nonWordAndColonTest, "").toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, "%");
      } catch (e) {
        return null;
      }
      return href;
    }
    var baseUrls = {};
    var justDomain = /^[^:]+:\/*[^/]*$/;
    var protocol = /^([^:]+:)[\s\S]*$/;
    var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    function resolveUrl(base, href) {
      if (!baseUrls[" " + base]) {
        if (justDomain.test(base)) {
          baseUrls[" " + base] = base + "/";
        } else {
          baseUrls[" " + base] = rtrim$1(base, "/", true);
        }
      }
      base = baseUrls[" " + base];
      var relativeBase = base.indexOf(":") === -1;
      if (href.substring(0, 2) === "//") {
        if (relativeBase) {
          return href;
        }
        return base.replace(protocol, "$1") + href;
      } else if (href.charAt(0) === "/") {
        if (relativeBase) {
          return href;
        }
        return base.replace(domain, "$1") + href;
      } else {
        return base + href;
      }
    }
    var noopTest$1 = {
      exec: function noopTest2() {
      }
    };
    function merge$2(obj) {
      var i = 1, target, key;
      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }
      return obj;
    }
    function splitCells$1(tableRow, count) {
      var row = tableRow.replace(/\|/g, function(match, offset, str) {
        var escaped = false, curr = offset;
        while (--curr >= 0 && str[curr] === "\\") {
          escaped = !escaped;
        }
        if (escaped) {
          return "|";
        } else {
          return " |";
        }
      }), cells = row.split(/ \|/);
      var i = 0;
      if (!cells[0].trim()) {
        cells.shift();
      }
      if (!cells[cells.length - 1].trim()) {
        cells.pop();
      }
      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count) {
          cells.push("");
        }
      }
      for (; i < cells.length; i++) {
        cells[i] = cells[i].trim().replace(/\\\|/g, "|");
      }
      return cells;
    }
    function rtrim$1(str, c, invert) {
      var l = str.length;
      if (l === 0) {
        return "";
      }
      var suffLen = 0;
      while (suffLen < l) {
        var currChar = str.charAt(l - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }
      return str.substr(0, l - suffLen);
    }
    function findClosingBracket$1(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      var l = str.length;
      var level = 0, i = 0;
      for (; i < l; i++) {
        if (str[i] === "\\") {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }
    function checkSanitizeDeprecation$1(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
      }
    }
    function repeatString$1(pattern, count) {
      if (count < 1) {
        return "";
      }
      var result = "";
      while (count > 1) {
        if (count & 1) {
          result += pattern;
        }
        count >>= 1;
        pattern += pattern;
      }
      return result + pattern;
    }
    var helpers = {
      escape: escape$2,
      unescape: unescape$1,
      edit: edit$1,
      cleanUrl: cleanUrl$1,
      resolveUrl,
      noopTest: noopTest$1,
      merge: merge$2,
      splitCells: splitCells$1,
      rtrim: rtrim$1,
      findClosingBracket: findClosingBracket$1,
      checkSanitizeDeprecation: checkSanitizeDeprecation$1,
      repeatString: repeatString$1
    };
    var defaults$4 = defaults$5.exports.defaults;
    var rtrim = helpers.rtrim, splitCells = helpers.splitCells, _escape = helpers.escape, findClosingBracket = helpers.findClosingBracket;
    function outputLink(cap, link, raw, lexer2) {
      var href = link.href;
      var title = link.title ? _escape(link.title) : null;
      var text2 = cap[1].replace(/\\([\[\]])/g, "$1");
      if (cap[0].charAt(0) !== "!") {
        lexer2.state.inLink = true;
        var token = {
          type: "link",
          raw,
          href,
          title,
          text: text2,
          tokens: lexer2.inlineTokens(text2, [])
        };
        lexer2.state.inLink = false;
        return token;
      } else {
        return {
          type: "image",
          raw,
          href,
          title,
          text: _escape(text2)
        };
      }
    }
    function indentCodeCompensation(raw, text2) {
      var matchIndentToCode = raw.match(/^(\s+)(?:```)/);
      if (matchIndentToCode === null) {
        return text2;
      }
      var indentToCode = matchIndentToCode[1];
      return text2.split("\n").map(function(node) {
        var matchIndentInNode = node.match(/^\s+/);
        if (matchIndentInNode === null) {
          return node;
        }
        var indentInNode = matchIndentInNode[0];
        if (indentInNode.length >= indentToCode.length) {
          return node.slice(indentToCode.length);
        }
        return node;
      }).join("\n");
    }
    var Tokenizer_1 = function() {
      function Tokenizer3(options) {
        this.options = options || defaults$4;
      }
      var _proto = Tokenizer3.prototype;
      _proto.space = function space(src) {
        var cap = this.rules.block.newline.exec(src);
        if (cap) {
          if (cap[0].length > 1) {
            return {
              type: "space",
              raw: cap[0]
            };
          }
          return {
            raw: "\n"
          };
        }
      };
      _proto.code = function code(src) {
        var cap = this.rules.block.code.exec(src);
        if (cap) {
          var text2 = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text2, "\n") : text2
          };
        }
      };
      _proto.fences = function fences(src) {
        var cap = this.rules.block.fences.exec(src);
        if (cap) {
          var raw = cap[0];
          var text2 = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim() : cap[2],
            text: text2
          };
        }
      };
      _proto.heading = function heading(src) {
        var cap = this.rules.block.heading.exec(src);
        if (cap) {
          var text2 = cap[2].trim();
          if (/#$/.test(text2)) {
            var trimmed = rtrim(text2, "#");
            if (this.options.pedantic) {
              text2 = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text2 = trimmed.trim();
            }
          }
          var token = {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text: text2,
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      };
      _proto.hr = function hr(src) {
        var cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      };
      _proto.blockquote = function blockquote(src) {
        var cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          var text2 = cap[0].replace(/^ *> ?/gm, "");
          return {
            type: "blockquote",
            raw: cap[0],
            tokens: this.lexer.blockTokens(text2, []),
            text: text2
          };
        }
      };
      _proto.list = function list(src) {
        var cap = this.rules.block.list.exec(src);
        if (cap) {
          var raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, lines, itemContents;
          var bull = cap[1].trim();
          var isordered = bull.length > 1;
          var list2 = {
            type: "list",
            raw: "",
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          bull = isordered ? "\\d{1,9}\\" + bull.slice(-1) : "\\" + bull;
          if (this.options.pedantic) {
            bull = isordered ? bull : "[*+-]";
          }
          var itemRegex = new RegExp("^( {0,3}" + bull + ")((?: [^\\n]*| *)(?:\\n[^\\n]*)*(?:\\n|$))");
          while (src) {
            if (this.rules.block.hr.test(src)) {
              break;
            }
            if (!(cap = itemRegex.exec(src))) {
              break;
            }
            lines = cap[2].split("\n");
            if (this.options.pedantic) {
              indent = 2;
              itemContents = lines[0].trimLeft();
            } else {
              indent = cap[2].search(/[^ ]/);
              indent = cap[1].length + (indent > 4 ? 1 : indent);
              itemContents = lines[0].slice(indent - cap[1].length);
            }
            blankLine = false;
            raw = cap[0];
            if (!lines[0] && /^ *$/.test(lines[1])) {
              raw = cap[1] + lines.slice(0, 2).join("\n") + "\n";
              list2.loose = true;
              lines = [];
            }
            var nextBulletRegex = new RegExp("^ {0," + Math.min(3, indent - 1) + "}(?:[*+-]|\\d{1,9}[.)])");
            for (i = 1; i < lines.length; i++) {
              line = lines[i];
              if (this.options.pedantic) {
                line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
              }
              if (nextBulletRegex.test(line)) {
                raw = cap[1] + lines.slice(0, i).join("\n") + "\n";
                break;
              }
              if (!blankLine) {
                if (!line.trim()) {
                  blankLine = true;
                }
                if (line.search(/[^ ]/) >= indent) {
                  itemContents += "\n" + line.slice(indent);
                } else {
                  itemContents += "\n" + line;
                }
                continue;
              }
              if (line.search(/[^ ]/) >= indent || !line.trim()) {
                itemContents += "\n" + line.slice(indent);
                continue;
              } else {
                raw = cap[1] + lines.slice(0, i).join("\n") + "\n";
                break;
              }
            }
            if (!list2.loose) {
              if (endsWithBlankLine) {
                list2.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== "[ ] ";
                itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
              }
            }
            list2.items.push({
              type: "list_item",
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents
            });
            list2.raw += raw;
            src = src.slice(raw.length);
          }
          list2.items[list2.items.length - 1].raw = raw.trimRight();
          list2.items[list2.items.length - 1].text = itemContents.trimRight();
          list2.raw = list2.raw.trimRight();
          var l = list2.items.length;
          for (i = 0; i < l; i++) {
            this.lexer.state.top = false;
            list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
            if (list2.items[i].tokens.some(function(t) {
              return t.type === "space";
            })) {
              list2.loose = true;
              list2.items[i].loose = true;
            }
          }
          return list2;
        }
      };
      _proto.html = function html2(src) {
        var cap = this.rules.block.html.exec(src);
        if (cap) {
          var token = {
            type: "html",
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: cap[0]
          };
          if (this.options.sanitize) {
            token.type = "paragraph";
            token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]);
            token.tokens = [];
            this.lexer.inline(token.text, token.tokens);
          }
          return token;
        }
      };
      _proto.def = function def(src) {
        var cap = this.rules.block.def.exec(src);
        if (cap) {
          if (cap[3])
            cap[3] = cap[3].substring(1, cap[3].length - 1);
          var tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          return {
            type: "def",
            tag,
            raw: cap[0],
            href: cap[2],
            title: cap[3]
          };
        }
      };
      _proto.table = function table(src) {
        var cap = this.rules.block.table.exec(src);
        if (cap) {
          var item = {
            type: "table",
            header: splitCells(cap[1]).map(function(c) {
              return {
                text: c
              };
            }),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            rows: cap[3] ? cap[3].replace(/\n$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            var l = item.align.length;
            var i, j, k, row;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.rows.length;
            for (i = 0; i < l; i++) {
              item.rows[i] = splitCells(item.rows[i], item.header.length).map(function(c) {
                return {
                  text: c
                };
              });
            }
            l = item.header.length;
            for (j = 0; j < l; j++) {
              item.header[j].tokens = [];
              this.lexer.inlineTokens(item.header[j].text, item.header[j].tokens);
            }
            l = item.rows.length;
            for (j = 0; j < l; j++) {
              row = item.rows[j];
              for (k = 0; k < row.length; k++) {
                row[k].tokens = [];
                this.lexer.inlineTokens(row[k].text, row[k].tokens);
              }
            }
            return item;
          }
        }
      };
      _proto.lheading = function lheading(src) {
        var cap = this.rules.block.lheading.exec(src);
        if (cap) {
          var token = {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      };
      _proto.paragraph = function paragraph(src) {
        var cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          var token = {
            type: "paragraph",
            raw: cap[0],
            text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      };
      _proto.text = function text2(src) {
        var cap = this.rules.block.text.exec(src);
        if (cap) {
          var token = {
            type: "text",
            raw: cap[0],
            text: cap[0],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      };
      _proto.escape = function escape3(src) {
        var cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: _escape(cap[1])
          };
        }
      };
      _proto.tag = function tag(src) {
        var cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]
          };
        }
      };
      _proto.link = function link(src) {
        var cap = this.rules.inline.link.exec(src);
        if (cap) {
          var trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            var rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            var lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              var start = cap[0].indexOf("!") === 0 ? 5 : 4;
              var linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          var href = cap[2];
          var title = "";
          if (this.options.pedantic) {
            var link2 = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link2) {
              href = link2[1];
              title = link2[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0], this.lexer);
        }
      };
      _proto.reflink = function reflink(src, links) {
        var cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          var link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links[link.toLowerCase()];
          if (!link || !link.href) {
            var text2 = cap[0].charAt(0);
            return {
              type: "text",
              raw: text2,
              text: text2
            };
          }
          return outputLink(cap, link, cap[0], this.lexer);
        }
      };
      _proto.emStrong = function emStrong(src, maskedSrc, prevChar) {
        if (prevChar === void 0) {
          prevChar = "";
        }
        var match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match)
          return;
        if (match[3] && prevChar.match(/(?:[0-9A-Za-z\xAA\xB2\xB3\xB5\xB9\xBA\xBC-\xBE\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u0660-\u0669\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07C0-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0966-\u096F\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09E6-\u09F1\u09F4-\u09F9\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A66-\u0A6F\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AE6-\u0AEF\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B66-\u0B6F\u0B71-\u0B77\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0BE6-\u0BF2\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C66-\u0C6F\u0C78-\u0C7E\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CE6-\u0CEF\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D58-\u0D61\u0D66-\u0D78\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DE6-\u0DEF\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F20-\u0F33\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F-\u1049\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u1090-\u1099\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1369-\u137C\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A16\u1A20-\u1A54\u1A80-\u1A89\u1A90-\u1A99\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B50-\u1B59\u1B83-\u1BA0\u1BAE-\u1BE5\u1C00-\u1C23\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2070\u2071\u2074-\u2079\u207F-\u2089\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2CFD\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u3192-\u3195\u31A0-\u31BF\u31F0-\u31FF\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA830-\uA835\uA840-\uA873\uA882-\uA8B3\uA8D0-\uA8D9\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA900-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF-\uA9D9\uA9E0-\uA9E4\uA9E6-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD07-\uDD33\uDD40-\uDD78\uDD8A\uDD8B\uDE80-\uDE9C\uDEA0-\uDED0\uDEE1-\uDEFB\uDF00-\uDF23\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC58-\uDC76\uDC79-\uDC9E\uDCA7-\uDCAF\uDCE0-\uDCF2\uDCF4\uDCF5\uDCFB-\uDD1B\uDD20-\uDD39\uDD80-\uDDB7\uDDBC-\uDDCF\uDDD2-\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE40-\uDE48\uDE60-\uDE7E\uDE80-\uDE9F\uDEC0-\uDEC7\uDEC9-\uDEE4\uDEEB-\uDEEF\uDF00-\uDF35\uDF40-\uDF55\uDF58-\uDF72\uDF78-\uDF91\uDFA9-\uDFAF]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDCFA-\uDD23\uDD30-\uDD39\uDE60-\uDE7E\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF27\uDF30-\uDF45\uDF51-\uDF54\uDFB0-\uDFCB\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC52-\uDC6F\uDC83-\uDCAF\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD03-\uDD26\uDD36-\uDD3F\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDD0-\uDDDA\uDDDC\uDDE1-\uDDF4\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDEF0-\uDEF9\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC50-\uDC59\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE50-\uDE59\uDE80-\uDEAA\uDEB8\uDEC0-\uDEC9\uDF00-\uDF1A\uDF30-\uDF3B]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCF2\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDD50-\uDD59\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC50-\uDC6C\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD50-\uDD59\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDDA0-\uDDA9\uDEE0-\uDEF2\uDFB0\uDFC0-\uDFD4]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF50-\uDF59\uDF5B-\uDF61\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE96\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82C[\uDC00-\uDD1E\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD834[\uDEE0-\uDEF3\uDF60-\uDF78]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD40-\uDD49\uDD4E\uDEC0-\uDEEB\uDEF0-\uDEF9]|\uD83A[\uDC00-\uDCC4\uDCC7-\uDCCF\uDD00-\uDD43\uDD4B\uDD50-\uDD59]|\uD83B[\uDC71-\uDCAB\uDCAD-\uDCAF\uDCB1-\uDCB4\uDD01-\uDD2D\uDD2F-\uDD3D\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD83C[\uDD00-\uDD0C]|\uD83E[\uDFF0-\uDFF9]|\uD869[\uDC00-\uDEDD\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/))
          return;
        var nextChar = match[1] || match[2] || "";
        if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
          var lLength = match[0].length - 1;
          var rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          var endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim)
              continue;
            rLength = rDelim.length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0)
              continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            if (Math.min(lLength, rLength) % 2) {
              var _text = src.slice(1, lLength + match.index + rLength);
              return {
                type: "em",
                raw: src.slice(0, lLength + match.index + rLength + 1),
                text: _text,
                tokens: this.lexer.inlineTokens(_text, [])
              };
            }
            var text2 = src.slice(2, lLength + match.index + rLength - 1);
            return {
              type: "strong",
              raw: src.slice(0, lLength + match.index + rLength + 1),
              text: text2,
              tokens: this.lexer.inlineTokens(text2, [])
            };
          }
        }
      };
      _proto.codespan = function codespan(src) {
        var cap = this.rules.inline.code.exec(src);
        if (cap) {
          var text2 = cap[2].replace(/\n/g, " ");
          var hasNonSpaceChars = /[^ ]/.test(text2);
          var hasSpaceCharsOnBothEnds = /^ /.test(text2) && / $/.test(text2);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text2 = text2.substring(1, text2.length - 1);
          }
          text2 = _escape(text2, true);
          return {
            type: "codespan",
            raw: cap[0],
            text: text2
          };
        }
      };
      _proto.br = function br(src) {
        var cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      };
      _proto.del = function del(src) {
        var cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2], [])
          };
        }
      };
      _proto.autolink = function autolink(src, mangle2) {
        var cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          var text2, href;
          if (cap[2] === "@") {
            text2 = _escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
            href = "mailto:" + text2;
          } else {
            text2 = _escape(cap[1]);
            href = text2;
          }
          return {
            type: "link",
            raw: cap[0],
            text: text2,
            href,
            tokens: [{
              type: "text",
              raw: text2,
              text: text2
            }]
          };
        }
      };
      _proto.url = function url(src, mangle2) {
        var cap;
        if (cap = this.rules.inline.url.exec(src)) {
          var text2, href;
          if (cap[2] === "@") {
            text2 = _escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
            href = "mailto:" + text2;
          } else {
            var prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text2 = _escape(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + text2;
            } else {
              href = text2;
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text: text2,
            href,
            tokens: [{
              type: "text",
              raw: text2,
              text: text2
            }]
          };
        }
      };
      _proto.inlineText = function inlineText(src, smartypants2) {
        var cap = this.rules.inline.text.exec(src);
        if (cap) {
          var text2;
          if (this.lexer.state.inRawBlock) {
            text2 = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];
          } else {
            text2 = _escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text: text2
          };
        }
      };
      return Tokenizer3;
    }();
    var noopTest = helpers.noopTest, edit = helpers.edit, merge$1 = helpers.merge;
    var block$1 = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block$1._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
    block$1._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block$1.def = edit(block$1.def).replace("label", block$1._label).replace("title", block$1._title).getRegex();
    block$1.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block$1.listItemStart = edit(/^( *)(bull) */).replace("bull", block$1.bullet).getRegex();
    block$1.list = edit(block$1.list).replace(/bull/g, block$1.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block$1.def.source + ")").getRegex();
    block$1._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block$1._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block$1.html = edit(block$1.html, "i").replace("comment", block$1._comment).replace("tag", block$1._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block$1.paragraph = edit(block$1._paragraph).replace("hr", block$1.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block$1._tag).getRegex();
    block$1.blockquote = edit(block$1.blockquote).replace("paragraph", block$1.paragraph).getRegex();
    block$1.normal = merge$1({}, block$1);
    block$1.gfm = merge$1({}, block$1.normal, {
      table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)\\|?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
    });
    block$1.gfm.table = edit(block$1.gfm.table).replace("hr", block$1.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block$1._tag).getRegex();
    block$1.pedantic = merge$1({}, block$1.normal, {
      html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block$1._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      paragraph: edit(block$1.normal._paragraph).replace("hr", block$1.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block$1.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    var inline$1 = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
      nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        rDelimAst: /\_\_[^_*]*?\*[^_*]*?\_\_|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
        rDelimUnd: /\*\*[^_*]*?\_[^_*]*?\*\*|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };
    inline$1._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    inline$1.punctuation = edit(inline$1.punctuation).replace(/punctuation/g, inline$1._punctuation).getRegex();
    inline$1.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    inline$1.escapedEmSt = /\\\*|\\_/g;
    inline$1._comment = edit(block$1._comment).replace("(?:-->|$)", "-->").getRegex();
    inline$1.emStrong.lDelim = edit(inline$1.emStrong.lDelim).replace(/punct/g, inline$1._punctuation).getRegex();
    inline$1.emStrong.rDelimAst = edit(inline$1.emStrong.rDelimAst, "g").replace(/punct/g, inline$1._punctuation).getRegex();
    inline$1.emStrong.rDelimUnd = edit(inline$1.emStrong.rDelimUnd, "g").replace(/punct/g, inline$1._punctuation).getRegex();
    inline$1._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    inline$1._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline$1._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline$1.autolink = edit(inline$1.autolink).replace("scheme", inline$1._scheme).replace("email", inline$1._email).getRegex();
    inline$1._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline$1.tag = edit(inline$1.tag).replace("comment", inline$1._comment).replace("attribute", inline$1._attribute).getRegex();
    inline$1._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline$1._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline$1._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline$1.link = edit(inline$1.link).replace("label", inline$1._label).replace("href", inline$1._href).replace("title", inline$1._title).getRegex();
    inline$1.reflink = edit(inline$1.reflink).replace("label", inline$1._label).getRegex();
    inline$1.reflinkSearch = edit(inline$1.reflinkSearch, "g").replace("reflink", inline$1.reflink).replace("nolink", inline$1.nolink).getRegex();
    inline$1.normal = merge$1({}, inline$1);
    inline$1.pedantic = merge$1({}, inline$1.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline$1._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline$1._label).getRegex()
    });
    inline$1.gfm = merge$1({}, inline$1.normal, {
      escape: edit(inline$1.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    });
    inline$1.gfm.url = edit(inline$1.gfm.url, "i").replace("email", inline$1.gfm._extended_email).getRegex();
    inline$1.breaks = merge$1({}, inline$1.gfm, {
      br: edit(inline$1.br).replace("{2,}", "*").getRegex(),
      text: edit(inline$1.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    var rules = {
      block: block$1,
      inline: inline$1
    };
    var Tokenizer$1 = Tokenizer_1;
    var defaults$3 = defaults$5.exports.defaults;
    var block = rules.block, inline = rules.inline;
    var repeatString = helpers.repeatString;
    function smartypants(text2) {
      return text2.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
    }
    function mangle(text2) {
      var out = "", i, ch;
      var l = text2.length;
      for (i = 0; i < l; i++) {
        ch = text2.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = "x" + ch.toString(16);
        }
        out += "&#" + ch + ";";
      }
      return out;
    }
    var Lexer_1 = function() {
      function Lexer3(options) {
        this.tokens = [];
        this.tokens.links = Object.create(null);
        this.options = options || defaults$3;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer$1();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };
        var rules2 = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules2.block = block.pedantic;
          rules2.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules2.block = block.gfm;
          if (this.options.breaks) {
            rules2.inline = inline.breaks;
          } else {
            rules2.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules2;
      }
      Lexer3.lex = function lex(src, options) {
        var lexer2 = new Lexer3(options);
        return lexer2.lex(src);
      };
      Lexer3.lexInline = function lexInline(src, options) {
        var lexer2 = new Lexer3(options);
        return lexer2.inlineTokens(src);
      };
      var _proto = Lexer3.prototype;
      _proto.lex = function lex(src) {
        src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
        this.blockTokens(src, this.tokens);
        var next;
        while (next = this.inlineQueue.shift()) {
          this.inlineTokens(next.src, next.tokens);
        }
        return this.tokens;
      };
      _proto.blockTokens = function blockTokens(src, tokens) {
        var _this = this;
        if (tokens === void 0) {
          tokens = [];
        }
        if (this.options.pedantic) {
          src = src.replace(/^ +$/gm, "");
        }
        var token, lastToken, cutSrc, lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some(function(extTokenizer) {
            if (token = extTokenizer.call({
              lexer: _this
            }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.type) {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            (function() {
              var startIndex = Infinity;
              var tempSrc = src.slice(1);
              var tempStart = void 0;
              _this.options.extensions.startBlock.forEach(function(getStartIndex) {
                tempStart = getStartIndex.call({
                  lexer: this
                }, tempSrc);
                if (typeof tempStart === "number" && tempStart >= 0) {
                  startIndex = Math.min(startIndex, tempStart);
                }
              });
              if (startIndex < Infinity && startIndex >= 0) {
                cutSrc = src.substring(0, startIndex + 1);
              }
            })();
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        this.state.top = true;
        return tokens;
      };
      _proto.inline = function inline2(src, tokens) {
        this.inlineQueue.push({
          src,
          tokens
        });
      };
      _proto.inlineTokens = function inlineTokens(src, tokens) {
        var _this2 = this;
        if (tokens === void 0) {
          tokens = [];
        }
        var token, lastToken, cutSrc;
        var maskedSrc = src;
        var match;
        var keepPrevChar, prevChar;
        if (this.tokens.links) {
          var links = Object.keys(this.tokens.links);
          if (links.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some(function(extTokenizer) {
            if (token = extTokenizer.call({
              lexer: _this2
            }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            (function() {
              var startIndex = Infinity;
              var tempSrc = src.slice(1);
              var tempStart = void 0;
              _this2.options.extensions.startInline.forEach(function(getStartIndex) {
                tempStart = getStartIndex.call({
                  lexer: this
                }, tempSrc);
                if (typeof tempStart === "number" && tempStart >= 0) {
                  startIndex = Math.min(startIndex, tempStart);
                }
              });
              if (startIndex < Infinity && startIndex >= 0) {
                cutSrc = src.substring(0, startIndex + 1);
              }
            })();
          }
          if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            var errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      };
      _createClass(Lexer3, null, [{
        key: "rules",
        get: function get() {
          return {
            block,
            inline
          };
        }
      }]);
      return Lexer3;
    }();
    var defaults$2 = defaults$5.exports.defaults;
    var cleanUrl = helpers.cleanUrl, escape$1 = helpers.escape;
    var Renderer_1 = function() {
      function Renderer3(options) {
        this.options = options || defaults$2;
      }
      var _proto = Renderer3.prototype;
      _proto.code = function code(_code, infostring, escaped) {
        var lang = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          var out = this.options.highlight(_code, lang);
          if (out != null && out !== _code) {
            escaped = true;
            _code = out;
          }
        }
        _code = _code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped ? _code : escape$1(_code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape$1(lang, true) + '">' + (escaped ? _code : escape$1(_code, true)) + "</code></pre>\n";
      };
      _proto.blockquote = function blockquote(quote) {
        return "<blockquote>\n" + quote + "</blockquote>\n";
      };
      _proto.html = function html2(_html) {
        return _html;
      };
      _proto.heading = function heading(text2, level, raw, slugger) {
        if (this.options.headerIds) {
          return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text2 + "</h" + level + ">\n";
        }
        return "<h" + level + ">" + text2 + "</h" + level + ">\n";
      };
      _proto.hr = function hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      };
      _proto.list = function list(body, ordered, start) {
        var type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
      };
      _proto.listitem = function listitem(text2) {
        return "<li>" + text2 + "</li>\n";
      };
      _proto.checkbox = function checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      };
      _proto.paragraph = function paragraph(text2) {
        return "<p>" + text2 + "</p>\n";
      };
      _proto.table = function table(header, body) {
        if (body)
          body = "<tbody>" + body + "</tbody>";
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      };
      _proto.tablerow = function tablerow(content) {
        return "<tr>\n" + content + "</tr>\n";
      };
      _proto.tablecell = function tablecell(content, flags) {
        var type = flags.header ? "th" : "td";
        var tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
        return tag + content + "</" + type + ">\n";
      };
      _proto.strong = function strong(text2) {
        return "<strong>" + text2 + "</strong>";
      };
      _proto.em = function em(text2) {
        return "<em>" + text2 + "</em>";
      };
      _proto.codespan = function codespan(text2) {
        return "<code>" + text2 + "</code>";
      };
      _proto.br = function br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      };
      _proto.del = function del(text2) {
        return "<del>" + text2 + "</del>";
      };
      _proto.link = function link(href, title, text2) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text2;
        }
        var out = '<a href="' + escape$1(href) + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text2 + "</a>";
        return out;
      };
      _proto.image = function image(href, title, text2) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text2;
        }
        var out = '<img src="' + href + '" alt="' + text2 + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      };
      _proto.text = function text2(_text) {
        return _text;
      };
      return Renderer3;
    }();
    var TextRenderer_1 = function() {
      function TextRenderer3() {
      }
      var _proto = TextRenderer3.prototype;
      _proto.strong = function strong(text2) {
        return text2;
      };
      _proto.em = function em(text2) {
        return text2;
      };
      _proto.codespan = function codespan(text2) {
        return text2;
      };
      _proto.del = function del(text2) {
        return text2;
      };
      _proto.html = function html2(text2) {
        return text2;
      };
      _proto.text = function text2(_text) {
        return _text;
      };
      _proto.link = function link(href, title, text2) {
        return "" + text2;
      };
      _proto.image = function image(href, title, text2) {
        return "" + text2;
      };
      _proto.br = function br() {
        return "";
      };
      return TextRenderer3;
    }();
    var Slugger_1 = function() {
      function Slugger3() {
        this.seen = {};
      }
      var _proto = Slugger3.prototype;
      _proto.serialize = function serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      };
      _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {
        var slug = originalSlug;
        var occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      };
      _proto.slug = function slug(value, options) {
        if (options === void 0) {
          options = {};
        }
        var slug2 = this.serialize(value);
        return this.getNextSafeSlug(slug2, options.dryrun);
      };
      return Slugger3;
    }();
    var Renderer$1 = Renderer_1;
    var TextRenderer$1 = TextRenderer_1;
    var Slugger$1 = Slugger_1;
    var defaults$1 = defaults$5.exports.defaults;
    var unescape = helpers.unescape;
    var Parser_1 = function() {
      function Parser3(options) {
        this.options = options || defaults$1;
        this.options.renderer = this.options.renderer || new Renderer$1();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer$1();
        this.slugger = new Slugger$1();
      }
      Parser3.parse = function parse3(tokens, options) {
        var parser2 = new Parser3(options);
        return parser2.parse(tokens);
      };
      Parser3.parseInline = function parseInline(tokens, options) {
        var parser2 = new Parser3(options);
        return parser2.parseInline(tokens);
      };
      var _proto = Parser3.prototype;
      _proto.parse = function parse3(tokens, top) {
        if (top === void 0) {
          top = true;
        }
        var out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
        var l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({
              parser: this
            }, token);
            if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }
            case "code": {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), {
                  header: true,
                  align: token.align[j]
                });
              }
              header += this.renderer.tablerow(cell);
              body = "";
              l2 = token.rows.length;
              for (j = 0; j < l2; j++) {
                row = token.rows[j];
                cell = "";
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), {
                    header: false,
                    align: token.align[k]
                  });
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = "";
              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case "html": {
              out += this.renderer.html(token.text);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case "text": {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i + 1 < l && tokens[i + 1].type === "text") {
                token = tokens[++i];
                body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      };
      _proto.parseInline = function parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        var out = "", i, token, ret;
        var l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({
              parser: this
            }, token);
            if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "escape": {
              out += renderer.text(token.text);
              break;
            }
            case "html": {
              out += renderer.html(token.text);
              break;
            }
            case "link": {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token.text);
              break;
            }
            default: {
              var errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      };
      return Parser3;
    }();
    var Lexer2 = Lexer_1;
    var Parser2 = Parser_1;
    var Tokenizer2 = Tokenizer_1;
    var Renderer2 = Renderer_1;
    var TextRenderer2 = TextRenderer_1;
    var Slugger2 = Slugger_1;
    var merge = helpers.merge, checkSanitizeDeprecation = helpers.checkSanitizeDeprecation, escape2 = helpers.escape;
    var getDefaults = defaults$5.exports.getDefaults, changeDefaults = defaults$5.exports.changeDefaults, defaults = defaults$5.exports.defaults;
    function marked3(src, opt, callback) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      if (typeof opt === "function") {
        callback = opt;
        opt = null;
      }
      opt = merge({}, marked3.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      if (callback) {
        var highlight = opt.highlight;
        var tokens;
        try {
          tokens = Lexer2.lex(src, opt);
        } catch (e) {
          return callback(e);
        }
        var done = function done2(err) {
          var out;
          if (!err) {
            try {
              if (opt.walkTokens) {
                marked3.walkTokens(tokens, opt.walkTokens);
              }
              out = Parser2.parse(tokens, opt);
            } catch (e) {
              err = e;
            }
          }
          opt.highlight = highlight;
          return err ? callback(err) : callback(null, out);
        };
        if (!highlight || highlight.length < 3) {
          return done();
        }
        delete opt.highlight;
        if (!tokens.length)
          return done();
        var pending = 0;
        marked3.walkTokens(tokens, function(token) {
          if (token.type === "code") {
            pending++;
            setTimeout(function() {
              highlight(token.text, token.lang, function(err, code) {
                if (err) {
                  return done(err);
                }
                if (code != null && code !== token.text) {
                  token.text = code;
                  token.escaped = true;
                }
                pending--;
                if (pending === 0) {
                  done();
                }
              });
            }, 0);
          }
        });
        if (pending === 0) {
          done();
        }
        return;
      }
      try {
        var _tokens = Lexer2.lex(src, opt);
        if (opt.walkTokens) {
          marked3.walkTokens(_tokens, opt.walkTokens);
        }
        return Parser2.parse(_tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape2(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    }
    marked3.options = marked3.setOptions = function(opt) {
      merge(marked3.defaults, opt);
      changeDefaults(marked3.defaults);
      return marked3;
    };
    marked3.getDefaults = getDefaults;
    marked3.defaults = defaults;
    marked3.use = function() {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var opts = merge.apply(void 0, [{}].concat(args));
      var extensions = marked3.defaults.extensions || {
        renderers: {},
        childTokens: {}
      };
      var hasExtensions;
      args.forEach(function(pack) {
        if (pack.extensions) {
          hasExtensions = true;
          pack.extensions.forEach(function(ext) {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if (ext.renderer) {
              var prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
              if (prevRenderer) {
                extensions.renderers[ext.name] = function() {
                  for (var _len2 = arguments.length, args2 = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args2[_key2] = arguments[_key2];
                  }
                  var ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if (ext.tokenizer) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              if (extensions[ext.level]) {
                extensions[ext.level].unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if (ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
        }
        if (pack.renderer) {
          (function() {
            var renderer = marked3.defaults.renderer || new Renderer2();
            var _loop = function _loop2(prop2) {
              var prevRenderer = renderer[prop2];
              renderer[prop2] = function() {
                for (var _len3 = arguments.length, args2 = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args2[_key3] = arguments[_key3];
                }
                var ret = pack.renderer[prop2].apply(renderer, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(renderer, args2);
                }
                return ret;
              };
            };
            for (var prop in pack.renderer) {
              _loop(prop);
            }
            opts.renderer = renderer;
          })();
        }
        if (pack.tokenizer) {
          (function() {
            var tokenizer = marked3.defaults.tokenizer || new Tokenizer2();
            var _loop2 = function _loop22(prop2) {
              var prevTokenizer = tokenizer[prop2];
              tokenizer[prop2] = function() {
                for (var _len4 = arguments.length, args2 = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                  args2[_key4] = arguments[_key4];
                }
                var ret = pack.tokenizer[prop2].apply(tokenizer, args2);
                if (ret === false) {
                  ret = prevTokenizer.apply(tokenizer, args2);
                }
                return ret;
              };
            };
            for (var prop in pack.tokenizer) {
              _loop2(prop);
            }
            opts.tokenizer = tokenizer;
          })();
        }
        if (pack.walkTokens) {
          var walkTokens = marked3.defaults.walkTokens;
          opts.walkTokens = function(token) {
            pack.walkTokens.call(_this, token);
            if (walkTokens) {
              walkTokens(token);
            }
          };
        }
        if (hasExtensions) {
          opts.extensions = extensions;
        }
        marked3.setOptions(opts);
      });
    };
    marked3.walkTokens = function(tokens, callback) {
      var _loop3 = function _loop32() {
        var token = _step.value;
        callback(token);
        switch (token.type) {
          case "table": {
            for (var _iterator2 = _createForOfIteratorHelperLoose(token.header), _step2; !(_step2 = _iterator2()).done; ) {
              var cell = _step2.value;
              marked3.walkTokens(cell.tokens, callback);
            }
            for (var _iterator3 = _createForOfIteratorHelperLoose(token.rows), _step3; !(_step3 = _iterator3()).done; ) {
              var row = _step3.value;
              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done; ) {
                var _cell = _step4.value;
                marked3.walkTokens(_cell.tokens, callback);
              }
            }
            break;
          }
          case "list": {
            marked3.walkTokens(token.items, callback);
            break;
          }
          default: {
            if (marked3.defaults.extensions && marked3.defaults.extensions.childTokens && marked3.defaults.extensions.childTokens[token.type]) {
              marked3.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                marked3.walkTokens(token[childTokens], callback);
              });
            } else if (token.tokens) {
              marked3.walkTokens(token.tokens, callback);
            }
          }
        }
      };
      for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done; ) {
        _loop3();
      }
    };
    marked3.parseInline = function(src, opt) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked.parseInline(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      opt = merge({}, marked3.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      try {
        var tokens = Lexer2.lexInline(src, opt);
        if (opt.walkTokens) {
          marked3.walkTokens(tokens, opt.walkTokens);
        }
        return Parser2.parseInline(tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape2(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    };
    marked3.Parser = Parser2;
    marked3.parser = Parser2.parse;
    marked3.Renderer = Renderer2;
    marked3.TextRenderer = TextRenderer2;
    marked3.Lexer = Lexer2;
    marked3.lexer = Lexer2.lex;
    marked3.Tokenizer = Tokenizer2;
    marked3.Slugger = Slugger2;
    marked3.parse = marked3;
    var marked_1 = marked3;
    return marked_1;
  });
})();
var marked = __marked_exports || exports;
var Parser = (__marked_exports || exports).Parser;
var parser = (__marked_exports || exports).parser;
var Renderer = (__marked_exports || exports).Renderer;
var TextRenderer = (__marked_exports || exports).TextRenderer;
var Lexer = (__marked_exports || exports).Lexer;
var lexer = (__marked_exports || exports).lexer;
var Tokenizer = (__marked_exports || exports).Tokenizer;
var Slugger = (__marked_exports || exports).Slugger;
var parse2 = (__marked_exports || exports).parse;

// node_modules/monaco-editor/esm/vs/base/browser/markdownRenderer.js
function renderMarkdown(markdown, options = {}, markedOptions = {}) {
  var _a5;
  const disposables = new DisposableStore();
  let isDisposed = false;
  const cts = disposables.add(new CancellationTokenSource());
  const element = createElement(options);
  const _uriMassage = function(part) {
    let data;
    try {
      data = parse(decodeURIComponent(part));
    } catch (e) {
    }
    if (!data) {
      return part;
    }
    data = cloneAndChange(data, (value2) => {
      if (markdown.uris && markdown.uris[value2]) {
        return URI.revive(markdown.uris[value2]);
      } else {
        return void 0;
      }
    });
    return encodeURIComponent(JSON.stringify(data));
  };
  const _href = function(href, isDomUri) {
    const data = markdown.uris && markdown.uris[href];
    let uri = URI.revive(data);
    if (isDomUri) {
      if (href.startsWith(Schemas.data + ":")) {
        return href;
      }
      if (!uri) {
        uri = URI.parse(href);
      }
      return FileAccess.asBrowserUri(uri).toString(true);
    }
    if (!uri) {
      return href;
    }
    if (URI.parse(href).toString() === uri.toString()) {
      return href;
    }
    if (uri.query) {
      uri = uri.with({ query: _uriMassage(uri.query) });
    }
    return uri.toString();
  };
  let signalInnerHTML;
  const withInnerHTML = new Promise((c) => signalInnerHTML = c);
  const renderer = new Renderer();
  renderer.image = (href, title, text2) => {
    let dimensions = [];
    let attributes = [];
    if (href) {
      ({ href, dimensions } = parseHrefAndDimensions(href));
      attributes.push(`src="${href}"`);
    }
    if (text2) {
      attributes.push(`alt="${text2}"`);
    }
    if (title) {
      attributes.push(`title="${title}"`);
    }
    if (dimensions.length) {
      attributes = attributes.concat(dimensions);
    }
    return "<img " + attributes.join(" ") + ">";
  };
  renderer.link = (href, title, text2) => {
    if (href === text2) {
      text2 = removeMarkdownEscapes(text2);
    }
    href = _href(href, false);
    if (options.baseUrl) {
      const hasScheme = /^\w[\w\d+.-]*:/.test(href);
      if (!hasScheme) {
        href = resolvePath(options.baseUrl, href).toString();
      }
    }
    title = removeMarkdownEscapes(title);
    href = removeMarkdownEscapes(href);
    if (!href || href.match(/^data:|javascript:/i) || href.match(/^command:/i) && !markdown.isTrusted || href.match(/^command:(\/\/\/)?_workbench\.downloadResource/i)) {
      return text2;
    } else {
      href = href.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
      return `<a href="#" data-href="${href}" title="${title || href}">${text2}</a>`;
    }
  };
  renderer.paragraph = (text2) => {
    return `<p>${text2}</p>`;
  };
  if (options.codeBlockRenderer) {
    renderer.code = (code, lang) => {
      const value2 = options.codeBlockRenderer(lang, code);
      const id = defaultGenerator.nextId();
      raceCancellation(Promise.all([value2, withInnerHTML]), cts.token).then((values) => {
        var _a6;
        if (!isDisposed && values) {
          const span = element.querySelector(`div[data-code="${id}"]`);
          if (span) {
            reset(span, values[0]);
          }
          (_a6 = options.asyncRenderCallback) === null || _a6 === void 0 ? void 0 : _a6.call(options);
        }
      }).catch(() => {
      });
      return `<div class="code" data-code="${id}">${escape(code)}</div>`;
    };
  }
  if (options.actionHandler) {
    const onClick = options.actionHandler.disposables.add(new DomEmitter(element, "click"));
    const onAuxClick = options.actionHandler.disposables.add(new DomEmitter(element, "auxclick"));
    options.actionHandler.disposables.add(Event.any(onClick.event, onAuxClick.event)((e) => {
      const mouseEvent = new StandardMouseEvent(e);
      if (!mouseEvent.leftButton && !mouseEvent.middleButton) {
        return;
      }
      let target = mouseEvent.target;
      if (target.tagName !== "A") {
        target = target.parentElement;
        if (!target || target.tagName !== "A") {
          return;
        }
      }
      try {
        const href = target.dataset["href"];
        if (href) {
          options.actionHandler.callback(href, mouseEvent);
        }
      } catch (err) {
        onUnexpectedError(err);
      } finally {
        mouseEvent.preventDefault();
      }
    }));
  }
  if (!markdown.supportHtml) {
    markedOptions.sanitizer = (html2) => {
      const match = markdown.isTrusted ? html2.match(/^(<span[^>]+>)|(<\/\s*span>)$/) : void 0;
      return match ? html2 : "";
    };
    markedOptions.sanitize = true;
    markedOptions.silent = true;
  }
  markedOptions.renderer = renderer;
  let value = (_a5 = markdown.value) !== null && _a5 !== void 0 ? _a5 : "";
  if (value.length > 1e5) {
    value = `${value.substr(0, 1e5)}\u2026`;
  }
  if (markdown.supportThemeIcons) {
    value = markdownEscapeEscapedIcons(value);
  }
  let renderedMarkdown = parse2(value, markedOptions);
  if (markdown.supportThemeIcons) {
    const elements = renderLabelWithIcons(renderedMarkdown);
    renderedMarkdown = elements.map((e) => typeof e === "string" ? e : e.outerHTML).join("");
  }
  const htmlParser = new DOMParser();
  const markdownHtmlDoc = htmlParser.parseFromString(sanitizeRenderedMarkdown(markdown, renderedMarkdown), "text/html");
  markdownHtmlDoc.body.querySelectorAll("img").forEach((img) => {
    if (img.src) {
      let href = _href(img.src, true);
      try {
        const hrefAsUri = URI.parse(href);
        if (options.baseUrl && hrefAsUri.scheme === Schemas.file) {
          href = resolvePath(options.baseUrl, href).toString();
        }
      } catch (err) {
      }
      img.src = href;
    }
  });
  element.innerHTML = sanitizeRenderedMarkdown(markdown, markdownHtmlDoc.body.innerHTML);
  signalInnerHTML();
  if (options.asyncRenderCallback) {
    for (const img of element.getElementsByTagName("img")) {
      const listener = disposables.add(addDisposableListener(img, "load", () => {
        listener.dispose();
        options.asyncRenderCallback();
      }));
    }
  }
  return {
    element,
    dispose: () => {
      isDisposed = true;
      cts.cancel();
      disposables.dispose();
    }
  };
}
function sanitizeRenderedMarkdown(options, renderedMarkdown) {
  const { config, allowedSchemes } = getSanitizerOptions(options);
  addHook("uponSanitizeAttribute", (element, e) => {
    if (e.attrName === "style" || e.attrName === "class") {
      if (element.tagName === "SPAN") {
        if (e.attrName === "style") {
          e.keepAttr = /^(color\:#[0-9a-fA-F]+;)?(background-color\:#[0-9a-fA-F]+;)?$/.test(e.attrValue);
          return;
        } else if (e.attrName === "class") {
          e.keepAttr = /^codicon codicon-[a-z\-]+( codicon-modifier-[a-z\-]+)?$/.test(e.attrValue);
          return;
        }
      }
      e.keepAttr = false;
      return;
    }
  });
  const anchor = document.createElement("a");
  addHook("afterSanitizeAttributes", (node) => {
    for (const attr of ["href", "src"]) {
      if (node.hasAttribute(attr)) {
        anchor.href = node.getAttribute(attr);
        if (!allowedSchemes.includes(anchor.protocol.replace(/:$/, ""))) {
          node.removeAttribute(attr);
        }
      }
    }
  });
  try {
    return sanitize(renderedMarkdown, Object.assign(Object.assign({}, config), { RETURN_TRUSTED_TYPE: true }));
  } finally {
    removeHook("uponSanitizeAttribute");
    removeHook("afterSanitizeAttributes");
  }
}
function getSanitizerOptions(options) {
  const allowedSchemes = [
    Schemas.http,
    Schemas.https,
    Schemas.mailto,
    Schemas.data,
    Schemas.file,
    Schemas.vscodeFileResource,
    Schemas.vscodeRemote,
    Schemas.vscodeRemoteResource
  ];
  if (options.isTrusted) {
    allowedSchemes.push(Schemas.command);
  }
  return {
    config: {
      ALLOWED_TAGS: ["ul", "li", "p", "b", "i", "code", "blockquote", "ol", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "em", "pre", "table", "thead", "tbody", "tr", "th", "td", "div", "del", "a", "strong", "br", "img", "span"],
      ALLOWED_ATTR: ["href", "data-href", "target", "title", "src", "alt", "class", "style", "data-code", "width", "height", "align"],
      ALLOW_UNKNOWN_PROTOCOLS: true
    },
    allowedSchemes
  };
}

// node_modules/monaco-editor/esm/vs/editor/browser/core/markdownRenderer.js
var __decorate19 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param19 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a2;
var MarkdownRenderer = class MarkdownRenderer2 {
  constructor(_options, _modeService, _openerService) {
    this._options = _options;
    this._modeService = _modeService;
    this._openerService = _openerService;
    this._onDidRenderAsync = new Emitter();
    this.onDidRenderAsync = this._onDidRenderAsync.event;
  }
  dispose() {
    this._onDidRenderAsync.dispose();
  }
  render(markdown, options, markedOptions) {
    if (!markdown) {
      const element = document.createElement("span");
      return { element, dispose: () => {
      } };
    }
    const disposables = new DisposableStore();
    const rendered = disposables.add(renderMarkdown(markdown, Object.assign(Object.assign({}, this._getRenderOptions(markdown, disposables)), options), markedOptions));
    return {
      element: rendered.element,
      dispose: () => disposables.dispose()
    };
  }
  _getRenderOptions(markdown, disposeables) {
    return {
      baseUrl: this._options.baseUrl,
      codeBlockRenderer: (languageAlias, value) => __awaiter17(this, void 0, void 0, function* () {
        var _a5, _b2, _c2, _d2;
        let languageId;
        if (languageAlias) {
          languageId = this._modeService.getModeIdForLanguageName(languageAlias);
        } else if (this._options.editor) {
          languageId = (_a5 = this._options.editor.getModel()) === null || _a5 === void 0 ? void 0 : _a5.getLanguageId();
        }
        if (!languageId) {
          languageId = "plaintext";
        }
        this._modeService.triggerMode(languageId);
        const tokenization = (_b2 = yield TokenizationRegistry.getPromise(languageId)) !== null && _b2 !== void 0 ? _b2 : void 0;
        const element = document.createElement("span");
        element.innerHTML = (_d2 = (_c2 = MarkdownRenderer2._ttpTokenizer) === null || _c2 === void 0 ? void 0 : _c2.createHTML(value, this._modeService.languageIdCodec, tokenization)) !== null && _d2 !== void 0 ? _d2 : tokenizeToString(value, this._modeService.languageIdCodec, tokenization);
        if (this._options.editor) {
          const fontInfo = this._options.editor.getOption(43);
          Configuration.applyFontInfoSlow(element, fontInfo);
        } else if (this._options.codeBlockFontFamily) {
          element.style.fontFamily = this._options.codeBlockFontFamily;
        }
        return element;
      }),
      asyncRenderCallback: () => this._onDidRenderAsync.fire(),
      actionHandler: {
        callback: (content) => this._openerService.open(content, { fromUserGesture: true, allowContributedOpeners: true, allowCommands: markdown.isTrusted }).catch(onUnexpectedError),
        disposables: disposeables
      }
    };
  }
};
MarkdownRenderer._ttpTokenizer = (_a2 = window.trustedTypes) === null || _a2 === void 0 ? void 0 : _a2.createPolicy("tokenizeToString", {
  createHTML(value, languageIdCodec, tokenizer) {
    return tokenizeToString(value, languageIdCodec, tokenizer);
  }
});
MarkdownRenderer = __decorate19([
  __param19(1, IModeService),
  __param19(2, IOpenerService)
], MarkdownRenderer);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/getHover.js
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var HoverProviderResult = class {
  constructor(provider, hover, ordinal) {
    this.provider = provider;
    this.hover = hover;
    this.ordinal = ordinal;
  }
};
function executeProvider(provider, ordinal, model, position, token) {
  return __awaiter18(this, void 0, void 0, function* () {
    try {
      const result = yield Promise.resolve(provider.provideHover(model, position, token));
      if (result && isValid(result)) {
        return new HoverProviderResult(provider, result, ordinal);
      }
    } catch (err) {
      onUnexpectedExternalError(err);
    }
    return void 0;
  });
}
function getHover(model, position, token) {
  const providers = HoverProviderRegistry.ordered(model);
  const promises = providers.map((provider, index) => executeProvider(provider, index, model, position, token));
  return AsyncIterableObject.fromPromises(promises).coalesce();
}
function getHoverPromise(model, position, token) {
  return getHover(model, position, token).map((item) => item.hover).toPromise();
}
registerModelAndPositionCommand("_executeHoverProvider", (model, position) => getHoverPromise(model, position, CancellationToken.None));
function isValid(result) {
  const hasRange = typeof result.range !== "undefined";
  const hasHtmlContent = typeof result.contents !== "undefined" && result.contents && result.contents.length > 0;
  return hasRange && hasHtmlContent;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/markdownHoverParticipant.js
var __decorate20 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param20 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $4 = $;
var MarkdownHover = class {
  constructor(owner, range, contents, ordinal) {
    this.owner = owner;
    this.range = range;
    this.contents = contents;
    this.ordinal = ordinal;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
};
var MarkdownHoverParticipant = class MarkdownHoverParticipant2 {
  constructor(_editor, _hover, _modeService, _openerService, _configurationService) {
    this._editor = _editor;
    this._hover = _hover;
    this._modeService = _modeService;
    this._openerService = _openerService;
    this._configurationService = _configurationService;
  }
  createLoadingMessage(anchor) {
    return new MarkdownHover(this, anchor.range, [new MarkdownString().appendText(localize("modesContentHover.loading", "Loading..."))], 2e3);
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return [];
    }
    const model = this._editor.getModel();
    const lineNumber = anchor.range.startLineNumber;
    const maxColumn = model.getLineMaxColumn(lineNumber);
    const result = [];
    let index = 1e3;
    const lineLength = model.getLineLength(lineNumber);
    const languageId = model.getLanguageIdAtPosition(anchor.range.startLineNumber, anchor.range.startColumn);
    const maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: languageId
    });
    if (typeof maxTokenizationLineLength === "number" && lineLength >= maxTokenizationLineLength) {
      result.push(new MarkdownHover(this, anchor.range, [{
        value: localize("too many characters", "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")
      }], index++));
    }
    for (const d of lineDecorations) {
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      const hoverMessage = d.options.hoverMessage;
      if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {
        continue;
      }
      const range = new Range(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
      result.push(new MarkdownHover(this, range, asArray(hoverMessage), index++));
    }
    return result;
  }
  computeAsync(anchor, lineDecorations, token) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return AsyncIterableObject.EMPTY;
    }
    const model = this._editor.getModel();
    if (!HoverProviderRegistry.has(model)) {
      return AsyncIterableObject.EMPTY;
    }
    const position = new Position(anchor.range.startLineNumber, anchor.range.startColumn);
    return getHover(model, position, token).filter((item) => !isEmptyMarkdownString(item.hover.contents)).map((item) => {
      const rng = item.hover.range ? Range.lift(item.hover.range) : anchor.range;
      return new MarkdownHover(this, rng, item.hover.contents, item.ordinal);
    });
  }
  renderHoverParts(hoverParts, fragment, statusBar) {
    return renderMarkdownHovers(hoverParts, fragment, this._editor, this._hover, this._modeService, this._openerService);
  }
};
MarkdownHoverParticipant = __decorate20([
  __param20(2, IModeService),
  __param20(3, IOpenerService),
  __param20(4, IConfigurationService)
], MarkdownHoverParticipant);
function renderMarkdownHovers(hoverParts, fragment, editor2, hover, modeService, openerService) {
  hoverParts.sort((a, b) => a.ordinal - b.ordinal);
  const disposables = new DisposableStore();
  for (const hoverPart of hoverParts) {
    for (const contents of hoverPart.contents) {
      if (isEmptyMarkdownString(contents)) {
        continue;
      }
      const markdownHoverElement = $4("div.hover-row.markdown-hover");
      const hoverContentsElement = append(markdownHoverElement, $4("div.hover-contents"));
      const renderer = disposables.add(new MarkdownRenderer({ editor: editor2 }, modeService, openerService));
      disposables.add(renderer.onDidRenderAsync(() => {
        hoverContentsElement.className = "hover-contents code-hover-contents";
        hover.onContentsChanged();
      }));
      const renderedContents = disposables.add(renderer.render(contents));
      hoverContentsElement.appendChild(renderedContents.element);
      fragment.appendChild(markdownHoverElement);
    }
  }
  return disposables;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/markerNavigationService.js
var __decorate21 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param21 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MarkerCoordinate = class {
  constructor(marker, index, total) {
    this.marker = marker;
    this.index = index;
    this.total = total;
  }
};
var MarkerList = class MarkerList2 {
  constructor(resourceFilter, _markerService, _configService) {
    this._markerService = _markerService;
    this._configService = _configService;
    this._onDidChange = new Emitter();
    this.onDidChange = this._onDidChange.event;
    this._dispoables = new DisposableStore();
    this._markers = [];
    this._nextIdx = -1;
    if (URI.isUri(resourceFilter)) {
      this._resourceFilter = (uri) => uri.toString() === resourceFilter.toString();
    } else if (resourceFilter) {
      this._resourceFilter = resourceFilter;
    }
    const compareOrder = this._configService.getValue("problems.sortOrder");
    const compareMarker = (a, b) => {
      let res = compare(a.resource.toString(), b.resource.toString());
      if (compareOrder === "position") {
        res = Range.compareRangesUsingStarts(a, b) || MarkerSeverity.compare(a.severity, b.severity);
      } else {
        res = MarkerSeverity.compare(a.severity, b.severity) || Range.compareRangesUsingStarts(a, b);
      }
      return res;
    };
    const updateMarker = () => {
      this._markers = this._markerService.read({
        resource: URI.isUri(resourceFilter) ? resourceFilter : void 0,
        severities: MarkerSeverity.Error | MarkerSeverity.Warning | MarkerSeverity.Info
      });
      if (typeof resourceFilter === "function") {
        this._markers = this._markers.filter((m) => this._resourceFilter(m.resource));
      }
      this._markers.sort(compareMarker);
    };
    updateMarker();
    this._dispoables.add(_markerService.onMarkerChanged((uris) => {
      if (!this._resourceFilter || uris.some((uri) => this._resourceFilter(uri))) {
        updateMarker();
        this._nextIdx = -1;
        this._onDidChange.fire();
      }
    }));
  }
  dispose() {
    this._dispoables.dispose();
    this._onDidChange.dispose();
  }
  matches(uri) {
    if (!this._resourceFilter && !uri) {
      return true;
    }
    if (!this._resourceFilter || !uri) {
      return false;
    }
    return this._resourceFilter(uri);
  }
  get selected() {
    const marker = this._markers[this._nextIdx];
    return marker && new MarkerCoordinate(marker, this._nextIdx + 1, this._markers.length);
  }
  _initIdx(model, position, fwd) {
    let found = false;
    let idx = this._markers.findIndex((marker) => marker.resource.toString() === model.uri.toString());
    if (idx < 0) {
      idx = binarySearch(this._markers, { resource: model.uri }, (a, b) => compare(a.resource.toString(), b.resource.toString()));
      if (idx < 0) {
        idx = ~idx;
      }
    }
    for (let i = idx; i < this._markers.length; i++) {
      let range = Range.lift(this._markers[i]);
      if (range.isEmpty()) {
        const word = model.getWordAtPosition(range.getStartPosition());
        if (word) {
          range = new Range(range.startLineNumber, word.startColumn, range.startLineNumber, word.endColumn);
        }
      }
      if (position && (range.containsPosition(position) || position.isBeforeOrEqual(range.getStartPosition()))) {
        this._nextIdx = i;
        found = true;
        break;
      }
      if (this._markers[i].resource.toString() !== model.uri.toString()) {
        break;
      }
    }
    if (!found) {
      this._nextIdx = fwd ? 0 : this._markers.length - 1;
    }
    if (this._nextIdx < 0) {
      this._nextIdx = this._markers.length - 1;
    }
  }
  resetIndex() {
    this._nextIdx = -1;
  }
  move(fwd, model, position) {
    if (this._markers.length === 0) {
      return false;
    }
    let oldIdx = this._nextIdx;
    if (this._nextIdx === -1) {
      this._initIdx(model, position, fwd);
    } else if (fwd) {
      this._nextIdx = (this._nextIdx + 1) % this._markers.length;
    } else if (!fwd) {
      this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length;
    }
    if (oldIdx !== this._nextIdx) {
      return true;
    }
    return false;
  }
  find(uri, position) {
    let idx = this._markers.findIndex((marker) => marker.resource.toString() === uri.toString());
    if (idx < 0) {
      return void 0;
    }
    for (; idx < this._markers.length; idx++) {
      if (Range.containsPosition(this._markers[idx], position)) {
        return new MarkerCoordinate(this._markers[idx], idx + 1, this._markers.length);
      }
    }
    return void 0;
  }
};
MarkerList = __decorate21([
  __param21(1, IMarkerService),
  __param21(2, IConfigurationService)
], MarkerList);
var IMarkerNavigationService = createDecorator("IMarkerNavigationService");
var MarkerNavigationService = class MarkerNavigationService2 {
  constructor(_markerService, _configService) {
    this._markerService = _markerService;
    this._configService = _configService;
    this._provider = new LinkedList();
  }
  getMarkerList(resource) {
    for (let provider of this._provider) {
      const result = provider.getMarkerList(resource);
      if (result) {
        return result;
      }
    }
    return new MarkerList(resource, this._markerService, this._configService);
  }
};
MarkerNavigationService = __decorate21([
  __param21(0, IMarkerService),
  __param21(1, IConfigurationService)
], MarkerNavigationService);
registerSingleton(IMarkerNavigationService, MarkerNavigationService, true);

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/gotoErrorWidget.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/media/gotoErrorWidget.css";

// node_modules/monaco-editor/esm/vs/platform/severityIcon/common/severityIcon.js
var SeverityIcon;
(function(SeverityIcon2) {
  function className(severity) {
    switch (severity) {
      case severity_default.Ignore:
        return "severity-ignore " + Codicon.info.classNames;
      case severity_default.Info:
        return Codicon.info.classNames;
      case severity_default.Warning:
        return Codicon.warning.classNames;
      case severity_default.Error:
        return Codicon.error.classNames;
      default:
        return "";
    }
  }
  SeverityIcon2.className = className;
})(SeverityIcon || (SeverityIcon = {}));
registerThemingParticipant((theme, collector) => {
  const errorIconForeground = theme.getColor(problemsErrorIconForeground);
  if (errorIconForeground) {
    const errorCodiconSelector = Codicon.error.cssSelector;
    collector.addRule(`
			.monaco-editor .zone-widget ${errorCodiconSelector},
			.markers-panel .marker-icon${errorCodiconSelector},
			.text-search-provider-messages .providerMessage ${errorCodiconSelector},
			.extensions-viewlet > .extensions ${errorCodiconSelector} {
				color: ${errorIconForeground};
			}
		`);
  }
  const warningIconForeground = theme.getColor(problemsWarningIconForeground);
  if (warningIconForeground) {
    const warningCodiconSelector = Codicon.warning.cssSelector;
    collector.addRule(`
			.monaco-editor .zone-widget ${warningCodiconSelector},
			.markers-panel .marker-icon${warningCodiconSelector},
			.extensions-viewlet > .extensions ${warningCodiconSelector},
			.extension-editor ${warningCodiconSelector},
			.text-search-provider-messages .providerMessage ${warningCodiconSelector},
			.preferences-editor ${warningCodiconSelector} {
				color: ${warningIconForeground};
			}
		`);
  }
  const infoIconForeground = theme.getColor(problemsInfoIconForeground);
  if (infoIconForeground) {
    const infoCodiconSelector = Codicon.info.cssSelector;
    collector.addRule(`
			.monaco-editor .zone-widget ${infoCodiconSelector},
			.markers-panel .marker-icon${infoCodiconSelector},
			.extensions-viewlet > .extensions ${infoCodiconSelector},
			.text-search-provider-messages .providerMessage ${infoCodiconSelector},
			.extension-editor ${infoCodiconSelector} {
				color: ${infoIconForeground};
			}
		`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/gotoErrorWidget.js
var __decorate22 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param22 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MessageWidget2 = class {
  constructor(parent, editor2, onRelatedInformation, _openerService, _labelService) {
    this._openerService = _openerService;
    this._labelService = _labelService;
    this._lines = 0;
    this._longestLineLength = 0;
    this._relatedDiagnostics = new WeakMap();
    this._disposables = new DisposableStore();
    this._editor = editor2;
    const domNode = document.createElement("div");
    domNode.className = "descriptioncontainer";
    this._messageBlock = document.createElement("div");
    this._messageBlock.classList.add("message");
    this._messageBlock.setAttribute("aria-live", "assertive");
    this._messageBlock.setAttribute("role", "alert");
    domNode.appendChild(this._messageBlock);
    this._relatedBlock = document.createElement("div");
    domNode.appendChild(this._relatedBlock);
    this._disposables.add(addStandardDisposableListener(this._relatedBlock, "click", (event) => {
      event.preventDefault();
      const related = this._relatedDiagnostics.get(event.target);
      if (related) {
        onRelatedInformation(related);
      }
    }));
    this._scrollable = new ScrollableElement(domNode, {
      horizontal: 1,
      vertical: 1,
      useShadows: false,
      horizontalScrollbarSize: 6,
      verticalScrollbarSize: 6
    });
    parent.appendChild(this._scrollable.getDomNode());
    this._disposables.add(this._scrollable.onScroll((e) => {
      domNode.style.left = `-${e.scrollLeft}px`;
      domNode.style.top = `-${e.scrollTop}px`;
    }));
    this._disposables.add(this._scrollable);
  }
  dispose() {
    dispose(this._disposables);
  }
  update(marker) {
    const { source, message, relatedInformation, code } = marker;
    let sourceAndCodeLength = ((source === null || source === void 0 ? void 0 : source.length) || 0) + "()".length;
    if (code) {
      if (typeof code === "string") {
        sourceAndCodeLength += code.length;
      } else {
        sourceAndCodeLength += code.value.length;
      }
    }
    const lines = splitLines(message);
    this._lines = lines.length;
    this._longestLineLength = 0;
    for (const line of lines) {
      this._longestLineLength = Math.max(line.length + sourceAndCodeLength, this._longestLineLength);
    }
    clearNode(this._messageBlock);
    this._messageBlock.setAttribute("aria-label", this.getAriaLabel(marker));
    this._editor.applyFontInfo(this._messageBlock);
    let lastLineElement = this._messageBlock;
    for (const line of lines) {
      lastLineElement = document.createElement("div");
      lastLineElement.innerText = line;
      if (line === "") {
        lastLineElement.style.height = this._messageBlock.style.lineHeight;
      }
      this._messageBlock.appendChild(lastLineElement);
    }
    if (source || code) {
      const detailsElement = document.createElement("span");
      detailsElement.classList.add("details");
      lastLineElement.appendChild(detailsElement);
      if (source) {
        const sourceElement = document.createElement("span");
        sourceElement.innerText = source;
        sourceElement.classList.add("source");
        detailsElement.appendChild(sourceElement);
      }
      if (code) {
        if (typeof code === "string") {
          const codeElement = document.createElement("span");
          codeElement.innerText = `(${code})`;
          codeElement.classList.add("code");
          detailsElement.appendChild(codeElement);
        } else {
          this._codeLink = $("a.code-link");
          this._codeLink.setAttribute("href", `${code.target.toString()}`);
          this._codeLink.onclick = (e) => {
            this._openerService.open(code.target, { allowCommands: true });
            e.preventDefault();
            e.stopPropagation();
          };
          const codeElement = append(this._codeLink, $("span"));
          codeElement.innerText = code.value;
          detailsElement.appendChild(this._codeLink);
        }
      }
    }
    clearNode(this._relatedBlock);
    this._editor.applyFontInfo(this._relatedBlock);
    if (isNonEmptyArray(relatedInformation)) {
      const relatedInformationNode = this._relatedBlock.appendChild(document.createElement("div"));
      relatedInformationNode.style.paddingTop = `${Math.floor(this._editor.getOption(58) * 0.66)}px`;
      this._lines += 1;
      for (const related of relatedInformation) {
        let container = document.createElement("div");
        let relatedResource = document.createElement("a");
        relatedResource.classList.add("filename");
        relatedResource.innerText = `${getBaseLabel(related.resource)}(${related.startLineNumber}, ${related.startColumn}): `;
        relatedResource.title = this._labelService.getUriLabel(related.resource);
        this._relatedDiagnostics.set(relatedResource, related);
        let relatedMessage = document.createElement("span");
        relatedMessage.innerText = related.message;
        container.appendChild(relatedResource);
        container.appendChild(relatedMessage);
        this._lines += 1;
        relatedInformationNode.appendChild(container);
      }
    }
    const fontInfo = this._editor.getOption(43);
    const scrollWidth = Math.ceil(fontInfo.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75);
    const scrollHeight = fontInfo.lineHeight * this._lines;
    this._scrollable.setScrollDimensions({ scrollWidth, scrollHeight });
  }
  layout(height, width) {
    this._scrollable.getDomNode().style.height = `${height}px`;
    this._scrollable.getDomNode().style.width = `${width}px`;
    this._scrollable.setScrollDimensions({ width, height });
  }
  getHeightInLines() {
    return Math.min(17, this._lines);
  }
  getAriaLabel(marker) {
    let severityLabel = "";
    switch (marker.severity) {
      case MarkerSeverity.Error:
        severityLabel = localize("Error", "Error");
        break;
      case MarkerSeverity.Warning:
        severityLabel = localize("Warning", "Warning");
        break;
      case MarkerSeverity.Info:
        severityLabel = localize("Info", "Info");
        break;
      case MarkerSeverity.Hint:
        severityLabel = localize("Hint", "Hint");
        break;
    }
    let ariaLabel = localize("marker aria", "{0} at {1}. ", severityLabel, marker.startLineNumber + ":" + marker.startColumn);
    const model = this._editor.getModel();
    if (model && marker.startLineNumber <= model.getLineCount() && marker.startLineNumber >= 1) {
      const lineContent = model.getLineContent(marker.startLineNumber);
      ariaLabel = `${lineContent}, ${ariaLabel}`;
    }
    return ariaLabel;
  }
};
var MarkerNavigationWidget = class MarkerNavigationWidget2 extends PeekViewWidget {
  constructor(editor2, _themeService, _openerService, _menuService, instantiationService, _contextKeyService, _labelService) {
    super(editor2, { showArrow: true, showFrame: true, isAccessible: true, frameWidth: 1 }, instantiationService);
    this._themeService = _themeService;
    this._openerService = _openerService;
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._labelService = _labelService;
    this._callOnDispose = new DisposableStore();
    this._onDidSelectRelatedInformation = new Emitter();
    this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event;
    this._severity = MarkerSeverity.Warning;
    this._backgroundColor = Color.white;
    this._applyTheme(_themeService.getColorTheme());
    this._callOnDispose.add(_themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
    this.create();
  }
  _applyTheme(theme) {
    this._backgroundColor = theme.getColor(editorMarkerNavigationBackground);
    let colorId = editorMarkerNavigationError;
    let headerBackground = editorMarkerNavigationErrorHeader;
    if (this._severity === MarkerSeverity.Warning) {
      colorId = editorMarkerNavigationWarning;
      headerBackground = editorMarkerNavigationWarningHeader;
    } else if (this._severity === MarkerSeverity.Info) {
      colorId = editorMarkerNavigationInfo;
      headerBackground = editorMarkerNavigationInfoHeader;
    }
    const frameColor = theme.getColor(colorId);
    const headerBg = theme.getColor(headerBackground);
    this.style({
      arrowColor: frameColor,
      frameColor,
      headerBackgroundColor: headerBg,
      primaryHeadingColor: theme.getColor(peekViewTitleForeground),
      secondaryHeadingColor: theme.getColor(peekViewTitleInfoForeground)
    });
  }
  _applyStyles() {
    if (this._parentContainer) {
      this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : "";
    }
    super._applyStyles();
  }
  dispose() {
    this._callOnDispose.dispose();
    super.dispose();
  }
  _fillHead(container) {
    super._fillHead(container);
    this._disposables.add(this._actionbarWidget.actionRunner.onBeforeRun((e) => this.editor.focus()));
    const actions = [];
    const menu = this._menuService.createMenu(MarkerNavigationWidget2.TitleMenu, this._contextKeyService);
    createAndFillInActionBarActions(menu, void 0, actions);
    this._actionbarWidget.push(actions, { label: false, icon: true, index: 0 });
    menu.dispose();
  }
  _fillTitleIcon(container) {
    this._icon = append(container, $(""));
  }
  _fillBody(container) {
    this._parentContainer = container;
    container.classList.add("marker-widget");
    this._parentContainer.tabIndex = 0;
    this._parentContainer.setAttribute("role", "tooltip");
    this._container = document.createElement("div");
    container.appendChild(this._container);
    this._message = new MessageWidget2(this._container, this.editor, (related) => this._onDidSelectRelatedInformation.fire(related), this._openerService, this._labelService);
    this._disposables.add(this._message);
  }
  show() {
    throw new Error("call showAtMarker");
  }
  showAtMarker(marker, markerIdx, markerCount) {
    this._container.classList.remove("stale");
    this._message.update(marker);
    this._severity = marker.severity;
    this._applyTheme(this._themeService.getColorTheme());
    let range = Range.lift(marker);
    const editorPosition = this.editor.getPosition();
    let position = editorPosition && range.containsPosition(editorPosition) ? editorPosition : range.getStartPosition();
    super.show(position, this.computeRequiredHeight());
    const model = this.editor.getModel();
    if (model) {
      const detail = markerCount > 1 ? localize("problems", "{0} of {1} problems", markerIdx, markerCount) : localize("change", "{0} of {1} problem", markerIdx, markerCount);
      this.setTitle(basename2(model.uri), detail);
    }
    this._icon.className = `codicon ${SeverityIcon.className(MarkerSeverity.toSeverity(this._severity))}`;
    this.editor.revealPositionNearTop(position, 0);
    this.editor.focus();
  }
  updateMarker(marker) {
    this._container.classList.remove("stale");
    this._message.update(marker);
  }
  showStale() {
    this._container.classList.add("stale");
    this._relayout();
  }
  _doLayoutBody(heightInPixel, widthInPixel) {
    super._doLayoutBody(heightInPixel, widthInPixel);
    this._heightInPixel = heightInPixel;
    this._message.layout(heightInPixel, widthInPixel);
    this._container.style.height = `${heightInPixel}px`;
  }
  _onWidth(widthInPixel) {
    this._message.layout(this._heightInPixel, widthInPixel);
  }
  _relayout() {
    super._relayout(this.computeRequiredHeight());
  }
  computeRequiredHeight() {
    return 3 + this._message.getHeightInLines();
  }
};
MarkerNavigationWidget.TitleMenu = new MenuId("gotoErrorTitleMenu");
MarkerNavigationWidget = __decorate22([
  __param22(1, IThemeService),
  __param22(2, IOpenerService),
  __param22(3, IMenuService),
  __param22(4, IInstantiationService),
  __param22(5, IContextKeyService),
  __param22(6, ILabelService)
], MarkerNavigationWidget);
var errorDefault = oneOf(editorErrorForeground, editorErrorBorder);
var warningDefault = oneOf(editorWarningForeground, editorWarningBorder);
var infoDefault = oneOf(editorInfoForeground, editorInfoBorder);
var editorMarkerNavigationError = registerColor("editorMarkerNavigationError.background", { dark: errorDefault, light: errorDefault, hc: contrastBorder }, localize("editorMarkerNavigationError", "Editor marker navigation widget error color."));
var editorMarkerNavigationErrorHeader = registerColor("editorMarkerNavigationError.headerBackground", { dark: transparent(editorMarkerNavigationError, 0.1), light: transparent(editorMarkerNavigationError, 0.1), hc: null }, localize("editorMarkerNavigationErrorHeaderBackground", "Editor marker navigation widget error heading background."));
var editorMarkerNavigationWarning = registerColor("editorMarkerNavigationWarning.background", { dark: warningDefault, light: warningDefault, hc: contrastBorder }, localize("editorMarkerNavigationWarning", "Editor marker navigation widget warning color."));
var editorMarkerNavigationWarningHeader = registerColor("editorMarkerNavigationWarning.headerBackground", { dark: transparent(editorMarkerNavigationWarning, 0.1), light: transparent(editorMarkerNavigationWarning, 0.1), hc: "#0C141F" }, localize("editorMarkerNavigationWarningBackground", "Editor marker navigation widget warning heading background."));
var editorMarkerNavigationInfo = registerColor("editorMarkerNavigationInfo.background", { dark: infoDefault, light: infoDefault, hc: contrastBorder }, localize("editorMarkerNavigationInfo", "Editor marker navigation widget info color."));
var editorMarkerNavigationInfoHeader = registerColor("editorMarkerNavigationInfo.headerBackground", { dark: transparent(editorMarkerNavigationInfo, 0.1), light: transparent(editorMarkerNavigationInfo, 0.1), hc: null }, localize("editorMarkerNavigationInfoHeaderBackground", "Editor marker navigation widget info heading background."));
var editorMarkerNavigationBackground = registerColor("editorMarkerNavigation.background", { dark: editorBackground, light: editorBackground, hc: editorBackground }, localize("editorMarkerNavigationBackground", "Editor marker navigation widget background."));

// node_modules/monaco-editor/esm/vs/editor/contrib/gotoError/gotoError.js
var __decorate23 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param23 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MarkerController = class MarkerController2 {
  constructor(editor2, _markerNavigationService, _contextKeyService, _editorService, _instantiationService) {
    this._markerNavigationService = _markerNavigationService;
    this._contextKeyService = _contextKeyService;
    this._editorService = _editorService;
    this._instantiationService = _instantiationService;
    this._sessionDispoables = new DisposableStore();
    this._editor = editor2;
    this._widgetVisible = CONTEXT_MARKERS_NAVIGATION_VISIBLE.bindTo(this._contextKeyService);
  }
  static get(editor2) {
    return editor2.getContribution(MarkerController2.ID);
  }
  dispose() {
    this._cleanUp();
    this._sessionDispoables.dispose();
  }
  _cleanUp() {
    this._widgetVisible.reset();
    this._sessionDispoables.clear();
    this._widget = void 0;
    this._model = void 0;
  }
  _getOrCreateModel(uri) {
    if (this._model && this._model.matches(uri)) {
      return this._model;
    }
    let reusePosition = false;
    if (this._model) {
      reusePosition = true;
      this._cleanUp();
    }
    this._model = this._markerNavigationService.getMarkerList(uri);
    if (reusePosition) {
      this._model.move(true, this._editor.getModel(), this._editor.getPosition());
    }
    this._widget = this._instantiationService.createInstance(MarkerNavigationWidget, this._editor);
    this._widget.onDidClose(() => this.close(), this, this._sessionDispoables);
    this._widgetVisible.set(true);
    this._sessionDispoables.add(this._model);
    this._sessionDispoables.add(this._widget);
    this._sessionDispoables.add(this._editor.onDidChangeCursorPosition((e) => {
      var _a5, _b2, _c2;
      if (!((_a5 = this._model) === null || _a5 === void 0 ? void 0 : _a5.selected) || !Range.containsPosition((_b2 = this._model) === null || _b2 === void 0 ? void 0 : _b2.selected.marker, e.position)) {
        (_c2 = this._model) === null || _c2 === void 0 ? void 0 : _c2.resetIndex();
      }
    }));
    this._sessionDispoables.add(this._model.onDidChange(() => {
      if (!this._widget || !this._widget.position || !this._model) {
        return;
      }
      const info = this._model.find(this._editor.getModel().uri, this._widget.position);
      if (info) {
        this._widget.updateMarker(info.marker);
      } else {
        this._widget.showStale();
      }
    }));
    this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation((related) => {
      this._editorService.openCodeEditor({
        resource: related.resource,
        options: { pinned: true, revealIfOpened: true, selection: Range.lift(related).collapseToStart() }
      }, this._editor);
      this.close(false);
    }));
    this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp()));
    return this._model;
  }
  close(focusEditor = true) {
    this._cleanUp();
    if (focusEditor) {
      this._editor.focus();
    }
  }
  showAtMarker(marker) {
    if (this._editor.hasModel()) {
      const model = this._getOrCreateModel(this._editor.getModel().uri);
      model.resetIndex();
      model.move(true, this._editor.getModel(), new Position(marker.startLineNumber, marker.startColumn));
      if (model.selected) {
        this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
      }
    }
  }
  nagivate(next, multiFile) {
    return __awaiter19(this, void 0, void 0, function* () {
      if (this._editor.hasModel()) {
        const model = this._getOrCreateModel(multiFile ? void 0 : this._editor.getModel().uri);
        model.move(next, this._editor.getModel(), this._editor.getPosition());
        if (!model.selected) {
          return;
        }
        if (model.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
          this._cleanUp();
          const otherEditor = yield this._editorService.openCodeEditor({
            resource: model.selected.marker.resource,
            options: { pinned: false, revealIfOpened: true, selectionRevealType: 2, selection: model.selected.marker }
          }, this._editor);
          if (otherEditor) {
            MarkerController2.get(otherEditor).close();
            MarkerController2.get(otherEditor).nagivate(next, multiFile);
          }
        } else {
          this._widget.showAtMarker(model.selected.marker, model.selected.index, model.selected.total);
        }
      }
    });
  }
};
MarkerController.ID = "editor.contrib.markerController";
MarkerController = __decorate23([
  __param23(1, IMarkerNavigationService),
  __param23(2, IContextKeyService),
  __param23(3, ICodeEditorService),
  __param23(4, IInstantiationService)
], MarkerController);
var MarkerNavigationAction = class extends EditorAction {
  constructor(_next, _multiFile, opts) {
    super(opts);
    this._next = _next;
    this._multiFile = _multiFile;
  }
  run(_accessor, editor2) {
    return __awaiter19(this, void 0, void 0, function* () {
      if (editor2.hasModel()) {
        MarkerController.get(editor2).nagivate(this._next, this._multiFile);
      }
    });
  }
};
var NextMarkerAction = class extends MarkerNavigationAction {
  constructor() {
    super(true, false, {
      id: NextMarkerAction.ID,
      label: NextMarkerAction.LABEL,
      alias: "Go to Next Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 512 | 66,
        weight: 100
      },
      menuOpts: {
        menuId: MarkerNavigationWidget.TitleMenu,
        title: NextMarkerAction.LABEL,
        icon: registerIcon("marker-navigation-next", Codicon.arrowDown, localize("nextMarkerIcon", "Icon for goto next marker.")),
        group: "navigation",
        order: 1
      }
    });
  }
};
NextMarkerAction.ID = "editor.action.marker.next";
NextMarkerAction.LABEL = localize("markerAction.next.label", "Go to Next Problem (Error, Warning, Info)");
var PrevMarkerAction = class extends MarkerNavigationAction {
  constructor() {
    super(false, false, {
      id: PrevMarkerAction.ID,
      label: PrevMarkerAction.LABEL,
      alias: "Go to Previous Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 1024 | 512 | 66,
        weight: 100
      },
      menuOpts: {
        menuId: MarkerNavigationWidget.TitleMenu,
        title: NextMarkerAction.LABEL,
        icon: registerIcon("marker-navigation-previous", Codicon.arrowUp, localize("previousMarkerIcon", "Icon for goto previous marker.")),
        group: "navigation",
        order: 2
      }
    });
  }
};
PrevMarkerAction.ID = "editor.action.marker.prev";
PrevMarkerAction.LABEL = localize("markerAction.previous.label", "Go to Previous Problem (Error, Warning, Info)");
var NextMarkerInFilesAction = class extends MarkerNavigationAction {
  constructor() {
    super(true, true, {
      id: "editor.action.marker.nextInFiles",
      label: localize("markerAction.nextInFiles.label", "Go to Next Problem in Files (Error, Warning, Info)"),
      alias: "Go to Next Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 66,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        title: localize({ key: "miGotoNextProblem", comment: ["&& denotes a mnemonic"] }, "Next &&Problem"),
        group: "6_problem_nav",
        order: 1
      }
    });
  }
};
var PrevMarkerInFilesAction = class extends MarkerNavigationAction {
  constructor() {
    super(false, true, {
      id: "editor.action.marker.prevInFiles",
      label: localize("markerAction.previousInFiles.label", "Go to Previous Problem in Files (Error, Warning, Info)"),
      alias: "Go to Previous Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 1024 | 66,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarGoMenu,
        title: localize({ key: "miGotoPreviousProblem", comment: ["&& denotes a mnemonic"] }, "Previous &&Problem"),
        group: "6_problem_nav",
        order: 2
      }
    });
  }
};
registerEditorContribution(MarkerController.ID, MarkerController);
registerEditorAction(NextMarkerAction);
registerEditorAction(PrevMarkerAction);
registerEditorAction(NextMarkerInFilesAction);
registerEditorAction(PrevMarkerInFilesAction);
var CONTEXT_MARKERS_NAVIGATION_VISIBLE = new RawContextKey("markersNavigationVisible", false);
var MarkerCommand = EditorCommand.bindToContribution(MarkerController.get);
registerEditorCommand(new MarkerCommand({
  id: "closeMarkersNavigation",
  precondition: CONTEXT_MARKERS_NAVIGATION_VISIBLE,
  handler: (x) => x.close(),
  kbOpts: {
    weight: 100 + 50,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/markerHoverParticipant.js
var __decorate24 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param24 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $5 = $;
var MarkerHover = class {
  constructor(owner, range, marker) {
    this.owner = owner;
    this.range = range;
    this.marker = marker;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
};
var markerCodeActionTrigger = {
  type: 1,
  filter: { include: CodeActionKind.QuickFix }
};
var MarkerHoverParticipant = class MarkerHoverParticipant2 {
  constructor(_editor, _hover, _markerDecorationsService, _openerService) {
    this._editor = _editor;
    this._hover = _hover;
    this._markerDecorationsService = _markerDecorationsService;
    this._openerService = _openerService;
    this.recentMarkerCodeActionsInfo = void 0;
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return [];
    }
    const model = this._editor.getModel();
    const lineNumber = anchor.range.startLineNumber;
    const maxColumn = model.getLineMaxColumn(lineNumber);
    const result = [];
    for (const d of lineDecorations) {
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      const marker = this._markerDecorationsService.getMarker(model.uri, d);
      if (!marker) {
        continue;
      }
      const range = new Range(anchor.range.startLineNumber, startColumn, anchor.range.startLineNumber, endColumn);
      result.push(new MarkerHover(this, range, marker));
    }
    return result;
  }
  renderHoverParts(hoverParts, fragment, statusBar) {
    if (!hoverParts.length) {
      return Disposable.None;
    }
    const disposables = new DisposableStore();
    hoverParts.forEach((msg) => fragment.appendChild(this.renderMarkerHover(msg, disposables)));
    const markerHoverForStatusbar = hoverParts.length === 1 ? hoverParts[0] : hoverParts.sort((a, b) => MarkerSeverity.compare(a.marker.severity, b.marker.severity))[0];
    this.renderMarkerStatusbar(markerHoverForStatusbar, statusBar, disposables);
    return disposables;
  }
  renderMarkerHover(markerHover, disposables) {
    const hoverElement = $5("div.hover-row");
    const markerElement = append(hoverElement, $5("div.marker.hover-contents"));
    const { source, message, code, relatedInformation } = markerHover.marker;
    this._editor.applyFontInfo(markerElement);
    const messageElement = append(markerElement, $5("span"));
    messageElement.style.whiteSpace = "pre-wrap";
    messageElement.innerText = message;
    if (source || code) {
      if (code && typeof code !== "string") {
        const sourceAndCodeElement = $5("span");
        if (source) {
          const sourceElement = append(sourceAndCodeElement, $5("span"));
          sourceElement.innerText = source;
        }
        const codeLink = append(sourceAndCodeElement, $5("a.code-link"));
        codeLink.setAttribute("href", code.target.toString());
        disposables.add(addDisposableListener(codeLink, "click", (e) => {
          this._openerService.open(code.target, { allowCommands: true });
          e.preventDefault();
          e.stopPropagation();
        }));
        const codeElement = append(codeLink, $5("span"));
        codeElement.innerText = code.value;
        const detailsElement = append(markerElement, sourceAndCodeElement);
        detailsElement.style.opacity = "0.6";
        detailsElement.style.paddingLeft = "6px";
      } else {
        const detailsElement = append(markerElement, $5("span"));
        detailsElement.style.opacity = "0.6";
        detailsElement.style.paddingLeft = "6px";
        detailsElement.innerText = source && code ? `${source}(${code})` : source ? source : `(${code})`;
      }
    }
    if (isNonEmptyArray(relatedInformation)) {
      for (const { message: message2, resource, startLineNumber, startColumn } of relatedInformation) {
        const relatedInfoContainer = append(markerElement, $5("div"));
        relatedInfoContainer.style.marginTop = "8px";
        const a = append(relatedInfoContainer, $5("a"));
        a.innerText = `${basename2(resource)}(${startLineNumber}, ${startColumn}): `;
        a.style.cursor = "pointer";
        disposables.add(addDisposableListener(a, "click", (e) => {
          e.stopPropagation();
          e.preventDefault();
          if (this._openerService) {
            this._openerService.open(resource, {
              fromUserGesture: true,
              editorOptions: { selection: { startLineNumber, startColumn } }
            }).catch(onUnexpectedError);
          }
        }));
        const messageElement2 = append(relatedInfoContainer, $5("span"));
        messageElement2.innerText = message2;
        this._editor.applyFontInfo(messageElement2);
      }
    }
    return hoverElement;
  }
  renderMarkerStatusbar(markerHover, statusBar, disposables) {
    if (markerHover.marker.severity === MarkerSeverity.Error || markerHover.marker.severity === MarkerSeverity.Warning || markerHover.marker.severity === MarkerSeverity.Info) {
      statusBar.addAction({
        label: localize("view problem", "View Problem"),
        commandId: NextMarkerAction.ID,
        run: () => {
          this._hover.hide();
          MarkerController.get(this._editor).showAtMarker(markerHover.marker);
          this._editor.focus();
        }
      });
    }
    if (!this._editor.getOption(80)) {
      const quickfixPlaceholderElement = statusBar.append($5("div"));
      if (this.recentMarkerCodeActionsInfo) {
        if (IMarkerData.makeKey(this.recentMarkerCodeActionsInfo.marker) === IMarkerData.makeKey(markerHover.marker)) {
          if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
            quickfixPlaceholderElement.textContent = localize("noQuickFixes", "No quick fixes available");
          }
        } else {
          this.recentMarkerCodeActionsInfo = void 0;
        }
      }
      const updatePlaceholderDisposable = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? Disposable.None : disposables.add(disposableTimeout(() => quickfixPlaceholderElement.textContent = localize("checkingForQuickFixes", "Checking for quick fixes..."), 200));
      if (!quickfixPlaceholderElement.textContent) {
        quickfixPlaceholderElement.textContent = String.fromCharCode(160);
      }
      const codeActionsPromise = this.getCodeActions(markerHover.marker);
      disposables.add(toDisposable(() => codeActionsPromise.cancel()));
      codeActionsPromise.then((actions) => {
        updatePlaceholderDisposable.dispose();
        this.recentMarkerCodeActionsInfo = { marker: markerHover.marker, hasCodeActions: actions.validActions.length > 0 };
        if (!this.recentMarkerCodeActionsInfo.hasCodeActions) {
          actions.dispose();
          quickfixPlaceholderElement.textContent = localize("noQuickFixes", "No quick fixes available");
          return;
        }
        quickfixPlaceholderElement.style.display = "none";
        let showing = false;
        disposables.add(toDisposable(() => {
          if (!showing) {
            actions.dispose();
          }
        }));
        statusBar.addAction({
          label: localize("quick fixes", "Quick Fix..."),
          commandId: QuickFixAction.Id,
          run: (target) => {
            showing = true;
            const controller = QuickFixController.get(this._editor);
            const elementPosition = getDomNodePagePosition(target);
            this._hover.hide();
            controller.showCodeActions(markerCodeActionTrigger, actions, {
              x: elementPosition.left + 6,
              y: elementPosition.top + elementPosition.height + 6
            });
          }
        });
      }, onUnexpectedError);
    }
  }
  getCodeActions(marker) {
    return createCancelablePromise((cancellationToken) => {
      return getCodeActions(this._editor.getModel(), new Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn), markerCodeActionTrigger, Progress.None, cancellationToken);
    });
  }
};
MarkerHoverParticipant = __decorate24([
  __param24(2, IMarkerDecorationsService),
  __param24(3, IOpenerService)
], MarkerHoverParticipant);
registerThemingParticipant((theme, collector) => {
  const linkFg = theme.getColor(textLinkForeground);
  if (linkFg) {
    collector.addRule(`.monaco-hover .hover-contents a.code-link span { color: ${linkFg}; }`);
  }
  const activeLinkFg = theme.getColor(textLinkActiveForeground);
  if (activeLinkFg) {
    collector.addRule(`.monaco-hover .hover-contents a.code-link span:hover { color: ${activeLinkFg}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/consts.js
var inlineSuggestCommitId = "editor.action.inlineSuggest.commit";

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.js
var GhostText = class {
  constructor(lineNumber, parts, additionalReservedLineCount = 0) {
    this.lineNumber = lineNumber;
    this.parts = parts;
    this.additionalReservedLineCount = additionalReservedLineCount;
  }
  renderForScreenReader(lineText) {
    if (this.parts.length === 0) {
      return "";
    }
    const lastPart = this.parts[this.parts.length - 1];
    const cappedLineText = lineText.substr(0, lastPart.column - 1);
    const text2 = applyEdits(cappedLineText, this.parts.map((p) => ({
      range: { startLineNumber: 1, endLineNumber: 1, startColumn: p.column, endColumn: p.column },
      text: p.lines.join("\n")
    })));
    return text2.substring(this.parts[0].column - 1);
  }
};
var PositionOffsetTransformer = class {
  constructor(text2) {
    this.lineStartOffsetByLineIdx = [];
    this.lineStartOffsetByLineIdx.push(0);
    for (let i = 0; i < text2.length; i++) {
      if (text2.charAt(i) === "\n") {
        this.lineStartOffsetByLineIdx.push(i + 1);
      }
    }
  }
  getOffset(position) {
    return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;
  }
};
function applyEdits(text2, edits) {
  const transformer = new PositionOffsetTransformer(text2);
  const offsetEdits = edits.map((e) => {
    const range = Range.lift(e.range);
    return {
      startOffset: transformer.getOffset(range.getStartPosition()),
      endOffset: transformer.getOffset(range.getEndPosition()),
      text: e.text
    };
  });
  offsetEdits.sort((a, b) => b.startOffset - a.startOffset);
  for (const edit of offsetEdits) {
    text2 = text2.substring(0, edit.startOffset) + edit.text + text2.substring(edit.endOffset);
  }
  return text2;
}
var GhostTextPart = class {
  constructor(column, lines, preview) {
    this.column = column;
    this.lines = lines;
    this.preview = preview;
  }
};
var BaseGhostTextWidgetModel = class extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this._expanded = void 0;
    this.onDidChangeEmitter = new Emitter();
    this.onDidChange = this.onDidChangeEmitter.event;
    this._register(editor2.onDidChangeConfiguration((e) => {
      if (e.hasChanged(105) && this._expanded === void 0) {
        this.onDidChangeEmitter.fire();
      }
    }));
  }
  setExpanded(expanded) {
    this._expanded = true;
    this.onDidChangeEmitter.fire();
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/inlineCompletionToGhostText.js
function normalizedInlineCompletionsEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.range.equalsRange(b.range) && a.text === b.text && a.command === b.command;
}
function inlineCompletionToGhostText(inlineCompletion, textModel, mode, cursorPosition, previewSuffixLength = 0) {
  if (inlineCompletion.range.startLineNumber !== inlineCompletion.range.endLineNumber) {
    return void 0;
  }
  const sourceLine = textModel.getLineContent(inlineCompletion.range.startLineNumber);
  const sourceIndentationLength = getLeadingWhitespace(sourceLine).length;
  const suggestionTouchesIndentation = inlineCompletion.range.startColumn - 1 <= sourceIndentationLength;
  if (suggestionTouchesIndentation) {
    const suggestionAddedIndentationLength = getLeadingWhitespace(inlineCompletion.text).length;
    const replacedIndentation = sourceLine.substring(inlineCompletion.range.startColumn - 1, sourceIndentationLength);
    const rangeThatDoesNotReplaceIndentation = Range.fromPositions(inlineCompletion.range.getStartPosition().delta(0, replacedIndentation.length), inlineCompletion.range.getEndPosition());
    const suggestionWithoutIndentationChange = inlineCompletion.text.startsWith(replacedIndentation) ? inlineCompletion.text.substring(replacedIndentation.length) : inlineCompletion.text.substring(suggestionAddedIndentationLength);
    inlineCompletion = {
      range: rangeThatDoesNotReplaceIndentation,
      text: suggestionWithoutIndentationChange,
      command: inlineCompletion.command
    };
  }
  const valueToBeReplaced = textModel.getValueInRange(inlineCompletion.range);
  const changes = cachingDiff(valueToBeReplaced, inlineCompletion.text);
  if (!changes) {
    return void 0;
  }
  const lineNumber = inlineCompletion.range.startLineNumber;
  const parts = new Array();
  if (mode === "prefix") {
    const filteredChanges = changes.filter((c) => c.originalLength === 0);
    if (filteredChanges.length > 1 || filteredChanges.length === 1 && filteredChanges[0].originalStart !== valueToBeReplaced.length) {
      return void 0;
    }
  }
  const previewStartInCompletionText = inlineCompletion.text.length - previewSuffixLength;
  for (const c of changes) {
    const insertColumn = inlineCompletion.range.startColumn + c.originalStart + c.originalLength;
    if (mode === "subwordSmart" && cursorPosition && cursorPosition.lineNumber === inlineCompletion.range.startLineNumber && insertColumn < cursorPosition.column) {
      return void 0;
    }
    if (c.originalLength > 0) {
      return void 0;
    }
    if (c.modifiedLength === 0) {
      continue;
    }
    const modifiedEnd = c.modifiedStart + c.modifiedLength;
    const nonPreviewTextEnd = Math.max(c.modifiedStart, Math.min(modifiedEnd, previewStartInCompletionText));
    const nonPreviewText = inlineCompletion.text.substring(c.modifiedStart, nonPreviewTextEnd);
    const italicText = inlineCompletion.text.substring(nonPreviewTextEnd, Math.max(c.modifiedStart, modifiedEnd));
    if (nonPreviewText.length > 0) {
      const lines = splitLines(nonPreviewText);
      parts.push(new GhostTextPart(insertColumn, lines, false));
    }
    if (italicText.length > 0) {
      const lines = splitLines(italicText);
      parts.push(new GhostTextPart(insertColumn, lines, true));
    }
  }
  return new GhostText(lineNumber, parts, 0);
}
var lastRequest = void 0;
function cachingDiff(originalValue, newValue) {
  if ((lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.originalValue) === originalValue && (lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.newValue) === newValue) {
    return lastRequest === null || lastRequest === void 0 ? void 0 : lastRequest.changes;
  } else {
    const changes = smartDiff(originalValue, newValue);
    lastRequest = {
      originalValue,
      newValue,
      changes
    };
    return changes;
  }
}
function smartDiff(originalValue, newValue) {
  if (originalValue.length > 5e3 || newValue.length > 5e3) {
    return void 0;
  }
  function getMaxCharCode(val) {
    let maxCharCode2 = 0;
    for (let i = 0, len = val.length; i < len; i++) {
      const charCode = val.charCodeAt(i);
      if (charCode > maxCharCode2) {
        maxCharCode2 = charCode;
      }
    }
    return maxCharCode2;
  }
  const maxCharCode = Math.max(getMaxCharCode(originalValue), getMaxCharCode(newValue));
  function getUniqueCharCode(id) {
    if (id < 0) {
      throw new Error("unexpected");
    }
    return maxCharCode + id + 1;
  }
  function getElements(source) {
    let level = 0;
    let group = 0;
    const characters = new Int32Array(source.length);
    for (let i = 0, len = source.length; i < len; i++) {
      const id = group * 100 + level;
      if (source[i] === "(") {
        characters[i] = getUniqueCharCode(2 * id);
        level++;
      } else if (source[i] === ")") {
        characters[i] = getUniqueCharCode(2 * id + 1);
        if (level === 1) {
          group++;
        }
        level = Math.max(level - 1, 0);
      } else {
        characters[i] = source.charCodeAt(i);
      }
    }
    return characters;
  }
  const elements1 = getElements(originalValue);
  const elements2 = getElements(newValue);
  return new LcsDiff({ getElements: () => elements1 }, { getElements: () => elements2 }).ComputeDiff(false).changes;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/inlineCompletionsModel.js
var __decorate25 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param25 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var InlineCompletionsModel = class InlineCompletionsModel2 extends Disposable {
  constructor(editor2, cache, commandService) {
    super();
    this.editor = editor2;
    this.cache = cache;
    this.commandService = commandService;
    this.onDidChangeEmitter = new Emitter();
    this.onDidChange = this.onDidChangeEmitter.event;
    this.completionSession = this._register(new MutableDisposable());
    this.active = false;
    this.disposed = false;
    this._register(commandService.onDidExecuteCommand((e) => {
      const commands = new Set([
        CoreEditingCommands.Tab.id,
        CoreEditingCommands.DeleteLeft.id,
        CoreEditingCommands.DeleteRight.id,
        inlineSuggestCommitId,
        "acceptSelectedSuggestion"
      ]);
      if (commands.has(e.commandId) && editor2.hasTextFocus()) {
        this.handleUserInput();
      }
    }));
    this._register(this.editor.onDidType((e) => {
      this.handleUserInput();
    }));
    this._register(this.editor.onDidChangeCursorPosition((e) => {
      if (this.session && !this.session.isValid) {
        this.hide();
      }
    }));
    this._register(toDisposable(() => {
      this.disposed = true;
    }));
    this._register(this.editor.onDidBlurEditorWidget(() => {
      this.hide();
    }));
  }
  handleUserInput() {
    if (this.session && !this.session.isValid) {
      this.hide();
    }
    setTimeout(() => {
      if (this.disposed) {
        return;
      }
      this.startSessionIfTriggered();
    }, 0);
  }
  get session() {
    return this.completionSession.value;
  }
  get ghostText() {
    var _a5;
    return (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.ghostText;
  }
  get minReservedLineCount() {
    return this.session ? this.session.minReservedLineCount : 0;
  }
  setExpanded(expanded) {
    var _a5;
    (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.setExpanded(expanded);
  }
  setActive(active) {
    var _a5;
    this.active = active;
    if (active) {
      (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.scheduleAutomaticUpdate();
    }
  }
  startSessionIfTriggered() {
    const suggestOptions = this.editor.getOption(54);
    if (!suggestOptions.enabled) {
      return;
    }
    if (this.session && this.session.isValid) {
      return;
    }
    this.trigger(InlineCompletionTriggerKind.Automatic);
  }
  trigger(triggerKind) {
    if (this.completionSession.value) {
      if (triggerKind === InlineCompletionTriggerKind.Explicit) {
        void this.completionSession.value.ensureUpdateWithExplicitContext();
      }
      return;
    }
    this.completionSession.value = new InlineCompletionsSession(this.editor, this.editor.getPosition(), () => this.active, this.commandService, this.cache, triggerKind);
    this.completionSession.value.takeOwnership(this.completionSession.value.onDidChange(() => {
      this.onDidChangeEmitter.fire();
    }));
  }
  hide() {
    this.completionSession.clear();
    this.onDidChangeEmitter.fire();
  }
  commitCurrentSuggestion() {
    var _a5;
    (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.commitCurrentCompletion();
  }
  showNext() {
    var _a5;
    (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.showNextInlineCompletion();
  }
  showPrevious() {
    var _a5;
    (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.showPreviousInlineCompletion();
  }
  hasMultipleInlineCompletions() {
    var _a5;
    return __awaiter20(this, void 0, void 0, function* () {
      const result = yield (_a5 = this.session) === null || _a5 === void 0 ? void 0 : _a5.hasMultipleInlineCompletions();
      return result !== void 0 ? result : false;
    });
  }
};
InlineCompletionsModel = __decorate25([
  __param25(2, ICommandService)
], InlineCompletionsModel);
var InlineCompletionsSession = class extends BaseGhostTextWidgetModel {
  constructor(editor2, triggerPosition, shouldUpdate, commandService, cache, initialTriggerKind) {
    super(editor2);
    this.triggerPosition = triggerPosition;
    this.shouldUpdate = shouldUpdate;
    this.commandService = commandService;
    this.cache = cache;
    this.initialTriggerKind = initialTriggerKind;
    this.minReservedLineCount = 0;
    this.updateOperation = this._register(new MutableDisposable());
    this.updateSoon = this._register(new RunOnceScheduler(() => {
      let triggerKind = this.initialTriggerKind;
      this.initialTriggerKind = InlineCompletionTriggerKind.Automatic;
      return this.update(triggerKind);
    }, 50));
    this.currentlySelectedCompletionId = void 0;
    let lastCompletionItem = void 0;
    this._register(this.onDidChange(() => {
      const currentCompletion = this.currentCompletion;
      if (currentCompletion && currentCompletion.sourceInlineCompletion !== lastCompletionItem) {
        lastCompletionItem = currentCompletion.sourceInlineCompletion;
        const provider = currentCompletion.sourceProvider;
        if (provider.handleItemDidShow) {
          provider.handleItemDidShow(currentCompletion.sourceInlineCompletions, lastCompletionItem);
        }
      }
    }));
    this._register(toDisposable(() => {
      this.cache.clear();
    }));
    this._register(this.editor.onDidChangeCursorPosition((e) => {
      if (this.cache.value) {
        this.onDidChangeEmitter.fire();
      }
    }));
    this._register(this.editor.onDidChangeModelContent((e) => {
      this.scheduleAutomaticUpdate();
    }));
    this._register(InlineCompletionsProviderRegistry.onDidChange(() => {
      this.updateSoon.schedule();
    }));
    this.scheduleAutomaticUpdate();
  }
  fixAndGetIndexOfCurrentSelection() {
    if (!this.currentlySelectedCompletionId || !this.cache.value) {
      return 0;
    }
    if (this.cache.value.completions.length === 0) {
      return 0;
    }
    const idx = this.cache.value.completions.findIndex((v) => v.semanticId === this.currentlySelectedCompletionId);
    if (idx === -1) {
      this.currentlySelectedCompletionId = void 0;
      return 0;
    }
    return idx;
  }
  get currentCachedCompletion() {
    if (!this.cache.value) {
      return void 0;
    }
    return this.cache.value.completions[this.fixAndGetIndexOfCurrentSelection()];
  }
  showNextInlineCompletion() {
    var _a5;
    return __awaiter20(this, void 0, void 0, function* () {
      yield this.ensureUpdateWithExplicitContext();
      const completions = ((_a5 = this.cache.value) === null || _a5 === void 0 ? void 0 : _a5.completions) || [];
      if (completions.length > 0) {
        const newIdx = (this.fixAndGetIndexOfCurrentSelection() + 1) % completions.length;
        this.currentlySelectedCompletionId = completions[newIdx].semanticId;
      } else {
        this.currentlySelectedCompletionId = void 0;
      }
      this.onDidChangeEmitter.fire();
    });
  }
  showPreviousInlineCompletion() {
    var _a5;
    return __awaiter20(this, void 0, void 0, function* () {
      yield this.ensureUpdateWithExplicitContext();
      const completions = ((_a5 = this.cache.value) === null || _a5 === void 0 ? void 0 : _a5.completions) || [];
      if (completions.length > 0) {
        const newIdx = (this.fixAndGetIndexOfCurrentSelection() + completions.length - 1) % completions.length;
        this.currentlySelectedCompletionId = completions[newIdx].semanticId;
      } else {
        this.currentlySelectedCompletionId = void 0;
      }
      this.onDidChangeEmitter.fire();
    });
  }
  ensureUpdateWithExplicitContext() {
    var _a5;
    return __awaiter20(this, void 0, void 0, function* () {
      if (this.updateOperation.value) {
        if (this.updateOperation.value.triggerKind === InlineCompletionTriggerKind.Explicit) {
          yield this.updateOperation.value.promise;
        } else {
          yield this.update(InlineCompletionTriggerKind.Explicit);
        }
      } else if (((_a5 = this.cache.value) === null || _a5 === void 0 ? void 0 : _a5.triggerKind) !== InlineCompletionTriggerKind.Explicit) {
        yield this.update(InlineCompletionTriggerKind.Explicit);
      }
    });
  }
  hasMultipleInlineCompletions() {
    var _a5;
    return __awaiter20(this, void 0, void 0, function* () {
      yield this.ensureUpdateWithExplicitContext();
      return (((_a5 = this.cache.value) === null || _a5 === void 0 ? void 0 : _a5.completions.length) || 0) > 1;
    });
  }
  get ghostText() {
    const currentCompletion = this.currentCompletion;
    const mode = this.editor.getOptions().get(54).mode;
    return currentCompletion ? inlineCompletionToGhostText(currentCompletion, this.editor.getModel(), mode, this.editor.getPosition()) : void 0;
  }
  get currentCompletion() {
    const completion = this.currentCachedCompletion;
    if (!completion) {
      return void 0;
    }
    return completion.toLiveInlineCompletion();
  }
  get isValid() {
    return this.editor.getPosition().lineNumber === this.triggerPosition.lineNumber;
  }
  scheduleAutomaticUpdate() {
    this.updateOperation.clear();
    this.updateSoon.schedule();
  }
  update(triggerKind) {
    return __awaiter20(this, void 0, void 0, function* () {
      if (!this.shouldUpdate()) {
        return;
      }
      const position = this.editor.getPosition();
      const promise = createCancelablePromise((token) => __awaiter20(this, void 0, void 0, function* () {
        let result;
        try {
          result = yield provideInlineCompletions(position, this.editor.getModel(), { triggerKind, selectedSuggestionInfo: void 0 }, token);
        } catch (e) {
          onUnexpectedError(e);
          return;
        }
        if (token.isCancellationRequested) {
          return;
        }
        this.cache.setValue(this.editor, result, triggerKind);
        this.onDidChangeEmitter.fire();
      }));
      const operation = new UpdateOperation(promise, triggerKind);
      this.updateOperation.value = operation;
      yield promise;
      if (this.updateOperation.value === operation) {
        this.updateOperation.clear();
      }
    });
  }
  takeOwnership(disposable) {
    this._register(disposable);
  }
  commitCurrentCompletion() {
    if (!this.ghostText) {
      return;
    }
    const completion = this.currentCompletion;
    if (completion) {
      this.commit(completion);
    }
  }
  commit(completion) {
    const cache = this.cache.clearAndLeak();
    this.editor.executeEdits("inlineSuggestion.accept", [
      EditOperation.replaceMove(completion.range, completion.text)
    ]);
    if (completion.command) {
      this.commandService.executeCommand(completion.command.id, ...completion.command.arguments || []).finally(() => {
        cache === null || cache === void 0 ? void 0 : cache.dispose();
      }).then(void 0, onUnexpectedExternalError);
    } else {
      cache === null || cache === void 0 ? void 0 : cache.dispose();
    }
    this.onDidChangeEmitter.fire();
  }
};
var UpdateOperation = class {
  constructor(promise, triggerKind) {
    this.promise = promise;
    this.triggerKind = triggerKind;
  }
  dispose() {
    this.promise.cancel();
  }
};
var SynchronizedInlineCompletionsCache = class extends Disposable {
  constructor(editor2, completionsSource, onChange, triggerKind) {
    super();
    this.triggerKind = triggerKind;
    const decorationIds = editor2.deltaDecorations([], completionsSource.items.map((i) => ({
      range: i.range,
      options: {
        description: "inline-completion-tracking-range"
      }
    })));
    this._register(toDisposable(() => {
      editor2.deltaDecorations(decorationIds, []);
    }));
    this.completions = completionsSource.items.map((c, idx) => new CachedInlineCompletion(c, decorationIds[idx]));
    this._register(editor2.onDidChangeModelContent(() => {
      let hasChanged = false;
      const model = editor2.getModel();
      for (const c of this.completions) {
        const newRange = model.getDecorationRange(c.decorationId);
        if (!newRange) {
          onUnexpectedError(new Error("Decoration has no range"));
          continue;
        }
        if (!c.synchronizedRange.equalsRange(newRange)) {
          hasChanged = true;
          c.synchronizedRange = newRange;
        }
      }
      if (hasChanged) {
        onChange();
      }
    }));
    this._register(completionsSource);
  }
};
var CachedInlineCompletion = class {
  constructor(inlineCompletion, decorationId) {
    this.inlineCompletion = inlineCompletion;
    this.decorationId = decorationId;
    this.semanticId = JSON.stringify({
      text: this.inlineCompletion.text,
      startLine: this.inlineCompletion.range.startLineNumber,
      startColumn: this.inlineCompletion.range.startColumn,
      command: this.inlineCompletion.command
    });
    this.synchronizedRange = inlineCompletion.range;
  }
  toLiveInlineCompletion() {
    return {
      text: this.inlineCompletion.text,
      range: this.synchronizedRange,
      command: this.inlineCompletion.command,
      sourceProvider: this.inlineCompletion.sourceProvider,
      sourceInlineCompletions: this.inlineCompletion.sourceInlineCompletions,
      sourceInlineCompletion: this.inlineCompletion.sourceInlineCompletion
    };
  }
};
function getDefaultRange(position, model) {
  const word = model.getWordAtPosition(position);
  const maxColumn = model.getLineMaxColumn(position.lineNumber);
  return word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, maxColumn) : Range.fromPositions(position, position.with(void 0, maxColumn));
}
function provideInlineCompletions(position, model, context, token = CancellationToken.None) {
  return __awaiter20(this, void 0, void 0, function* () {
    const defaultReplaceRange = getDefaultRange(position, model);
    const providers = InlineCompletionsProviderRegistry.all(model);
    const results = yield Promise.all(providers.map((provider) => __awaiter20(this, void 0, void 0, function* () {
      const completions = yield provider.provideInlineCompletions(model, position, context, token);
      return {
        completions,
        provider,
        dispose: () => {
          if (completions) {
            provider.freeInlineCompletions(completions);
          }
        }
      };
    })));
    const itemsByHash = new Map();
    for (const result of results) {
      const completions = result.completions;
      if (completions) {
        for (const item of completions.items.map((item2) => ({
          text: item2.text,
          range: item2.range ? Range.lift(item2.range) : defaultReplaceRange,
          command: item2.command,
          sourceProvider: result.provider,
          sourceInlineCompletions: completions,
          sourceInlineCompletion: item2
        }))) {
          if (item.range.startLineNumber !== item.range.endLineNumber) {
            continue;
          }
          itemsByHash.set(JSON.stringify({ text: item.text, range: item.range }), item);
        }
      }
    }
    return {
      items: [...itemsByHash.values()],
      dispose: () => {
        for (const result of results) {
          result.dispose();
        }
      }
    };
  });
}
function minimizeInlineCompletion(model, inlineCompletion) {
  if (!inlineCompletion) {
    return inlineCompletion;
  }
  const valueToReplace = model.getValueInRange(inlineCompletion.range);
  const commonPrefixLen = commonPrefixLength(valueToReplace, inlineCompletion.text);
  const startOffset = model.getOffsetAt(inlineCompletion.range.getStartPosition()) + commonPrefixLen;
  const start = model.getPositionAt(startOffset);
  const remainingValueToReplace = valueToReplace.substr(commonPrefixLen);
  const commonSuffixLen = commonSuffixLength(remainingValueToReplace, inlineCompletion.text);
  const end = model.getPositionAt(Math.max(startOffset, model.getOffsetAt(inlineCompletion.range.getEndPosition()) - commonSuffixLen));
  return {
    range: Range.fromPositions(start, end),
    text: inlineCompletion.text.substr(commonPrefixLen, inlineCompletion.text.length - commonPrefixLen - commonSuffixLen)
  };
}

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetParser.js
var Scanner = class {
  constructor() {
    this.value = "";
    this.pos = 0;
  }
  static isDigitCharacter(ch) {
    return ch >= 48 && ch <= 57;
  }
  static isVariableCharacter(ch) {
    return ch === 95 || ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90;
  }
  text(value) {
    this.value = value;
    this.pos = 0;
  }
  tokenText(token) {
    return this.value.substr(token.pos, token.len);
  }
  next() {
    if (this.pos >= this.value.length) {
      return { type: 14, pos: this.pos, len: 0 };
    }
    let pos = this.pos;
    let len = 0;
    let ch = this.value.charCodeAt(pos);
    let type;
    type = Scanner._table[ch];
    if (typeof type === "number") {
      this.pos += 1;
      return { type, pos, len: 1 };
    }
    if (Scanner.isDigitCharacter(ch)) {
      type = 8;
      do {
        len += 1;
        ch = this.value.charCodeAt(pos + len);
      } while (Scanner.isDigitCharacter(ch));
      this.pos += len;
      return { type, pos, len };
    }
    if (Scanner.isVariableCharacter(ch)) {
      type = 9;
      do {
        ch = this.value.charCodeAt(pos + ++len);
      } while (Scanner.isVariableCharacter(ch) || Scanner.isDigitCharacter(ch));
      this.pos += len;
      return { type, pos, len };
    }
    type = 10;
    do {
      len += 1;
      ch = this.value.charCodeAt(pos + len);
    } while (!isNaN(ch) && typeof Scanner._table[ch] === "undefined" && !Scanner.isDigitCharacter(ch) && !Scanner.isVariableCharacter(ch));
    this.pos += len;
    return { type, pos, len };
  }
};
Scanner._table = {
  [36]: 0,
  [58]: 1,
  [44]: 2,
  [123]: 3,
  [125]: 4,
  [92]: 5,
  [47]: 6,
  [124]: 7,
  [43]: 11,
  [45]: 12,
  [63]: 13
};
var Marker = class {
  constructor() {
    this._children = [];
  }
  appendChild(child) {
    if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
      this._children[this._children.length - 1].value += child.value;
    } else {
      child.parent = this;
      this._children.push(child);
    }
    return this;
  }
  replace(child, others) {
    const { parent } = child;
    const idx = parent.children.indexOf(child);
    const newChildren = parent.children.slice(0);
    newChildren.splice(idx, 1, ...others);
    parent._children = newChildren;
    (function _fixParent(children, parent2) {
      for (const child2 of children) {
        child2.parent = parent2;
        _fixParent(child2.children, child2);
      }
    })(others, parent);
  }
  get children() {
    return this._children;
  }
  get snippet() {
    let candidate = this;
    while (true) {
      if (!candidate) {
        return void 0;
      }
      if (candidate instanceof TextmateSnippet) {
        return candidate;
      }
      candidate = candidate.parent;
    }
  }
  toString() {
    return this.children.reduce((prev, cur) => prev + cur.toString(), "");
  }
  len() {
    return 0;
  }
};
var Text = class extends Marker {
  constructor(value) {
    super();
    this.value = value;
  }
  toString() {
    return this.value;
  }
  len() {
    return this.value.length;
  }
  clone() {
    return new Text(this.value);
  }
};
var TransformableMarker = class extends Marker {
};
var Placeholder = class extends TransformableMarker {
  constructor(index) {
    super();
    this.index = index;
  }
  static compareByIndex(a, b) {
    if (a.index === b.index) {
      return 0;
    } else if (a.isFinalTabstop) {
      return 1;
    } else if (b.isFinalTabstop) {
      return -1;
    } else if (a.index < b.index) {
      return -1;
    } else if (a.index > b.index) {
      return 1;
    } else {
      return 0;
    }
  }
  get isFinalTabstop() {
    return this.index === 0;
  }
  get choice() {
    return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
  }
  clone() {
    let ret = new Placeholder(this.index);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
var Choice = class extends Marker {
  constructor() {
    super(...arguments);
    this.options = [];
  }
  appendChild(marker) {
    if (marker instanceof Text) {
      marker.parent = this;
      this.options.push(marker);
    }
    return this;
  }
  toString() {
    return this.options[0].value;
  }
  len() {
    return this.options[0].len();
  }
  clone() {
    let ret = new Choice();
    this.options.forEach(ret.appendChild, ret);
    return ret;
  }
};
var Transform = class extends Marker {
  constructor() {
    super(...arguments);
    this.regexp = new RegExp("");
  }
  resolve(value) {
    const _this = this;
    let didMatch = false;
    let ret = value.replace(this.regexp, function() {
      didMatch = true;
      return _this._replace(Array.prototype.slice.call(arguments, 0, -2));
    });
    if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
      ret = this._replace([]);
    }
    return ret;
  }
  _replace(groups) {
    let ret = "";
    for (const marker of this._children) {
      if (marker instanceof FormatString) {
        let value = groups[marker.index] || "";
        value = marker.resolve(value);
        ret += value;
      } else {
        ret += marker.toString();
      }
    }
    return ret;
  }
  toString() {
    return "";
  }
  clone() {
    let ret = new Transform();
    ret.regexp = new RegExp(this.regexp.source, "" + (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
var FormatString = class extends Marker {
  constructor(index, shorthandName, ifValue, elseValue) {
    super();
    this.index = index;
    this.shorthandName = shorthandName;
    this.ifValue = ifValue;
    this.elseValue = elseValue;
  }
  resolve(value) {
    if (this.shorthandName === "upcase") {
      return !value ? "" : value.toLocaleUpperCase();
    } else if (this.shorthandName === "downcase") {
      return !value ? "" : value.toLocaleLowerCase();
    } else if (this.shorthandName === "capitalize") {
      return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
    } else if (this.shorthandName === "pascalcase") {
      return !value ? "" : this._toPascalCase(value);
    } else if (this.shorthandName === "camelcase") {
      return !value ? "" : this._toCamelCase(value);
    } else if (Boolean(value) && typeof this.ifValue === "string") {
      return this.ifValue;
    } else if (!Boolean(value) && typeof this.elseValue === "string") {
      return this.elseValue;
    } else {
      return value || "";
    }
  }
  _toPascalCase(value) {
    const match = value.match(/[a-z0-9]+/gi);
    if (!match) {
      return value;
    }
    return match.map((word) => {
      return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
    }).join("");
  }
  _toCamelCase(value) {
    const match = value.match(/[a-z0-9]+/gi);
    if (!match) {
      return value;
    }
    return match.map((word, index) => {
      if (index === 0) {
        return word.toLowerCase();
      } else {
        return word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
      }
    }).join("");
  }
  clone() {
    let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
    return ret;
  }
};
var Variable = class extends TransformableMarker {
  constructor(name) {
    super();
    this.name = name;
  }
  resolve(resolver) {
    let value = resolver.resolve(this);
    if (this.transform) {
      value = this.transform.resolve(value || "");
    }
    if (value !== void 0) {
      this._children = [new Text(value)];
      return true;
    }
    return false;
  }
  clone() {
    const ret = new Variable(this.name);
    if (this.transform) {
      ret.transform = this.transform.clone();
    }
    ret._children = this.children.map((child) => child.clone());
    return ret;
  }
};
function walk(marker, visitor) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
var TextmateSnippet = class extends Marker {
  get placeholderInfo() {
    if (!this._placeholders) {
      let all = [];
      let last;
      this.walk(function(candidate) {
        if (candidate instanceof Placeholder) {
          all.push(candidate);
          last = !last || last.index < candidate.index ? candidate : last;
        }
        return true;
      });
      this._placeholders = { all, last };
    }
    return this._placeholders;
  }
  get placeholders() {
    const { all } = this.placeholderInfo;
    return all;
  }
  offset(marker) {
    let pos = 0;
    let found = false;
    this.walk((candidate) => {
      if (candidate === marker) {
        found = true;
        return false;
      }
      pos += candidate.len();
      return true;
    });
    if (!found) {
      return -1;
    }
    return pos;
  }
  fullLen(marker) {
    let ret = 0;
    walk([marker], (marker2) => {
      ret += marker2.len();
      return true;
    });
    return ret;
  }
  enclosingPlaceholders(placeholder) {
    let ret = [];
    let { parent } = placeholder;
    while (parent) {
      if (parent instanceof Placeholder) {
        ret.push(parent);
      }
      parent = parent.parent;
    }
    return ret;
  }
  resolveVariables(resolver) {
    this.walk((candidate) => {
      if (candidate instanceof Variable) {
        if (candidate.resolve(resolver)) {
          this._placeholders = void 0;
        }
      }
      return true;
    });
    return this;
  }
  appendChild(child) {
    this._placeholders = void 0;
    return super.appendChild(child);
  }
  replace(child, others) {
    this._placeholders = void 0;
    return super.replace(child, others);
  }
  clone() {
    let ret = new TextmateSnippet();
    this._children = this.children.map((child) => child.clone());
    return ret;
  }
  walk(visitor) {
    walk(this.children, visitor);
  }
};
var SnippetParser = class {
  constructor() {
    this._scanner = new Scanner();
    this._token = { type: 14, pos: 0, len: 0 };
  }
  static escape(value) {
    return value.replace(/\$|}|\\/g, "\\$&");
  }
  static guessNeedsClipboard(template) {
    return /\${?CLIPBOARD/.test(template);
  }
  parse(value, insertFinalTabstop, enforceFinalTabstop) {
    this._scanner.text(value);
    this._token = this._scanner.next();
    const snippet = new TextmateSnippet();
    while (this._parse(snippet)) {
    }
    const placeholderDefaultValues = new Map();
    const incompletePlaceholders = [];
    let placeholderCount = 0;
    snippet.walk((marker) => {
      if (marker instanceof Placeholder) {
        placeholderCount += 1;
        if (marker.isFinalTabstop) {
          placeholderDefaultValues.set(0, void 0);
        } else if (!placeholderDefaultValues.has(marker.index) && marker.children.length > 0) {
          placeholderDefaultValues.set(marker.index, marker.children);
        } else {
          incompletePlaceholders.push(marker);
        }
      }
      return true;
    });
    for (const placeholder of incompletePlaceholders) {
      const defaultValues = placeholderDefaultValues.get(placeholder.index);
      if (defaultValues) {
        const clone2 = new Placeholder(placeholder.index);
        clone2.transform = placeholder.transform;
        for (const child of defaultValues) {
          clone2.appendChild(child.clone());
        }
        snippet.replace(placeholder, [clone2]);
      }
    }
    if (!enforceFinalTabstop) {
      enforceFinalTabstop = placeholderCount > 0 && insertFinalTabstop;
    }
    if (!placeholderDefaultValues.has(0) && enforceFinalTabstop) {
      snippet.appendChild(new Placeholder(0));
    }
    return snippet;
  }
  _accept(type, value) {
    if (type === void 0 || this._token.type === type) {
      let ret = !value ? true : this._scanner.tokenText(this._token);
      this._token = this._scanner.next();
      return ret;
    }
    return false;
  }
  _backTo(token) {
    this._scanner.pos = token.pos + token.len;
    this._token = token;
    return false;
  }
  _until(type) {
    const start = this._token;
    while (this._token.type !== type) {
      if (this._token.type === 14) {
        return false;
      } else if (this._token.type === 5) {
        const nextToken = this._scanner.next();
        if (nextToken.type !== 0 && nextToken.type !== 4 && nextToken.type !== 5) {
          return false;
        }
      }
      this._token = this._scanner.next();
    }
    const value = this._scanner.value.substring(start.pos, this._token.pos).replace(/\\(\$|}|\\)/g, "$1");
    this._token = this._scanner.next();
    return value;
  }
  _parse(marker) {
    return this._parseEscaped(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
  }
  _parseEscaped(marker) {
    let value;
    if (value = this._accept(5, true)) {
      value = this._accept(0, true) || this._accept(4, true) || this._accept(5, true) || value;
      marker.appendChild(new Text(value));
      return true;
    }
    return false;
  }
  _parseTabstopOrVariableName(parent) {
    let value;
    const token = this._token;
    const match = this._accept(0) && (value = this._accept(9, true) || this._accept(8, true));
    if (!match) {
      return this._backTo(token);
    }
    parent.appendChild(/^\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));
    return true;
  }
  _parseComplexPlaceholder(parent) {
    let index;
    const token = this._token;
    const match = this._accept(0) && this._accept(3) && (index = this._accept(8, true));
    if (!match) {
      return this._backTo(token);
    }
    const placeholder = new Placeholder(Number(index));
    if (this._accept(1)) {
      while (true) {
        if (this._accept(4)) {
          parent.appendChild(placeholder);
          return true;
        }
        if (this._parse(placeholder)) {
          continue;
        }
        parent.appendChild(new Text("${" + index + ":"));
        placeholder.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (placeholder.index > 0 && this._accept(7)) {
      const choice = new Choice();
      while (true) {
        if (this._parseChoiceElement(choice)) {
          if (this._accept(2)) {
            continue;
          }
          if (this._accept(7)) {
            placeholder.appendChild(choice);
            if (this._accept(4)) {
              parent.appendChild(placeholder);
              return true;
            }
          }
        }
        this._backTo(token);
        return false;
      }
    } else if (this._accept(6)) {
      if (this._parseTransform(placeholder)) {
        parent.appendChild(placeholder);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4)) {
      parent.appendChild(placeholder);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseChoiceElement(parent) {
    const token = this._token;
    const values = [];
    while (true) {
      if (this._token.type === 2 || this._token.type === 7) {
        break;
      }
      let value;
      if (value = this._accept(5, true)) {
        value = this._accept(2, true) || this._accept(7, true) || this._accept(5, true) || value;
      } else {
        value = this._accept(void 0, true);
      }
      if (!value) {
        this._backTo(token);
        return false;
      }
      values.push(value);
    }
    if (values.length === 0) {
      this._backTo(token);
      return false;
    }
    parent.appendChild(new Text(values.join("")));
    return true;
  }
  _parseComplexVariable(parent) {
    let name;
    const token = this._token;
    const match = this._accept(0) && this._accept(3) && (name = this._accept(9, true));
    if (!match) {
      return this._backTo(token);
    }
    const variable = new Variable(name);
    if (this._accept(1)) {
      while (true) {
        if (this._accept(4)) {
          parent.appendChild(variable);
          return true;
        }
        if (this._parse(variable)) {
          continue;
        }
        parent.appendChild(new Text("${" + name + ":"));
        variable.children.forEach(parent.appendChild, parent);
        return true;
      }
    } else if (this._accept(6)) {
      if (this._parseTransform(variable)) {
        parent.appendChild(variable);
        return true;
      }
      this._backTo(token);
      return false;
    } else if (this._accept(4)) {
      parent.appendChild(variable);
      return true;
    } else {
      return this._backTo(token);
    }
  }
  _parseTransform(parent) {
    let transform = new Transform();
    let regexValue = "";
    let regexOptions = "";
    while (true) {
      if (this._accept(6)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5, true)) {
        escaped = this._accept(6, true) || escaped;
        regexValue += escaped;
        continue;
      }
      if (this._token.type !== 14) {
        regexValue += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(6)) {
        break;
      }
      let escaped;
      if (escaped = this._accept(5, true)) {
        escaped = this._accept(5, true) || this._accept(6, true) || escaped;
        transform.appendChild(new Text(escaped));
        continue;
      }
      if (this._parseFormatString(transform) || this._parseAnything(transform)) {
        continue;
      }
      return false;
    }
    while (true) {
      if (this._accept(4)) {
        break;
      }
      if (this._token.type !== 14) {
        regexOptions += this._accept(void 0, true);
        continue;
      }
      return false;
    }
    try {
      transform.regexp = new RegExp(regexValue, regexOptions);
    } catch (e) {
      return false;
    }
    parent.transform = transform;
    return true;
  }
  _parseFormatString(parent) {
    const token = this._token;
    if (!this._accept(0)) {
      return false;
    }
    let complex = false;
    if (this._accept(3)) {
      complex = true;
    }
    let index = this._accept(8, true);
    if (!index) {
      this._backTo(token);
      return false;
    } else if (!complex) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (this._accept(4)) {
      parent.appendChild(new FormatString(Number(index)));
      return true;
    } else if (!this._accept(1)) {
      this._backTo(token);
      return false;
    }
    if (this._accept(6)) {
      let shorthand = this._accept(9, true);
      if (!shorthand || !this._accept(4)) {
        this._backTo(token);
        return false;
      } else {
        parent.appendChild(new FormatString(Number(index), shorthand));
        return true;
      }
    } else if (this._accept(11)) {
      let ifValue = this._until(4);
      if (ifValue) {
        parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
        return true;
      }
    } else if (this._accept(12)) {
      let elseValue = this._until(4);
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    } else if (this._accept(13)) {
      let ifValue = this._until(1);
      if (ifValue) {
        let elseValue = this._until(4);
        if (elseValue) {
          parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
          return true;
        }
      }
    } else {
      let elseValue = this._until(4);
      if (elseValue) {
        parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
        return true;
      }
    }
    this._backTo(token);
    return false;
  }
  _parseAnything(marker) {
    if (this._token.type !== 14) {
      marker.appendChild(new Text(this._scanner.tokenText(this._token)));
      this._accept(void 0);
      return true;
    }
    return false;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.css";

// node_modules/monaco-editor/esm/vs/base/common/uuid.js
var _data = new Uint8Array(16);
var _hex = [];
for (let i = 0; i < 256; i++) {
  _hex.push(i.toString(16).padStart(2, "0"));
}
var _fillRandomValues;
if (typeof crypto === "object" && typeof crypto.getRandomValues === "function") {
  _fillRandomValues = crypto.getRandomValues.bind(crypto);
} else {
  _fillRandomValues = function(bucket) {
    for (let i = 0; i < bucket.length; i++) {
      bucket[i] = Math.floor(Math.random() * 256);
    }
    return bucket;
  };
}
function generateUuid() {
  _fillRandomValues(_data);
  _data[6] = _data[6] & 15 | 64;
  _data[8] = _data[8] & 63 | 128;
  let i = 0;
  let result = "";
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += "-";
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += "-";
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += "-";
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += "-";
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  result += _hex[_data[i++]];
  return result;
}

// node_modules/monaco-editor/esm/vs/platform/workspaces/common/workspaces.js
var WORKSPACE_EXTENSION = "code-workspace";
var WORKSPACE_FILTER = [{ name: localize("codeWorkspace", "Code Workspace"), extensions: [WORKSPACE_EXTENSION] }];
function isSingleFolderWorkspaceIdentifier(obj) {
  const singleFolderIdentifier = obj;
  return typeof (singleFolderIdentifier === null || singleFolderIdentifier === void 0 ? void 0 : singleFolderIdentifier.id) === "string" && URI.isUri(singleFolderIdentifier.uri);
}
function toWorkspaceIdentifier(workspace) {
  if (workspace.configuration) {
    return {
      id: workspace.id,
      configPath: workspace.configuration
    };
  }
  if (workspace.folders.length === 1) {
    return {
      id: workspace.id,
      uri: workspace.folders[0].uri
    };
  }
  return void 0;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetVariables.js
var KnownSnippetVariableNames = Object.freeze({
  "CURRENT_YEAR": true,
  "CURRENT_YEAR_SHORT": true,
  "CURRENT_MONTH": true,
  "CURRENT_DATE": true,
  "CURRENT_HOUR": true,
  "CURRENT_MINUTE": true,
  "CURRENT_SECOND": true,
  "CURRENT_DAY_NAME": true,
  "CURRENT_DAY_NAME_SHORT": true,
  "CURRENT_MONTH_NAME": true,
  "CURRENT_MONTH_NAME_SHORT": true,
  "CURRENT_SECONDS_UNIX": true,
  "SELECTION": true,
  "CLIPBOARD": true,
  "TM_SELECTED_TEXT": true,
  "TM_CURRENT_LINE": true,
  "TM_CURRENT_WORD": true,
  "TM_LINE_INDEX": true,
  "TM_LINE_NUMBER": true,
  "TM_FILENAME": true,
  "TM_FILENAME_BASE": true,
  "TM_DIRECTORY": true,
  "TM_FILEPATH": true,
  "RELATIVE_FILEPATH": true,
  "BLOCK_COMMENT_START": true,
  "BLOCK_COMMENT_END": true,
  "LINE_COMMENT": true,
  "WORKSPACE_NAME": true,
  "WORKSPACE_FOLDER": true,
  "RANDOM": true,
  "RANDOM_HEX": true,
  "UUID": true
});
var CompositeSnippetVariableResolver = class {
  constructor(_delegates) {
    this._delegates = _delegates;
  }
  resolve(variable) {
    for (const delegate of this._delegates) {
      let value = delegate.resolve(variable);
      if (value !== void 0) {
        return value;
      }
    }
    return void 0;
  }
};
var SelectionBasedVariableResolver = class {
  constructor(_model, _selection, _selectionIdx, _overtypingCapturer) {
    this._model = _model;
    this._selection = _selection;
    this._selectionIdx = _selectionIdx;
    this._overtypingCapturer = _overtypingCapturer;
  }
  resolve(variable) {
    const { name } = variable;
    if (name === "SELECTION" || name === "TM_SELECTED_TEXT") {
      let value = this._model.getValueInRange(this._selection) || void 0;
      let isMultiline = this._selection.startLineNumber !== this._selection.endLineNumber;
      if (!value && this._overtypingCapturer) {
        const info = this._overtypingCapturer.getLastOvertypedInfo(this._selectionIdx);
        if (info) {
          value = info.value;
          isMultiline = info.multiline;
        }
      }
      if (value && isMultiline && variable.snippet) {
        const line = this._model.getLineContent(this._selection.startLineNumber);
        const lineLeadingWhitespace = getLeadingWhitespace(line, 0, this._selection.startColumn - 1);
        let varLeadingWhitespace = lineLeadingWhitespace;
        variable.snippet.walk((marker) => {
          if (marker === variable) {
            return false;
          }
          if (marker instanceof Text) {
            varLeadingWhitespace = getLeadingWhitespace(splitLines(marker.value).pop());
          }
          return true;
        });
        const whitespaceCommonLength = commonPrefixLength(varLeadingWhitespace, lineLeadingWhitespace);
        value = value.replace(/(\r\n|\r|\n)(.*)/g, (m, newline, rest) => `${newline}${varLeadingWhitespace.substr(whitespaceCommonLength)}${rest}`);
      }
      return value;
    } else if (name === "TM_CURRENT_LINE") {
      return this._model.getLineContent(this._selection.positionLineNumber);
    } else if (name === "TM_CURRENT_WORD") {
      const info = this._model.getWordAtPosition({
        lineNumber: this._selection.positionLineNumber,
        column: this._selection.positionColumn
      });
      return info && info.word || void 0;
    } else if (name === "TM_LINE_INDEX") {
      return String(this._selection.positionLineNumber - 1);
    } else if (name === "TM_LINE_NUMBER") {
      return String(this._selection.positionLineNumber);
    }
    return void 0;
  }
};
var ModelBasedVariableResolver = class {
  constructor(_labelService, _model) {
    this._labelService = _labelService;
    this._model = _model;
  }
  resolve(variable) {
    const { name } = variable;
    if (name === "TM_FILENAME") {
      return basename(this._model.uri.fsPath);
    } else if (name === "TM_FILENAME_BASE") {
      const name2 = basename(this._model.uri.fsPath);
      const idx = name2.lastIndexOf(".");
      if (idx <= 0) {
        return name2;
      } else {
        return name2.slice(0, idx);
      }
    } else if (name === "TM_DIRECTORY") {
      if (dirname(this._model.uri.fsPath) === ".") {
        return "";
      }
      return this._labelService.getUriLabel(dirname2(this._model.uri));
    } else if (name === "TM_FILEPATH") {
      return this._labelService.getUriLabel(this._model.uri);
    } else if (name === "RELATIVE_FILEPATH") {
      return this._labelService.getUriLabel(this._model.uri, { relative: true, noPrefix: true });
    }
    return void 0;
  }
};
var ClipboardBasedVariableResolver = class {
  constructor(_readClipboardText, _selectionIdx, _selectionCount, _spread) {
    this._readClipboardText = _readClipboardText;
    this._selectionIdx = _selectionIdx;
    this._selectionCount = _selectionCount;
    this._spread = _spread;
  }
  resolve(variable) {
    if (variable.name !== "CLIPBOARD") {
      return void 0;
    }
    const clipboardText = this._readClipboardText();
    if (!clipboardText) {
      return void 0;
    }
    if (this._spread) {
      const lines = clipboardText.split(/\r\n|\n|\r/).filter((s) => !isFalsyOrWhitespace(s));
      if (lines.length === this._selectionCount) {
        return lines[this._selectionIdx];
      }
    }
    return clipboardText;
  }
};
var CommentBasedVariableResolver = class {
  constructor(_model, _selection) {
    this._model = _model;
    this._selection = _selection;
  }
  resolve(variable) {
    const { name } = variable;
    const langId = this._model.getLanguageIdAtPosition(this._selection.selectionStartLineNumber, this._selection.selectionStartColumn);
    const config = LanguageConfigurationRegistry.getComments(langId);
    if (!config) {
      return void 0;
    }
    if (name === "LINE_COMMENT") {
      return config.lineCommentToken || void 0;
    } else if (name === "BLOCK_COMMENT_START") {
      return config.blockCommentStartToken || void 0;
    } else if (name === "BLOCK_COMMENT_END") {
      return config.blockCommentEndToken || void 0;
    }
    return void 0;
  }
};
var TimeBasedVariableResolver = class {
  constructor() {
    this._date = new Date();
  }
  resolve(variable) {
    const { name } = variable;
    if (name === "CURRENT_YEAR") {
      return String(this._date.getFullYear());
    } else if (name === "CURRENT_YEAR_SHORT") {
      return String(this._date.getFullYear()).slice(-2);
    } else if (name === "CURRENT_MONTH") {
      return String(this._date.getMonth().valueOf() + 1).padStart(2, "0");
    } else if (name === "CURRENT_DATE") {
      return String(this._date.getDate().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_HOUR") {
      return String(this._date.getHours().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_MINUTE") {
      return String(this._date.getMinutes().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_SECOND") {
      return String(this._date.getSeconds().valueOf()).padStart(2, "0");
    } else if (name === "CURRENT_DAY_NAME") {
      return TimeBasedVariableResolver.dayNames[this._date.getDay()];
    } else if (name === "CURRENT_DAY_NAME_SHORT") {
      return TimeBasedVariableResolver.dayNamesShort[this._date.getDay()];
    } else if (name === "CURRENT_MONTH_NAME") {
      return TimeBasedVariableResolver.monthNames[this._date.getMonth()];
    } else if (name === "CURRENT_MONTH_NAME_SHORT") {
      return TimeBasedVariableResolver.monthNamesShort[this._date.getMonth()];
    } else if (name === "CURRENT_SECONDS_UNIX") {
      return String(Math.floor(this._date.getTime() / 1e3));
    }
    return void 0;
  }
};
TimeBasedVariableResolver.dayNames = [localize("Sunday", "Sunday"), localize("Monday", "Monday"), localize("Tuesday", "Tuesday"), localize("Wednesday", "Wednesday"), localize("Thursday", "Thursday"), localize("Friday", "Friday"), localize("Saturday", "Saturday")];
TimeBasedVariableResolver.dayNamesShort = [localize("SundayShort", "Sun"), localize("MondayShort", "Mon"), localize("TuesdayShort", "Tue"), localize("WednesdayShort", "Wed"), localize("ThursdayShort", "Thu"), localize("FridayShort", "Fri"), localize("SaturdayShort", "Sat")];
TimeBasedVariableResolver.monthNames = [localize("January", "January"), localize("February", "February"), localize("March", "March"), localize("April", "April"), localize("May", "May"), localize("June", "June"), localize("July", "July"), localize("August", "August"), localize("September", "September"), localize("October", "October"), localize("November", "November"), localize("December", "December")];
TimeBasedVariableResolver.monthNamesShort = [localize("JanuaryShort", "Jan"), localize("FebruaryShort", "Feb"), localize("MarchShort", "Mar"), localize("AprilShort", "Apr"), localize("MayShort", "May"), localize("JuneShort", "Jun"), localize("JulyShort", "Jul"), localize("AugustShort", "Aug"), localize("SeptemberShort", "Sep"), localize("OctoberShort", "Oct"), localize("NovemberShort", "Nov"), localize("DecemberShort", "Dec")];
var WorkspaceBasedVariableResolver = class {
  constructor(_workspaceService) {
    this._workspaceService = _workspaceService;
  }
  resolve(variable) {
    if (!this._workspaceService) {
      return void 0;
    }
    const workspaceIdentifier = toWorkspaceIdentifier(this._workspaceService.getWorkspace());
    if (!workspaceIdentifier) {
      return void 0;
    }
    if (variable.name === "WORKSPACE_NAME") {
      return this._resolveWorkspaceName(workspaceIdentifier);
    } else if (variable.name === "WORKSPACE_FOLDER") {
      return this._resoveWorkspacePath(workspaceIdentifier);
    }
    return void 0;
  }
  _resolveWorkspaceName(workspaceIdentifier) {
    if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
      return basename(workspaceIdentifier.uri.path);
    }
    let filename = basename(workspaceIdentifier.configPath.path);
    if (filename.endsWith(WORKSPACE_EXTENSION)) {
      filename = filename.substr(0, filename.length - WORKSPACE_EXTENSION.length - 1);
    }
    return filename;
  }
  _resoveWorkspacePath(workspaceIdentifier) {
    if (isSingleFolderWorkspaceIdentifier(workspaceIdentifier)) {
      return normalizeDriveLetter(workspaceIdentifier.uri.fsPath);
    }
    let filename = basename(workspaceIdentifier.configPath.path);
    let folderpath = workspaceIdentifier.configPath.fsPath;
    if (folderpath.endsWith(filename)) {
      folderpath = folderpath.substr(0, folderpath.length - filename.length - 1);
    }
    return folderpath ? normalizeDriveLetter(folderpath) : "/";
  }
};
var RandomBasedVariableResolver = class {
  resolve(variable) {
    const { name } = variable;
    if (name === "RANDOM") {
      return Math.random().toString().slice(-6);
    } else if (name === "RANDOM_HEX") {
      return Math.random().toString(16).slice(-6);
    } else if (name === "UUID") {
      return generateUuid();
    }
    return void 0;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetSession.js
var OneSnippet = class {
  constructor(_editor, _snippet, _offset, _snippetLineLeadingWhitespace) {
    this._editor = _editor;
    this._snippet = _snippet;
    this._offset = _offset;
    this._snippetLineLeadingWhitespace = _snippetLineLeadingWhitespace;
    this._nestingLevel = 1;
    this._placeholderGroups = groupBy(_snippet.placeholders, Placeholder.compareByIndex);
    this._placeholderGroupsIdx = -1;
  }
  dispose() {
    if (this._placeholderDecorations) {
      this._editor.deltaDecorations([...this._placeholderDecorations.values()], []);
    }
    this._placeholderGroups.length = 0;
  }
  _initDecorations() {
    if (this._placeholderDecorations) {
      return;
    }
    this._placeholderDecorations = new Map();
    const model = this._editor.getModel();
    this._editor.changeDecorations((accessor) => {
      for (const placeholder of this._snippet.placeholders) {
        const placeholderOffset = this._snippet.offset(placeholder);
        const placeholderLen = this._snippet.fullLen(placeholder);
        const range = Range.fromPositions(model.getPositionAt(this._offset + placeholderOffset), model.getPositionAt(this._offset + placeholderOffset + placeholderLen));
        const options = placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive;
        const handle = accessor.addDecoration(range, options);
        this._placeholderDecorations.set(placeholder, handle);
      }
    });
  }
  move(fwd) {
    if (!this._editor.hasModel()) {
      return [];
    }
    this._initDecorations();
    if (this._placeholderGroupsIdx >= 0) {
      let operations = [];
      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
        if (placeholder.transform) {
          const id = this._placeholderDecorations.get(placeholder);
          const range = this._editor.getModel().getDecorationRange(id);
          const currentValue = this._editor.getModel().getValueInRange(range);
          const transformedValueLines = placeholder.transform.resolve(currentValue).split(/\r\n|\r|\n/);
          for (let i = 1; i < transformedValueLines.length; i++) {
            transformedValueLines[i] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + transformedValueLines[i]);
          }
          operations.push(EditOperation.replace(range, transformedValueLines.join(this._editor.getModel().getEOL())));
        }
      }
      if (operations.length > 0) {
        this._editor.executeEdits("snippet.placeholderTransform", operations);
      }
    }
    let couldSkipThisPlaceholder = false;
    if (fwd === true && this._placeholderGroupsIdx < this._placeholderGroups.length - 1) {
      this._placeholderGroupsIdx += 1;
      couldSkipThisPlaceholder = true;
    } else if (fwd === false && this._placeholderGroupsIdx > 0) {
      this._placeholderGroupsIdx -= 1;
      couldSkipThisPlaceholder = true;
    } else {
    }
    const newSelections = this._editor.getModel().changeDecorations((accessor) => {
      const activePlaceholders = new Set();
      const selections = [];
      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const id = this._placeholderDecorations.get(placeholder);
        const range = this._editor.getModel().getDecorationRange(id);
        selections.push(new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn));
        couldSkipThisPlaceholder = couldSkipThisPlaceholder && this._hasPlaceholderBeenCollapsed(placeholder);
        accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);
        activePlaceholders.add(placeholder);
        for (const enclosingPlaceholder of this._snippet.enclosingPlaceholders(placeholder)) {
          const id2 = this._placeholderDecorations.get(enclosingPlaceholder);
          accessor.changeDecorationOptions(id2, enclosingPlaceholder.isFinalTabstop ? OneSnippet._decor.activeFinal : OneSnippet._decor.active);
          activePlaceholders.add(enclosingPlaceholder);
        }
      }
      for (const [placeholder, id] of this._placeholderDecorations) {
        if (!activePlaceholders.has(placeholder)) {
          accessor.changeDecorationOptions(id, placeholder.isFinalTabstop ? OneSnippet._decor.inactiveFinal : OneSnippet._decor.inactive);
        }
      }
      return selections;
    });
    return !couldSkipThisPlaceholder ? newSelections !== null && newSelections !== void 0 ? newSelections : [] : this.move(fwd);
  }
  _hasPlaceholderBeenCollapsed(placeholder) {
    let marker = placeholder;
    while (marker) {
      if (marker instanceof Placeholder) {
        const id = this._placeholderDecorations.get(marker);
        const range = this._editor.getModel().getDecorationRange(id);
        if (range.isEmpty() && marker.toString().length > 0) {
          return true;
        }
      }
      marker = marker.parent;
    }
    return false;
  }
  get isAtFirstPlaceholder() {
    return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;
  }
  get isAtLastPlaceholder() {
    return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;
  }
  get hasPlaceholder() {
    return this._snippet.placeholders.length > 0;
  }
  computePossibleSelections() {
    const result = new Map();
    for (const placeholdersWithEqualIndex of this._placeholderGroups) {
      let ranges;
      for (const placeholder of placeholdersWithEqualIndex) {
        if (placeholder.isFinalTabstop) {
          break;
        }
        if (!ranges) {
          ranges = [];
          result.set(placeholder.index, ranges);
        }
        const id = this._placeholderDecorations.get(placeholder);
        const range = this._editor.getModel().getDecorationRange(id);
        if (!range) {
          result.delete(placeholder.index);
          break;
        }
        ranges.push(range);
      }
    }
    return result;
  }
  get choice() {
    return this._placeholderGroups[this._placeholderGroupsIdx][0].choice;
  }
  merge(others) {
    const model = this._editor.getModel();
    this._nestingLevel *= 10;
    this._editor.changeDecorations((accessor) => {
      for (const placeholder of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const nested = others.shift();
        console.assert(!nested._placeholderDecorations);
        const indexLastPlaceholder = nested._snippet.placeholderInfo.last.index;
        for (const nestedPlaceholder of nested._snippet.placeholderInfo.all) {
          if (nestedPlaceholder.isFinalTabstop) {
            nestedPlaceholder.index = placeholder.index + (indexLastPlaceholder + 1) / this._nestingLevel;
          } else {
            nestedPlaceholder.index = placeholder.index + nestedPlaceholder.index / this._nestingLevel;
          }
        }
        this._snippet.replace(placeholder, nested._snippet.children);
        const id = this._placeholderDecorations.get(placeholder);
        accessor.removeDecoration(id);
        this._placeholderDecorations.delete(placeholder);
        for (const placeholder2 of nested._snippet.placeholders) {
          const placeholderOffset = nested._snippet.offset(placeholder2);
          const placeholderLen = nested._snippet.fullLen(placeholder2);
          const range = Range.fromPositions(model.getPositionAt(nested._offset + placeholderOffset), model.getPositionAt(nested._offset + placeholderOffset + placeholderLen));
          const handle = accessor.addDecoration(range, OneSnippet._decor.inactive);
          this._placeholderDecorations.set(placeholder2, handle);
        }
      }
      this._placeholderGroups = groupBy(this._snippet.placeholders, Placeholder.compareByIndex);
    });
  }
};
OneSnippet._decor = {
  active: ModelDecorationOptions.register({ description: "snippet-placeholder-1", stickiness: 0, className: "snippet-placeholder" }),
  inactive: ModelDecorationOptions.register({ description: "snippet-placeholder-2", stickiness: 1, className: "snippet-placeholder" }),
  activeFinal: ModelDecorationOptions.register({ description: "snippet-placeholder-3", stickiness: 1, className: "finish-snippet-placeholder" }),
  inactiveFinal: ModelDecorationOptions.register({ description: "snippet-placeholder-4", stickiness: 1, className: "finish-snippet-placeholder" })
};
var _defaultOptions = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  adjustWhitespace: true,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
var SnippetSession = class {
  constructor(editor2, template, options = _defaultOptions) {
    this._templateMerges = [];
    this._snippets = [];
    this._editor = editor2;
    this._template = template;
    this._options = options;
  }
  static adjustWhitespace(model, position, snippet, adjustIndentation, adjustNewlines) {
    const line = model.getLineContent(position.lineNumber);
    const lineLeadingWhitespace = getLeadingWhitespace(line, 0, position.column - 1);
    let snippetTextString;
    snippet.walk((marker) => {
      if (!(marker instanceof Text) || marker.parent instanceof Choice) {
        return true;
      }
      const lines = marker.value.split(/\r\n|\r|\n/);
      if (adjustIndentation) {
        const offset = snippet.offset(marker);
        if (offset === 0) {
          lines[0] = model.normalizeIndentation(lines[0]);
        } else {
          snippetTextString = snippetTextString !== null && snippetTextString !== void 0 ? snippetTextString : snippet.toString();
          let prevChar = snippetTextString.charCodeAt(offset - 1);
          if (prevChar === 10 || prevChar === 13) {
            lines[0] = model.normalizeIndentation(lineLeadingWhitespace + lines[0]);
          }
        }
        for (let i = 1; i < lines.length; i++) {
          lines[i] = model.normalizeIndentation(lineLeadingWhitespace + lines[i]);
        }
      }
      const newValue = lines.join(model.getEOL());
      if (newValue !== marker.value) {
        marker.parent.replace(marker, [new Text(newValue)]);
        snippetTextString = void 0;
      }
      return true;
    });
    return lineLeadingWhitespace;
  }
  static adjustSelection(model, selection, overwriteBefore, overwriteAfter) {
    if (overwriteBefore !== 0 || overwriteAfter !== 0) {
      const { positionLineNumber, positionColumn } = selection;
      const positionColumnBefore = positionColumn - overwriteBefore;
      const positionColumnAfter = positionColumn + overwriteAfter;
      const range = model.validateRange({
        startLineNumber: positionLineNumber,
        startColumn: positionColumnBefore,
        endLineNumber: positionLineNumber,
        endColumn: positionColumnAfter
      });
      selection = Selection.createWithDirection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn, selection.getDirection());
    }
    return selection;
  }
  static createEditsAndSnippets(editor2, template, overwriteBefore, overwriteAfter, enforceFinalTabstop, adjustWhitespace, clipboardText, overtypingCapturer) {
    const edits = [];
    const snippets = [];
    if (!editor2.hasModel()) {
      return { edits, snippets };
    }
    const model = editor2.getModel();
    const workspaceService = editor2.invokeWithinContext((accessor) => accessor.get(IWorkspaceContextService));
    const modelBasedVariableResolver = editor2.invokeWithinContext((accessor) => new ModelBasedVariableResolver(accessor.get(ILabelService), model));
    const readClipboardText = () => clipboardText;
    let delta = 0;
    let firstBeforeText = model.getValueInRange(SnippetSession.adjustSelection(model, editor2.getSelection(), overwriteBefore, 0));
    let firstAfterText = model.getValueInRange(SnippetSession.adjustSelection(model, editor2.getSelection(), 0, overwriteAfter));
    let firstLineFirstNonWhitespace = model.getLineFirstNonWhitespaceColumn(editor2.getSelection().positionLineNumber);
    const indexedSelections = editor2.getSelections().map((selection, idx) => ({ selection, idx })).sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
    for (const { selection, idx } of indexedSelections) {
      let extensionBefore = SnippetSession.adjustSelection(model, selection, overwriteBefore, 0);
      let extensionAfter = SnippetSession.adjustSelection(model, selection, 0, overwriteAfter);
      if (firstBeforeText !== model.getValueInRange(extensionBefore)) {
        extensionBefore = selection;
      }
      if (firstAfterText !== model.getValueInRange(extensionAfter)) {
        extensionAfter = selection;
      }
      const snippetSelection = selection.setStartPosition(extensionBefore.startLineNumber, extensionBefore.startColumn).setEndPosition(extensionAfter.endLineNumber, extensionAfter.endColumn);
      const snippet = new SnippetParser().parse(template, true, enforceFinalTabstop);
      const start = snippetSelection.getStartPosition();
      const snippetLineLeadingWhitespace = SnippetSession.adjustWhitespace(model, start, snippet, adjustWhitespace || idx > 0 && firstLineFirstNonWhitespace !== model.getLineFirstNonWhitespaceColumn(selection.positionLineNumber), true);
      snippet.resolveVariables(new CompositeSnippetVariableResolver([
        modelBasedVariableResolver,
        new ClipboardBasedVariableResolver(readClipboardText, idx, indexedSelections.length, editor2.getOption(70) === "spread"),
        new SelectionBasedVariableResolver(model, selection, idx, overtypingCapturer),
        new CommentBasedVariableResolver(model, selection),
        new TimeBasedVariableResolver(),
        new WorkspaceBasedVariableResolver(workspaceService),
        new RandomBasedVariableResolver()
      ]));
      const offset = model.getOffsetAt(start) + delta;
      delta += snippet.toString().length - model.getValueLengthInRange(snippetSelection);
      edits[idx] = EditOperation.replace(snippetSelection, snippet.toString());
      edits[idx].identifier = { major: idx, minor: 0 };
      snippets[idx] = new OneSnippet(editor2, snippet, offset, snippetLineLeadingWhitespace);
    }
    return { edits, snippets };
  }
  dispose() {
    dispose(this._snippets);
  }
  _logInfo() {
    return `template="${this._template}", merged_templates="${this._templateMerges.join(" -> ")}"`;
  }
  insert() {
    if (!this._editor.hasModel()) {
      return;
    }
    const { edits, snippets } = SnippetSession.createEditsAndSnippets(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, false, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer);
    this._snippets = snippets;
    this._editor.executeEdits("snippet", edits, (undoEdits) => {
      if (this._snippets[0].hasPlaceholder) {
        return this._move(true);
      } else {
        return undoEdits.filter((edit) => !!edit.identifier).map((edit) => Selection.fromPositions(edit.range.getEndPosition()));
      }
    });
    this._editor.revealRange(this._editor.getSelections()[0]);
  }
  merge(template, options = _defaultOptions) {
    if (!this._editor.hasModel()) {
      return;
    }
    this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, template]);
    const { edits, snippets } = SnippetSession.createEditsAndSnippets(this._editor, template, options.overwriteBefore, options.overwriteAfter, true, options.adjustWhitespace, options.clipboardText, options.overtypingCapturer);
    this._editor.executeEdits("snippet", edits, (undoEdits) => {
      for (const snippet of this._snippets) {
        snippet.merge(snippets);
      }
      console.assert(snippets.length === 0);
      if (this._snippets[0].hasPlaceholder) {
        return this._move(void 0);
      } else {
        return undoEdits.filter((edit) => !!edit.identifier).map((edit) => Selection.fromPositions(edit.range.getEndPosition()));
      }
    });
  }
  next() {
    const newSelections = this._move(true);
    this._editor.setSelections(newSelections);
    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
  }
  prev() {
    const newSelections = this._move(false);
    this._editor.setSelections(newSelections);
    this._editor.revealPositionInCenterIfOutsideViewport(newSelections[0].getPosition());
  }
  _move(fwd) {
    const selections = [];
    for (const snippet of this._snippets) {
      const oneSelection = snippet.move(fwd);
      selections.push(...oneSelection);
    }
    return selections;
  }
  get isAtFirstPlaceholder() {
    return this._snippets[0].isAtFirstPlaceholder;
  }
  get isAtLastPlaceholder() {
    return this._snippets[0].isAtLastPlaceholder;
  }
  get hasPlaceholder() {
    return this._snippets[0].hasPlaceholder;
  }
  get choice() {
    return this._snippets[0].choice;
  }
  isSelectionWithinPlaceholders() {
    if (!this.hasPlaceholder) {
      return false;
    }
    const selections = this._editor.getSelections();
    if (selections.length < this._snippets.length) {
      return false;
    }
    let allPossibleSelections = new Map();
    for (const snippet of this._snippets) {
      const possibleSelections = snippet.computePossibleSelections();
      if (allPossibleSelections.size === 0) {
        for (const [index, ranges] of possibleSelections) {
          ranges.sort(Range.compareRangesUsingStarts);
          for (const selection of selections) {
            if (ranges[0].containsRange(selection)) {
              allPossibleSelections.set(index, []);
              break;
            }
          }
        }
      }
      if (allPossibleSelections.size === 0) {
        return false;
      }
      allPossibleSelections.forEach((array, index) => {
        array.push(...possibleSelections.get(index));
      });
    }
    selections.sort(Range.compareRangesUsingStarts);
    for (let [index, ranges] of allPossibleSelections) {
      if (ranges.length !== selections.length) {
        allPossibleSelections.delete(index);
        continue;
      }
      ranges.sort(Range.compareRangesUsingStarts);
      for (let i = 0; i < ranges.length; i++) {
        if (!ranges[i].containsRange(selections[i])) {
          allPossibleSelections.delete(index);
          continue;
        }
      }
    }
    return allPossibleSelections.size > 0;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggest.js
var __awaiter21 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Context = {
  Visible: new RawContextKey("suggestWidgetVisible", false, localize("suggestWidgetVisible", "Whether suggestion are visible")),
  DetailsVisible: new RawContextKey("suggestWidgetDetailsVisible", false, localize("suggestWidgetDetailsVisible", "Whether suggestion details are visible")),
  MultipleSuggestions: new RawContextKey("suggestWidgetMultipleSuggestions", false, localize("suggestWidgetMultipleSuggestions", "Whether there are multiple suggestions to pick from")),
  MakesTextEdit: new RawContextKey("suggestionMakesTextEdit", true, localize("suggestionMakesTextEdit", "Whether inserting the current suggestion yields in a change or has everything already been typed")),
  AcceptSuggestionsOnEnter: new RawContextKey("acceptSuggestionOnEnter", true, localize("acceptSuggestionOnEnter", "Whether suggestions are inserted when pressing Enter")),
  HasInsertAndReplaceRange: new RawContextKey("suggestionHasInsertAndReplaceRange", false, localize("suggestionHasInsertAndReplaceRange", "Whether the current suggestion has insert and replace behaviour")),
  InsertMode: new RawContextKey("suggestionInsertMode", void 0, { type: "string", description: localize("suggestionInsertMode", "Whether the default behaviour is to insert or replace") }),
  CanResolve: new RawContextKey("suggestionCanResolve", false, localize("suggestionCanResolve", "Whether the current suggestion supports to resolve further details"))
};
var suggestWidgetStatusbarMenu = new MenuId("suggestWidgetStatusBar");
var CompletionItem = class {
  constructor(position, completion, container, provider) {
    this.position = position;
    this.completion = completion;
    this.container = container;
    this.provider = provider;
    this.isInvalid = false;
    this.score = FuzzyScore.Default;
    this.distance = 0;
    this.textLabel = typeof completion.label === "string" ? completion.label : completion.label.label;
    this.labelLow = this.textLabel.toLowerCase();
    this.isInvalid = !this.textLabel;
    this.sortTextLow = completion.sortText && completion.sortText.toLowerCase();
    this.filterTextLow = completion.filterText && completion.filterText.toLowerCase();
    if (Range.isIRange(completion.range)) {
      this.editStart = new Position(completion.range.startLineNumber, completion.range.startColumn);
      this.editInsertEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);
      this.editReplaceEnd = new Position(completion.range.endLineNumber, completion.range.endColumn);
      this.isInvalid = this.isInvalid || Range.spansMultipleLines(completion.range) || completion.range.startLineNumber !== position.lineNumber;
    } else {
      this.editStart = new Position(completion.range.insert.startLineNumber, completion.range.insert.startColumn);
      this.editInsertEnd = new Position(completion.range.insert.endLineNumber, completion.range.insert.endColumn);
      this.editReplaceEnd = new Position(completion.range.replace.endLineNumber, completion.range.replace.endColumn);
      this.isInvalid = this.isInvalid || Range.spansMultipleLines(completion.range.insert) || Range.spansMultipleLines(completion.range.replace) || completion.range.insert.startLineNumber !== position.lineNumber || completion.range.replace.startLineNumber !== position.lineNumber || completion.range.insert.startColumn !== completion.range.replace.startColumn;
    }
    if (typeof provider.resolveCompletionItem !== "function") {
      this._resolveCache = Promise.resolve();
      this._isResolved = true;
    }
  }
  get isResolved() {
    return !!this._isResolved;
  }
  resolve(token) {
    return __awaiter21(this, void 0, void 0, function* () {
      if (!this._resolveCache) {
        const sub = token.onCancellationRequested(() => {
          this._resolveCache = void 0;
          this._isResolved = false;
        });
        this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, token)).then((value) => {
          Object.assign(this.completion, value);
          this._isResolved = true;
          sub.dispose();
        }, (err) => {
          if (isPromiseCanceledError(err)) {
            this._resolveCache = void 0;
            this._isResolved = false;
          }
        });
      }
      return this._resolveCache;
    });
  }
};
var CompletionOptions = class {
  constructor(snippetSortOrder = 2, kindFilter = new Set(), providerFilter = new Set(), showDeprecated = true) {
    this.snippetSortOrder = snippetSortOrder;
    this.kindFilter = kindFilter;
    this.providerFilter = providerFilter;
    this.showDeprecated = showDeprecated;
  }
};
CompletionOptions.default = new CompletionOptions();
var _snippetSuggestSupport;
function getSnippetSuggestSupport() {
  return _snippetSuggestSupport;
}
var CompletionItemModel = class {
  constructor(items, needsClipboard, durations, disposable) {
    this.items = items;
    this.needsClipboard = needsClipboard;
    this.durations = durations;
    this.disposable = disposable;
  }
};
function provideSuggestionItems(model, position, options = CompletionOptions.default, context = { triggerKind: 0 }, token = CancellationToken.None) {
  return __awaiter21(this, void 0, void 0, function* () {
    const sw = new StopWatch(true);
    position = position.clone();
    const word = model.getWordAtPosition(position);
    const defaultReplaceRange = word ? new Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn) : Range.fromPositions(position);
    const defaultRange = { replace: defaultReplaceRange, insert: defaultReplaceRange.setEndPosition(position.lineNumber, position.column) };
    const result = [];
    const disposables = new DisposableStore();
    const durations = [];
    let needsClipboard = false;
    const onCompletionList = (provider, container, sw2) => {
      var _a5, _b2, _c2;
      if (!container) {
        return;
      }
      for (let suggestion of container.suggestions) {
        if (!options.kindFilter.has(suggestion.kind)) {
          if (!options.showDeprecated && ((_a5 = suggestion === null || suggestion === void 0 ? void 0 : suggestion.tags) === null || _a5 === void 0 ? void 0 : _a5.includes(1))) {
            continue;
          }
          if (!suggestion.range) {
            suggestion.range = defaultRange;
          }
          if (!suggestion.sortText) {
            suggestion.sortText = typeof suggestion.label === "string" ? suggestion.label : suggestion.label.label;
          }
          if (!needsClipboard && suggestion.insertTextRules && suggestion.insertTextRules & 4) {
            needsClipboard = SnippetParser.guessNeedsClipboard(suggestion.insertText);
          }
          result.push(new CompletionItem(position, suggestion, container, provider));
        }
      }
      if (isDisposable(container)) {
        disposables.add(container);
      }
      durations.push({
        providerName: (_b2 = provider._debugDisplayName) !== null && _b2 !== void 0 ? _b2 : "unkown_provider",
        elapsedProvider: (_c2 = container.duration) !== null && _c2 !== void 0 ? _c2 : -1,
        elapsedOverall: sw2.elapsed()
      });
    };
    const snippetCompletions = (() => __awaiter21(this, void 0, void 0, function* () {
      if (!_snippetSuggestSupport || options.kindFilter.has(27)) {
        return;
      }
      if (options.providerFilter.size > 0 && !options.providerFilter.has(_snippetSuggestSupport)) {
        return;
      }
      const sw2 = new StopWatch(true);
      const list = yield _snippetSuggestSupport.provideCompletionItems(model, position, context, token);
      onCompletionList(_snippetSuggestSupport, list, sw2);
    }))();
    for (let providerGroup of CompletionProviderRegistry.orderedGroups(model)) {
      let lenBefore = result.length;
      yield Promise.all(providerGroup.map((provider) => __awaiter21(this, void 0, void 0, function* () {
        if (options.providerFilter.size > 0 && !options.providerFilter.has(provider)) {
          return;
        }
        try {
          const sw2 = new StopWatch(true);
          const list = yield provider.provideCompletionItems(model, position, context, token);
          onCompletionList(provider, list, sw2);
        } catch (err) {
          onUnexpectedExternalError(err);
        }
      })));
      if (lenBefore !== result.length || token.isCancellationRequested) {
        break;
      }
    }
    yield snippetCompletions;
    if (token.isCancellationRequested) {
      disposables.dispose();
      return Promise.reject(canceled());
    }
    return new CompletionItemModel(result.sort(getSuggestionComparator(options.snippetSortOrder)), needsClipboard, { entries: durations, elapsed: sw.elapsed() }, disposables);
  });
}
function defaultComparator(a, b) {
  if (a.sortTextLow && b.sortTextLow) {
    if (a.sortTextLow < b.sortTextLow) {
      return -1;
    } else if (a.sortTextLow > b.sortTextLow) {
      return 1;
    }
  }
  if (a.completion.label < b.completion.label) {
    return -1;
  } else if (a.completion.label > b.completion.label) {
    return 1;
  }
  return a.completion.kind - b.completion.kind;
}
function snippetUpComparator(a, b) {
  if (a.completion.kind !== b.completion.kind) {
    if (a.completion.kind === 27) {
      return -1;
    } else if (b.completion.kind === 27) {
      return 1;
    }
  }
  return defaultComparator(a, b);
}
function snippetDownComparator(a, b) {
  if (a.completion.kind !== b.completion.kind) {
    if (a.completion.kind === 27) {
      return 1;
    } else if (b.completion.kind === 27) {
      return -1;
    }
  }
  return defaultComparator(a, b);
}
var _snippetComparators = new Map();
_snippetComparators.set(0, snippetUpComparator);
_snippetComparators.set(2, snippetDownComparator);
_snippetComparators.set(1, defaultComparator);
function getSuggestionComparator(snippetConfig) {
  return _snippetComparators.get(snippetConfig);
}
CommandsRegistry.registerCommand("_executeCompletionItemProvider", (accessor, ...args) => __awaiter21(void 0, void 0, void 0, function* () {
  const [uri, position, triggerCharacter, maxItemsToResolve] = args;
  assertType(URI.isUri(uri));
  assertType(Position.isIPosition(position));
  assertType(typeof triggerCharacter === "string" || !triggerCharacter);
  assertType(typeof maxItemsToResolve === "number" || !maxItemsToResolve);
  const ref = yield accessor.get(ITextModelService).createModelReference(uri);
  try {
    const result = {
      incomplete: false,
      suggestions: []
    };
    const resolving = [];
    const completions = yield provideSuggestionItems(ref.object.textEditorModel, Position.lift(position), void 0, { triggerCharacter, triggerKind: triggerCharacter ? 1 : 0 });
    for (const item of completions.items) {
      if (resolving.length < (maxItemsToResolve !== null && maxItemsToResolve !== void 0 ? maxItemsToResolve : 0)) {
        resolving.push(item.resolve(CancellationToken.None));
      }
      result.incomplete = result.incomplete || item.container.incomplete;
      result.suggestions.push(item.completion);
    }
    try {
      yield Promise.all(resolving);
      return result;
    } finally {
      setTimeout(() => completions.disposable.dispose(), 100);
    }
  } finally {
    ref.dispose();
  }
}));
var _provider = new class {
  constructor() {
    this.onlyOnceSuggestions = [];
  }
  provideCompletionItems() {
    let suggestions = this.onlyOnceSuggestions.slice(0);
    let result = { suggestions };
    this.onlyOnceSuggestions.length = 0;
    return result;
  }
}();
CompletionProviderRegistry.register("*", _provider);
function showSimpleSuggestions(editor2, suggestions) {
  setTimeout(() => {
    _provider.onlyOnceSuggestions.push(...suggestions);
    editor2.getContribution("editor.contrib.suggestController").triggerSuggest(new Set().add(_provider));
  }, 0);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/snippet/snippetController2.js
var __decorate26 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param26 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _defaultOptions2 = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  undoStopBefore: true,
  undoStopAfter: true,
  adjustWhitespace: true,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
var SnippetController2 = class SnippetController22 {
  constructor(_editor, _logService, contextKeyService) {
    this._editor = _editor;
    this._logService = _logService;
    this._snippetListener = new DisposableStore();
    this._modelVersionId = -1;
    this._inSnippet = SnippetController22.InSnippetMode.bindTo(contextKeyService);
    this._hasNextTabstop = SnippetController22.HasNextTabstop.bindTo(contextKeyService);
    this._hasPrevTabstop = SnippetController22.HasPrevTabstop.bindTo(contextKeyService);
  }
  static get(editor2) {
    return editor2.getContribution(SnippetController22.ID);
  }
  dispose() {
    var _a5;
    this._inSnippet.reset();
    this._hasPrevTabstop.reset();
    this._hasNextTabstop.reset();
    (_a5 = this._session) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    this._snippetListener.dispose();
  }
  insert(template, opts) {
    try {
      this._doInsert(template, typeof opts === "undefined" ? _defaultOptions2 : Object.assign(Object.assign({}, _defaultOptions2), opts));
    } catch (e) {
      this.cancel();
      this._logService.error(e);
      this._logService.error("snippet_error");
      this._logService.error("insert_template=", template);
      this._logService.error("existing_template=", this._session ? this._session._logInfo() : "<no_session>");
    }
  }
  _doInsert(template, opts) {
    if (!this._editor.hasModel()) {
      return;
    }
    this._snippetListener.clear();
    if (opts.undoStopBefore) {
      this._editor.getModel().pushStackElement();
    }
    if (!this._session) {
      this._modelVersionId = this._editor.getModel().getAlternativeVersionId();
      this._session = new SnippetSession(this._editor, template, opts);
      this._session.insert();
    } else {
      this._session.merge(template, opts);
    }
    if (opts.undoStopAfter) {
      this._editor.getModel().pushStackElement();
    }
    this._updateState();
    this._snippetListener.add(this._editor.onDidChangeModelContent((e) => e.isFlush && this.cancel()));
    this._snippetListener.add(this._editor.onDidChangeModel(() => this.cancel()));
    this._snippetListener.add(this._editor.onDidChangeCursorSelection(() => this._updateState()));
  }
  _updateState() {
    if (!this._session || !this._editor.hasModel()) {
      return;
    }
    if (this._modelVersionId === this._editor.getModel().getAlternativeVersionId()) {
      return this.cancel();
    }
    if (!this._session.hasPlaceholder) {
      return this.cancel();
    }
    if (this._session.isAtLastPlaceholder || !this._session.isSelectionWithinPlaceholders()) {
      return this.cancel();
    }
    this._inSnippet.set(true);
    this._hasPrevTabstop.set(!this._session.isAtFirstPlaceholder);
    this._hasNextTabstop.set(!this._session.isAtLastPlaceholder);
    this._handleChoice();
  }
  _handleChoice() {
    if (!this._session || !this._editor.hasModel()) {
      this._currentChoice = void 0;
      return;
    }
    const { choice } = this._session;
    if (!choice) {
      this._currentChoice = void 0;
      return;
    }
    if (this._currentChoice !== choice) {
      this._currentChoice = choice;
      this._editor.setSelections(this._editor.getSelections().map((s) => Selection.fromPositions(s.getStartPosition())));
      const [first2] = choice.options;
      showSimpleSuggestions(this._editor, choice.options.map((option, i) => {
        return {
          kind: 13,
          label: option.value,
          insertText: option.value,
          sortText: "a".repeat(i + 1),
          range: Range.fromPositions(this._editor.getPosition(), this._editor.getPosition().delta(0, first2.value.length))
        };
      }));
    }
  }
  finish() {
    while (this._inSnippet.get()) {
      this.next();
    }
  }
  cancel(resetSelection = false) {
    var _a5;
    this._inSnippet.reset();
    this._hasPrevTabstop.reset();
    this._hasNextTabstop.reset();
    this._snippetListener.clear();
    (_a5 = this._session) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    this._session = void 0;
    this._modelVersionId = -1;
    if (resetSelection) {
      this._editor.setSelections([this._editor.getSelection()]);
    }
  }
  prev() {
    if (this._session) {
      this._session.prev();
    }
    this._updateState();
  }
  next() {
    if (this._session) {
      this._session.next();
    }
    this._updateState();
  }
  isInSnippet() {
    return Boolean(this._inSnippet.get());
  }
};
SnippetController2.ID = "snippetController2";
SnippetController2.InSnippetMode = new RawContextKey("inSnippetMode", false, localize("inSnippetMode", "Whether the editor in current in snippet mode"));
SnippetController2.HasNextTabstop = new RawContextKey("hasNextTabstop", false, localize("hasNextTabstop", "Whether there is a next tab stop when in snippet mode"));
SnippetController2.HasPrevTabstop = new RawContextKey("hasPrevTabstop", false, localize("hasPrevTabstop", "Whether there is a previous tab stop when in snippet mode"));
SnippetController2 = __decorate26([
  __param26(1, ILogService),
  __param26(2, IContextKeyService)
], SnippetController2);
registerEditorContribution(SnippetController2.ID, SnippetController2);
var CommandCtor = EditorCommand.bindToContribution(SnippetController2.get);
registerEditorCommand(new CommandCtor({
  id: "jumpToNextSnippetPlaceholder",
  precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasNextTabstop),
  handler: (ctrl) => ctrl.next(),
  kbOpts: {
    weight: 100 + 30,
    kbExpr: EditorContextKeys.editorTextFocus,
    primary: 2
  }
}));
registerEditorCommand(new CommandCtor({
  id: "jumpToPrevSnippetPlaceholder",
  precondition: ContextKeyExpr.and(SnippetController2.InSnippetMode, SnippetController2.HasPrevTabstop),
  handler: (ctrl) => ctrl.prev(),
  kbOpts: {
    weight: 100 + 30,
    kbExpr: EditorContextKeys.editorTextFocus,
    primary: 1024 | 2
  }
}));
registerEditorCommand(new CommandCtor({
  id: "leaveSnippet",
  precondition: SnippetController2.InSnippetMode,
  handler: (ctrl) => ctrl.cancel(true),
  kbOpts: {
    weight: 100 + 30,
    kbExpr: EditorContextKeys.editorTextFocus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerEditorCommand(new CommandCtor({
  id: "acceptSnippet",
  precondition: SnippetController2.InSnippetMode,
  handler: (ctrl) => ctrl.finish()
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestMemory.js
var __decorate27 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param27 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var Memory = class {
  constructor(name) {
    this.name = name;
  }
  select(model, pos, items) {
    if (items.length === 0) {
      return 0;
    }
    let topScore = items[0].score[0];
    for (let i = 0; i < items.length; i++) {
      const { score, completion: suggestion } = items[i];
      if (score[0] !== topScore) {
        break;
      }
      if (suggestion.preselect) {
        return i;
      }
    }
    return 0;
  }
};
var NoMemory = class extends Memory {
  constructor() {
    super("first");
  }
  memorize(model, pos, item) {
  }
  toJSON() {
    return void 0;
  }
  fromJSON() {
  }
};
var LRUMemory = class extends Memory {
  constructor() {
    super("recentlyUsed");
    this._cache = new LRUCache(300, 0.66);
    this._seq = 0;
  }
  memorize(model, pos, item) {
    const key = `${model.getLanguageId()}/${item.textLabel}`;
    this._cache.set(key, {
      touch: this._seq++,
      type: item.completion.kind,
      insertText: item.completion.insertText
    });
  }
  select(model, pos, items) {
    if (items.length === 0) {
      return 0;
    }
    const lineSuffix = model.getLineContent(pos.lineNumber).substr(pos.column - 10, pos.column - 1);
    if (/\s$/.test(lineSuffix)) {
      return super.select(model, pos, items);
    }
    let topScore = items[0].score[0];
    let indexPreselect = -1;
    let indexRecency = -1;
    let seq = -1;
    for (let i = 0; i < items.length; i++) {
      if (items[i].score[0] !== topScore) {
        break;
      }
      const key = `${model.getLanguageId()}/${items[i].textLabel}`;
      const item = this._cache.peek(key);
      if (item && item.touch > seq && item.type === items[i].completion.kind && item.insertText === items[i].completion.insertText) {
        seq = item.touch;
        indexRecency = i;
      }
      if (items[i].completion.preselect && indexPreselect === -1) {
        return indexPreselect = i;
      }
    }
    if (indexRecency !== -1) {
      return indexRecency;
    } else if (indexPreselect !== -1) {
      return indexPreselect;
    } else {
      return 0;
    }
  }
  toJSON() {
    return this._cache.toJSON();
  }
  fromJSON(data) {
    this._cache.clear();
    let seq = 0;
    for (const [key, value] of data) {
      value.touch = seq;
      value.type = typeof value.type === "number" ? value.type : completionKindFromString(value.type);
      this._cache.set(key, value);
    }
    this._seq = this._cache.size;
  }
};
var PrefixMemory = class extends Memory {
  constructor() {
    super("recentlyUsedByPrefix");
    this._trie = TernarySearchTree.forStrings();
    this._seq = 0;
  }
  memorize(model, pos, item) {
    const { word } = model.getWordUntilPosition(pos);
    const key = `${model.getLanguageId()}/${word}`;
    this._trie.set(key, {
      type: item.completion.kind,
      insertText: item.completion.insertText,
      touch: this._seq++
    });
  }
  select(model, pos, items) {
    let { word } = model.getWordUntilPosition(pos);
    if (!word) {
      return super.select(model, pos, items);
    }
    let key = `${model.getLanguageId()}/${word}`;
    let item = this._trie.get(key);
    if (!item) {
      item = this._trie.findSubstr(key);
    }
    if (item) {
      for (let i = 0; i < items.length; i++) {
        let { kind, insertText } = items[i].completion;
        if (kind === item.type && insertText === item.insertText) {
          return i;
        }
      }
    }
    return super.select(model, pos, items);
  }
  toJSON() {
    let entries = [];
    this._trie.forEach((value, key) => entries.push([key, value]));
    entries.sort((a, b) => -(a[1].touch - b[1].touch)).forEach((value, i) => value[1].touch = i);
    return entries.slice(0, 200);
  }
  fromJSON(data) {
    this._trie.clear();
    if (data.length > 0) {
      this._seq = data[0][1].touch + 1;
      for (const [key, value] of data) {
        value.type = typeof value.type === "number" ? value.type : completionKindFromString(value.type);
        this._trie.set(key, value);
      }
    }
  }
};
var SuggestMemoryService = class SuggestMemoryService2 {
  constructor(_storageService, _configService) {
    this._storageService = _storageService;
    this._configService = _configService;
    this._disposables = new DisposableStore();
    this._persistSoon = new RunOnceScheduler(() => this._saveState(), 500);
    this._disposables.add(_storageService.onWillSaveState((e) => {
      if (e.reason === WillSaveStateReason.SHUTDOWN) {
        this._saveState();
      }
    }));
  }
  dispose() {
    this._disposables.dispose();
    this._persistSoon.dispose();
  }
  memorize(model, pos, item) {
    this._withStrategy(model, pos).memorize(model, pos, item);
    this._persistSoon.schedule();
  }
  select(model, pos, items) {
    return this._withStrategy(model, pos).select(model, pos, items);
  }
  _withStrategy(model, pos) {
    var _a5;
    const mode = this._configService.getValue("editor.suggestSelection", {
      overrideIdentifier: model.getLanguageIdAtPosition(pos.lineNumber, pos.column),
      resource: model.uri
    });
    if (((_a5 = this._strategy) === null || _a5 === void 0 ? void 0 : _a5.name) !== mode) {
      this._saveState();
      const ctor = SuggestMemoryService2._strategyCtors.get(mode) || NoMemory;
      this._strategy = new ctor();
      try {
        const share = this._configService.getValue("editor.suggest.shareSuggestSelections");
        const scope = share ? 0 : 1;
        const raw = this._storageService.get(`${SuggestMemoryService2._storagePrefix}/${mode}`, scope);
        if (raw) {
          this._strategy.fromJSON(JSON.parse(raw));
        }
      } catch (e) {
      }
    }
    return this._strategy;
  }
  _saveState() {
    if (this._strategy) {
      const share = this._configService.getValue("editor.suggest.shareSuggestSelections");
      const scope = share ? 0 : 1;
      const raw = JSON.stringify(this._strategy);
      this._storageService.store(`${SuggestMemoryService2._storagePrefix}/${this._strategy.name}`, raw, scope, 1);
    }
  }
};
SuggestMemoryService._strategyCtors = new Map([
  ["recentlyUsedByPrefix", PrefixMemory],
  ["recentlyUsed", LRUMemory],
  ["first", NoMemory]
]);
SuggestMemoryService._storagePrefix = "suggest/memories";
SuggestMemoryService = __decorate27([
  __param27(0, IStorageService),
  __param27(1, IConfigurationService)
], SuggestMemoryService);
var ISuggestMemoryService = createDecorator("ISuggestMemories");
registerSingleton(ISuggestMemoryService, SuggestMemoryService, true);

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/wordContextKey.js
var __decorate28 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param28 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var WordContextKey = class WordContextKey2 {
  constructor(_editor, contextKeyService) {
    this._editor = _editor;
    this._enabled = false;
    this._ckAtEnd = WordContextKey2.AtEnd.bindTo(contextKeyService);
    this._configListener = this._editor.onDidChangeConfiguration((e) => e.hasChanged(110) && this._update());
    this._update();
  }
  dispose() {
    var _a5;
    this._configListener.dispose();
    (_a5 = this._selectionListener) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    this._ckAtEnd.reset();
  }
  _update() {
    const enabled = this._editor.getOption(110) === "on";
    if (this._enabled === enabled) {
      return;
    }
    this._enabled = enabled;
    if (this._enabled) {
      const checkForWordEnd = () => {
        if (!this._editor.hasModel()) {
          this._ckAtEnd.set(false);
          return;
        }
        const model = this._editor.getModel();
        const selection = this._editor.getSelection();
        const word = model.getWordAtPosition(selection.getStartPosition());
        if (!word) {
          this._ckAtEnd.set(false);
          return;
        }
        this._ckAtEnd.set(word.endColumn === selection.getStartPosition().column);
      };
      this._selectionListener = this._editor.onDidChangeCursorSelection(checkForWordEnd);
      checkForWordEnd();
    } else if (this._selectionListener) {
      this._ckAtEnd.reset();
      this._selectionListener.dispose();
      this._selectionListener = void 0;
    }
  }
};
WordContextKey.AtEnd = new RawContextKey("atEndOfWord", false);
WordContextKey = __decorate28([
  __param28(1, IContextKeyService)
], WordContextKey);

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestAlternatives.js
var __decorate29 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param29 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var SuggestAlternatives = class SuggestAlternatives2 {
  constructor(_editor, contextKeyService) {
    this._editor = _editor;
    this._index = 0;
    this._ckOtherSuggestions = SuggestAlternatives2.OtherSuggestions.bindTo(contextKeyService);
  }
  dispose() {
    this.reset();
  }
  reset() {
    var _a5;
    this._ckOtherSuggestions.reset();
    (_a5 = this._listener) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    this._model = void 0;
    this._acceptNext = void 0;
    this._ignore = false;
  }
  set({ model, index }, acceptNext) {
    if (model.items.length === 0) {
      this.reset();
      return;
    }
    let nextIndex = SuggestAlternatives2._moveIndex(true, model, index);
    if (nextIndex === index) {
      this.reset();
      return;
    }
    this._acceptNext = acceptNext;
    this._model = model;
    this._index = index;
    this._listener = this._editor.onDidChangeCursorPosition(() => {
      if (!this._ignore) {
        this.reset();
      }
    });
    this._ckOtherSuggestions.set(true);
  }
  static _moveIndex(fwd, model, index) {
    let newIndex = index;
    while (true) {
      newIndex = (newIndex + model.items.length + (fwd ? 1 : -1)) % model.items.length;
      if (newIndex === index) {
        break;
      }
      if (!model.items[newIndex].completion.additionalTextEdits) {
        break;
      }
    }
    return newIndex;
  }
  next() {
    this._move(true);
  }
  prev() {
    this._move(false);
  }
  _move(fwd) {
    if (!this._model) {
      return;
    }
    try {
      this._ignore = true;
      this._index = SuggestAlternatives2._moveIndex(fwd, this._model, this._index);
      this._acceptNext({ index: this._index, item: this._model.items[this._index], model: this._model });
    } finally {
      this._ignore = false;
    }
  }
};
SuggestAlternatives.OtherSuggestions = new RawContextKey("hasOtherSuggestions", false);
SuggestAlternatives = __decorate29([
  __param29(1, IContextKeyService)
], SuggestAlternatives);

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestCommitCharacters.js
var CommitCharacterController = class {
  constructor(editor2, widget, accept) {
    this._disposables = new DisposableStore();
    this._disposables.add(widget.onDidShow(() => this._onItem(widget.getFocusedItem())));
    this._disposables.add(widget.onDidFocus(this._onItem, this));
    this._disposables.add(widget.onDidHide(this.reset, this));
    this._disposables.add(editor2.onWillType((text2) => {
      if (this._active && !widget.isFrozen()) {
        const ch = text2.charCodeAt(text2.length - 1);
        if (this._active.acceptCharacters.has(ch) && editor2.getOption(0)) {
          accept(this._active.item);
        }
      }
    }));
  }
  _onItem(selected) {
    if (!selected || !isNonEmptyArray(selected.item.completion.commitCharacters)) {
      this.reset();
      return;
    }
    if (this._active && this._active.item.item === selected.item) {
      return;
    }
    const acceptCharacters = new CharacterSet();
    for (const ch of selected.item.completion.commitCharacters) {
      if (ch.length > 0) {
        acceptCharacters.add(ch.charCodeAt(0));
      }
    }
    this._active = { acceptCharacters, item: selected };
  }
  reset() {
    this._active = void 0;
  }
  dispose() {
    this._disposables.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/bracketSelections.js
var __awaiter22 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var BracketSelectionRangeProvider = class {
  provideSelectionRanges(model, positions) {
    return __awaiter22(this, void 0, void 0, function* () {
      const result = [];
      for (const position of positions) {
        const bucket = [];
        result.push(bucket);
        const ranges = new Map();
        yield new Promise((resolve) => BracketSelectionRangeProvider._bracketsRightYield(resolve, 0, model, position, ranges));
        yield new Promise((resolve) => BracketSelectionRangeProvider._bracketsLeftYield(resolve, 0, model, position, ranges, bucket));
      }
      return result;
    });
  }
  static _bracketsRightYield(resolve, round, model, pos, ranges) {
    const counts = new Map();
    const t1 = Date.now();
    while (true) {
      if (round >= BracketSelectionRangeProvider._maxRounds) {
        resolve();
        break;
      }
      if (!pos) {
        resolve();
        break;
      }
      let bracket = model.bracketPairs.findNextBracket(pos);
      if (!bracket) {
        resolve();
        break;
      }
      let d = Date.now() - t1;
      if (d > BracketSelectionRangeProvider._maxDuration) {
        setTimeout(() => BracketSelectionRangeProvider._bracketsRightYield(resolve, round + 1, model, pos, ranges));
        break;
      }
      const key = bracket.close[0];
      if (bracket.isOpen) {
        let val = counts.has(key) ? counts.get(key) : 0;
        counts.set(key, val + 1);
      } else {
        let val = counts.has(key) ? counts.get(key) : 0;
        val -= 1;
        counts.set(key, Math.max(0, val));
        if (val < 0) {
          let list = ranges.get(key);
          if (!list) {
            list = new LinkedList();
            ranges.set(key, list);
          }
          list.push(bracket.range);
        }
      }
      pos = bracket.range.getEndPosition();
    }
  }
  static _bracketsLeftYield(resolve, round, model, pos, ranges, bucket) {
    const counts = new Map();
    const t1 = Date.now();
    while (true) {
      if (round >= BracketSelectionRangeProvider._maxRounds && ranges.size === 0) {
        resolve();
        break;
      }
      if (!pos) {
        resolve();
        break;
      }
      let bracket = model.bracketPairs.findPrevBracket(pos);
      if (!bracket) {
        resolve();
        break;
      }
      let d = Date.now() - t1;
      if (d > BracketSelectionRangeProvider._maxDuration) {
        setTimeout(() => BracketSelectionRangeProvider._bracketsLeftYield(resolve, round + 1, model, pos, ranges, bucket));
        break;
      }
      const key = bracket.close[0];
      if (!bracket.isOpen) {
        let val = counts.has(key) ? counts.get(key) : 0;
        counts.set(key, val + 1);
      } else {
        let val = counts.has(key) ? counts.get(key) : 0;
        val -= 1;
        counts.set(key, Math.max(0, val));
        if (val < 0) {
          let list = ranges.get(key);
          if (list) {
            let closing = list.shift();
            if (list.size === 0) {
              ranges.delete(key);
            }
            const innerBracket = Range.fromPositions(bracket.range.getEndPosition(), closing.getStartPosition());
            const outerBracket = Range.fromPositions(bracket.range.getStartPosition(), closing.getEndPosition());
            bucket.push({ range: innerBracket });
            bucket.push({ range: outerBracket });
            BracketSelectionRangeProvider._addBracketLeading(model, outerBracket, bucket);
          }
        }
      }
      pos = bracket.range.getStartPosition();
    }
  }
  static _addBracketLeading(model, bracket, bucket) {
    if (bracket.startLineNumber === bracket.endLineNumber) {
      return;
    }
    const startLine = bracket.startLineNumber;
    const column = model.getLineFirstNonWhitespaceColumn(startLine);
    if (column !== 0 && column !== bracket.startColumn) {
      bucket.push({ range: Range.fromPositions(new Position(startLine, column), bracket.getEndPosition()) });
      bucket.push({ range: Range.fromPositions(new Position(startLine, 1), bracket.getEndPosition()) });
    }
    const aboveLine = startLine - 1;
    if (aboveLine > 0) {
      const column2 = model.getLineFirstNonWhitespaceColumn(aboveLine);
      if (column2 === bracket.startColumn && column2 !== model.getLineLastNonWhitespaceColumn(aboveLine)) {
        bucket.push({ range: Range.fromPositions(new Position(aboveLine, column2), bracket.getEndPosition()) });
        bucket.push({ range: Range.fromPositions(new Position(aboveLine, 1), bracket.getEndPosition()) });
      }
    }
  }
};
BracketSelectionRangeProvider._maxDuration = 30;
BracketSelectionRangeProvider._maxRounds = 2;

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/wordDistance.js
var __awaiter23 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var WordDistance = class {
  static create(service, editor2) {
    return __awaiter23(this, void 0, void 0, function* () {
      if (!editor2.getOption(105).localityBonus) {
        return WordDistance.None;
      }
      if (!editor2.hasModel()) {
        return WordDistance.None;
      }
      const model = editor2.getModel();
      const position = editor2.getPosition();
      if (!service.canComputeWordRanges(model.uri)) {
        return WordDistance.None;
      }
      const [ranges] = yield new BracketSelectionRangeProvider().provideSelectionRanges(model, [position]);
      if (ranges.length === 0) {
        return WordDistance.None;
      }
      const wordRanges = yield service.computeWordRanges(model.uri, ranges[0].range);
      if (!wordRanges) {
        return WordDistance.None;
      }
      const wordUntilPos = model.getWordUntilPosition(position);
      delete wordRanges[wordUntilPos.word];
      return new class extends WordDistance {
        distance(anchor, item) {
          if (!position.equals(editor2.getPosition())) {
            return 0;
          }
          if (item.kind === 17) {
            return 2 << 20;
          }
          let word = typeof item.label === "string" ? item.label : item.label.label;
          let wordLines = wordRanges[word];
          if (isFalsyOrEmpty(wordLines)) {
            return 2 << 20;
          }
          let idx = binarySearch(wordLines, Range.fromPositions(anchor), Range.compareRangesUsingStarts);
          let bestWordRange = idx >= 0 ? wordLines[idx] : wordLines[Math.max(0, ~idx - 1)];
          let blockDistance = ranges.length;
          for (const range of ranges) {
            if (!Range.containsRange(range.range, bestWordRange)) {
              break;
            }
            blockDistance -= 1;
          }
          return blockDistance;
        }
      }();
    });
  }
};
WordDistance.None = new class extends WordDistance {
  distance() {
    return 0;
  }
}();

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/completionModel.js
var CompletionModel = class {
  constructor(items, column, lineContext, wordDistance, options, snippetSuggestions, clipboardText) {
    this.clipboardText = clipboardText;
    this._snippetCompareFn = CompletionModel._compareCompletionItems;
    this._items = items;
    this._column = column;
    this._wordDistance = wordDistance;
    this._options = options;
    this._refilterKind = 1;
    this._lineContext = lineContext;
    if (snippetSuggestions === "top") {
      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsUp;
    } else if (snippetSuggestions === "bottom") {
      this._snippetCompareFn = CompletionModel._compareCompletionItemsSnippetsDown;
    }
  }
  get lineContext() {
    return this._lineContext;
  }
  set lineContext(value) {
    if (this._lineContext.leadingLineContent !== value.leadingLineContent || this._lineContext.characterCountDelta !== value.characterCountDelta) {
      this._refilterKind = this._lineContext.characterCountDelta < value.characterCountDelta && this._filteredItems ? 2 : 1;
      this._lineContext = value;
    }
  }
  get items() {
    this._ensureCachedState();
    return this._filteredItems;
  }
  get allProvider() {
    this._ensureCachedState();
    return this._providerInfo.keys();
  }
  get incomplete() {
    this._ensureCachedState();
    const result = new Set();
    for (let [provider, incomplete] of this._providerInfo) {
      if (incomplete) {
        result.add(provider);
      }
    }
    return result;
  }
  adopt(except) {
    let res = [];
    for (let i = 0; i < this._items.length; ) {
      if (!except.has(this._items[i].provider)) {
        res.push(this._items[i]);
        this._items[i] = this._items[this._items.length - 1];
        this._items.pop();
      } else {
        i++;
      }
    }
    this._refilterKind = 1;
    return res;
  }
  get stats() {
    this._ensureCachedState();
    return this._stats;
  }
  _ensureCachedState() {
    if (this._refilterKind !== 0) {
      this._createCachedState();
    }
  }
  _createCachedState() {
    this._providerInfo = new Map();
    const labelLengths = [];
    const { leadingLineContent, characterCountDelta } = this._lineContext;
    let word = "";
    let wordLow = "";
    const source = this._refilterKind === 1 ? this._items : this._filteredItems;
    const target = [];
    const scoreFn = !this._options.filterGraceful || source.length > 2e3 ? fuzzyScore : fuzzyScoreGracefulAggressive;
    for (let i = 0; i < source.length; i++) {
      const item = source[i];
      if (item.isInvalid) {
        continue;
      }
      this._providerInfo.set(item.provider, Boolean(item.container.incomplete));
      const overwriteBefore = item.position.column - item.editStart.column;
      const wordLen = overwriteBefore + characterCountDelta - (item.position.column - this._column);
      if (word.length !== wordLen) {
        word = wordLen === 0 ? "" : leadingLineContent.slice(-wordLen);
        wordLow = word.toLowerCase();
      }
      item.word = word;
      if (wordLen === 0) {
        item.score = FuzzyScore.Default;
      } else {
        let wordPos = 0;
        while (wordPos < overwriteBefore) {
          const ch = word.charCodeAt(wordPos);
          if (ch === 32 || ch === 9) {
            wordPos += 1;
          } else {
            break;
          }
        }
        if (wordPos >= wordLen) {
          item.score = FuzzyScore.Default;
        } else if (typeof item.completion.filterText === "string") {
          let match = scoreFn(word, wordLow, wordPos, item.completion.filterText, item.filterTextLow, 0, false);
          if (!match) {
            continue;
          }
          if (compareIgnoreCase(item.completion.filterText, item.textLabel) === 0) {
            item.score = match;
          } else {
            item.score = anyScore(word, wordLow, wordPos, item.textLabel, item.labelLow, 0);
            item.score[0] = match[0];
          }
        } else {
          let match = scoreFn(word, wordLow, wordPos, item.textLabel, item.labelLow, 0, false);
          if (!match) {
            continue;
          }
          item.score = match;
        }
      }
      item.idx = i;
      item.distance = this._wordDistance.distance(item.position, item.completion);
      target.push(item);
      labelLengths.push(item.textLabel.length);
    }
    this._filteredItems = target.sort(this._snippetCompareFn);
    this._refilterKind = 0;
    this._stats = {
      pLabelLen: labelLengths.length ? quickSelect(labelLengths.length - 0.85, labelLengths, (a, b) => a - b) : 0
    };
  }
  static _compareCompletionItems(a, b) {
    if (a.score[0] > b.score[0]) {
      return -1;
    } else if (a.score[0] < b.score[0]) {
      return 1;
    } else if (a.distance < b.distance) {
      return -1;
    } else if (a.distance > b.distance) {
      return 1;
    } else if (a.idx < b.idx) {
      return -1;
    } else if (a.idx > b.idx) {
      return 1;
    } else {
      return 0;
    }
  }
  static _compareCompletionItemsSnippetsDown(a, b) {
    if (a.completion.kind !== b.completion.kind) {
      if (a.completion.kind === 27) {
        return 1;
      } else if (b.completion.kind === 27) {
        return -1;
      }
    }
    return CompletionModel._compareCompletionItems(a, b);
  }
  static _compareCompletionItemsSnippetsUp(a, b) {
    if (a.completion.kind !== b.completion.kind) {
      if (a.completion.kind === 27) {
        return -1;
      } else if (b.completion.kind === 27) {
        return 1;
      }
    }
    return CompletionModel._compareCompletionItems(a, b);
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestModel.js
var __decorate30 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param30 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter24 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var LineContext = class {
  constructor(model, position, auto, shy) {
    this.leadingLineContent = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
    this.leadingWord = model.getWordUntilPosition(position);
    this.lineNumber = position.lineNumber;
    this.column = position.column;
    this.auto = auto;
    this.shy = shy;
  }
  static shouldAutoTrigger(editor2) {
    if (!editor2.hasModel()) {
      return false;
    }
    const model = editor2.getModel();
    const pos = editor2.getPosition();
    model.tokenizeIfCheap(pos.lineNumber);
    const word = model.getWordAtPosition(pos);
    if (!word) {
      return false;
    }
    if (word.endColumn !== pos.column) {
      return false;
    }
    if (!isNaN(Number(word.word))) {
      return false;
    }
    return true;
  }
};
function canShowQuickSuggest(editor2, contextKeyService, configurationService) {
  if (!Boolean(contextKeyService.getContextKeyValue("inlineSuggestionVisible"))) {
    return true;
  }
  const allowQuickSuggestions = configurationService.getValue("editor.inlineSuggest.allowQuickSuggestions");
  if (allowQuickSuggestions !== void 0) {
    return Boolean(allowQuickSuggestions);
  }
  return false;
}
function canShowSuggestOnTriggerCharacters(editor2, contextKeyService, configurationService) {
  if (!Boolean(contextKeyService.getContextKeyValue("inlineSuggestionVisible"))) {
    return true;
  }
  const allowQuickSuggestions = configurationService.getValue("editor.inlineSuggest.allowSuggestOnTriggerCharacters");
  if (allowQuickSuggestions !== void 0) {
    return Boolean(allowQuickSuggestions);
  }
  return false;
}
var SuggestModel = class SuggestModel2 {
  constructor(_editor, _editorWorkerService, _clipboardService, _telemetryService, _logService, _contextKeyService, _configurationService) {
    this._editor = _editor;
    this._editorWorkerService = _editorWorkerService;
    this._clipboardService = _clipboardService;
    this._telemetryService = _telemetryService;
    this._logService = _logService;
    this._contextKeyService = _contextKeyService;
    this._configurationService = _configurationService;
    this._toDispose = new DisposableStore();
    this._quickSuggestDelay = 10;
    this._triggerCharacterListener = new DisposableStore();
    this._triggerQuickSuggest = new TimeoutTimer();
    this._state = 0;
    this._completionDisposables = new DisposableStore();
    this._onDidCancel = new Emitter();
    this._onDidTrigger = new Emitter();
    this._onDidSuggest = new Emitter();
    this.onDidCancel = this._onDidCancel.event;
    this.onDidTrigger = this._onDidTrigger.event;
    this.onDidSuggest = this._onDidSuggest.event;
    this._telemetryGate = 0;
    this._currentSelection = this._editor.getSelection() || new Selection(1, 1, 1, 1);
    this._toDispose.add(this._editor.onDidChangeModel(() => {
      this._updateTriggerCharacters();
      this.cancel();
    }));
    this._toDispose.add(this._editor.onDidChangeModelLanguage(() => {
      this._updateTriggerCharacters();
      this.cancel();
    }));
    this._toDispose.add(this._editor.onDidChangeConfiguration(() => {
      this._updateTriggerCharacters();
      this._updateQuickSuggest();
    }));
    this._toDispose.add(CompletionProviderRegistry.onDidChange(() => {
      this._updateTriggerCharacters();
      this._updateActiveSuggestSession();
    }));
    this._toDispose.add(this._editor.onDidChangeCursorSelection((e) => {
      this._onCursorChange(e);
    }));
    let editorIsComposing = false;
    this._toDispose.add(this._editor.onDidCompositionStart(() => {
      editorIsComposing = true;
    }));
    this._toDispose.add(this._editor.onDidCompositionEnd(() => {
      editorIsComposing = false;
      this._onCompositionEnd();
    }));
    this._toDispose.add(this._editor.onDidChangeModelContent(() => {
      if (!editorIsComposing) {
        this._refilterCompletionItems();
      }
    }));
    this._updateTriggerCharacters();
    this._updateQuickSuggest();
  }
  dispose() {
    dispose(this._triggerCharacterListener);
    dispose([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerQuickSuggest]);
    this._toDispose.dispose();
    this._completionDisposables.dispose();
    this.cancel();
  }
  _updateQuickSuggest() {
    this._quickSuggestDelay = this._editor.getOption(79);
    if (isNaN(this._quickSuggestDelay) || !this._quickSuggestDelay && this._quickSuggestDelay !== 0 || this._quickSuggestDelay < 0) {
      this._quickSuggestDelay = 10;
    }
  }
  _updateTriggerCharacters() {
    this._triggerCharacterListener.clear();
    if (this._editor.getOption(80) || !this._editor.hasModel() || !this._editor.getOption(108)) {
      return;
    }
    const supportsByTriggerCharacter = new Map();
    for (const support of CompletionProviderRegistry.all(this._editor.getModel())) {
      for (const ch of support.triggerCharacters || []) {
        let set = supportsByTriggerCharacter.get(ch);
        if (!set) {
          set = new Set();
          set.add(getSnippetSuggestSupport());
          supportsByTriggerCharacter.set(ch, set);
        }
        set.add(support);
      }
    }
    const checkTriggerCharacter = (text2) => {
      if (!canShowSuggestOnTriggerCharacters(this._editor, this._contextKeyService, this._configurationService)) {
        return;
      }
      if (LineContext.shouldAutoTrigger(this._editor)) {
        return;
      }
      if (!text2) {
        const position = this._editor.getPosition();
        const model = this._editor.getModel();
        text2 = model.getLineContent(position.lineNumber).substr(0, position.column - 1);
      }
      let lastChar = "";
      if (isLowSurrogate(text2.charCodeAt(text2.length - 1))) {
        if (isHighSurrogate(text2.charCodeAt(text2.length - 2))) {
          lastChar = text2.substr(text2.length - 2);
        }
      } else {
        lastChar = text2.charAt(text2.length - 1);
      }
      const supports = supportsByTriggerCharacter.get(lastChar);
      if (supports) {
        const existing = this._completionModel ? { items: this._completionModel.adopt(supports), clipboardText: this._completionModel.clipboardText } : void 0;
        this.trigger({ auto: true, shy: false, triggerCharacter: lastChar }, Boolean(this._completionModel), supports, existing);
      }
    };
    this._triggerCharacterListener.add(this._editor.onDidType(checkTriggerCharacter));
    this._triggerCharacterListener.add(this._editor.onDidCompositionEnd(checkTriggerCharacter));
  }
  get state() {
    return this._state;
  }
  cancel(retrigger = false) {
    var _a5;
    if (this._state !== 0) {
      this._triggerQuickSuggest.cancel();
      (_a5 = this._requestToken) === null || _a5 === void 0 ? void 0 : _a5.cancel();
      this._requestToken = void 0;
      this._state = 0;
      this._completionModel = void 0;
      this._context = void 0;
      this._onDidCancel.fire({ retrigger });
    }
  }
  clear() {
    this._completionDisposables.clear();
  }
  _updateActiveSuggestSession() {
    if (this._state !== 0) {
      if (!this._editor.hasModel() || !CompletionProviderRegistry.has(this._editor.getModel())) {
        this.cancel();
      } else {
        this.trigger({ auto: this._state === 2, shy: false }, true);
      }
    }
  }
  _onCursorChange(e) {
    if (!this._editor.hasModel()) {
      return;
    }
    const prevSelection = this._currentSelection;
    this._currentSelection = this._editor.getSelection();
    if (!e.selection.isEmpty() || e.reason !== 0 && e.reason !== 3 || e.source !== "keyboard" && e.source !== "deleteLeft") {
      this.cancel();
      return;
    }
    if (this._state === 0 && e.reason === 0) {
      if (prevSelection.containsRange(this._currentSelection) || prevSelection.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition())) {
        this._doTriggerQuickSuggest();
      }
    } else if (this._state !== 0 && e.reason === 3) {
      this._refilterCompletionItems();
    }
  }
  _onCompositionEnd() {
    if (this._state === 0) {
      this._doTriggerQuickSuggest();
    } else {
      this._refilterCompletionItems();
    }
  }
  _doTriggerQuickSuggest() {
    if (this._editor.getOption(78) === false) {
      return;
    }
    if (this._editor.getOption(105).snippetsPreventQuickSuggestions && SnippetController2.get(this._editor).isInSnippet()) {
      return;
    }
    this.cancel();
    this._triggerQuickSuggest.cancelAndSet(() => {
      if (this._state !== 0) {
        return;
      }
      if (!LineContext.shouldAutoTrigger(this._editor)) {
        return;
      }
      if (!this._editor.hasModel()) {
        return;
      }
      const model = this._editor.getModel();
      const pos = this._editor.getPosition();
      const quickSuggestions = this._editor.getOption(78);
      if (quickSuggestions === false) {
        return;
      } else if (quickSuggestions === true) {
      } else {
        model.tokenizeIfCheap(pos.lineNumber);
        const lineTokens = model.getLineTokens(pos.lineNumber);
        const tokenType = lineTokens.getStandardTokenType(lineTokens.findTokenIndexAtOffset(Math.max(pos.column - 1 - 1, 0)));
        const inValidScope = quickSuggestions.other && tokenType === 0 || quickSuggestions.comments && tokenType === 1 || quickSuggestions.strings && tokenType === 2;
        if (!inValidScope) {
          return;
        }
      }
      if (!canShowQuickSuggest(this._editor, this._contextKeyService, this._configurationService)) {
        return;
      }
      if (!CompletionProviderRegistry.has(model)) {
        return;
      }
      this.trigger({ auto: true, shy: false });
    }, this._quickSuggestDelay);
  }
  _refilterCompletionItems() {
    Promise.resolve().then(() => {
      if (this._state === 0) {
        return;
      }
      if (!this._editor.hasModel()) {
        return;
      }
      const model = this._editor.getModel();
      const position = this._editor.getPosition();
      const ctx = new LineContext(model, position, this._state === 2, false);
      this._onNewContext(ctx);
    });
  }
  trigger(context, retrigger = false, onlyFrom, existing) {
    var _a5;
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const auto = context.auto;
    const ctx = new LineContext(model, this._editor.getPosition(), auto, context.shy);
    this.cancel(retrigger);
    this._state = auto ? 2 : 1;
    this._onDidTrigger.fire({ auto, shy: context.shy, position: this._editor.getPosition() });
    this._context = ctx;
    let suggestCtx = { triggerKind: (_a5 = context.triggerKind) !== null && _a5 !== void 0 ? _a5 : 0 };
    if (context.triggerCharacter) {
      suggestCtx = {
        triggerKind: 1,
        triggerCharacter: context.triggerCharacter
      };
    }
    this._requestToken = new CancellationTokenSource();
    const snippetSuggestions = this._editor.getOption(100);
    let snippetSortOrder = 1;
    switch (snippetSuggestions) {
      case "top":
        snippetSortOrder = 0;
        break;
      case "bottom":
        snippetSortOrder = 2;
        break;
    }
    const { itemKind: itemKindFilter, showDeprecated } = SuggestModel2._createSuggestFilter(this._editor);
    const wordDistance = WordDistance.create(this._editorWorkerService, this._editor);
    const completions = provideSuggestionItems(model, this._editor.getPosition(), new CompletionOptions(snippetSortOrder, itemKindFilter, onlyFrom, showDeprecated), suggestCtx, this._requestToken.token);
    Promise.all([completions, wordDistance]).then(([completions2, wordDistance2]) => __awaiter24(this, void 0, void 0, function* () {
      var _b2;
      (_b2 = this._requestToken) === null || _b2 === void 0 ? void 0 : _b2.dispose();
      if (!this._editor.hasModel()) {
        return;
      }
      let clipboardText = existing === null || existing === void 0 ? void 0 : existing.clipboardText;
      if (!clipboardText && completions2.needsClipboard) {
        clipboardText = yield this._clipboardService.readText();
      }
      if (this._state === 0) {
        return;
      }
      const model2 = this._editor.getModel();
      let items = completions2.items;
      if (existing) {
        const cmpFn = getSuggestionComparator(snippetSortOrder);
        items = items.concat(existing.items).sort(cmpFn);
      }
      const ctx2 = new LineContext(model2, this._editor.getPosition(), auto, context.shy);
      this._completionModel = new CompletionModel(items, this._context.column, {
        leadingLineContent: ctx2.leadingLineContent,
        characterCountDelta: ctx2.column - this._context.column
      }, wordDistance2, this._editor.getOption(105), this._editor.getOption(100), clipboardText);
      this._completionDisposables.add(completions2.disposable);
      this._onNewContext(ctx2);
      this._reportDurationsTelemetry(completions2.durations);
    })).catch(onUnexpectedError);
  }
  _reportDurationsTelemetry(durations) {
    if (this._telemetryGate++ % 230 !== 0) {
      return;
    }
    setTimeout(() => {
      this._telemetryService.publicLog2("suggest.durations.json", { data: JSON.stringify(durations) });
      this._logService.debug("suggest.durations.json", durations);
    });
  }
  static _createSuggestFilter(editor2) {
    const result = new Set();
    const snippetSuggestions = editor2.getOption(100);
    if (snippetSuggestions === "none") {
      result.add(27);
    }
    const suggestOptions = editor2.getOption(105);
    if (!suggestOptions.showMethods) {
      result.add(0);
    }
    if (!suggestOptions.showFunctions) {
      result.add(1);
    }
    if (!suggestOptions.showConstructors) {
      result.add(2);
    }
    if (!suggestOptions.showFields) {
      result.add(3);
    }
    if (!suggestOptions.showVariables) {
      result.add(4);
    }
    if (!suggestOptions.showClasses) {
      result.add(5);
    }
    if (!suggestOptions.showStructs) {
      result.add(6);
    }
    if (!suggestOptions.showInterfaces) {
      result.add(7);
    }
    if (!suggestOptions.showModules) {
      result.add(8);
    }
    if (!suggestOptions.showProperties) {
      result.add(9);
    }
    if (!suggestOptions.showEvents) {
      result.add(10);
    }
    if (!suggestOptions.showOperators) {
      result.add(11);
    }
    if (!suggestOptions.showUnits) {
      result.add(12);
    }
    if (!suggestOptions.showValues) {
      result.add(13);
    }
    if (!suggestOptions.showConstants) {
      result.add(14);
    }
    if (!suggestOptions.showEnums) {
      result.add(15);
    }
    if (!suggestOptions.showEnumMembers) {
      result.add(16);
    }
    if (!suggestOptions.showKeywords) {
      result.add(17);
    }
    if (!suggestOptions.showWords) {
      result.add(18);
    }
    if (!suggestOptions.showColors) {
      result.add(19);
    }
    if (!suggestOptions.showFiles) {
      result.add(20);
    }
    if (!suggestOptions.showReferences) {
      result.add(21);
    }
    if (!suggestOptions.showColors) {
      result.add(22);
    }
    if (!suggestOptions.showFolders) {
      result.add(23);
    }
    if (!suggestOptions.showTypeParameters) {
      result.add(24);
    }
    if (!suggestOptions.showSnippets) {
      result.add(27);
    }
    if (!suggestOptions.showUsers) {
      result.add(25);
    }
    if (!suggestOptions.showIssues) {
      result.add(26);
    }
    return { itemKind: result, showDeprecated: suggestOptions.showDeprecated };
  }
  _onNewContext(ctx) {
    if (!this._context) {
      return;
    }
    if (ctx.lineNumber !== this._context.lineNumber) {
      this.cancel();
      return;
    }
    if (getLeadingWhitespace(ctx.leadingLineContent) !== getLeadingWhitespace(this._context.leadingLineContent)) {
      this.cancel();
      return;
    }
    if (ctx.column < this._context.column) {
      if (ctx.leadingWord.word) {
        this.trigger({ auto: this._context.auto, shy: false }, true);
      } else {
        this.cancel();
      }
      return;
    }
    if (!this._completionModel) {
      return;
    }
    if (ctx.leadingWord.word.length !== 0 && ctx.leadingWord.startColumn > this._context.leadingWord.startColumn) {
      const inactiveProvider = new Set(CompletionProviderRegistry.all(this._editor.getModel()));
      for (let provider of this._completionModel.allProvider) {
        inactiveProvider.delete(provider);
      }
      const items = this._completionModel.adopt(new Set());
      this.trigger({ auto: this._context.auto, shy: false }, true, inactiveProvider, { items, clipboardText: this._completionModel.clipboardText });
      return;
    }
    if (ctx.column > this._context.column && this._completionModel.incomplete.size > 0 && ctx.leadingWord.word.length !== 0) {
      const { incomplete } = this._completionModel;
      const items = this._completionModel.adopt(incomplete);
      this.trigger({ auto: this._state === 2, shy: false, triggerKind: 2 }, true, incomplete, { items, clipboardText: this._completionModel.clipboardText });
    } else {
      let oldLineContext = this._completionModel.lineContext;
      let isFrozen2 = false;
      this._completionModel.lineContext = {
        leadingLineContent: ctx.leadingLineContent,
        characterCountDelta: ctx.column - this._context.column
      };
      if (this._completionModel.items.length === 0) {
        if (LineContext.shouldAutoTrigger(this._editor) && this._context.leadingWord.endColumn < ctx.leadingWord.startColumn) {
          this.trigger({ auto: this._context.auto, shy: false }, true);
          return;
        }
        if (!this._context.auto) {
          this._completionModel.lineContext = oldLineContext;
          isFrozen2 = this._completionModel.items.length > 0;
          if (isFrozen2 && ctx.leadingWord.word.length === 0) {
            this.cancel();
            return;
          }
        } else {
          this.cancel();
          return;
        }
      }
      this._onDidSuggest.fire({
        completionModel: this._completionModel,
        auto: this._context.auto,
        shy: this._context.shy,
        isFrozen: isFrozen2
      });
    }
  }
};
SuggestModel = __decorate30([
  __param30(1, IEditorWorkerService),
  __param30(2, IClipboardService),
  __param30(3, ITelemetryService),
  __param30(4, ILogService),
  __param30(5, IContextKeyService),
  __param30(6, IConfigurationService)
], SuggestModel);

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestOvertypingCapturer.js
var OvertypingCapturer = class {
  constructor(editor2, suggestModel) {
    this._disposables = new DisposableStore();
    this._lastOvertyped = [];
    this._empty = true;
    this._disposables.add(editor2.onWillType(() => {
      if (!this._empty) {
        return;
      }
      if (!editor2.hasModel()) {
        return;
      }
      const selections = editor2.getSelections();
      const selectionsLength = selections.length;
      let willOvertype = false;
      for (let i = 0; i < selectionsLength; i++) {
        if (!selections[i].isEmpty()) {
          willOvertype = true;
          break;
        }
      }
      if (!willOvertype) {
        return;
      }
      this._lastOvertyped = [];
      const model = editor2.getModel();
      for (let i = 0; i < selectionsLength; i++) {
        const selection = selections[i];
        if (model.getValueLengthInRange(selection) > OvertypingCapturer._maxSelectionLength) {
          return;
        }
        this._lastOvertyped[i] = { value: model.getValueInRange(selection), multiline: selection.startLineNumber !== selection.endLineNumber };
      }
      this._empty = false;
    }));
    this._disposables.add(suggestModel.onDidCancel((e) => {
      if (!this._empty && !e.retrigger) {
        this._empty = true;
      }
    }));
  }
  getLastOvertypedInfo(idx) {
    if (!this._empty && idx >= 0 && idx < this._lastOvertyped.length) {
      return this._lastOvertyped[idx];
    }
    return void 0;
  }
  dispose() {
    this._disposables.dispose();
  }
};
OvertypingCapturer._maxSelectionLength = 51200;

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidget.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/suggest/media/suggest.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidgetStatus.js
var __decorate31 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param31 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StatusBarViewItem = class extends MenuEntryActionViewItem {
  updateLabel() {
    const kb = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
    if (!kb) {
      return super.updateLabel();
    }
    if (this.label) {
      this.label.textContent = localize("ddd", "{0} ({1})", this._action.label, StatusBarViewItem.symbolPrintEnter(kb));
    }
  }
  static symbolPrintEnter(kb) {
    var _a5;
    return (_a5 = kb.getLabel()) === null || _a5 === void 0 ? void 0 : _a5.replace(/\benter\b/gi, "\u23CE");
  }
};
var SuggestWidgetStatus = class SuggestWidgetStatus2 {
  constructor(container, instantiationService, _menuService, _contextKeyService) {
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._menuDisposables = new DisposableStore();
    this.element = append(container, $(".suggest-status-bar"));
    const actionViewItemProvider = (action) => {
      return action instanceof MenuItemAction ? instantiationService.createInstance(StatusBarViewItem, action, void 0) : void 0;
    };
    this._leftActions = new ActionBar(this.element, { actionViewItemProvider });
    this._rightActions = new ActionBar(this.element, { actionViewItemProvider });
    this._leftActions.domNode.classList.add("left");
    this._rightActions.domNode.classList.add("right");
  }
  dispose() {
    this._menuDisposables.dispose();
    this.element.remove();
  }
  show() {
    const menu = this._menuService.createMenu(suggestWidgetStatusbarMenu, this._contextKeyService);
    const renderMenu = () => {
      const left = [];
      const right = [];
      for (let [group, actions] of menu.getActions()) {
        if (group === "left") {
          left.push(...actions);
        } else {
          right.push(...actions);
        }
      }
      this._leftActions.clear();
      this._leftActions.push(left);
      this._rightActions.clear();
      this._rightActions.push(right);
    };
    this._menuDisposables.add(menu.onDidChange(() => renderMenu()));
    this._menuDisposables.add(menu);
  }
  hide() {
    this._menuDisposables.clear();
  }
};
SuggestWidgetStatus = __decorate31([
  __param31(1, IInstantiationService),
  __param31(2, IMenuService),
  __param31(3, IContextKeyService)
], SuggestWidgetStatus);

// node_modules/monaco-editor/esm/vs/editor/contrib/symbolIcons/symbolIcons.js
var SYMBOL_ICON_ARRAY_FOREGROUND = registerColor("symbolIcon.arrayForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.arrayForeground", "The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_BOOLEAN_FOREGROUND = registerColor("symbolIcon.booleanForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.booleanForeground", "The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_CLASS_FOREGROUND = registerColor("symbolIcon.classForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hc: "#EE9D28"
}, localize("symbolIcon.classForeground", "The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_COLOR_FOREGROUND = registerColor("symbolIcon.colorForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.colorForeground", "The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_CONSTANT_FOREGROUND = registerColor("symbolIcon.constantForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.constantForeground", "The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_CONSTRUCTOR_FOREGROUND = registerColor("symbolIcon.constructorForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hc: "#B180D7"
}, localize("symbolIcon.constructorForeground", "The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_ENUMERATOR_FOREGROUND = registerColor("symbolIcon.enumeratorForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hc: "#EE9D28"
}, localize("symbolIcon.enumeratorForeground", "The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND = registerColor("symbolIcon.enumeratorMemberForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hc: "#75BEFF"
}, localize("symbolIcon.enumeratorMemberForeground", "The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_EVENT_FOREGROUND = registerColor("symbolIcon.eventForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hc: "#EE9D28"
}, localize("symbolIcon.eventForeground", "The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FIELD_FOREGROUND = registerColor("symbolIcon.fieldForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hc: "#75BEFF"
}, localize("symbolIcon.fieldForeground", "The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FILE_FOREGROUND = registerColor("symbolIcon.fileForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.fileForeground", "The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FOLDER_FOREGROUND = registerColor("symbolIcon.folderForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.folderForeground", "The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_FUNCTION_FOREGROUND = registerColor("symbolIcon.functionForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hc: "#B180D7"
}, localize("symbolIcon.functionForeground", "The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_INTERFACE_FOREGROUND = registerColor("symbolIcon.interfaceForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hc: "#75BEFF"
}, localize("symbolIcon.interfaceForeground", "The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_KEY_FOREGROUND = registerColor("symbolIcon.keyForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.keyForeground", "The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_KEYWORD_FOREGROUND = registerColor("symbolIcon.keywordForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.keywordForeground", "The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_METHOD_FOREGROUND = registerColor("symbolIcon.methodForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hc: "#B180D7"
}, localize("symbolIcon.methodForeground", "The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_MODULE_FOREGROUND = registerColor("symbolIcon.moduleForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.moduleForeground", "The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_NAMESPACE_FOREGROUND = registerColor("symbolIcon.namespaceForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.namespaceForeground", "The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_NULL_FOREGROUND = registerColor("symbolIcon.nullForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.nullForeground", "The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_NUMBER_FOREGROUND = registerColor("symbolIcon.numberForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.numberForeground", "The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_OBJECT_FOREGROUND = registerColor("symbolIcon.objectForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.objectForeground", "The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_OPERATOR_FOREGROUND = registerColor("symbolIcon.operatorForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.operatorForeground", "The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_PACKAGE_FOREGROUND = registerColor("symbolIcon.packageForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.packageForeground", "The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_PROPERTY_FOREGROUND = registerColor("symbolIcon.propertyForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.propertyForeground", "The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_REFERENCE_FOREGROUND = registerColor("symbolIcon.referenceForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.referenceForeground", "The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_SNIPPET_FOREGROUND = registerColor("symbolIcon.snippetForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.snippetForeground", "The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_STRING_FOREGROUND = registerColor("symbolIcon.stringForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.stringForeground", "The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_STRUCT_FOREGROUND = registerColor("symbolIcon.structForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.structForeground", "The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_TEXT_FOREGROUND = registerColor("symbolIcon.textForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.textForeground", "The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_TYPEPARAMETER_FOREGROUND = registerColor("symbolIcon.typeParameterForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.typeParameterForeground", "The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_UNIT_FOREGROUND = registerColor("symbolIcon.unitForeground", {
  dark: foreground,
  light: foreground,
  hc: foreground
}, localize("symbolIcon.unitForeground", "The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
var SYMBOL_ICON_VARIABLE_FOREGROUND = registerColor("symbolIcon.variableForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hc: "#75BEFF"
}, localize("symbolIcon.variableForeground", "The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
registerThemingParticipant((theme, collector) => {
  const symbolIconArrayColor = theme.getColor(SYMBOL_ICON_ARRAY_FOREGROUND);
  if (symbolIconArrayColor) {
    collector.addRule(`${Codicon.symbolArray.cssSelector} { color: ${symbolIconArrayColor}; }`);
  }
  const symbolIconBooleanColor = theme.getColor(SYMBOL_ICON_BOOLEAN_FOREGROUND);
  if (symbolIconBooleanColor) {
    collector.addRule(`${Codicon.symbolBoolean.cssSelector} { color: ${symbolIconBooleanColor}; }`);
  }
  const symbolIconClassColor = theme.getColor(SYMBOL_ICON_CLASS_FOREGROUND);
  if (symbolIconClassColor) {
    collector.addRule(`${Codicon.symbolClass.cssSelector} { color: ${symbolIconClassColor}; }`);
  }
  const symbolIconMethodColor = theme.getColor(SYMBOL_ICON_METHOD_FOREGROUND);
  if (symbolIconMethodColor) {
    collector.addRule(`${Codicon.symbolMethod.cssSelector} { color: ${symbolIconMethodColor}; }`);
  }
  const symbolIconColorColor = theme.getColor(SYMBOL_ICON_COLOR_FOREGROUND);
  if (symbolIconColorColor) {
    collector.addRule(`${Codicon.symbolColor.cssSelector} { color: ${symbolIconColorColor}; }`);
  }
  const symbolIconConstantColor = theme.getColor(SYMBOL_ICON_CONSTANT_FOREGROUND);
  if (symbolIconConstantColor) {
    collector.addRule(`${Codicon.symbolConstant.cssSelector} { color: ${symbolIconConstantColor}; }`);
  }
  const symbolIconConstructorColor = theme.getColor(SYMBOL_ICON_CONSTRUCTOR_FOREGROUND);
  if (symbolIconConstructorColor) {
    collector.addRule(`${Codicon.symbolConstructor.cssSelector} { color: ${symbolIconConstructorColor}; }`);
  }
  const symbolIconEnumeratorColor = theme.getColor(SYMBOL_ICON_ENUMERATOR_FOREGROUND);
  if (symbolIconEnumeratorColor) {
    collector.addRule(`
			${Codicon.symbolValue.cssSelector},${Codicon.symbolEnum.cssSelector} { color: ${symbolIconEnumeratorColor}; }`);
  }
  const symbolIconEnumeratorMemberColor = theme.getColor(SYMBOL_ICON_ENUMERATOR_MEMBER_FOREGROUND);
  if (symbolIconEnumeratorMemberColor) {
    collector.addRule(`${Codicon.symbolEnumMember.cssSelector} { color: ${symbolIconEnumeratorMemberColor}; }`);
  }
  const symbolIconEventColor = theme.getColor(SYMBOL_ICON_EVENT_FOREGROUND);
  if (symbolIconEventColor) {
    collector.addRule(`${Codicon.symbolEvent.cssSelector} { color: ${symbolIconEventColor}; }`);
  }
  const symbolIconFieldColor = theme.getColor(SYMBOL_ICON_FIELD_FOREGROUND);
  if (symbolIconFieldColor) {
    collector.addRule(`${Codicon.symbolField.cssSelector} { color: ${symbolIconFieldColor}; }`);
  }
  const symbolIconFileColor = theme.getColor(SYMBOL_ICON_FILE_FOREGROUND);
  if (symbolIconFileColor) {
    collector.addRule(`${Codicon.symbolFile.cssSelector} { color: ${symbolIconFileColor}; }`);
  }
  const symbolIconFolderColor = theme.getColor(SYMBOL_ICON_FOLDER_FOREGROUND);
  if (symbolIconFolderColor) {
    collector.addRule(`${Codicon.symbolFolder.cssSelector} { color: ${symbolIconFolderColor}; }`);
  }
  const symbolIconFunctionColor = theme.getColor(SYMBOL_ICON_FUNCTION_FOREGROUND);
  if (symbolIconFunctionColor) {
    collector.addRule(`${Codicon.symbolFunction.cssSelector} { color: ${symbolIconFunctionColor}; }`);
  }
  const symbolIconInterfaceColor = theme.getColor(SYMBOL_ICON_INTERFACE_FOREGROUND);
  if (symbolIconInterfaceColor) {
    collector.addRule(`${Codicon.symbolInterface.cssSelector} { color: ${symbolIconInterfaceColor}; }`);
  }
  const symbolIconKeyColor = theme.getColor(SYMBOL_ICON_KEY_FOREGROUND);
  if (symbolIconKeyColor) {
    collector.addRule(`${Codicon.symbolKey.cssSelector} { color: ${symbolIconKeyColor}; }`);
  }
  const symbolIconKeywordColor = theme.getColor(SYMBOL_ICON_KEYWORD_FOREGROUND);
  if (symbolIconKeywordColor) {
    collector.addRule(`${Codicon.symbolKeyword.cssSelector} { color: ${symbolIconKeywordColor}; }`);
  }
  const symbolIconModuleColor = theme.getColor(SYMBOL_ICON_MODULE_FOREGROUND);
  if (symbolIconModuleColor) {
    collector.addRule(`${Codicon.symbolModule.cssSelector} { color: ${symbolIconModuleColor}; }`);
  }
  const outlineNamespaceColor = theme.getColor(SYMBOL_ICON_NAMESPACE_FOREGROUND);
  if (outlineNamespaceColor) {
    collector.addRule(`${Codicon.symbolNamespace.cssSelector} { color: ${outlineNamespaceColor}; }`);
  }
  const symbolIconNullColor = theme.getColor(SYMBOL_ICON_NULL_FOREGROUND);
  if (symbolIconNullColor) {
    collector.addRule(`${Codicon.symbolNull.cssSelector} { color: ${symbolIconNullColor}; }`);
  }
  const symbolIconNumberColor = theme.getColor(SYMBOL_ICON_NUMBER_FOREGROUND);
  if (symbolIconNumberColor) {
    collector.addRule(`${Codicon.symbolNumber.cssSelector} { color: ${symbolIconNumberColor}; }`);
  }
  const symbolIconObjectColor = theme.getColor(SYMBOL_ICON_OBJECT_FOREGROUND);
  if (symbolIconObjectColor) {
    collector.addRule(`${Codicon.symbolObject.cssSelector} { color: ${symbolIconObjectColor}; }`);
  }
  const symbolIconOperatorColor = theme.getColor(SYMBOL_ICON_OPERATOR_FOREGROUND);
  if (symbolIconOperatorColor) {
    collector.addRule(`${Codicon.symbolOperator.cssSelector} { color: ${symbolIconOperatorColor}; }`);
  }
  const symbolIconPackageColor = theme.getColor(SYMBOL_ICON_PACKAGE_FOREGROUND);
  if (symbolIconPackageColor) {
    collector.addRule(`${Codicon.symbolPackage.cssSelector} { color: ${symbolIconPackageColor}; }`);
  }
  const symbolIconPropertyColor = theme.getColor(SYMBOL_ICON_PROPERTY_FOREGROUND);
  if (symbolIconPropertyColor) {
    collector.addRule(`${Codicon.symbolProperty.cssSelector} { color: ${symbolIconPropertyColor}; }`);
  }
  const symbolIconReferenceColor = theme.getColor(SYMBOL_ICON_REFERENCE_FOREGROUND);
  if (symbolIconReferenceColor) {
    collector.addRule(`${Codicon.symbolReference.cssSelector} { color: ${symbolIconReferenceColor}; }`);
  }
  const symbolIconSnippetColor = theme.getColor(SYMBOL_ICON_SNIPPET_FOREGROUND);
  if (symbolIconSnippetColor) {
    collector.addRule(`${Codicon.symbolSnippet.cssSelector} { color: ${symbolIconSnippetColor}; }`);
  }
  const symbolIconStringColor = theme.getColor(SYMBOL_ICON_STRING_FOREGROUND);
  if (symbolIconStringColor) {
    collector.addRule(`${Codicon.symbolString.cssSelector} { color: ${symbolIconStringColor}; }`);
  }
  const symbolIconStructColor = theme.getColor(SYMBOL_ICON_STRUCT_FOREGROUND);
  if (symbolIconStructColor) {
    collector.addRule(`${Codicon.symbolStruct.cssSelector} { color: ${symbolIconStructColor}; }`);
  }
  const symbolIconTextColor = theme.getColor(SYMBOL_ICON_TEXT_FOREGROUND);
  if (symbolIconTextColor) {
    collector.addRule(`${Codicon.symbolText.cssSelector} { color: ${symbolIconTextColor}; }`);
  }
  const symbolIconTypeParameterColor = theme.getColor(SYMBOL_ICON_TYPEPARAMETER_FOREGROUND);
  if (symbolIconTypeParameterColor) {
    collector.addRule(`${Codicon.symbolTypeParameter.cssSelector} { color: ${symbolIconTypeParameterColor}; }`);
  }
  const symbolIconUnitColor = theme.getColor(SYMBOL_ICON_UNIT_FOREGROUND);
  if (symbolIconUnitColor) {
    collector.addRule(`${Codicon.symbolUnit.cssSelector} { color: ${symbolIconUnitColor}; }`);
  }
  const symbolIconVariableColor = theme.getColor(SYMBOL_ICON_VARIABLE_FOREGROUND);
  if (symbolIconVariableColor) {
    collector.addRule(`${Codicon.symbolVariable.cssSelector} { color: ${symbolIconVariableColor}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/resizable.js
var ResizableHTMLElement = class {
  constructor() {
    this._onDidWillResize = new Emitter();
    this.onDidWillResize = this._onDidWillResize.event;
    this._onDidResize = new Emitter();
    this.onDidResize = this._onDidResize.event;
    this._sashListener = new DisposableStore();
    this._size = new Dimension(0, 0);
    this._minSize = new Dimension(0, 0);
    this._maxSize = new Dimension(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
    this.domNode = document.createElement("div");
    this._eastSash = new Sash(this.domNode, { getVerticalSashLeft: () => this._size.width }, { orientation: 0 });
    this._westSash = new Sash(this.domNode, { getVerticalSashLeft: () => 0 }, { orientation: 0 });
    this._northSash = new Sash(this.domNode, { getHorizontalSashTop: () => 0 }, { orientation: 1, orthogonalEdge: OrthogonalEdge.North });
    this._southSash = new Sash(this.domNode, { getHorizontalSashTop: () => this._size.height }, { orientation: 1, orthogonalEdge: OrthogonalEdge.South });
    this._northSash.orthogonalStartSash = this._westSash;
    this._northSash.orthogonalEndSash = this._eastSash;
    this._southSash.orthogonalStartSash = this._westSash;
    this._southSash.orthogonalEndSash = this._eastSash;
    let currentSize;
    let deltaY = 0;
    let deltaX = 0;
    this._sashListener.add(Event.any(this._northSash.onDidStart, this._eastSash.onDidStart, this._southSash.onDidStart, this._westSash.onDidStart)(() => {
      if (currentSize === void 0) {
        this._onDidWillResize.fire();
        currentSize = this._size;
        deltaY = 0;
        deltaX = 0;
      }
    }));
    this._sashListener.add(Event.any(this._northSash.onDidEnd, this._eastSash.onDidEnd, this._southSash.onDidEnd, this._westSash.onDidEnd)(() => {
      if (currentSize !== void 0) {
        currentSize = void 0;
        deltaY = 0;
        deltaX = 0;
        this._onDidResize.fire({ dimension: this._size, done: true });
      }
    }));
    this._sashListener.add(this._eastSash.onDidChange((e) => {
      if (currentSize) {
        deltaX = e.currentX - e.startX;
        this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
        this._onDidResize.fire({ dimension: this._size, done: false, east: true });
      }
    }));
    this._sashListener.add(this._westSash.onDidChange((e) => {
      if (currentSize) {
        deltaX = -(e.currentX - e.startX);
        this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
        this._onDidResize.fire({ dimension: this._size, done: false, west: true });
      }
    }));
    this._sashListener.add(this._northSash.onDidChange((e) => {
      if (currentSize) {
        deltaY = -(e.currentY - e.startY);
        this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
        this._onDidResize.fire({ dimension: this._size, done: false, north: true });
      }
    }));
    this._sashListener.add(this._southSash.onDidChange((e) => {
      if (currentSize) {
        deltaY = e.currentY - e.startY;
        this.layout(currentSize.height + deltaY, currentSize.width + deltaX);
        this._onDidResize.fire({ dimension: this._size, done: false, south: true });
      }
    }));
    this._sashListener.add(Event.any(this._eastSash.onDidReset, this._westSash.onDidReset)((e) => {
      if (this._preferredSize) {
        this.layout(this._size.height, this._preferredSize.width);
        this._onDidResize.fire({ dimension: this._size, done: true });
      }
    }));
    this._sashListener.add(Event.any(this._northSash.onDidReset, this._southSash.onDidReset)((e) => {
      if (this._preferredSize) {
        this.layout(this._preferredSize.height, this._size.width);
        this._onDidResize.fire({ dimension: this._size, done: true });
      }
    }));
  }
  dispose() {
    this._northSash.dispose();
    this._southSash.dispose();
    this._eastSash.dispose();
    this._westSash.dispose();
    this._sashListener.dispose();
    this._onDidResize.dispose();
    this._onDidWillResize.dispose();
    this.domNode.remove();
  }
  enableSashes(north, east, south, west) {
    this._northSash.state = north ? 3 : 0;
    this._eastSash.state = east ? 3 : 0;
    this._southSash.state = south ? 3 : 0;
    this._westSash.state = west ? 3 : 0;
  }
  layout(height = this.size.height, width = this.size.width) {
    const { height: minHeight, width: minWidth } = this._minSize;
    const { height: maxHeight, width: maxWidth } = this._maxSize;
    height = Math.max(minHeight, Math.min(maxHeight, height));
    width = Math.max(minWidth, Math.min(maxWidth, width));
    const newSize = new Dimension(width, height);
    if (!Dimension.equals(newSize, this._size)) {
      this.domNode.style.height = height + "px";
      this.domNode.style.width = width + "px";
      this._size = newSize;
      this._northSash.layout();
      this._eastSash.layout();
      this._southSash.layout();
      this._westSash.layout();
    }
  }
  clearSashHoverState() {
    this._eastSash.clearSashHoverState();
    this._westSash.clearSashHoverState();
    this._northSash.clearSashHoverState();
    this._southSash.clearSashHoverState();
  }
  get size() {
    return this._size;
  }
  set maxSize(value) {
    this._maxSize = value;
  }
  get maxSize() {
    return this._maxSize;
  }
  set minSize(value) {
    this._minSize = value;
  }
  get minSize() {
    return this._minSize;
  }
  set preferredSize(value) {
    this._preferredSize = value;
  }
  get preferredSize() {
    return this._preferredSize;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidgetDetails.js
var __decorate32 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param32 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function canExpandCompletionItem(item) {
  return !!item && Boolean(item.completion.documentation || item.completion.detail && item.completion.detail !== item.completion.label);
}
var SuggestDetailsWidget = class SuggestDetailsWidget2 {
  constructor(_editor, instaService) {
    this._editor = _editor;
    this._onDidClose = new Emitter();
    this.onDidClose = this._onDidClose.event;
    this._onDidChangeContents = new Emitter();
    this.onDidChangeContents = this._onDidChangeContents.event;
    this._disposables = new DisposableStore();
    this._renderDisposeable = new DisposableStore();
    this._borderWidth = 1;
    this._size = new Dimension(330, 0);
    this.domNode = $(".suggest-details");
    this.domNode.classList.add("no-docs");
    this._markdownRenderer = instaService.createInstance(MarkdownRenderer, { editor: _editor });
    this._body = $(".body");
    this._scrollbar = new DomScrollableElement(this._body, {});
    append(this.domNode, this._scrollbar.getDomNode());
    this._disposables.add(this._scrollbar);
    this._header = append(this._body, $(".header"));
    this._close = append(this._header, $("span" + Codicon.close.cssSelector));
    this._close.title = localize("details.close", "Close");
    this._type = append(this._header, $("p.type"));
    this._docs = append(this._body, $("p.docs"));
    this._configureFont();
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(43)) {
        this._configureFont();
      }
    }));
  }
  dispose() {
    this._disposables.dispose();
    this._renderDisposeable.dispose();
  }
  _configureFont() {
    const options = this._editor.getOptions();
    const fontInfo = options.get(43);
    const fontFamily = fontInfo.getMassagedFontFamily(isSafari ? EDITOR_FONT_DEFAULTS.fontFamily : null);
    const fontSize = options.get(106) || fontInfo.fontSize;
    const lineHeight = options.get(107) || fontInfo.lineHeight;
    const fontWeight = fontInfo.fontWeight;
    const fontSizePx = `${fontSize}px`;
    const lineHeightPx = `${lineHeight}px`;
    this.domNode.style.fontSize = fontSizePx;
    this.domNode.style.lineHeight = `${lineHeight / fontSize}`;
    this.domNode.style.fontWeight = fontWeight;
    this.domNode.style.fontFeatureSettings = fontInfo.fontFeatureSettings;
    this._type.style.fontFamily = fontFamily;
    this._close.style.height = lineHeightPx;
    this._close.style.width = lineHeightPx;
  }
  getLayoutInfo() {
    const lineHeight = this._editor.getOption(107) || this._editor.getOption(43).lineHeight;
    const borderWidth = this._borderWidth;
    const borderHeight = borderWidth * 2;
    return {
      lineHeight,
      borderWidth,
      borderHeight,
      verticalPadding: 22,
      horizontalPadding: 14
    };
  }
  renderLoading() {
    this._type.textContent = localize("loading", "Loading...");
    this._docs.textContent = "";
    this.domNode.classList.remove("no-docs", "no-type");
    this.layout(this.size.width, this.getLayoutInfo().lineHeight * 2);
    this._onDidChangeContents.fire(this);
  }
  renderItem(item, explainMode) {
    var _a5, _b2;
    this._renderDisposeable.clear();
    let { detail, documentation } = item.completion;
    if (explainMode) {
      let md = "";
      md += `score: ${item.score[0]}
`;
      md += `prefix: ${(_a5 = item.word) !== null && _a5 !== void 0 ? _a5 : "(no prefix)"}
`;
      md += `word: ${item.completion.filterText ? item.completion.filterText + " (filterText)" : item.textLabel}
`;
      md += `distance: ${item.distance} (localityBonus-setting)
`;
      md += `index: ${item.idx}, based on ${item.completion.sortText && `sortText: "${item.completion.sortText}"` || "label"}
`;
      md += `commit_chars: ${(_b2 = item.completion.commitCharacters) === null || _b2 === void 0 ? void 0 : _b2.join("")}
`;
      documentation = new MarkdownString().appendCodeblock("empty", md);
      detail = `Provider: ${item.provider._debugDisplayName}`;
    }
    if (!explainMode && !canExpandCompletionItem(item)) {
      this.clearContents();
      return;
    }
    this.domNode.classList.remove("no-docs", "no-type");
    if (detail) {
      const cappedDetail = detail.length > 1e5 ? `${detail.substr(0, 1e5)}\u2026` : detail;
      this._type.textContent = cappedDetail;
      this._type.title = cappedDetail;
      show(this._type);
      this._type.classList.toggle("auto-wrap", !/\r?\n^\s+/gmi.test(cappedDetail));
    } else {
      clearNode(this._type);
      this._type.title = "";
      hide(this._type);
      this.domNode.classList.add("no-type");
    }
    clearNode(this._docs);
    if (typeof documentation === "string") {
      this._docs.classList.remove("markdown-docs");
      this._docs.textContent = documentation;
    } else if (documentation) {
      this._docs.classList.add("markdown-docs");
      clearNode(this._docs);
      const renderedContents = this._markdownRenderer.render(documentation);
      this._docs.appendChild(renderedContents.element);
      this._renderDisposeable.add(renderedContents);
      this._renderDisposeable.add(this._markdownRenderer.onDidRenderAsync(() => {
        this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);
        this._onDidChangeContents.fire(this);
      }));
    }
    this.domNode.style.userSelect = "text";
    this.domNode.tabIndex = -1;
    this._close.onmousedown = (e) => {
      e.preventDefault();
      e.stopPropagation();
    };
    this._close.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      this._onDidClose.fire();
    };
    this._body.scrollTop = 0;
    this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight);
    this._onDidChangeContents.fire(this);
  }
  clearContents() {
    this.domNode.classList.add("no-docs");
    this._type.textContent = "";
    this._docs.textContent = "";
  }
  get size() {
    return this._size;
  }
  layout(width, height) {
    const newSize = new Dimension(width, height);
    if (!Dimension.equals(newSize, this._size)) {
      this._size = newSize;
      size(this.domNode, width, height);
    }
    this._scrollbar.scanDomNode();
  }
  scrollDown(much = 8) {
    this._body.scrollTop += much;
  }
  scrollUp(much = 8) {
    this._body.scrollTop -= much;
  }
  scrollTop() {
    this._body.scrollTop = 0;
  }
  scrollBottom() {
    this._body.scrollTop = this._body.scrollHeight;
  }
  pageDown() {
    this.scrollDown(80);
  }
  pageUp() {
    this.scrollUp(80);
  }
  set borderWidth(width) {
    this._borderWidth = width;
  }
  get borderWidth() {
    return this._borderWidth;
  }
};
SuggestDetailsWidget = __decorate32([
  __param32(1, IInstantiationService)
], SuggestDetailsWidget);
var SuggestDetailsOverlay = class {
  constructor(widget, _editor) {
    this.widget = widget;
    this._editor = _editor;
    this._disposables = new DisposableStore();
    this._added = false;
    this._preferAlignAtTop = true;
    this._resizable = new ResizableHTMLElement();
    this._resizable.domNode.classList.add("suggest-details-container");
    this._resizable.domNode.appendChild(widget.domNode);
    this._resizable.enableSashes(false, true, true, false);
    let topLeftNow;
    let sizeNow;
    let deltaTop = 0;
    let deltaLeft = 0;
    this._disposables.add(this._resizable.onDidWillResize(() => {
      topLeftNow = this._topLeft;
      sizeNow = this._resizable.size;
    }));
    this._disposables.add(this._resizable.onDidResize((e) => {
      if (topLeftNow && sizeNow) {
        this.widget.layout(e.dimension.width, e.dimension.height);
        let updateTopLeft = false;
        if (e.west) {
          deltaLeft = sizeNow.width - e.dimension.width;
          updateTopLeft = true;
        }
        if (e.north) {
          deltaTop = sizeNow.height - e.dimension.height;
          updateTopLeft = true;
        }
        if (updateTopLeft) {
          this._applyTopLeft({
            top: topLeftNow.top + deltaTop,
            left: topLeftNow.left + deltaLeft
          });
        }
      }
      if (e.done) {
        topLeftNow = void 0;
        sizeNow = void 0;
        deltaTop = 0;
        deltaLeft = 0;
        this._userSize = e.dimension;
      }
    }));
    this._disposables.add(this.widget.onDidChangeContents(() => {
      var _a5;
      if (this._anchorBox) {
        this._placeAtAnchor(this._anchorBox, (_a5 = this._userSize) !== null && _a5 !== void 0 ? _a5 : this.widget.size, this._preferAlignAtTop);
      }
    }));
  }
  dispose() {
    this._resizable.dispose();
    this._disposables.dispose();
    this.hide();
  }
  getId() {
    return "suggest.details";
  }
  getDomNode() {
    return this._resizable.domNode;
  }
  getPosition() {
    return null;
  }
  show() {
    if (!this._added) {
      this._editor.addOverlayWidget(this);
      this.getDomNode().style.position = "fixed";
      this._added = true;
    }
  }
  hide(sessionEnded = false) {
    this._resizable.clearSashHoverState();
    if (this._added) {
      this._editor.removeOverlayWidget(this);
      this._added = false;
      this._anchorBox = void 0;
      this._topLeft = void 0;
    }
    if (sessionEnded) {
      this._userSize = void 0;
      this.widget.clearContents();
    }
  }
  placeAtAnchor(anchor, preferAlignAtTop) {
    var _a5;
    const anchorBox = anchor.getBoundingClientRect();
    this._anchorBox = anchorBox;
    this._preferAlignAtTop = preferAlignAtTop;
    this._placeAtAnchor(this._anchorBox, (_a5 = this._userSize) !== null && _a5 !== void 0 ? _a5 : this.widget.size, preferAlignAtTop);
  }
  _placeAtAnchor(anchorBox, size2, preferAlignAtTop) {
    var _a5;
    const bodyBox = getClientArea(document.body);
    const info = this.widget.getLayoutInfo();
    const defaultMinSize = new Dimension(220, 2 * info.lineHeight);
    const defaultTop = anchorBox.top;
    const eastPlacement = function() {
      const width = bodyBox.width - (anchorBox.left + anchorBox.width + info.borderWidth + info.horizontalPadding);
      const left = -info.borderWidth + anchorBox.left + anchorBox.width;
      const maxSizeTop = new Dimension(width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);
      const maxSizeBottom = maxSizeTop.with(void 0, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);
      return { top: defaultTop, left, fit: width - size2.width, maxSizeTop, maxSizeBottom, minSize: defaultMinSize.with(Math.min(width, defaultMinSize.width)) };
    }();
    const westPlacement = function() {
      const width = anchorBox.left - info.borderWidth - info.horizontalPadding;
      const left = Math.max(info.horizontalPadding, anchorBox.left - size2.width - info.borderWidth);
      const maxSizeTop = new Dimension(width, bodyBox.height - anchorBox.top - info.borderHeight - info.verticalPadding);
      const maxSizeBottom = maxSizeTop.with(void 0, anchorBox.top + anchorBox.height - info.borderHeight - info.verticalPadding);
      return { top: defaultTop, left, fit: width - size2.width, maxSizeTop, maxSizeBottom, minSize: defaultMinSize.with(Math.min(width, defaultMinSize.width)) };
    }();
    const southPacement = function() {
      const left = anchorBox.left;
      const top = -info.borderWidth + anchorBox.top + anchorBox.height;
      const maxSizeBottom = new Dimension(anchorBox.width - info.borderHeight, bodyBox.height - anchorBox.top - anchorBox.height - info.verticalPadding);
      return { top, left, fit: maxSizeBottom.height - size2.height, maxSizeBottom, maxSizeTop: maxSizeBottom, minSize: defaultMinSize.with(maxSizeBottom.width) };
    }();
    const placements = [eastPlacement, westPlacement, southPacement];
    const placement = (_a5 = placements.find((p) => p.fit >= 0)) !== null && _a5 !== void 0 ? _a5 : placements.sort((a, b) => b.fit - a.fit)[0];
    const bottom = anchorBox.top + anchorBox.height - info.borderHeight;
    let alignAtTop;
    let height = size2.height;
    const maxHeight = Math.max(placement.maxSizeTop.height, placement.maxSizeBottom.height);
    if (height > maxHeight) {
      height = maxHeight;
    }
    let maxSize;
    if (preferAlignAtTop) {
      if (height <= placement.maxSizeTop.height) {
        alignAtTop = true;
        maxSize = placement.maxSizeTop;
      } else {
        alignAtTop = false;
        maxSize = placement.maxSizeBottom;
      }
    } else {
      if (height <= placement.maxSizeBottom.height) {
        alignAtTop = false;
        maxSize = placement.maxSizeBottom;
      } else {
        alignAtTop = true;
        maxSize = placement.maxSizeTop;
      }
    }
    this._applyTopLeft({ left: placement.left, top: alignAtTop ? placement.top : bottom - height });
    this.getDomNode().style.position = "fixed";
    this._resizable.enableSashes(!alignAtTop, placement === eastPlacement, alignAtTop, placement !== eastPlacement);
    this._resizable.minSize = placement.minSize;
    this._resizable.maxSize = maxSize;
    this._resizable.layout(height, Math.min(maxSize.width, size2.width));
    this.widget.layout(this._resizable.size.width, this._resizable.size.height);
  }
  _applyTopLeft(topLeft) {
    this._topLeft = topLeft;
    this.getDomNode().style.left = `${this._topLeft.left}px`;
    this.getDomNode().style.top = `${this._topLeft.top}px`;
  }
};

// node_modules/monaco-editor/esm/vs/platform/files/common/files.js
var FileKind;
(function(FileKind2) {
  FileKind2[FileKind2["FILE"] = 0] = "FILE";
  FileKind2[FileKind2["FOLDER"] = 1] = "FOLDER";
  FileKind2[FileKind2["ROOT_FOLDER"] = 2] = "ROOT_FOLDER";
})(FileKind || (FileKind = {}));

// node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js
function getIconClasses(modelService, modeService, resource, fileKind) {
  const classes = fileKind === FileKind.ROOT_FOLDER ? ["rootfolder-icon"] : fileKind === FileKind.FOLDER ? ["folder-icon"] : ["file-icon"];
  if (resource) {
    let name;
    if (resource.scheme === Schemas.data) {
      const metadata = DataUri.parseMetaData(resource);
      name = metadata.get(DataUri.META_DATA_LABEL);
    } else {
      name = cssEscape(basenameOrAuthority(resource).toLowerCase());
    }
    if (fileKind === FileKind.FOLDER) {
      classes.push(`${name}-name-folder-icon`);
    } else {
      if (name) {
        classes.push(`${name}-name-file-icon`);
        if (name.length <= 255) {
          const dotSegments = name.split(".");
          for (let i = 1; i < dotSegments.length; i++) {
            classes.push(`${dotSegments.slice(i).join(".")}-ext-file-icon`);
          }
        }
        classes.push(`ext-file-icon`);
      }
      const detectedModeId = detectModeId(modelService, modeService, resource);
      if (detectedModeId) {
        classes.push(`${cssEscape(detectedModeId)}-lang-file-icon`);
      }
    }
  }
  return classes;
}
function detectModeId(modelService, modeService, resource) {
  if (!resource) {
    return null;
  }
  let modeId = null;
  if (resource.scheme === Schemas.data) {
    const metadata = DataUri.parseMetaData(resource);
    const mime = metadata.get(DataUri.META_DATA_MIME);
    if (mime) {
      modeId = modeService.getModeId(mime);
    }
  } else {
    const model = modelService.getModel(resource);
    if (model) {
      modeId = model.getLanguageId();
    }
  }
  if (modeId && modeId !== PLAINTEXT_MODE_ID) {
    return modeId;
  }
  return modeService.getModeIdByFilepathOrFirstLine(resource);
}
function cssEscape(str) {
  return str.replace(/[\11\12\14\15\40]/g, "/");
}

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidgetRenderer.js
var __decorate33 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param33 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _a3;
function getAriaId(index) {
  return `suggest-aria-id:${index}`;
}
var suggestMoreInfoIcon = registerIcon("suggest-more-info", Codicon.chevronRight, localize("suggestMoreInfoIcon", "Icon for more information in the suggest widget."));
var _completionItemColor = new (_a3 = class ColorExtractor {
  extract(item, out) {
    if (item.textLabel.match(ColorExtractor._regexStrict)) {
      out[0] = item.textLabel;
      return true;
    }
    if (item.completion.detail && item.completion.detail.match(ColorExtractor._regexStrict)) {
      out[0] = item.completion.detail;
      return true;
    }
    if (typeof item.completion.documentation === "string") {
      const match = ColorExtractor._regexRelaxed.exec(item.completion.documentation);
      if (match && (match.index === 0 || match.index + match[0].length === item.completion.documentation.length)) {
        out[0] = match[0];
        return true;
      }
    }
    return false;
  }
}, _a3._regexRelaxed = /(#([\da-fA-F]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))/, _a3._regexStrict = new RegExp(`^${_a3._regexRelaxed.source}$`, "i"), _a3)();
var ItemRenderer = class ItemRenderer2 {
  constructor(_editor, _modelService, _modeService, _themeService) {
    this._editor = _editor;
    this._modelService = _modelService;
    this._modeService = _modeService;
    this._themeService = _themeService;
    this._onDidToggleDetails = new Emitter();
    this.onDidToggleDetails = this._onDidToggleDetails.event;
    this.templateId = "suggestion";
  }
  dispose() {
    this._onDidToggleDetails.dispose();
  }
  renderTemplate(container) {
    const data = Object.create(null);
    data.disposables = new DisposableStore();
    data.root = container;
    data.root.classList.add("show-file-icons");
    data.icon = append(container, $(".icon"));
    data.colorspan = append(data.icon, $("span.colorspan"));
    const text2 = append(container, $(".contents"));
    const main = append(text2, $(".main"));
    data.iconContainer = append(main, $(".icon-label.codicon"));
    data.left = append(main, $("span.left"));
    data.right = append(main, $("span.right"));
    data.iconLabel = new IconLabel(data.left, { supportHighlights: true, supportIcons: true });
    data.disposables.add(data.iconLabel);
    data.parametersLabel = append(data.left, $("span.signature-label"));
    data.qualifierLabel = append(data.left, $("span.qualifier-label"));
    data.detailsLabel = append(data.right, $("span.details-label"));
    data.readMore = append(data.right, $("span.readMore" + ThemeIcon.asCSSSelector(suggestMoreInfoIcon)));
    data.readMore.title = localize("readMore", "Read More");
    const configureFont = () => {
      const options = this._editor.getOptions();
      const fontInfo = options.get(43);
      const fontFamily = fontInfo.getMassagedFontFamily(isSafari ? EDITOR_FONT_DEFAULTS.fontFamily : null);
      const fontFeatureSettings = fontInfo.fontFeatureSettings;
      const fontSize = options.get(106) || fontInfo.fontSize;
      const lineHeight = options.get(107) || fontInfo.lineHeight;
      const fontWeight = fontInfo.fontWeight;
      const fontSizePx = `${fontSize}px`;
      const lineHeightPx = `${lineHeight}px`;
      data.root.style.fontSize = fontSizePx;
      data.root.style.fontWeight = fontWeight;
      main.style.fontFamily = fontFamily;
      main.style.fontFeatureSettings = fontFeatureSettings;
      main.style.lineHeight = lineHeightPx;
      data.icon.style.height = lineHeightPx;
      data.icon.style.width = lineHeightPx;
      data.readMore.style.height = lineHeightPx;
      data.readMore.style.width = lineHeightPx;
    };
    configureFont();
    data.disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(43) || e.hasChanged(106) || e.hasChanged(107)) {
        configureFont();
      }
    }));
    return data;
  }
  renderElement(element, index, data) {
    const { completion } = element;
    data.root.id = getAriaId(index);
    data.colorspan.style.backgroundColor = "";
    const labelOptions = {
      labelEscapeNewLines: true,
      matches: createMatches(element.score)
    };
    let color = [];
    if (completion.kind === 19 && _completionItemColor.extract(element, color)) {
      data.icon.className = "icon customcolor";
      data.iconContainer.className = "icon hide";
      data.colorspan.style.backgroundColor = color[0];
    } else if (completion.kind === 20 && this._themeService.getFileIconTheme().hasFileIcons) {
      data.icon.className = "icon hide";
      data.iconContainer.className = "icon hide";
      const labelClasses = getIconClasses(this._modelService, this._modeService, URI.from({ scheme: "fake", path: element.textLabel }), FileKind.FILE);
      const detailClasses = getIconClasses(this._modelService, this._modeService, URI.from({ scheme: "fake", path: completion.detail }), FileKind.FILE);
      labelOptions.extraClasses = labelClasses.length > detailClasses.length ? labelClasses : detailClasses;
    } else if (completion.kind === 23 && this._themeService.getFileIconTheme().hasFolderIcons) {
      data.icon.className = "icon hide";
      data.iconContainer.className = "icon hide";
      labelOptions.extraClasses = flatten([
        getIconClasses(this._modelService, this._modeService, URI.from({ scheme: "fake", path: element.textLabel }), FileKind.FOLDER),
        getIconClasses(this._modelService, this._modeService, URI.from({ scheme: "fake", path: completion.detail }), FileKind.FOLDER)
      ]);
    } else {
      data.icon.className = "icon hide";
      data.iconContainer.className = "";
      data.iconContainer.classList.add("suggest-icon", ...completionKindToCssClass(completion.kind).split(" "));
    }
    if (completion.tags && completion.tags.indexOf(1) >= 0) {
      labelOptions.extraClasses = (labelOptions.extraClasses || []).concat(["deprecated"]);
      labelOptions.matches = [];
    }
    data.iconLabel.setLabel(element.textLabel, void 0, labelOptions);
    if (typeof completion.label === "string") {
      data.parametersLabel.textContent = "";
      data.detailsLabel.textContent = stripNewLines(completion.detail || "");
      data.root.classList.add("string-label");
    } else {
      data.parametersLabel.textContent = stripNewLines(completion.label.detail || "");
      data.detailsLabel.textContent = stripNewLines(completion.label.description || "");
      data.root.classList.remove("string-label");
    }
    if (this._editor.getOption(105).showInlineDetails) {
      show(data.detailsLabel);
    } else {
      hide(data.detailsLabel);
    }
    if (canExpandCompletionItem(element)) {
      data.right.classList.add("can-expand-details");
      show(data.readMore);
      data.readMore.onmousedown = (e) => {
        e.stopPropagation();
        e.preventDefault();
      };
      data.readMore.onclick = (e) => {
        e.stopPropagation();
        e.preventDefault();
        this._onDidToggleDetails.fire();
      };
    } else {
      data.right.classList.remove("can-expand-details");
      hide(data.readMore);
      data.readMore.onmousedown = null;
      data.readMore.onclick = null;
    }
  }
  disposeTemplate(templateData) {
    templateData.disposables.dispose();
  }
};
ItemRenderer = __decorate33([
  __param33(1, IModelService),
  __param33(2, IModeService),
  __param33(3, IThemeService)
], ItemRenderer);
function stripNewLines(str) {
  return str.replace(/\r\n|\r|\n/g, "");
}

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestWidget.js
var __decorate34 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param34 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter25 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var editorSuggestWidgetBackground = registerColor("editorSuggestWidget.background", { dark: editorWidgetBackground, light: editorWidgetBackground, hc: editorWidgetBackground }, localize("editorSuggestWidgetBackground", "Background color of the suggest widget."));
var editorSuggestWidgetBorder = registerColor("editorSuggestWidget.border", { dark: editorWidgetBorder, light: editorWidgetBorder, hc: editorWidgetBorder }, localize("editorSuggestWidgetBorder", "Border color of the suggest widget."));
var editorSuggestWidgetForeground = registerColor("editorSuggestWidget.foreground", { dark: editorForeground, light: editorForeground, hc: editorForeground }, localize("editorSuggestWidgetForeground", "Foreground color of the suggest widget."));
var editorSuggestWidgetSelectedForeground = registerColor("editorSuggestWidget.selectedForeground", { dark: quickInputListFocusForeground, light: quickInputListFocusForeground, hc: quickInputListFocusForeground }, localize("editorSuggestWidgetSelectedForeground", "Foreground color of the selected entry in the suggest widget."));
var editorSuggestWidgetSelectedIconForeground = registerColor("editorSuggestWidget.selectedIconForeground", { dark: quickInputListFocusIconForeground, light: quickInputListFocusIconForeground, hc: quickInputListFocusIconForeground }, localize("editorSuggestWidgetSelectedIconForeground", "Icon foreground color of the selected entry in the suggest widget."));
var editorSuggestWidgetSelectedBackground = registerColor("editorSuggestWidget.selectedBackground", { dark: quickInputListFocusBackground, light: quickInputListFocusBackground, hc: quickInputListFocusBackground }, localize("editorSuggestWidgetSelectedBackground", "Background color of the selected entry in the suggest widget."));
var editorSuggestWidgetHighlightForeground = registerColor("editorSuggestWidget.highlightForeground", { dark: listHighlightForeground, light: listHighlightForeground, hc: listHighlightForeground }, localize("editorSuggestWidgetHighlightForeground", "Color of the match highlights in the suggest widget."));
var editorSuggestWidgetHighlightFocusForeground = registerColor("editorSuggestWidget.focusHighlightForeground", { dark: listFocusHighlightForeground, light: listFocusHighlightForeground, hc: listFocusHighlightForeground }, localize("editorSuggestWidgetFocusHighlightForeground", "Color of the match highlights in the suggest widget when an item is focused."));
var editorSuggestWidgetStatusForeground = registerColor("editorSuggestWidgetStatus.foreground", { dark: transparent(editorSuggestWidgetForeground, 0.5), light: transparent(editorSuggestWidgetForeground, 0.5), hc: transparent(editorSuggestWidgetForeground, 0.5) }, localize("editorSuggestWidgetStatusForeground", "Foreground color of the suggest widget status."));
var PersistedWidgetSize = class {
  constructor(_service, editor2) {
    this._service = _service;
    this._key = `suggestWidget.size/${editor2.getEditorType()}/${editor2 instanceof EmbeddedCodeEditorWidget}`;
  }
  restore() {
    var _a5;
    const raw = (_a5 = this._service.get(this._key, 0)) !== null && _a5 !== void 0 ? _a5 : "";
    try {
      const obj = JSON.parse(raw);
      if (Dimension.is(obj)) {
        return Dimension.lift(obj);
      }
    } catch (_b2) {
    }
    return void 0;
  }
  store(size2) {
    this._service.store(this._key, JSON.stringify(size2), 0, 1);
  }
  reset() {
    this._service.remove(this._key, 0);
  }
};
var SuggestWidget = class SuggestWidget2 {
  constructor(editor2, _storageService, _contextKeyService, _themeService, instantiationService) {
    this.editor = editor2;
    this._storageService = _storageService;
    this._state = 0;
    this._isAuto = false;
    this._ignoreFocusEvents = false;
    this._forceRenderingAbove = false;
    this._explainMode = false;
    this._showTimeout = new TimeoutTimer();
    this._disposables = new DisposableStore();
    this._onDidSelect = new Emitter();
    this._onDidFocus = new Emitter();
    this._onDidHide = new Emitter();
    this._onDidShow = new Emitter();
    this.onDidSelect = this._onDidSelect.event;
    this.onDidFocus = this._onDidFocus.event;
    this.onDidHide = this._onDidHide.event;
    this.onDidShow = this._onDidShow.event;
    this._onDetailsKeydown = new Emitter();
    this.onDetailsKeyDown = this._onDetailsKeydown.event;
    this.element = new ResizableHTMLElement();
    this.element.domNode.classList.add("editor-widget", "suggest-widget");
    this._contentWidget = new SuggestContentWidget(this, editor2);
    this._persistedSize = new PersistedWidgetSize(_storageService, editor2);
    class ResizeState {
      constructor(persistedSize, currentSize, persistHeight = false, persistWidth = false) {
        this.persistedSize = persistedSize;
        this.currentSize = currentSize;
        this.persistHeight = persistHeight;
        this.persistWidth = persistWidth;
      }
    }
    let state;
    this._disposables.add(this.element.onDidWillResize(() => {
      this._contentWidget.lockPreference();
      state = new ResizeState(this._persistedSize.restore(), this.element.size);
    }));
    this._disposables.add(this.element.onDidResize((e) => {
      var _a5, _b2, _c2, _d2;
      this._resize(e.dimension.width, e.dimension.height);
      if (state) {
        state.persistHeight = state.persistHeight || !!e.north || !!e.south;
        state.persistWidth = state.persistWidth || !!e.east || !!e.west;
      }
      if (!e.done) {
        return;
      }
      if (state) {
        const { itemHeight, defaultSize } = this.getLayoutInfo();
        const threshold = Math.round(itemHeight / 2);
        let { width, height } = this.element.size;
        if (!state.persistHeight || Math.abs(state.currentSize.height - height) <= threshold) {
          height = (_b2 = (_a5 = state.persistedSize) === null || _a5 === void 0 ? void 0 : _a5.height) !== null && _b2 !== void 0 ? _b2 : defaultSize.height;
        }
        if (!state.persistWidth || Math.abs(state.currentSize.width - width) <= threshold) {
          width = (_d2 = (_c2 = state.persistedSize) === null || _c2 === void 0 ? void 0 : _c2.width) !== null && _d2 !== void 0 ? _d2 : defaultSize.width;
        }
        this._persistedSize.store(new Dimension(width, height));
      }
      this._contentWidget.unlockPreference();
      state = void 0;
    }));
    this._messageElement = append(this.element.domNode, $(".message"));
    this._listElement = append(this.element.domNode, $(".tree"));
    const details = instantiationService.createInstance(SuggestDetailsWidget, this.editor);
    details.onDidClose(this.toggleDetails, this, this._disposables);
    this._details = new SuggestDetailsOverlay(details, this.editor);
    const applyIconStyle = () => this.element.domNode.classList.toggle("no-icons", !this.editor.getOption(105).showIcons);
    applyIconStyle();
    const renderer = instantiationService.createInstance(ItemRenderer, this.editor);
    this._disposables.add(renderer);
    this._disposables.add(renderer.onDidToggleDetails(() => this.toggleDetails()));
    this._list = new List("SuggestWidget", this._listElement, {
      getHeight: (_element) => this.getLayoutInfo().itemHeight,
      getTemplateId: (_element) => "suggestion"
    }, [renderer], {
      alwaysConsumeMouseWheel: true,
      useShadows: false,
      mouseSupport: false,
      accessibilityProvider: {
        getRole: () => "option",
        getAriaLabel: (item) => {
          if (item.isResolved && this._isDetailsVisible()) {
            const { documentation, detail } = item.completion;
            const docs = format("{0}{1}", detail || "", documentation ? typeof documentation === "string" ? documentation : documentation.value : "");
            return localize("ariaCurrenttSuggestionReadDetails", "{0}, docs: {1}", item.textLabel, docs);
          } else {
            return item.textLabel;
          }
        },
        getWidgetAriaLabel: () => localize("suggest", "Suggest"),
        getWidgetRole: () => "listbox"
      }
    });
    this._status = instantiationService.createInstance(SuggestWidgetStatus, this.element.domNode);
    const applyStatusBarStyle = () => this.element.domNode.classList.toggle("with-status-bar", this.editor.getOption(105).showStatusBar);
    applyStatusBarStyle();
    this._disposables.add(attachListStyler(this._list, _themeService, {
      listInactiveFocusBackground: editorSuggestWidgetSelectedBackground,
      listInactiveFocusOutline: activeContrastBorder
    }));
    this._disposables.add(_themeService.onDidColorThemeChange((t) => this._onThemeChange(t)));
    this._onThemeChange(_themeService.getColorTheme());
    this._disposables.add(this._list.onMouseDown((e) => this._onListMouseDownOrTap(e)));
    this._disposables.add(this._list.onTap((e) => this._onListMouseDownOrTap(e)));
    this._disposables.add(this._list.onDidChangeSelection((e) => this._onListSelection(e)));
    this._disposables.add(this._list.onDidChangeFocus((e) => this._onListFocus(e)));
    this._disposables.add(this.editor.onDidChangeCursorSelection(() => this._onCursorSelectionChanged()));
    this._disposables.add(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(105)) {
        applyStatusBarStyle();
        applyIconStyle();
      }
    }));
    this._ctxSuggestWidgetVisible = Context.Visible.bindTo(_contextKeyService);
    this._ctxSuggestWidgetDetailsVisible = Context.DetailsVisible.bindTo(_contextKeyService);
    this._ctxSuggestWidgetMultipleSuggestions = Context.MultipleSuggestions.bindTo(_contextKeyService);
    this._disposables.add(addStandardDisposableListener(this._details.widget.domNode, "keydown", (e) => {
      this._onDetailsKeydown.fire(e);
    }));
    this._disposables.add(this.editor.onMouseDown((e) => this._onEditorMouseDown(e)));
  }
  dispose() {
    var _a5;
    this._details.widget.dispose();
    this._details.dispose();
    this._list.dispose();
    this._status.dispose();
    this._disposables.dispose();
    (_a5 = this._loadingTimeout) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    this._showTimeout.dispose();
    this._contentWidget.dispose();
    this.element.dispose();
  }
  _onEditorMouseDown(mouseEvent) {
    if (this._details.widget.domNode.contains(mouseEvent.target.element)) {
      this._details.widget.domNode.focus();
    } else {
      if (this.element.domNode.contains(mouseEvent.target.element)) {
        this.editor.focus();
      }
    }
  }
  _onCursorSelectionChanged() {
    if (this._state !== 0) {
      this._contentWidget.layout();
    }
  }
  _onListMouseDownOrTap(e) {
    if (typeof e.element === "undefined" || typeof e.index === "undefined") {
      return;
    }
    e.browserEvent.preventDefault();
    e.browserEvent.stopPropagation();
    this._select(e.element, e.index);
  }
  _onListSelection(e) {
    if (e.elements.length) {
      this._select(e.elements[0], e.indexes[0]);
    }
  }
  _select(item, index) {
    const completionModel = this._completionModel;
    if (completionModel) {
      this._onDidSelect.fire({ item, index, model: completionModel });
      this.editor.focus();
    }
  }
  _onThemeChange(theme) {
    this._details.widget.borderWidth = theme.type === "hc" ? 2 : 1;
  }
  _onListFocus(e) {
    var _a5;
    if (this._ignoreFocusEvents) {
      return;
    }
    if (!e.elements.length) {
      if (this._currentSuggestionDetails) {
        this._currentSuggestionDetails.cancel();
        this._currentSuggestionDetails = void 0;
        this._focusedItem = void 0;
      }
      this.editor.setAriaOptions({ activeDescendant: void 0 });
      return;
    }
    if (!this._completionModel) {
      return;
    }
    const item = e.elements[0];
    const index = e.indexes[0];
    if (item !== this._focusedItem) {
      (_a5 = this._currentSuggestionDetails) === null || _a5 === void 0 ? void 0 : _a5.cancel();
      this._currentSuggestionDetails = void 0;
      this._focusedItem = item;
      this._list.reveal(index);
      this._currentSuggestionDetails = createCancelablePromise((token) => __awaiter25(this, void 0, void 0, function* () {
        const loading = disposableTimeout(() => {
          if (this._isDetailsVisible()) {
            this.showDetails(true);
          }
        }, 250);
        token.onCancellationRequested(() => loading.dispose());
        const result = yield item.resolve(token);
        loading.dispose();
        return result;
      }));
      this._currentSuggestionDetails.then(() => {
        if (index >= this._list.length || item !== this._list.element(index)) {
          return;
        }
        this._ignoreFocusEvents = true;
        this._list.splice(index, 1, [item]);
        this._list.setFocus([index]);
        this._ignoreFocusEvents = false;
        if (this._isDetailsVisible()) {
          this.showDetails(false);
        } else {
          this.element.domNode.classList.remove("docs-side");
        }
        this.editor.setAriaOptions({ activeDescendant: getAriaId(index) });
      }).catch(onUnexpectedError);
    }
    this._onDidFocus.fire({ item, index, model: this._completionModel });
  }
  _setState(state) {
    if (this._state === state) {
      return;
    }
    this._state = state;
    this.element.domNode.classList.toggle("frozen", state === 4);
    this.element.domNode.classList.remove("message");
    switch (state) {
      case 0:
        hide(this._messageElement, this._listElement, this._status.element);
        this._details.hide(true);
        this._status.hide();
        this._contentWidget.hide();
        this._ctxSuggestWidgetVisible.reset();
        this._ctxSuggestWidgetMultipleSuggestions.reset();
        this._showTimeout.cancel();
        this.element.domNode.classList.remove("visible");
        this._list.splice(0, this._list.length);
        this._focusedItem = void 0;
        this._cappedHeight = void 0;
        this._explainMode = false;
        break;
      case 1:
        this.element.domNode.classList.add("message");
        this._messageElement.textContent = SuggestWidget2.LOADING_MESSAGE;
        hide(this._listElement, this._status.element);
        show(this._messageElement);
        this._details.hide();
        this._show();
        this._focusedItem = void 0;
        break;
      case 2:
        this.element.domNode.classList.add("message");
        this._messageElement.textContent = SuggestWidget2.NO_SUGGESTIONS_MESSAGE;
        hide(this._listElement, this._status.element);
        show(this._messageElement);
        this._details.hide();
        this._show();
        this._focusedItem = void 0;
        break;
      case 3:
        hide(this._messageElement);
        show(this._listElement, this._status.element);
        this._show();
        break;
      case 4:
        hide(this._messageElement);
        show(this._listElement, this._status.element);
        this._show();
        break;
      case 5:
        hide(this._messageElement);
        show(this._listElement, this._status.element);
        this._details.show();
        this._show();
        break;
    }
  }
  _show() {
    this._status.show();
    this._contentWidget.show();
    this._layout(this._persistedSize.restore());
    this._ctxSuggestWidgetVisible.set(true);
    this._showTimeout.cancelAndSet(() => {
      this.element.domNode.classList.add("visible");
      this._onDidShow.fire(this);
    }, 100);
  }
  showTriggered(auto, delay) {
    if (this._state !== 0) {
      return;
    }
    this._contentWidget.setPosition(this.editor.getPosition());
    this._isAuto = !!auto;
    if (!this._isAuto) {
      this._loadingTimeout = disposableTimeout(() => this._setState(1), delay);
    }
  }
  showSuggestions(completionModel, selectionIndex, isFrozen2, isAuto) {
    var _a5, _b2;
    this._contentWidget.setPosition(this.editor.getPosition());
    (_a5 = this._loadingTimeout) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    (_b2 = this._currentSuggestionDetails) === null || _b2 === void 0 ? void 0 : _b2.cancel();
    this._currentSuggestionDetails = void 0;
    if (this._completionModel !== completionModel) {
      this._completionModel = completionModel;
    }
    if (isFrozen2 && this._state !== 2 && this._state !== 0) {
      this._setState(4);
      return;
    }
    const visibleCount = this._completionModel.items.length;
    const isEmpty = visibleCount === 0;
    this._ctxSuggestWidgetMultipleSuggestions.set(visibleCount > 1);
    if (isEmpty) {
      this._setState(isAuto ? 0 : 2);
      this._completionModel = void 0;
      return;
    }
    this._focusedItem = void 0;
    this._list.splice(0, this._list.length, this._completionModel.items);
    this._setState(isFrozen2 ? 4 : 3);
    this._list.reveal(selectionIndex, 0);
    this._list.setFocus([selectionIndex]);
    this._layout(this.element.size);
    this._details.widget.domNode.classList.remove("focused");
  }
  selectNextPage() {
    switch (this._state) {
      case 0:
        return false;
      case 5:
        this._details.widget.pageDown();
        return true;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusNextPage();
        return true;
    }
  }
  selectNext() {
    switch (this._state) {
      case 0:
        return false;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusNext(1, true);
        return true;
    }
  }
  selectLast() {
    switch (this._state) {
      case 0:
        return false;
      case 5:
        this._details.widget.scrollBottom();
        return true;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusLast();
        return true;
    }
  }
  selectPreviousPage() {
    switch (this._state) {
      case 0:
        return false;
      case 5:
        this._details.widget.pageUp();
        return true;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusPreviousPage();
        return true;
    }
  }
  selectPrevious() {
    switch (this._state) {
      case 0:
        return false;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusPrevious(1, true);
        return false;
    }
  }
  selectFirst() {
    switch (this._state) {
      case 0:
        return false;
      case 5:
        this._details.widget.scrollTop();
        return true;
      case 1:
        return !this._isAuto;
      default:
        this._list.focusFirst();
        return true;
    }
  }
  getFocusedItem() {
    if (this._state !== 0 && this._state !== 2 && this._state !== 1 && this._completionModel) {
      return {
        item: this._list.getFocusedElements()[0],
        index: this._list.getFocus()[0],
        model: this._completionModel
      };
    }
    return void 0;
  }
  toggleDetailsFocus() {
    if (this._state === 5) {
      this._setState(3);
      this._details.widget.domNode.classList.remove("focused");
    } else if (this._state === 3 && this._isDetailsVisible()) {
      this._setState(5);
      this._details.widget.domNode.classList.add("focused");
    }
  }
  toggleDetails() {
    if (this._isDetailsVisible()) {
      this._ctxSuggestWidgetDetailsVisible.set(false);
      this._setDetailsVisible(false);
      this._details.hide();
      this.element.domNode.classList.remove("shows-details");
    } else if ((canExpandCompletionItem(this._list.getFocusedElements()[0]) || this._explainMode) && (this._state === 3 || this._state === 5 || this._state === 4)) {
      this._ctxSuggestWidgetDetailsVisible.set(true);
      this._setDetailsVisible(true);
      this.showDetails(false);
    }
  }
  showDetails(loading) {
    this._details.show();
    if (loading) {
      this._details.widget.renderLoading();
    } else {
      this._details.widget.renderItem(this._list.getFocusedElements()[0], this._explainMode);
    }
    this._positionDetails();
    this.editor.focus();
    this.element.domNode.classList.add("shows-details");
  }
  toggleExplainMode() {
    if (this._list.getFocusedElements()[0]) {
      this._explainMode = !this._explainMode;
      if (!this._isDetailsVisible()) {
        this.toggleDetails();
      } else {
        this.showDetails(false);
      }
    }
  }
  resetPersistedSize() {
    this._persistedSize.reset();
  }
  hideWidget() {
    var _a5;
    (_a5 = this._loadingTimeout) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    this._setState(0);
    this._onDidHide.fire(this);
    this.element.clearSashHoverState();
    const dim = this._persistedSize.restore();
    const minPersistedHeight = Math.ceil(this.getLayoutInfo().itemHeight * 4.3);
    if (dim && dim.height < minPersistedHeight) {
      this._persistedSize.store(dim.with(void 0, minPersistedHeight));
    }
  }
  isFrozen() {
    return this._state === 4;
  }
  _afterRender(position) {
    if (position === null) {
      if (this._isDetailsVisible()) {
        this._details.hide();
      }
      return;
    }
    if (this._state === 2 || this._state === 1) {
      return;
    }
    if (this._isDetailsVisible()) {
      this._details.show();
    }
    this._positionDetails();
  }
  _layout(size2) {
    var _a5, _b2, _c2;
    if (!this.editor.hasModel()) {
      return;
    }
    if (!this.editor.getDomNode()) {
      return;
    }
    const bodyBox = getClientArea(document.body);
    const info = this.getLayoutInfo();
    if (!size2) {
      size2 = info.defaultSize;
    }
    let height = size2.height;
    let width = size2.width;
    this._status.element.style.lineHeight = `${info.itemHeight}px`;
    if (this._state === 2 || this._state === 1) {
      height = info.itemHeight + info.borderHeight;
      width = info.defaultSize.width / 2;
      this.element.enableSashes(false, false, false, false);
      this.element.minSize = this.element.maxSize = new Dimension(width, height);
      this._contentWidget.setPreference(2);
    } else {
      const maxWidth = bodyBox.width - info.borderHeight - 2 * info.horizontalPadding;
      if (width > maxWidth) {
        width = maxWidth;
      }
      const preferredWidth = this._completionModel ? this._completionModel.stats.pLabelLen * info.typicalHalfwidthCharacterWidth : width;
      const fullHeight = info.statusBarHeight + this._list.contentHeight + info.borderHeight;
      const minHeight = info.itemHeight + info.statusBarHeight;
      const editorBox = getDomNodePagePosition(this.editor.getDomNode());
      const cursorBox = this.editor.getScrolledVisiblePosition(this.editor.getPosition());
      const cursorBottom = editorBox.top + cursorBox.top + cursorBox.height;
      const maxHeightBelow = Math.min(bodyBox.height - cursorBottom - info.verticalPadding, fullHeight);
      const availableSpaceAbove = editorBox.top + cursorBox.top - info.verticalPadding;
      const maxHeightAbove = Math.min(availableSpaceAbove, fullHeight);
      let maxHeight = Math.min(Math.max(maxHeightAbove, maxHeightBelow) + info.borderHeight, fullHeight);
      if (height === ((_a5 = this._cappedHeight) === null || _a5 === void 0 ? void 0 : _a5.capped)) {
        height = this._cappedHeight.wanted;
      }
      if (height < minHeight) {
        height = minHeight;
      }
      if (height > maxHeight) {
        height = maxHeight;
      }
      const forceRenderingAboveRequiredSpace = 150;
      if (height > maxHeightBelow || this._forceRenderingAbove && availableSpaceAbove > forceRenderingAboveRequiredSpace) {
        this._contentWidget.setPreference(1);
        this.element.enableSashes(true, true, false, false);
        maxHeight = maxHeightAbove;
      } else {
        this._contentWidget.setPreference(2);
        this.element.enableSashes(false, true, true, false);
        maxHeight = maxHeightBelow;
      }
      this.element.preferredSize = new Dimension(preferredWidth, info.defaultSize.height);
      this.element.maxSize = new Dimension(maxWidth, maxHeight);
      this.element.minSize = new Dimension(220, minHeight);
      this._cappedHeight = height === fullHeight ? { wanted: (_c2 = (_b2 = this._cappedHeight) === null || _b2 === void 0 ? void 0 : _b2.wanted) !== null && _c2 !== void 0 ? _c2 : size2.height, capped: height } : void 0;
    }
    this._resize(width, height);
  }
  _resize(width, height) {
    const { width: maxWidth, height: maxHeight } = this.element.maxSize;
    width = Math.min(maxWidth, width);
    height = Math.min(maxHeight, height);
    const { statusBarHeight } = this.getLayoutInfo();
    this._list.layout(height - statusBarHeight, width);
    this._listElement.style.height = `${height - statusBarHeight}px`;
    this.element.layout(height, width);
    this._contentWidget.layout();
    this._positionDetails();
  }
  _positionDetails() {
    var _a5;
    if (this._isDetailsVisible()) {
      this._details.placeAtAnchor(this.element.domNode, ((_a5 = this._contentWidget.getPosition()) === null || _a5 === void 0 ? void 0 : _a5.preference[0]) === 2);
    }
  }
  getLayoutInfo() {
    const fontInfo = this.editor.getOption(43);
    const itemHeight = clamp(this.editor.getOption(107) || fontInfo.lineHeight, 8, 1e3);
    const statusBarHeight = !this.editor.getOption(105).showStatusBar || this._state === 2 || this._state === 1 ? 0 : itemHeight;
    const borderWidth = this._details.widget.borderWidth;
    const borderHeight = 2 * borderWidth;
    return {
      itemHeight,
      statusBarHeight,
      borderWidth,
      borderHeight,
      typicalHalfwidthCharacterWidth: fontInfo.typicalHalfwidthCharacterWidth,
      verticalPadding: 22,
      horizontalPadding: 14,
      defaultSize: new Dimension(430, statusBarHeight + 12 * itemHeight + borderHeight)
    };
  }
  _isDetailsVisible() {
    return this._storageService.getBoolean("expandSuggestionDocs", 0, false);
  }
  _setDetailsVisible(value) {
    this._storageService.store("expandSuggestionDocs", value, 0, 0);
  }
  forceRenderingAbove() {
    if (!this._forceRenderingAbove) {
      this._forceRenderingAbove = true;
      this._layout(this._persistedSize.restore());
    }
  }
  stopForceRenderingAbove() {
    this._forceRenderingAbove = false;
  }
};
SuggestWidget.LOADING_MESSAGE = localize("suggestWidget.loading", "Loading...");
SuggestWidget.NO_SUGGESTIONS_MESSAGE = localize("suggestWidget.noSuggestions", "No suggestions.");
SuggestWidget = __decorate34([
  __param34(1, IStorageService),
  __param34(2, IContextKeyService),
  __param34(3, IThemeService),
  __param34(4, IInstantiationService)
], SuggestWidget);
var SuggestContentWidget = class {
  constructor(_widget, _editor) {
    this._widget = _widget;
    this._editor = _editor;
    this.allowEditorOverflow = true;
    this.suppressMouseDown = false;
    this._preferenceLocked = false;
    this._added = false;
    this._hidden = false;
  }
  dispose() {
    if (this._added) {
      this._added = false;
      this._editor.removeContentWidget(this);
    }
  }
  getId() {
    return "editor.widget.suggestWidget";
  }
  getDomNode() {
    return this._widget.element.domNode;
  }
  show() {
    this._hidden = false;
    if (!this._added) {
      this._added = true;
      this._editor.addContentWidget(this);
    }
  }
  hide() {
    if (!this._hidden) {
      this._hidden = true;
      this.layout();
    }
  }
  layout() {
    this._editor.layoutContentWidget(this);
  }
  getPosition() {
    if (this._hidden || !this._position || !this._preference) {
      return null;
    }
    return {
      position: this._position,
      preference: [this._preference]
    };
  }
  beforeRender() {
    const { height, width } = this._widget.element.size;
    const { borderWidth, horizontalPadding } = this._widget.getLayoutInfo();
    return new Dimension(width + 2 * borderWidth + horizontalPadding, height + 2 * borderWidth);
  }
  afterRender(position) {
    this._widget._afterRender(position);
  }
  setPreference(preference) {
    if (!this._preferenceLocked) {
      this._preference = preference;
    }
  }
  lockPreference() {
    this._preferenceLocked = true;
  }
  unlockPreference() {
    this._preferenceLocked = false;
  }
  setPosition(position) {
    this._position = position;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/suggest/suggestController.js
var __decorate35 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param35 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _sticky = false;
var LineSuffix = class {
  constructor(_model, _position) {
    this._model = _model;
    this._position = _position;
    const maxColumn = _model.getLineMaxColumn(_position.lineNumber);
    if (maxColumn !== _position.column) {
      const offset = _model.getOffsetAt(_position);
      const end = _model.getPositionAt(offset + 1);
      this._marker = _model.deltaDecorations([], [{
        range: Range.fromPositions(_position, end),
        options: { description: "suggest-line-suffix", stickiness: 1 }
      }]);
    }
  }
  dispose() {
    if (this._marker && !this._model.isDisposed()) {
      this._model.deltaDecorations(this._marker, []);
    }
  }
  delta(position) {
    if (this._model.isDisposed() || this._position.lineNumber !== position.lineNumber) {
      return 0;
    }
    if (this._marker) {
      const range = this._model.getDecorationRange(this._marker[0]);
      const end = this._model.getOffsetAt(range.getStartPosition());
      return end - this._model.getOffsetAt(position);
    } else {
      return this._model.getLineMaxColumn(position.lineNumber) - position.column;
    }
  }
};
var SuggestController = class SuggestController2 {
  constructor(editor2, _memoryService, _commandService, _contextKeyService, _instantiationService, _logService, _telemetryService) {
    this._memoryService = _memoryService;
    this._commandService = _commandService;
    this._contextKeyService = _contextKeyService;
    this._instantiationService = _instantiationService;
    this._logService = _logService;
    this._telemetryService = _telemetryService;
    this._lineSuffix = new MutableDisposable();
    this._toDispose = new DisposableStore();
    this._selectors = new PriorityRegistry((s) => s.priority);
    this._telemetryGate = 0;
    this.editor = editor2;
    this.model = _instantiationService.createInstance(SuggestModel, this.editor);
    const ctxInsertMode = Context.InsertMode.bindTo(_contextKeyService);
    ctxInsertMode.set(editor2.getOption(105).insertMode);
    this.model.onDidTrigger(() => ctxInsertMode.set(editor2.getOption(105).insertMode));
    this.widget = this._toDispose.add(new IdleValue(() => {
      const widget = this._instantiationService.createInstance(SuggestWidget, this.editor);
      this._toDispose.add(widget);
      this._toDispose.add(widget.onDidSelect((item) => this._insertSuggestion(item, 0), this));
      const commitCharacterController = new CommitCharacterController(this.editor, widget, (item) => this._insertSuggestion(item, 2));
      this._toDispose.add(commitCharacterController);
      this._toDispose.add(this.model.onDidSuggest((e) => {
        if (e.completionModel.items.length === 0) {
          commitCharacterController.reset();
        }
      }));
      const ctxMakesTextEdit = Context.MakesTextEdit.bindTo(this._contextKeyService);
      const ctxHasInsertAndReplace = Context.HasInsertAndReplaceRange.bindTo(this._contextKeyService);
      const ctxCanResolve = Context.CanResolve.bindTo(this._contextKeyService);
      this._toDispose.add(toDisposable(() => {
        ctxMakesTextEdit.reset();
        ctxHasInsertAndReplace.reset();
        ctxCanResolve.reset();
      }));
      this._toDispose.add(widget.onDidFocus(({ item }) => {
        const position = this.editor.getPosition();
        const startColumn = item.editStart.column;
        const endColumn = position.column;
        let value = true;
        if (this.editor.getOption(1) === "smart" && this.model.state === 2 && !item.completion.additionalTextEdits && !(item.completion.insertTextRules & 4) && endColumn - startColumn === item.completion.insertText.length) {
          const oldText = this.editor.getModel().getValueInRange({
            startLineNumber: position.lineNumber,
            startColumn,
            endLineNumber: position.lineNumber,
            endColumn
          });
          value = oldText !== item.completion.insertText;
        }
        ctxMakesTextEdit.set(value);
        ctxHasInsertAndReplace.set(!Position.equals(item.editInsertEnd, item.editReplaceEnd));
        ctxCanResolve.set(Boolean(item.provider.resolveCompletionItem) || Boolean(item.completion.documentation) || item.completion.detail !== item.completion.label);
      }));
      this._toDispose.add(widget.onDetailsKeyDown((e) => {
        if (e.toKeybinding().equals(new SimpleKeybinding(true, false, false, false, 33)) || isMacintosh && e.toKeybinding().equals(new SimpleKeybinding(false, false, false, true, 33))) {
          e.stopPropagation();
          return;
        }
        if (!e.toKeybinding().isModifierKey()) {
          this.editor.focus();
        }
      }));
      return widget;
    }));
    this._overtypingCapturer = this._toDispose.add(new IdleValue(() => {
      return this._toDispose.add(new OvertypingCapturer(this.editor, this.model));
    }));
    this._alternatives = this._toDispose.add(new IdleValue(() => {
      return this._toDispose.add(new SuggestAlternatives(this.editor, this._contextKeyService));
    }));
    this._toDispose.add(_instantiationService.createInstance(WordContextKey, editor2));
    this._toDispose.add(this.model.onDidTrigger((e) => {
      this.widget.value.showTriggered(e.auto, e.shy ? 250 : 50);
      this._lineSuffix.value = new LineSuffix(this.editor.getModel(), e.position);
    }));
    this._toDispose.add(this.model.onDidSuggest((e) => {
      if (!e.shy) {
        let index = -1;
        for (const selector of this._selectors.itemsOrderedByPriorityDesc) {
          index = selector.select(this.editor.getModel(), this.editor.getPosition(), e.completionModel.items);
          if (index !== -1) {
            break;
          }
        }
        if (index === -1) {
          index = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), e.completionModel.items);
        }
        this.widget.value.showSuggestions(e.completionModel, index, e.isFrozen, e.auto);
      }
    }));
    this._toDispose.add(this.model.onDidCancel((e) => {
      if (!e.retrigger) {
        this.widget.value.hideWidget();
      }
    }));
    this._toDispose.add(this.editor.onDidBlurEditorWidget(() => {
      if (!_sticky) {
        this.model.cancel();
        this.model.clear();
      }
    }));
    let acceptSuggestionsOnEnter = Context.AcceptSuggestionsOnEnter.bindTo(_contextKeyService);
    let updateFromConfig = () => {
      const acceptSuggestionOnEnter = this.editor.getOption(1);
      acceptSuggestionsOnEnter.set(acceptSuggestionOnEnter === "on" || acceptSuggestionOnEnter === "smart");
    };
    this._toDispose.add(this.editor.onDidChangeConfiguration(() => updateFromConfig()));
    updateFromConfig();
  }
  static get(editor2) {
    return editor2.getContribution(SuggestController2.ID);
  }
  dispose() {
    this._alternatives.dispose();
    this._toDispose.dispose();
    this.widget.dispose();
    this.model.dispose();
    this._lineSuffix.dispose();
  }
  _insertSuggestion(event, flags) {
    if (!event || !event.item) {
      this._alternatives.value.reset();
      this.model.cancel();
      this.model.clear();
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    const model = this.editor.getModel();
    const modelVersionNow = model.getAlternativeVersionId();
    const { item } = event;
    const tasks = [];
    const cts = new CancellationTokenSource();
    if (!(flags & 1)) {
      this.editor.pushUndoStop();
    }
    const info = this.getOverwriteInfo(item, Boolean(flags & 8));
    this._memoryService.memorize(model, this.editor.getPosition(), item);
    if (Array.isArray(item.completion.additionalTextEdits)) {
      const scrollState = StableEditorScrollState.capture(this.editor);
      this.editor.executeEdits("suggestController.additionalTextEdits.sync", item.completion.additionalTextEdits.map((edit) => EditOperation.replace(Range.lift(edit.range), edit.text)));
      scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);
    } else if (!item.isResolved) {
      const sw = new StopWatch(true);
      let position;
      const docListener = model.onDidChangeContent((e) => {
        if (e.isFlush) {
          cts.cancel();
          docListener.dispose();
          return;
        }
        for (let change of e.changes) {
          const thisPosition = Range.getEndPosition(change.range);
          if (!position || Position.isBefore(thisPosition, position)) {
            position = thisPosition;
          }
        }
      });
      let oldFlags = flags;
      flags |= 2;
      let didType = false;
      let typeListener = this.editor.onWillType(() => {
        typeListener.dispose();
        didType = true;
        if (!(oldFlags & 2)) {
          this.editor.pushUndoStop();
        }
      });
      tasks.push(item.resolve(cts.token).then(() => {
        if (!item.completion.additionalTextEdits || cts.token.isCancellationRequested) {
          return false;
        }
        if (position && item.completion.additionalTextEdits.some((edit) => Position.isBefore(position, Range.getStartPosition(edit.range)))) {
          return false;
        }
        if (didType) {
          this.editor.pushUndoStop();
        }
        const scrollState = StableEditorScrollState.capture(this.editor);
        this.editor.executeEdits("suggestController.additionalTextEdits.async", item.completion.additionalTextEdits.map((edit) => EditOperation.replace(Range.lift(edit.range), edit.text)));
        scrollState.restoreRelativeVerticalPositionOfCursor(this.editor);
        if (didType || !(oldFlags & 2)) {
          this.editor.pushUndoStop();
        }
        return true;
      }).then((applied) => {
        this._logService.trace("[suggest] async resolving of edits DONE (ms, applied?)", sw.elapsed(), applied);
        docListener.dispose();
        typeListener.dispose();
      }));
    }
    let { insertText } = item.completion;
    if (!(item.completion.insertTextRules & 4)) {
      insertText = SnippetParser.escape(insertText);
    }
    SnippetController2.get(this.editor).insert(insertText, {
      overwriteBefore: info.overwriteBefore,
      overwriteAfter: info.overwriteAfter,
      undoStopBefore: false,
      undoStopAfter: false,
      adjustWhitespace: !(item.completion.insertTextRules & 1),
      clipboardText: event.model.clipboardText,
      overtypingCapturer: this._overtypingCapturer.value
    });
    if (!(flags & 2)) {
      this.editor.pushUndoStop();
    }
    if (!item.completion.command) {
      this.model.cancel();
    } else if (item.completion.command.id === TriggerSuggestAction.id) {
      this.model.trigger({ auto: true, shy: false }, true);
    } else {
      tasks.push(this._commandService.executeCommand(item.completion.command.id, ...item.completion.command.arguments ? [...item.completion.command.arguments] : []).catch(onUnexpectedError));
      this.model.cancel();
    }
    if (flags & 4) {
      this._alternatives.value.set(event, (next) => {
        cts.cancel();
        while (model.canUndo()) {
          if (modelVersionNow !== model.getAlternativeVersionId()) {
            model.undo();
          }
          this._insertSuggestion(next, 1 | 2 | (flags & 8 ? 8 : 0));
          break;
        }
      });
    }
    this._alertCompletionItem(item);
    Promise.all(tasks).finally(() => {
      this._reportSuggestionAcceptedTelemetry(model, event);
      this.model.clear();
      cts.dispose();
    });
  }
  _reportSuggestionAcceptedTelemetry(model, acceptedSuggestion) {
    var _a5;
    if (this._telemetryGate++ % 100 !== 0) {
      return;
    }
    const providerId = ((_a5 = acceptedSuggestion.item.provider._debugDisplayName) !== null && _a5 !== void 0 ? _a5 : "unknown").split("(", 1)[0].toLowerCase();
    this._telemetryService.publicLog2("suggest.acceptedSuggestion", {
      providerId,
      basenameHash: hash(basename2(model.uri)).toString(16),
      languageId: model.getLanguageId(),
      fileExtension: extname(model.uri)
    });
  }
  getOverwriteInfo(item, toggleMode) {
    assertType(this.editor.hasModel());
    let replace = this.editor.getOption(105).insertMode === "replace";
    if (toggleMode) {
      replace = !replace;
    }
    const overwriteBefore = item.position.column - item.editStart.column;
    const overwriteAfter = (replace ? item.editReplaceEnd.column : item.editInsertEnd.column) - item.position.column;
    const columnDelta = this.editor.getPosition().column - item.position.column;
    const suffixDelta = this._lineSuffix.value ? this._lineSuffix.value.delta(this.editor.getPosition()) : 0;
    return {
      overwriteBefore: overwriteBefore + columnDelta,
      overwriteAfter: overwriteAfter + suffixDelta
    };
  }
  _alertCompletionItem(item) {
    if (isNonEmptyArray(item.completion.additionalTextEdits)) {
      let msg = localize("aria.alert.snippet", "Accepting '{0}' made {1} additional edits", item.textLabel, item.completion.additionalTextEdits.length);
      alert(msg);
    }
  }
  triggerSuggest(onlyFrom, auto) {
    if (this.editor.hasModel()) {
      this.model.trigger({ auto: auto !== null && auto !== void 0 ? auto : false, shy: false }, false, onlyFrom);
      this.editor.revealPosition(this.editor.getPosition(), 0);
      this.editor.focus();
    }
  }
  triggerSuggestAndAcceptBest(arg) {
    if (!this.editor.hasModel()) {
      return;
    }
    const positionNow = this.editor.getPosition();
    const fallback = () => {
      if (positionNow.equals(this.editor.getPosition())) {
        this._commandService.executeCommand(arg.fallback);
      }
    };
    const makesTextEdit = (item) => {
      if (item.completion.insertTextRules & 4 || item.completion.additionalTextEdits) {
        return true;
      }
      const position = this.editor.getPosition();
      const startColumn = item.editStart.column;
      const endColumn = position.column;
      if (endColumn - startColumn !== item.completion.insertText.length) {
        return true;
      }
      const textNow = this.editor.getModel().getValueInRange({
        startLineNumber: position.lineNumber,
        startColumn,
        endLineNumber: position.lineNumber,
        endColumn
      });
      return textNow !== item.completion.insertText;
    };
    Event.once(this.model.onDidTrigger)((_) => {
      let listener = [];
      Event.any(this.model.onDidTrigger, this.model.onDidCancel)(() => {
        dispose(listener);
        fallback();
      }, void 0, listener);
      this.model.onDidSuggest(({ completionModel }) => {
        dispose(listener);
        if (completionModel.items.length === 0) {
          fallback();
          return;
        }
        const index = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), completionModel.items);
        const item = completionModel.items[index];
        if (!makesTextEdit(item)) {
          fallback();
          return;
        }
        this.editor.pushUndoStop();
        this._insertSuggestion({ index, item, model: completionModel }, 4 | 1 | 2);
      }, void 0, listener);
    });
    this.model.trigger({ auto: false, shy: true });
    this.editor.revealPosition(positionNow, 0);
    this.editor.focus();
  }
  acceptSelectedSuggestion(keepAlternativeSuggestions, alternativeOverwriteConfig) {
    const item = this.widget.value.getFocusedItem();
    let flags = 0;
    if (keepAlternativeSuggestions) {
      flags |= 4;
    }
    if (alternativeOverwriteConfig) {
      flags |= 8;
    }
    this._insertSuggestion(item, flags);
  }
  acceptNextSuggestion() {
    this._alternatives.value.next();
  }
  acceptPrevSuggestion() {
    this._alternatives.value.prev();
  }
  cancelSuggestWidget() {
    this.model.cancel();
    this.model.clear();
    this.widget.value.hideWidget();
  }
  selectNextSuggestion() {
    this.widget.value.selectNext();
  }
  selectNextPageSuggestion() {
    this.widget.value.selectNextPage();
  }
  selectLastSuggestion() {
    this.widget.value.selectLast();
  }
  selectPrevSuggestion() {
    this.widget.value.selectPrevious();
  }
  selectPrevPageSuggestion() {
    this.widget.value.selectPreviousPage();
  }
  selectFirstSuggestion() {
    this.widget.value.selectFirst();
  }
  toggleSuggestionDetails() {
    this.widget.value.toggleDetails();
  }
  toggleExplainMode() {
    this.widget.value.toggleExplainMode();
  }
  toggleSuggestionFocus() {
    this.widget.value.toggleDetailsFocus();
  }
  resetWidgetSize() {
    this.widget.value.resetPersistedSize();
  }
  forceRenderingAbove() {
    this.widget.value.forceRenderingAbove();
  }
  stopForceRenderingAbove() {
    if (!this.widget.isInitialized) {
      return;
    }
    this.widget.value.stopForceRenderingAbove();
  }
  registerSelector(selector) {
    return this._selectors.register(selector);
  }
};
SuggestController.ID = "editor.contrib.suggestController";
SuggestController = __decorate35([
  __param35(1, ISuggestMemoryService),
  __param35(2, ICommandService),
  __param35(3, IContextKeyService),
  __param35(4, IInstantiationService),
  __param35(5, ILogService),
  __param35(6, ITelemetryService)
], SuggestController);
var PriorityRegistry = class {
  constructor(prioritySelector) {
    this.prioritySelector = prioritySelector;
    this._items = new Array();
  }
  register(value) {
    if (this._items.indexOf(value) !== -1) {
      throw new Error("Value is already registered");
    }
    this._items.push(value);
    this._items.sort((s1, s2) => this.prioritySelector(s2) - this.prioritySelector(s1));
    return {
      dispose: () => {
        const idx = this._items.indexOf(value);
        if (idx >= 0) {
          this._items.splice(idx, 1);
        }
      }
    };
  }
  get itemsOrderedByPriorityDesc() {
    return this._items;
  }
};
var TriggerSuggestAction = class extends EditorAction {
  constructor() {
    super({
      id: TriggerSuggestAction.id,
      label: localize("suggest.trigger.label", "Trigger Suggest"),
      alias: "Trigger Suggest",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasCompletionItemProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 10,
        secondary: [2048 | 39],
        mac: { primary: 256 | 10, secondary: [512 | 9, 2048 | 39] },
        weight: 100
      }
    });
  }
  run(_accessor, editor2, args) {
    const controller = SuggestController.get(editor2);
    if (!controller) {
      return;
    }
    let auto;
    if (args && typeof args === "object") {
      if (args.auto === true) {
        auto = true;
      }
    }
    controller.triggerSuggest(void 0, auto);
  }
};
TriggerSuggestAction.id = "editor.action.triggerSuggest";
registerEditorContribution(SuggestController.ID, SuggestController);
registerEditorAction(TriggerSuggestAction);
var weight = 100 + 90;
var SuggestCommand = EditorCommand.bindToContribution(SuggestController.get);
registerEditorCommand(new SuggestCommand({
  id: "acceptSelectedSuggestion",
  precondition: Context.Visible,
  handler(x) {
    x.acceptSelectedSuggestion(true, false);
  }
}));
KeybindingsRegistry.registerKeybindingRule({
  id: "acceptSelectedSuggestion",
  when: ContextKeyExpr.and(Context.Visible, EditorContextKeys.textInputFocus),
  primary: 2,
  weight
});
KeybindingsRegistry.registerKeybindingRule({
  id: "acceptSelectedSuggestion",
  when: ContextKeyExpr.and(Context.Visible, EditorContextKeys.textInputFocus, Context.AcceptSuggestionsOnEnter, Context.MakesTextEdit),
  primary: 3,
  weight
});
MenuRegistry.appendMenuItem(suggestWidgetStatusbarMenu, {
  command: { id: "acceptSelectedSuggestion", title: localize("accept.insert", "Insert") },
  group: "left",
  order: 1,
  when: Context.HasInsertAndReplaceRange.toNegated()
});
MenuRegistry.appendMenuItem(suggestWidgetStatusbarMenu, {
  command: { id: "acceptSelectedSuggestion", title: localize("accept.insert", "Insert") },
  group: "left",
  order: 1,
  when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("insert"))
});
MenuRegistry.appendMenuItem(suggestWidgetStatusbarMenu, {
  command: { id: "acceptSelectedSuggestion", title: localize("accept.replace", "Replace") },
  group: "left",
  order: 1,
  when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("replace"))
});
registerEditorCommand(new SuggestCommand({
  id: "acceptAlternativeSelectedSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, EditorContextKeys.textInputFocus),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 1024 | 3,
    secondary: [1024 | 2]
  },
  handler(x) {
    x.acceptSelectedSuggestion(false, true);
  },
  menuOpts: [{
    menuId: suggestWidgetStatusbarMenu,
    group: "left",
    order: 2,
    when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("insert")),
    title: localize("accept.replace", "Replace")
  }, {
    menuId: suggestWidgetStatusbarMenu,
    group: "left",
    order: 2,
    when: ContextKeyExpr.and(Context.HasInsertAndReplaceRange, Context.InsertMode.isEqualTo("replace")),
    title: localize("accept.insert", "Insert")
  }]
}));
CommandsRegistry.registerCommandAlias("acceptSelectedSuggestionOnEnter", "acceptSelectedSuggestion");
registerEditorCommand(new SuggestCommand({
  id: "hideSuggestWidget",
  precondition: Context.Visible,
  handler: (x) => x.cancelSuggestWidget(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectNextSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
  handler: (c) => c.selectNextSuggestion(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 18,
    secondary: [2048 | 18],
    mac: { primary: 18, secondary: [2048 | 18, 256 | 44] }
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectNextPageSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
  handler: (c) => c.selectNextPageSuggestion(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 12,
    secondary: [2048 | 12]
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectLastSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
  handler: (c) => c.selectLastSuggestion()
}));
registerEditorCommand(new SuggestCommand({
  id: "selectPrevSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
  handler: (c) => c.selectPrevSuggestion(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 16,
    secondary: [2048 | 16],
    mac: { primary: 16, secondary: [2048 | 16, 256 | 46] }
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectPrevPageSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
  handler: (c) => c.selectPrevPageSuggestion(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 11,
    secondary: [2048 | 11]
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "selectFirstSuggestion",
  precondition: ContextKeyExpr.and(Context.Visible, Context.MultipleSuggestions),
  handler: (c) => c.selectFirstSuggestion()
}));
registerEditorCommand(new SuggestCommand({
  id: "toggleSuggestionDetails",
  precondition: Context.Visible,
  handler: (x) => x.toggleSuggestionDetails(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2048 | 10,
    secondary: [2048 | 39],
    mac: { primary: 256 | 10, secondary: [2048 | 39] }
  },
  menuOpts: [{
    menuId: suggestWidgetStatusbarMenu,
    group: "right",
    order: 1,
    when: ContextKeyExpr.and(Context.DetailsVisible, Context.CanResolve),
    title: localize("detail.more", "show less")
  }, {
    menuId: suggestWidgetStatusbarMenu,
    group: "right",
    order: 1,
    when: ContextKeyExpr.and(Context.DetailsVisible.toNegated(), Context.CanResolve),
    title: localize("detail.less", "show more")
  }]
}));
registerEditorCommand(new SuggestCommand({
  id: "toggleExplainMode",
  precondition: Context.Visible,
  handler: (x) => x.toggleExplainMode(),
  kbOpts: {
    weight: 100,
    primary: 2048 | 85
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "toggleSuggestionFocus",
  precondition: Context.Visible,
  handler: (x) => x.toggleSuggestionFocus(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2048 | 512 | 10,
    mac: { primary: 256 | 512 | 10 }
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "insertBestCompletion",
  precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), WordContextKey.AtEnd, Context.Visible.toNegated(), SuggestAlternatives.OtherSuggestions.toNegated(), SnippetController2.InSnippetMode.toNegated()),
  handler: (x, arg) => {
    x.triggerSuggestAndAcceptBest(isObject(arg) ? Object.assign({ fallback: "tab" }, arg) : { fallback: "tab" });
  },
  kbOpts: {
    weight,
    primary: 2
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "insertNextSuggestion",
  precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), SuggestAlternatives.OtherSuggestions, Context.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),
  handler: (x) => x.acceptNextSuggestion(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 2
  }
}));
registerEditorCommand(new SuggestCommand({
  id: "insertPrevSuggestion",
  precondition: ContextKeyExpr.and(EditorContextKeys.textInputFocus, ContextKeyExpr.equals("config.editor.tabCompletion", "on"), SuggestAlternatives.OtherSuggestions, Context.Visible.toNegated(), SnippetController2.InSnippetMode.toNegated()),
  handler: (x) => x.acceptPrevSuggestion(),
  kbOpts: {
    weight,
    kbExpr: EditorContextKeys.textInputFocus,
    primary: 1024 | 2
  }
}));
registerEditorAction(class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.resetSuggestSize",
      label: localize("suggest.reset.label", "Reset Suggest Widget Size"),
      alias: "Reset Suggest Widget Size",
      precondition: void 0
    });
  }
  run(_accessor, editor2) {
    SuggestController.get(editor2).resetWidgetSize();
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/utils.js
function createDisposableRef(object, disposable) {
  return {
    object,
    dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose()
  };
}
function compareBy(selector, comparator) {
  return (a, b) => comparator(selector(a), selector(b));
}
function compareByNumber() {
  return (a, b) => a - b;
}
function findMaxBy(items, comparator) {
  let min = void 0;
  for (const item of items) {
    if (min === void 0 || comparator(item, min) > 0) {
      min = item;
    }
  }
  return min;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/suggestWidgetInlineCompletionProvider.js
var SuggestWidgetInlineCompletionProvider = class extends Disposable {
  constructor(editor2, suggestControllerPreselector) {
    super();
    this.editor = editor2;
    this.suggestControllerPreselector = suggestControllerPreselector;
    this.isSuggestWidgetVisible = false;
    this.isShiftKeyPressed = false;
    this._isActive = false;
    this._currentSuggestItemInfo = void 0;
    this.onDidChangeEmitter = new Emitter();
    this.onDidChange = this.onDidChangeEmitter.event;
    this.setInactiveDelayed = this._register(new RunOnceScheduler(() => {
      if (!this.isSuggestWidgetVisible) {
        if (this._isActive) {
          this._isActive = false;
          this.onDidChangeEmitter.fire();
        }
      }
    }, 100));
    this._register(editor2.onKeyDown((e) => {
      if (e.shiftKey && !this.isShiftKeyPressed) {
        this.isShiftKeyPressed = true;
        this.update(this._isActive);
      }
    }));
    this._register(editor2.onKeyUp((e) => {
      if (e.shiftKey && this.isShiftKeyPressed) {
        this.isShiftKeyPressed = false;
        this.update(this._isActive);
      }
    }));
    const suggestController = SuggestController.get(this.editor);
    if (suggestController) {
      this._register(suggestController.registerSelector({
        priority: 100,
        select: (model, pos, suggestItems) => {
          const textModel = this.editor.getModel();
          const normalizedItemToPreselect = minimizeInlineCompletion(textModel, this.suggestControllerPreselector());
          if (!normalizedItemToPreselect) {
            return -1;
          }
          const position = Position.lift(pos);
          const candidates = suggestItems.map((suggestItem, index) => {
            const inlineSuggestItem = suggestionToSuggestItemInfo(suggestController, position, suggestItem, this.isShiftKeyPressed);
            const normalizedSuggestItem = minimizeInlineCompletion(textModel, inlineSuggestItem === null || inlineSuggestItem === void 0 ? void 0 : inlineSuggestItem.normalizedInlineCompletion);
            if (!normalizedSuggestItem) {
              return void 0;
            }
            const valid = rangeStartsWith(normalizedItemToPreselect.range, normalizedSuggestItem.range) && normalizedItemToPreselect.text.startsWith(normalizedSuggestItem.text);
            return { index, valid, prefixLength: normalizedSuggestItem.text.length, suggestItem };
          }).filter((item) => item && item.valid);
          const result = findMaxBy(candidates, compareBy((s) => s.prefixLength, compareByNumber()));
          return result ? result.index : -1;
        }
      }));
      let isBoundToSuggestWidget = false;
      const bindToSuggestWidget = () => {
        if (isBoundToSuggestWidget) {
          return;
        }
        isBoundToSuggestWidget = true;
        this._register(suggestController.widget.value.onDidShow(() => {
          this.isSuggestWidgetVisible = true;
          this.update(true);
        }));
        this._register(suggestController.widget.value.onDidHide(() => {
          this.isSuggestWidgetVisible = false;
          this.setInactiveDelayed.schedule();
          this.update(this._isActive);
        }));
        this._register(suggestController.widget.value.onDidFocus(() => {
          this.isSuggestWidgetVisible = true;
          this.update(true);
        }));
      };
      this._register(Event.once(suggestController.model.onDidTrigger)((e) => {
        bindToSuggestWidget();
      }));
    }
    this.update(this._isActive);
  }
  get state() {
    if (!this._isActive) {
      return void 0;
    }
    return { selectedItem: this._currentSuggestItemInfo };
  }
  update(newActive) {
    const newInlineCompletion = this.getSuggestItemInfo();
    let shouldFire = false;
    if (!suggestItemInfoEquals(this._currentSuggestItemInfo, newInlineCompletion)) {
      this._currentSuggestItemInfo = newInlineCompletion;
      shouldFire = true;
    }
    if (this._isActive !== newActive) {
      this._isActive = newActive;
      shouldFire = true;
    }
    if (shouldFire) {
      this.onDidChangeEmitter.fire();
    }
  }
  getSuggestItemInfo() {
    const suggestController = SuggestController.get(this.editor);
    if (!suggestController) {
      return void 0;
    }
    if (!this.isSuggestWidgetVisible) {
      return void 0;
    }
    const focusedItem = suggestController.widget.value.getFocusedItem();
    if (!focusedItem) {
      return void 0;
    }
    return suggestionToSuggestItemInfo(suggestController, this.editor.getPosition(), focusedItem.item, this.isShiftKeyPressed);
  }
  stopForceRenderingAbove() {
    const suggestController = SuggestController.get(this.editor);
    if (suggestController) {
      suggestController.stopForceRenderingAbove();
    }
  }
  forceRenderingAbove() {
    const suggestController = SuggestController.get(this.editor);
    if (suggestController) {
      suggestController.forceRenderingAbove();
    }
  }
};
function rangeStartsWith(rangeToTest, prefix) {
  return prefix.startLineNumber === rangeToTest.startLineNumber && prefix.startColumn === rangeToTest.startColumn && (prefix.endLineNumber < rangeToTest.endLineNumber || prefix.endLineNumber === rangeToTest.endLineNumber && prefix.endColumn <= rangeToTest.endColumn);
}
function suggestItemInfoEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  return a.completionItemKind === b.completionItemKind && a.isSnippetText === b.isSnippetText && normalizedInlineCompletionsEquals(a.normalizedInlineCompletion, b.normalizedInlineCompletion);
}
function suggestionToSuggestItemInfo(suggestController, position, item, toggleMode) {
  if (Array.isArray(item.completion.additionalTextEdits) && item.completion.additionalTextEdits.length > 0) {
    return {
      completionItemKind: item.completion.kind,
      isSnippetText: false,
      normalizedInlineCompletion: {
        range: Range.fromPositions(position, position),
        text: ""
      }
    };
  }
  let { insertText } = item.completion;
  let isSnippetText = false;
  if (item.completion.insertTextRules & 4) {
    const snippet = new SnippetParser().parse(insertText);
    const model = suggestController.editor.getModel();
    if (snippet.children.length > 100) {
      return void 0;
    }
    SnippetSession.adjustWhitespace(model, position, snippet, true, true);
    insertText = snippet.toString();
    isSnippetText = true;
  }
  const info = suggestController.getOverwriteInfo(item, toggleMode);
  return {
    isSnippetText,
    completionItemKind: item.completion.kind,
    normalizedInlineCompletion: {
      text: insertText,
      range: Range.fromPositions(position.delta(0, -info.overwriteBefore), position.delta(0, Math.max(info.overwriteAfter, 0)))
    }
  };
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/suggestWidgetPreviewModel.js
var __awaiter26 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SuggestWidgetPreviewModel = class extends BaseGhostTextWidgetModel {
  constructor(editor2, cache) {
    super(editor2);
    this.cache = cache;
    this.suggestionInlineCompletionSource = this._register(new SuggestWidgetInlineCompletionProvider(this.editor, () => {
      var _a5, _b2;
      return (_b2 = (_a5 = this.cache.value) === null || _a5 === void 0 ? void 0 : _a5.completions[0]) === null || _b2 === void 0 ? void 0 : _b2.toLiveInlineCompletion();
    }));
    this.updateOperation = this._register(new MutableDisposable());
    this.updateCacheSoon = this._register(new RunOnceScheduler(() => this.updateCache(), 50));
    this.minReservedLineCount = 0;
    this._register(this.suggestionInlineCompletionSource.onDidChange(() => {
      this.updateCacheSoon.schedule();
      const suggestWidgetState = this.suggestionInlineCompletionSource.state;
      if (!suggestWidgetState) {
        this.minReservedLineCount = 0;
      }
      const newGhostText = this.ghostText;
      if (newGhostText) {
        this.minReservedLineCount = Math.max(this.minReservedLineCount, sum(newGhostText.parts.map((p) => p.lines.length - 1)));
      }
      if (this.minReservedLineCount >= 1) {
        this.suggestionInlineCompletionSource.forceRenderingAbove();
      } else {
        this.suggestionInlineCompletionSource.stopForceRenderingAbove();
      }
      this.onDidChangeEmitter.fire();
    }));
    this._register(this.cache.onDidChange(() => {
      this.onDidChangeEmitter.fire();
    }));
    this._register(this.editor.onDidChangeCursorPosition((e) => {
      this.minReservedLineCount = 0;
      this.updateCacheSoon.schedule();
      this.onDidChangeEmitter.fire();
    }));
    this._register(toDisposable(() => this.suggestionInlineCompletionSource.stopForceRenderingAbove()));
  }
  get isActive() {
    return this.suggestionInlineCompletionSource.state !== void 0;
  }
  isSuggestionPreviewEnabled() {
    const suggestOptions = this.editor.getOption(105);
    return suggestOptions.preview;
  }
  updateCache() {
    return __awaiter26(this, void 0, void 0, function* () {
      const state = this.suggestionInlineCompletionSource.state;
      if (!state || !state.selectedItem) {
        return;
      }
      const info = {
        text: state.selectedItem.normalizedInlineCompletion.text,
        range: state.selectedItem.normalizedInlineCompletion.range,
        isSnippetText: state.selectedItem.isSnippetText,
        completionKind: state.selectedItem.completionItemKind
      };
      const position = this.editor.getPosition();
      const promise = createCancelablePromise((token) => __awaiter26(this, void 0, void 0, function* () {
        let result;
        try {
          result = yield provideInlineCompletions(position, this.editor.getModel(), { triggerKind: InlineCompletionTriggerKind.Automatic, selectedSuggestionInfo: info }, token);
        } catch (e) {
          onUnexpectedError(e);
          return;
        }
        if (token.isCancellationRequested) {
          return;
        }
        this.cache.setValue(this.editor, result, InlineCompletionTriggerKind.Automatic);
        this.onDidChangeEmitter.fire();
      }));
      const operation = new UpdateOperation(promise, InlineCompletionTriggerKind.Automatic);
      this.updateOperation.value = operation;
      yield promise;
      if (this.updateOperation.value === operation) {
        this.updateOperation.clear();
      }
    });
  }
  get ghostText() {
    var _a5, _b2, _c2;
    const isSuggestionPreviewEnabled = this.isSuggestionPreviewEnabled();
    const augmentedCompletion = minimizeInlineCompletion(this.editor.getModel(), (_b2 = (_a5 = this.cache.value) === null || _a5 === void 0 ? void 0 : _a5.completions[0]) === null || _b2 === void 0 ? void 0 : _b2.toLiveInlineCompletion());
    const suggestWidgetState = this.suggestionInlineCompletionSource.state;
    const suggestInlineCompletion = minimizeInlineCompletion(this.editor.getModel(), (_c2 = suggestWidgetState === null || suggestWidgetState === void 0 ? void 0 : suggestWidgetState.selectedItem) === null || _c2 === void 0 ? void 0 : _c2.normalizedInlineCompletion);
    const isAugmentedCompletionValid = augmentedCompletion && suggestInlineCompletion && augmentedCompletion.text.startsWith(suggestInlineCompletion.text) && augmentedCompletion.range.equalsRange(suggestInlineCompletion.range);
    if (!isSuggestionPreviewEnabled && !isAugmentedCompletionValid) {
      return void 0;
    }
    const finalCompletion = isAugmentedCompletionValid ? augmentedCompletion : suggestInlineCompletion || augmentedCompletion;
    const inlineCompletionPreviewLength = isAugmentedCompletionValid ? finalCompletion.text.length - suggestInlineCompletion.text.length : 0;
    const newGhostText = this.toGhostText(finalCompletion, inlineCompletionPreviewLength);
    return newGhostText;
  }
  toGhostText(completion, inlineCompletionPreviewLength) {
    const mode = this.editor.getOptions().get(105).previewMode;
    return completion ? inlineCompletionToGhostText(completion, this.editor.getModel(), mode, this.editor.getPosition(), inlineCompletionPreviewLength) || new GhostText(completion.range.endLineNumber, [], this.minReservedLineCount) : void 0;
  }
};
function sum(arr) {
  return arr.reduce((a, b) => a + b, 0);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostTextModel.js
var __decorate36 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param36 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter27 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DelegatingModel = class extends Disposable {
  constructor() {
    super(...arguments);
    this.onDidChangeEmitter = new Emitter();
    this.onDidChange = this.onDidChangeEmitter.event;
    this.hasCachedGhostText = false;
    this.currentModelRef = this._register(new MutableDisposable());
  }
  get targetModel() {
    var _a5;
    return (_a5 = this.currentModelRef.value) === null || _a5 === void 0 ? void 0 : _a5.object;
  }
  setTargetModel(model) {
    var _a5;
    if (((_a5 = this.currentModelRef.value) === null || _a5 === void 0 ? void 0 : _a5.object) === model) {
      return;
    }
    this.currentModelRef.clear();
    this.currentModelRef.value = model ? createDisposableRef(model, model.onDidChange(() => {
      this.hasCachedGhostText = false;
      this.onDidChangeEmitter.fire();
    })) : void 0;
    this.hasCachedGhostText = false;
    this.onDidChangeEmitter.fire();
  }
  get ghostText() {
    var _a5, _b2;
    if (!this.hasCachedGhostText) {
      this.cachedGhostText = (_b2 = (_a5 = this.currentModelRef.value) === null || _a5 === void 0 ? void 0 : _a5.object) === null || _b2 === void 0 ? void 0 : _b2.ghostText;
      this.hasCachedGhostText = true;
    }
    return this.cachedGhostText;
  }
  setExpanded(expanded) {
    var _a5;
    (_a5 = this.targetModel) === null || _a5 === void 0 ? void 0 : _a5.setExpanded(expanded);
  }
  get minReservedLineCount() {
    return this.targetModel ? this.targetModel.minReservedLineCount : 0;
  }
};
var GhostTextModel = class GhostTextModel2 extends DelegatingModel {
  constructor(editor2, commandService) {
    super();
    this.editor = editor2;
    this.commandService = commandService;
    this.sharedCache = this._register(new SharedInlineCompletionCache());
    this.suggestWidgetAdapterModel = this._register(new SuggestWidgetPreviewModel(this.editor, this.sharedCache));
    this.inlineCompletionsModel = this._register(new InlineCompletionsModel(this.editor, this.sharedCache, this.commandService));
    this._register(this.suggestWidgetAdapterModel.onDidChange(() => {
      this.updateModel();
    }));
    this.updateModel();
  }
  get activeInlineCompletionsModel() {
    if (this.targetModel === this.inlineCompletionsModel) {
      return this.inlineCompletionsModel;
    }
    return void 0;
  }
  updateModel() {
    this.setTargetModel(this.suggestWidgetAdapterModel.isActive ? this.suggestWidgetAdapterModel : this.inlineCompletionsModel);
    this.inlineCompletionsModel.setActive(this.targetModel === this.inlineCompletionsModel);
  }
  shouldShowHoverAt(hoverRange) {
    var _a5;
    const ghostText = (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.ghostText;
    if (ghostText) {
      return ghostText.parts.some((p) => hoverRange.containsPosition(new Position(ghostText.lineNumber, p.column)));
    }
    return false;
  }
  triggerInlineCompletion() {
    var _a5;
    (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.trigger(InlineCompletionTriggerKind.Explicit);
  }
  commitInlineCompletion() {
    var _a5;
    (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.commitCurrentSuggestion();
  }
  hideInlineCompletion() {
    var _a5;
    (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.hide();
  }
  showNextInlineCompletion() {
    var _a5;
    (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.showNext();
  }
  showPreviousInlineCompletion() {
    var _a5;
    (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.showPrevious();
  }
  hasMultipleInlineCompletions() {
    var _a5;
    return __awaiter27(this, void 0, void 0, function* () {
      const result = yield (_a5 = this.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.hasMultipleInlineCompletions();
      return result !== void 0 ? result : false;
    });
  }
};
GhostTextModel = __decorate36([
  __param36(1, ICommandService)
], GhostTextModel);
var SharedInlineCompletionCache = class extends Disposable {
  constructor() {
    super(...arguments);
    this.onDidChangeEmitter = new Emitter();
    this.onDidChange = this.onDidChangeEmitter.event;
    this.cache = this._register(new MutableDisposable());
  }
  get value() {
    return this.cache.value;
  }
  setValue(editor2, completionsSource, triggerKind) {
    this.cache.value = new SynchronizedInlineCompletionsCache(editor2, completionsSource, () => this.onDidChangeEmitter.fire(), triggerKind);
  }
  clearAndLeak() {
    return this.cache.clearAndLeak();
  }
  clear() {
    this.cache.clear();
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostTextWidget.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostText.css";
var __decorate37 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param37 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _a4;
var ttPolicy = (_a4 = window.trustedTypes) === null || _a4 === void 0 ? void 0 : _a4.createPolicy("editorGhostText", { createHTML: (value) => value });
var GhostTextWidget = class GhostTextWidget2 extends Disposable {
  constructor(editor2, model, instantiationService, modeService) {
    super();
    this.editor = editor2;
    this.model = model;
    this.instantiationService = instantiationService;
    this.modeService = modeService;
    this.disposed = false;
    this.partsWidget = this._register(this.instantiationService.createInstance(DecorationsWidget, this.editor));
    this.additionalLinesWidget = this._register(new AdditionalLinesWidget(this.editor, this.modeService.languageIdCodec));
    this.viewMoreContentWidget = void 0;
    this._register(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(29) || e.hasChanged(104) || e.hasChanged(87) || e.hasChanged(82) || e.hasChanged(44) || e.hasChanged(43) || e.hasChanged(58)) {
        this.update();
      }
    }));
    this._register(toDisposable(() => {
      var _a5;
      this.disposed = true;
      this.update();
      (_a5 = this.viewMoreContentWidget) === null || _a5 === void 0 ? void 0 : _a5.dispose();
      this.viewMoreContentWidget = void 0;
    }));
    this._register(model.onDidChange(() => {
      this.update();
    }));
    this.update();
  }
  shouldShowHoverAtViewZone(viewZoneId) {
    return this.additionalLinesWidget.viewZoneId === viewZoneId;
  }
  update() {
    var _a5;
    const ghostText = this.model.ghostText;
    if (!this.editor.hasModel() || !ghostText || this.disposed) {
      this.partsWidget.clear();
      this.additionalLinesWidget.clear();
      return;
    }
    const inlineTexts = new Array();
    const additionalLines = new Array();
    function addToAdditionalLines(lines, className) {
      if (additionalLines.length > 0) {
        const lastLine = additionalLines[additionalLines.length - 1];
        if (className) {
          lastLine.decorations.push(new LineDecoration(lastLine.content.length + 1, lastLine.content.length + 1 + lines[0].length, className, 0));
        }
        lastLine.content += lines[0];
        lines = lines.slice(1);
      }
      for (const line of lines) {
        additionalLines.push({
          content: line,
          decorations: className ? [new LineDecoration(1, line.length + 1, className, 0)] : []
        });
      }
    }
    const textBufferLine = this.editor.getModel().getLineContent(ghostText.lineNumber);
    this.editor.getModel().getLineTokens(ghostText.lineNumber);
    let hiddenTextStartColumn = void 0;
    let lastIdx = 0;
    for (const part of ghostText.parts) {
      let lines = part.lines;
      if (hiddenTextStartColumn === void 0) {
        inlineTexts.push({
          column: part.column,
          text: lines[0],
          preview: part.preview
        });
        lines = lines.slice(1);
      } else {
        addToAdditionalLines([textBufferLine.substring(lastIdx, part.column - 1)], void 0);
      }
      if (lines.length > 0) {
        addToAdditionalLines(lines, "ghost-text");
        if (hiddenTextStartColumn === void 0 && part.column <= textBufferLine.length) {
          hiddenTextStartColumn = part.column;
        }
      }
      lastIdx = part.column - 1;
    }
    if (hiddenTextStartColumn !== void 0) {
      addToAdditionalLines([textBufferLine.substring(lastIdx)], void 0);
    }
    this.partsWidget.setParts(ghostText.lineNumber, inlineTexts, hiddenTextStartColumn !== void 0 ? { column: hiddenTextStartColumn, length: textBufferLine.length + 1 - hiddenTextStartColumn } : void 0);
    this.additionalLinesWidget.updateLines(ghostText.lineNumber, additionalLines, ghostText.additionalReservedLineCount);
    if (ghostText.parts.some((p) => p.lines.length < 0)) {
      this.viewMoreContentWidget = this.renderViewMoreLines(new Position(ghostText.lineNumber, this.editor.getModel().getLineMaxColumn(ghostText.lineNumber)), "", 0);
    } else {
      (_a5 = this.viewMoreContentWidget) === null || _a5 === void 0 ? void 0 : _a5.dispose();
      this.viewMoreContentWidget = void 0;
    }
  }
  renderViewMoreLines(position, firstLineText, remainingLinesLength) {
    const fontInfo = this.editor.getOption(43);
    const domNode = document.createElement("div");
    domNode.className = "suggest-preview-additional-widget";
    Configuration.applyFontInfoSlow(domNode, fontInfo);
    const spacer = document.createElement("span");
    spacer.className = "content-spacer";
    spacer.append(firstLineText);
    domNode.append(spacer);
    const newline = document.createElement("span");
    newline.className = "content-newline suggest-preview-text";
    newline.append("\u23CE  ");
    domNode.append(newline);
    const disposableStore = new DisposableStore();
    const button = document.createElement("div");
    button.className = "button suggest-preview-text";
    button.append(`+${remainingLinesLength} lines\u2026`);
    disposableStore.add(addStandardDisposableListener(button, "mousedown", (e) => {
      var _a5;
      (_a5 = this.model) === null || _a5 === void 0 ? void 0 : _a5.setExpanded(true);
      e.preventDefault();
      this.editor.focus();
    }));
    domNode.append(button);
    return new ViewMoreLinesContentWidget(this.editor, position, domNode, disposableStore);
  }
};
GhostTextWidget = __decorate37([
  __param37(2, IInstantiationService),
  __param37(3, IModeService)
], GhostTextWidget);
var DecorationsWidget = class {
  constructor(editor2) {
    this.editor = editor2;
    this.decorationIds = [];
    this.disposableStore = new DisposableStore();
  }
  dispose() {
    this.clear();
    this.disposableStore.dispose();
  }
  clear() {
    this.editor.deltaDecorations(this.decorationIds, []);
    this.disposableStore.clear();
  }
  setParts(lineNumber, parts, hiddenText) {
    this.disposableStore.clear();
    const textModel = this.editor.getModel();
    if (!textModel) {
      return;
    }
    const hiddenTextDecorations = new Array();
    if (hiddenText) {
      hiddenTextDecorations.push({
        range: Range.fromPositions(new Position(lineNumber, hiddenText.column), new Position(lineNumber, hiddenText.column + hiddenText.length)),
        options: {
          inlineClassName: "ghost-text-hidden",
          description: "ghost-text-hidden"
        }
      });
    }
    this.decorationIds = this.editor.deltaDecorations(this.decorationIds, parts.map((p) => {
      return {
        range: Range.fromPositions(new Position(lineNumber, p.column)),
        options: {
          description: "ghost-text",
          after: { content: p.text, inlineClassName: p.preview ? "ghost-text-decoration-preview" : "ghost-text-decoration" },
          showIfCollapsed: true
        }
      };
    }).concat(hiddenTextDecorations));
  }
};
var AdditionalLinesWidget = class {
  constructor(editor2, languageIdCodec) {
    this.editor = editor2;
    this.languageIdCodec = languageIdCodec;
    this._viewZoneId = void 0;
  }
  get viewZoneId() {
    return this._viewZoneId;
  }
  dispose() {
    this.clear();
  }
  clear() {
    this.editor.changeViewZones((changeAccessor) => {
      if (this._viewZoneId) {
        changeAccessor.removeZone(this._viewZoneId);
        this._viewZoneId = void 0;
      }
    });
  }
  updateLines(lineNumber, additionalLines, minReservedLineCount) {
    const textModel = this.editor.getModel();
    if (!textModel) {
      return;
    }
    const { tabSize } = textModel.getOptions();
    this.editor.changeViewZones((changeAccessor) => {
      if (this._viewZoneId) {
        changeAccessor.removeZone(this._viewZoneId);
        this._viewZoneId = void 0;
      }
      const heightInLines = Math.max(additionalLines.length, minReservedLineCount);
      if (heightInLines > 0) {
        const domNode = document.createElement("div");
        renderLines(domNode, tabSize, additionalLines, this.editor.getOptions(), this.languageIdCodec);
        this._viewZoneId = changeAccessor.addZone({
          afterLineNumber: lineNumber,
          heightInLines,
          domNode
        });
      }
    });
  }
};
function renderLines(domNode, tabSize, lines, opts, languageIdCodec) {
  const disableMonospaceOptimizations = opts.get(29);
  const stopRenderingLineAfter = opts.get(104);
  const renderWhitespace = "none";
  const renderControlCharacters = opts.get(82);
  const fontLigatures = opts.get(44);
  const fontInfo = opts.get(43);
  const lineHeight = opts.get(58);
  const sb = createStringBuilder(1e4);
  sb.appendASCIIString('<div class="suggest-preview-text">');
  for (let i = 0, len = lines.length; i < len; i++) {
    const lineData = lines[i];
    const line = lineData.content;
    sb.appendASCIIString('<div class="view-line');
    sb.appendASCIIString('" style="top:');
    sb.appendASCIIString(String(i * lineHeight));
    sb.appendASCIIString('px;width:1000000px;">');
    const isBasicASCII2 = isBasicASCII(line);
    const containsRTL2 = containsRTL(line);
    const lineTokens = LineTokens.createEmpty(line, languageIdCodec);
    renderViewLine(new RenderLineInput(fontInfo.isMonospace && !disableMonospaceOptimizations, fontInfo.canUseHalfwidthRightwardsArrow, line, false, isBasicASCII2, containsRTL2, 0, lineTokens, lineData.decorations, tabSize, 0, fontInfo.spaceWidth, fontInfo.middotWidth, fontInfo.wsmiddotWidth, stopRenderingLineAfter, renderWhitespace, renderControlCharacters, fontLigatures !== EditorFontLigatures.OFF, null), sb);
    sb.appendASCIIString("</div>");
  }
  sb.appendASCIIString("</div>");
  Configuration.applyFontInfoSlow(domNode, fontInfo);
  const html2 = sb.build();
  const trustedhtml = ttPolicy ? ttPolicy.createHTML(html2) : html2;
  domNode.innerHTML = trustedhtml;
}
var ViewMoreLinesContentWidget = class extends Disposable {
  constructor(editor2, position, domNode, disposableStore) {
    super();
    this.editor = editor2;
    this.position = position;
    this.domNode = domNode;
    this.allowEditorOverflow = false;
    this.suppressMouseDown = false;
    this._register(disposableStore);
    this._register(toDisposable(() => {
      this.editor.removeContentWidget(this);
    }));
    this.editor.addContentWidget(this);
  }
  getId() {
    return "editor.widget.viewMoreLinesWidget";
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      position: this.position,
      preference: [0]
    };
  }
};
registerThemingParticipant((theme, collector) => {
  const foreground2 = theme.getColor(ghostTextForeground);
  if (foreground2) {
    collector.addRule(`.monaco-editor .ghost-text-decoration { color: ${foreground2.toString()} !important; }`);
    collector.addRule(`.monaco-editor .ghost-text-decoration-preview { color: ${foreground2.toString()} !important; }`);
    collector.addRule(`.monaco-editor .suggest-preview-text .ghost-text { color: ${foreground2.toString()} !important; }`);
  }
  const background = theme.getColor(ghostTextBackground);
  if (background) {
    collector.addRule(`.monaco-editor .ghost-text-decoration { background-color: ${background.toString()}; }`);
    collector.addRule(`.monaco-editor .ghost-text-decoration-preview { background-color: ${background.toString()}; }`);
    collector.addRule(`.monaco-editor .suggest-preview-text .ghost-text { background-color: ${background.toString()}; }`);
  }
  const border = theme.getColor(ghostTextBorder);
  if (border) {
    collector.addRule(`.monaco-editor .suggest-preview-text .ghost-text { border: 1px solid ${border}; }`);
    collector.addRule(`.monaco-editor .ghost-text-decoration { border: 1px solid ${border}; }`);
    collector.addRule(`.monaco-editor .ghost-text-decoration-preview { border: 1px solid ${border}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/ghostTextController.js
var __decorate38 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param38 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter28 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var GhostTextController = class GhostTextController2 extends Disposable {
  constructor(editor2, instantiationService) {
    super();
    this.editor = editor2;
    this.instantiationService = instantiationService;
    this.triggeredExplicitly = false;
    this.activeController = this._register(new MutableDisposable());
    this._register(this.editor.onDidChangeModel(() => {
      this.updateModelController();
    }));
    this._register(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(105)) {
        this.updateModelController();
      }
      if (e.hasChanged(54)) {
        this.updateModelController();
      }
    }));
    this.updateModelController();
  }
  static get(editor2) {
    return editor2.getContribution(GhostTextController2.ID);
  }
  get activeModel() {
    var _a5;
    return (_a5 = this.activeController.value) === null || _a5 === void 0 ? void 0 : _a5.model;
  }
  updateModelController() {
    const suggestOptions = this.editor.getOption(105);
    const inlineSuggestOptions = this.editor.getOption(54);
    this.activeController.value = void 0;
    this.activeController.value = this.editor.hasModel() && (suggestOptions.preview || inlineSuggestOptions.enabled || this.triggeredExplicitly) ? this.instantiationService.createInstance(ActiveGhostTextController, this.editor) : void 0;
  }
  shouldShowHoverAt(hoverRange) {
    var _a5;
    return ((_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.shouldShowHoverAt(hoverRange)) || false;
  }
  shouldShowHoverAtViewZone(viewZoneId) {
    var _a5, _b2;
    return ((_b2 = (_a5 = this.activeController.value) === null || _a5 === void 0 ? void 0 : _a5.widget) === null || _b2 === void 0 ? void 0 : _b2.shouldShowHoverAtViewZone(viewZoneId)) || false;
  }
  trigger() {
    var _a5;
    this.triggeredExplicitly = true;
    if (!this.activeController.value) {
      this.updateModelController();
    }
    (_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.triggerInlineCompletion();
  }
  commit() {
    var _a5;
    (_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.commitInlineCompletion();
  }
  hide() {
    var _a5;
    (_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.hideInlineCompletion();
  }
  showNextInlineCompletion() {
    var _a5;
    (_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.showNextInlineCompletion();
  }
  showPreviousInlineCompletion() {
    var _a5;
    (_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.showPreviousInlineCompletion();
  }
  hasMultipleInlineCompletions() {
    var _a5;
    return __awaiter28(this, void 0, void 0, function* () {
      const result = yield (_a5 = this.activeModel) === null || _a5 === void 0 ? void 0 : _a5.hasMultipleInlineCompletions();
      return result !== void 0 ? result : false;
    });
  }
};
GhostTextController.inlineSuggestionVisible = new RawContextKey("inlineSuggestionVisible", false, localize("inlineSuggestionVisible", "Whether an inline suggestion is visible"));
GhostTextController.inlineSuggestionHasIndentation = new RawContextKey("inlineSuggestionHasIndentation", false, localize("inlineSuggestionHasIndentation", "Whether the inline suggestion starts with whitespace"));
GhostTextController.inlineSuggestionHasIndentationLessThanTabSize = new RawContextKey("inlineSuggestionHasIndentationLessThanTabSize", true, localize("inlineSuggestionHasIndentationLessThanTabSize", "Whether the inline suggestion starts with whitespace that is less than what would be inserted by tab"));
GhostTextController.ID = "editor.contrib.ghostTextController";
GhostTextController = __decorate38([
  __param38(1, IInstantiationService)
], GhostTextController);
var GhostTextContextKeys = class {
  constructor(contextKeyService) {
    this.contextKeyService = contextKeyService;
    this.inlineCompletionVisible = GhostTextController.inlineSuggestionVisible.bindTo(this.contextKeyService);
    this.inlineCompletionSuggestsIndentation = GhostTextController.inlineSuggestionHasIndentation.bindTo(this.contextKeyService);
    this.inlineCompletionSuggestsIndentationLessThanTabSize = GhostTextController.inlineSuggestionHasIndentationLessThanTabSize.bindTo(this.contextKeyService);
  }
};
var ActiveGhostTextController = class ActiveGhostTextController2 extends Disposable {
  constructor(editor2, instantiationService, contextKeyService) {
    super();
    this.editor = editor2;
    this.instantiationService = instantiationService;
    this.contextKeyService = contextKeyService;
    this.contextKeys = new GhostTextContextKeys(this.contextKeyService);
    this.model = this._register(this.instantiationService.createInstance(GhostTextModel, this.editor));
    this.widget = this._register(this.instantiationService.createInstance(GhostTextWidget, this.editor, this.model));
    this._register(toDisposable(() => {
      this.contextKeys.inlineCompletionVisible.set(false);
      this.contextKeys.inlineCompletionSuggestsIndentation.set(false);
      this.contextKeys.inlineCompletionSuggestsIndentationLessThanTabSize.set(true);
    }));
    this._register(this.model.onDidChange(() => {
      this.updateContextKeys();
    }));
    this.updateContextKeys();
  }
  updateContextKeys() {
    var _a5;
    this.contextKeys.inlineCompletionVisible.set(((_a5 = this.model.activeInlineCompletionsModel) === null || _a5 === void 0 ? void 0 : _a5.ghostText) !== void 0);
    let startsWithIndentation = false;
    let startsWithIndentationLessThanTabSize = true;
    const ghostText = this.model.inlineCompletionsModel.ghostText;
    if (!!this.model.activeInlineCompletionsModel && ghostText && ghostText.parts.length > 0) {
      const { column, lines } = ghostText.parts[0];
      const firstLine = lines[0];
      const indentationEndColumn = this.editor.getModel().getLineIndentColumn(ghostText.lineNumber);
      const inIndentation = column <= indentationEndColumn;
      if (inIndentation) {
        let firstNonWsIdx = firstNonWhitespaceIndex(firstLine);
        if (firstNonWsIdx === -1) {
          firstNonWsIdx = firstLine.length - 1;
        }
        startsWithIndentation = firstNonWsIdx > 0;
        const tabSize = this.editor.getModel().getOptions().tabSize;
        const visibleColumnIndentation = CursorColumns.visibleColumnFromColumn(firstLine, firstNonWsIdx + 1, tabSize);
        startsWithIndentationLessThanTabSize = visibleColumnIndentation < tabSize;
      }
    }
    this.contextKeys.inlineCompletionSuggestsIndentation.set(startsWithIndentation);
    this.contextKeys.inlineCompletionSuggestsIndentationLessThanTabSize.set(startsWithIndentationLessThanTabSize);
  }
};
ActiveGhostTextController = __decorate38([
  __param38(1, IInstantiationService),
  __param38(2, IContextKeyService)
], ActiveGhostTextController);
var GhostTextCommand = EditorCommand.bindToContribution(GhostTextController.get);
var commitInlineSuggestionAction = new GhostTextCommand({
  id: inlineSuggestCommitId,
  precondition: GhostTextController.inlineSuggestionVisible,
  handler(x) {
    x.commit();
    x.editor.focus();
  }
});
registerEditorCommand(commitInlineSuggestionAction);
KeybindingsRegistry.registerKeybindingRule({
  primary: 2,
  weight: 200,
  id: commitInlineSuggestionAction.id,
  when: ContextKeyExpr.and(commitInlineSuggestionAction.precondition, EditorContextKeys.tabMovesFocus.toNegated(), GhostTextController.inlineSuggestionHasIndentationLessThanTabSize)
});
registerEditorCommand(new GhostTextCommand({
  id: "editor.action.inlineSuggest.hide",
  precondition: GhostTextController.inlineSuggestionVisible,
  kbOpts: {
    weight: 100,
    primary: 9
  },
  handler(x) {
    x.hide();
  }
}));
var ShowNextInlineSuggestionAction = class extends EditorAction {
  constructor() {
    super({
      id: ShowNextInlineSuggestionAction.ID,
      label: localize("action.inlineSuggest.showNext", "Show Next Inline Suggestion"),
      alias: "Show Next Inline Suggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, GhostTextController.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 512 | 89
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter28(this, void 0, void 0, function* () {
      const controller = GhostTextController.get(editor2);
      if (controller) {
        controller.showNextInlineCompletion();
        editor2.focus();
      }
    });
  }
};
ShowNextInlineSuggestionAction.ID = "editor.action.inlineSuggest.showNext";
var ShowPreviousInlineSuggestionAction = class extends EditorAction {
  constructor() {
    super({
      id: ShowPreviousInlineSuggestionAction.ID,
      label: localize("action.inlineSuggest.showPrevious", "Show Previous Inline Suggestion"),
      alias: "Show Previous Inline Suggestion",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, GhostTextController.inlineSuggestionVisible),
      kbOpts: {
        weight: 100,
        primary: 512 | 87
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter28(this, void 0, void 0, function* () {
      const controller = GhostTextController.get(editor2);
      if (controller) {
        controller.showPreviousInlineCompletion();
        editor2.focus();
      }
    });
  }
};
ShowPreviousInlineSuggestionAction.ID = "editor.action.inlineSuggest.showPrevious";
var TriggerInlineSuggestionAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inlineSuggest.trigger",
      label: localize("action.inlineSuggest.trigger", "Trigger Inline Suggestion"),
      alias: "Trigger Inline Suggestion",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    return __awaiter28(this, void 0, void 0, function* () {
      const controller = GhostTextController.get(editor2);
      if (controller) {
        controller.trigger();
      }
    });
  }
};
registerEditorContribution(GhostTextController.ID, GhostTextController);
registerEditorAction(TriggerInlineSuggestionAction);
registerEditorAction(ShowNextInlineSuggestionAction);
registerEditorAction(ShowPreviousInlineSuggestionAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlineCompletions/inlineCompletionsHoverParticipant.js
var __decorate39 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param39 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InlineCompletionsHover = class {
  constructor(owner, range, controller) {
    this.owner = owner;
    this.range = range;
    this.controller = controller;
  }
  isValidForHoverAnchor(anchor) {
    return anchor.type === 1 && this.range.startColumn <= anchor.range.startColumn && this.range.endColumn >= anchor.range.endColumn;
  }
  hasMultipleSuggestions() {
    return this.controller.hasMultipleInlineCompletions();
  }
};
var InlineCompletionsHoverParticipant = class InlineCompletionsHoverParticipant2 {
  constructor(_editor, _hover, _commandService, _menuService, _contextKeyService, _modeService, _openerService, accessibilityService) {
    this._editor = _editor;
    this._hover = _hover;
    this._commandService = _commandService;
    this._menuService = _menuService;
    this._contextKeyService = _contextKeyService;
    this._modeService = _modeService;
    this._openerService = _openerService;
    this.accessibilityService = accessibilityService;
  }
  suggestHoverAnchor(mouseEvent) {
    const controller = GhostTextController.get(this._editor);
    if (!controller) {
      return null;
    }
    if (mouseEvent.target.type === 8) {
      const viewZoneData = mouseEvent.target.detail;
      if (controller.shouldShowHoverAtViewZone(viewZoneData.viewZoneId)) {
        return new HoverForeignElementAnchor(1e3, this, Range.fromPositions(viewZoneData.positionBefore || viewZoneData.position, viewZoneData.positionBefore || viewZoneData.position));
      }
    }
    if (mouseEvent.target.type === 7 && mouseEvent.target.range) {
      if (controller.shouldShowHoverAt(mouseEvent.target.range)) {
        return new HoverForeignElementAnchor(1e3, this, mouseEvent.target.range);
      }
    }
    if (mouseEvent.target.type === 6 && mouseEvent.target.range && mouseEvent.target.detail) {
      const mightBeForeignElement = mouseEvent.target.detail.mightBeForeignElement;
      if (mightBeForeignElement && controller.shouldShowHoverAt(mouseEvent.target.range)) {
        return new HoverForeignElementAnchor(1e3, this, mouseEvent.target.range);
      }
    }
    return null;
  }
  computeSync(anchor, lineDecorations) {
    const controller = GhostTextController.get(this._editor);
    if (controller && controller.shouldShowHoverAt(anchor.range)) {
      return [new InlineCompletionsHover(this, anchor.range, controller)];
    }
    return [];
  }
  renderHoverParts(hoverParts, fragment, statusBar) {
    const disposableStore = new DisposableStore();
    const part = hoverParts[0];
    if (this.accessibilityService.isScreenReaderOptimized()) {
      this.renderScreenReaderText(part, fragment, disposableStore);
    }
    const menu = disposableStore.add(this._menuService.createMenu(MenuId.InlineCompletionsActions, this._contextKeyService));
    const previousAction = statusBar.addAction({
      label: localize("showNextInlineSuggestion", "Next"),
      commandId: ShowNextInlineSuggestionAction.ID,
      run: () => this._commandService.executeCommand(ShowNextInlineSuggestionAction.ID)
    });
    const nextAction = statusBar.addAction({
      label: localize("showPreviousInlineSuggestion", "Previous"),
      commandId: ShowPreviousInlineSuggestionAction.ID,
      run: () => this._commandService.executeCommand(ShowPreviousInlineSuggestionAction.ID)
    });
    statusBar.addAction({
      label: localize("acceptInlineSuggestion", "Accept"),
      commandId: commitInlineSuggestionAction.id,
      run: () => this._commandService.executeCommand(commitInlineSuggestionAction.id)
    });
    const actions = [previousAction, nextAction];
    for (const action of actions) {
      action.setEnabled(false);
    }
    part.hasMultipleSuggestions().then((hasMore) => {
      for (const action of actions) {
        action.setEnabled(hasMore);
      }
    });
    for (const [_, group] of menu.getActions()) {
      for (const action of group) {
        if (action instanceof MenuItemAction) {
          statusBar.addAction({
            label: action.label,
            commandId: action.item.id,
            run: () => this._commandService.executeCommand(action.item.id)
          });
        }
      }
    }
    return disposableStore;
  }
  renderScreenReaderText(part, fragment, disposableStore) {
    var _a5, _b2;
    const $9 = $;
    const markdownHoverElement = $9("div.hover-row.markdown-hover");
    const hoverContentsElement = append(markdownHoverElement, $9("div.hover-contents"));
    const renderer = disposableStore.add(new MarkdownRenderer({ editor: this._editor }, this._modeService, this._openerService));
    const render = (code) => {
      disposableStore.add(renderer.onDidRenderAsync(() => {
        hoverContentsElement.className = "hover-contents code-hover-contents";
        this._hover.onContentsChanged();
      }));
      const inlineSuggestionAvailable = localize("inlineSuggestionFollows", "Suggestion:");
      const renderedContents = disposableStore.add(renderer.render(new MarkdownString().appendText(inlineSuggestionAvailable).appendCodeblock("text", code)));
      hoverContentsElement.replaceChildren(renderedContents.element);
    };
    const ghostText = (_b2 = (_a5 = part.controller.activeModel) === null || _a5 === void 0 ? void 0 : _a5.inlineCompletionsModel) === null || _b2 === void 0 ? void 0 : _b2.ghostText;
    if (ghostText) {
      const lineText = this._editor.getModel().getLineContent(ghostText.lineNumber);
      render(ghostText.renderForScreenReader(lineText));
    }
    fragment.appendChild(markdownHoverElement);
  }
};
InlineCompletionsHoverParticipant = __decorate39([
  __param39(2, ICommandService),
  __param39(3, IMenuService),
  __param39(4, IContextKeyService),
  __param39(5, IModeService),
  __param39(6, IOpenerService),
  __param39(7, IAccessibilityService)
], InlineCompletionsHoverParticipant);

// node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/unicodeHighlighter.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/unicodeHighlighter.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/bannerController.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/bannerController.css";

// node_modules/monaco-editor/esm/vs/platform/opener/browser/link.js
var __decorate40 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param40 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var Link = class Link2 extends Disposable {
  constructor(container, _link, options = {}, openerService) {
    var _a5;
    super();
    this._link = _link;
    this._enabled = true;
    this.el = append(container, $("a.monaco-link", {
      tabIndex: (_a5 = _link.tabIndex) !== null && _a5 !== void 0 ? _a5 : 0,
      href: _link.href,
      title: _link.title
    }, _link.label));
    this.el.setAttribute("role", "button");
    const onClickEmitter = this._register(new DomEmitter(this.el, "click"));
    const onKeyPress = this._register(new DomEmitter(this.el, "keypress"));
    const onEnterPress = Event.chain(onKeyPress.event).map((e) => new StandardKeyboardEvent(e)).filter((e) => e.keyCode === 3).event;
    const onTap = this._register(new DomEmitter(this.el, EventType2.Tap)).event;
    this._register(Gesture.addTarget(this.el));
    const onOpen = Event.any(onClickEmitter.event, onEnterPress, onTap);
    this._register(onOpen((e) => {
      if (!this.enabled) {
        return;
      }
      EventHelper.stop(e, true);
      if (options === null || options === void 0 ? void 0 : options.opener) {
        options.opener(this._link.href);
      } else {
        openerService.open(this._link.href, { allowCommands: true });
      }
    }));
    this.enabled = true;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    if (enabled) {
      this.el.setAttribute("aria-disabled", "false");
      this.el.tabIndex = 0;
      this.el.style.pointerEvents = "auto";
      this.el.style.opacity = "1";
      this.el.style.cursor = "pointer";
      this._enabled = false;
    } else {
      this.el.setAttribute("aria-disabled", "true");
      this.el.tabIndex = -1;
      this.el.style.pointerEvents = "none";
      this.el.style.opacity = "0.4";
      this.el.style.cursor = "default";
      this._enabled = true;
    }
    this._enabled = enabled;
  }
};
Link = __decorate40([
  __param40(3, IOpenerService)
], Link);
registerThemingParticipant((theme, collector) => {
  const textLinkForegroundColor = theme.getColor(textLinkForeground);
  if (textLinkForegroundColor) {
    collector.addRule(`.monaco-link { color: ${textLinkForegroundColor}; }`);
  }
  const textLinkActiveForegroundColor = theme.getColor(textLinkActiveForeground);
  if (textLinkActiveForegroundColor) {
    collector.addRule(`.monaco-link:hover { color: ${textLinkActiveForegroundColor}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/bannerController.js
var __decorate41 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param41 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var BANNER_ELEMENT_HEIGHT = 26;
var BannerController = class BannerController2 extends Disposable {
  constructor(_editor, instantiationService) {
    super();
    this._editor = _editor;
    this.instantiationService = instantiationService;
    this.banner = this._register(this.instantiationService.createInstance(Banner));
  }
  hide() {
    this._editor.setBanner(null, 0);
    this.banner.clear();
  }
  show(item) {
    this.banner.show(Object.assign(Object.assign({}, item), { onClose: () => {
      this.hide();
      if (item.onClose) {
        item.onClose();
      }
    } }));
    this._editor.setBanner(this.banner.element, BANNER_ELEMENT_HEIGHT);
  }
};
BannerController = __decorate41([
  __param41(1, IInstantiationService)
], BannerController);
var Banner = class Banner2 extends Disposable {
  constructor(instantiationService) {
    super();
    this.instantiationService = instantiationService;
    this.markdownRenderer = this.instantiationService.createInstance(MarkdownRenderer, {});
    this.element = $("div.editor-banner");
    this.element.tabIndex = 0;
  }
  getAriaLabel(item) {
    if (item.ariaLabel) {
      return item.ariaLabel;
    }
    if (typeof item.message === "string") {
      return item.message;
    }
    return void 0;
  }
  getBannerMessage(message) {
    if (typeof message === "string") {
      const element = $("span");
      element.innerText = message;
      return element;
    }
    return this.markdownRenderer.render(message).element;
  }
  clear() {
    clearNode(this.element);
  }
  show(item) {
    clearNode(this.element);
    const ariaLabel = this.getAriaLabel(item);
    if (ariaLabel) {
      this.element.setAttribute("aria-label", ariaLabel);
    }
    const iconContainer = append(this.element, $("div.icon-container"));
    iconContainer.setAttribute("aria-hidden", "true");
    if (item.icon) {
      iconContainer.appendChild($(`div${ThemeIcon.asCSSSelector(item.icon)}`));
    }
    const messageContainer = append(this.element, $("div.message-container"));
    messageContainer.setAttribute("aria-hidden", "true");
    messageContainer.appendChild(this.getBannerMessage(item.message));
    this.messageActionsContainer = append(this.element, $("div.message-actions-container"));
    if (item.actions) {
      for (const action of item.actions) {
        this._register(this.instantiationService.createInstance(Link, this.messageActionsContainer, Object.assign(Object.assign({}, action), { tabIndex: -1 }), {}));
      }
    }
    const actionBarContainer = append(this.element, $("div.action-container"));
    this.actionBar = this._register(new ActionBar(actionBarContainer));
    this.actionBar.push(this._register(new Action("banner.close", "Close Banner", ThemeIcon.asClassName(widgetClose), true, () => {
      if (typeof item.onClose === "function") {
        item.onClose();
      }
    })), { icon: true, label: false });
    this.actionBar.setFocusable(false);
  }
};
Banner = __decorate41([
  __param41(0, IInstantiationService)
], Banner);

// node_modules/monaco-editor/esm/vs/editor/contrib/unicodeHighlighter/unicodeHighlighter.js
var __decorate42 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param42 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter29 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var warningIcon = registerIcon("extensions-warning-message", Codicon.warning, localize("warningIcon", "Icon shown with a warning message in the extensions editor."));
var UnicodeHighlighter = class UnicodeHighlighter2 extends Disposable {
  constructor(_editor, _editorWorkerService, _workspaceTrustService, instantiationService) {
    super();
    this._editor = _editor;
    this._editorWorkerService = _editorWorkerService;
    this._workspaceTrustService = _workspaceTrustService;
    this._highlighter = null;
    this._bannerClosed = false;
    this._updateState = (state) => {
      if (state && state.hasMore) {
        if (this._bannerClosed) {
          return;
        }
        const max = Math.max(state.ambiguousCharacterCount, state.nonBasicAsciiCharacterCount, state.invisibleCharacterCount);
        let data;
        if (state.nonBasicAsciiCharacterCount >= max) {
          data = {
            message: localize("unicodeHighlighting.thisDocumentHasManyNonBasicAsciiUnicodeCharacters", "This document contains many non-basic ASCII unicode characters"),
            command: new DisableHighlightingOfNonBasicAsciiCharactersAction()
          };
        } else if (state.ambiguousCharacterCount >= max) {
          data = {
            message: localize("unicodeHighlighting.thisDocumentHasManyAmbiguousUnicodeCharacters", "This document contains many ambiguous unicode characters"),
            command: new DisableHighlightingOfAmbiguousCharactersAction()
          };
        } else if (state.invisibleCharacterCount >= max) {
          data = {
            message: localize("unicodeHighlighting.thisDocumentHasManyInvisibleUnicodeCharacters", "This document contains many invisible unicode characters"),
            command: new DisableHighlightingOfInvisibleCharactersAction()
          };
        } else {
          throw new Error("Unreachable");
        }
        this._bannerController.show({
          id: "unicodeHighlightBanner",
          message: data.message,
          icon: warningIcon,
          actions: [
            {
              label: data.command.shortLabel,
              href: `command:${data.command.id}`
            }
          ],
          onClose: () => {
            this._bannerClosed = true;
          }
        });
      } else {
        this._bannerController.hide();
      }
    };
    this._bannerController = this._register(instantiationService.createInstance(BannerController, _editor));
    this._register(this._editor.onDidChangeModel(() => {
      this._bannerClosed = false;
      this._updateHighlighter();
    }));
    this._options = _editor.getOption(112);
    this._register(_workspaceTrustService.onDidChangeTrust((e) => {
      this._updateHighlighter();
    }));
    this._register(_editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(112)) {
        this._options = _editor.getOption(112);
        this._updateHighlighter();
      }
    }));
    this._updateHighlighter();
  }
  dispose() {
    if (this._highlighter) {
      this._highlighter.dispose();
      this._highlighter = null;
    }
    super.dispose();
  }
  _updateHighlighter() {
    this._updateState(null);
    if (this._highlighter) {
      this._highlighter.dispose();
      this._highlighter = null;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const options = resolveOptions(this._workspaceTrustService.isWorkspaceTrusted(), this._options);
    if ([
      options.nonBasicASCII,
      options.ambiguousCharacters,
      options.invisibleCharacters
    ].every((option) => option === false)) {
      return;
    }
    const highlightOptions = {
      nonBasicASCII: options.nonBasicASCII,
      ambiguousCharacters: options.ambiguousCharacters,
      invisibleCharacters: options.invisibleCharacters,
      includeComments: options.includeComments,
      allowedCodePoints: Object.keys(options.allowedCharacters).map((c) => c.codePointAt(0))
    };
    if (this._editorWorkerService.canComputeUnicodeHighlights(this._editor.getModel().uri)) {
      this._highlighter = new DocumentUnicodeHighlighter(this._editor, highlightOptions, this._updateState, this._editorWorkerService);
    } else {
      this._highlighter = new ViewportUnicodeHighlighter(this._editor, highlightOptions, this._updateState);
    }
  }
  getDecorationInfo(decorationId) {
    if (this._highlighter) {
      return this._highlighter.getDecorationInfo(decorationId);
    }
    return null;
  }
};
UnicodeHighlighter.ID = "editor.contrib.unicodeHighlighter";
UnicodeHighlighter = __decorate42([
  __param42(1, IEditorWorkerService),
  __param42(2, IWorkspaceTrustManagementService),
  __param42(3, IInstantiationService)
], UnicodeHighlighter);
function resolveOptions(trusted, options) {
  var _a5;
  return {
    nonBasicASCII: options.nonBasicASCII === inUntrustedWorkspace ? !trusted : options.nonBasicASCII,
    ambiguousCharacters: options.ambiguousCharacters,
    invisibleCharacters: options.invisibleCharacters,
    includeComments: options.includeComments === inUntrustedWorkspace ? !trusted : options.includeComments,
    allowedCharacters: (_a5 = options.allowedCharacters) !== null && _a5 !== void 0 ? _a5 : {}
  };
}
var DocumentUnicodeHighlighter = class DocumentUnicodeHighlighter2 extends Disposable {
  constructor(_editor, _options, _updateState, _editorWorkerService) {
    super();
    this._editor = _editor;
    this._options = _options;
    this._updateState = _updateState;
    this._editorWorkerService = _editorWorkerService;
    this._model = this._editor.getModel();
    this._decorationIds = new Set();
    this._updateSoon = this._register(new RunOnceScheduler(() => this._update(), 250));
    this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    }));
    this._updateSoon.schedule();
  }
  dispose() {
    this._decorationIds = new Set(this._model.deltaDecorations(Array.from(this._decorationIds), []));
    super.dispose();
  }
  _update() {
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorationIds = new Set(this._editor.deltaDecorations(Array.from(this._decorationIds), []));
      return;
    }
    const modelVersionId = this._model.getVersionId();
    this._editorWorkerService.computedUnicodeHighlights(this._model.uri, this._options).then((info) => {
      if (this._model.getVersionId() !== modelVersionId) {
        return;
      }
      this._updateState(info);
      const decorations = [];
      if (!info.hasMore) {
        for (const range of info.ranges) {
          decorations.push({ range, options: this._options.includeComments ? DECORATION : DECORATION_HIDE_IN_COMMENTS });
        }
      }
      this._decorationIds = new Set(this._editor.deltaDecorations(Array.from(this._decorationIds), decorations));
    });
  }
  getDecorationInfo(decorationId) {
    if (!this._decorationIds.has(decorationId)) {
      return null;
    }
    const model = this._editor.getModel();
    const range = model.getDecorationRange(decorationId);
    if (!isModelDecorationVisible(model, {
      range,
      options: this._options.includeComments ? DECORATION : DECORATION_HIDE_IN_COMMENTS,
      id: decorationId,
      ownerId: 0
    })) {
      return null;
    }
    const text2 = model.getValueInRange(range);
    return {
      reason: computeReason(text2, this._options)
    };
  }
};
DocumentUnicodeHighlighter = __decorate42([
  __param42(3, IEditorWorkerService)
], DocumentUnicodeHighlighter);
var ViewportUnicodeHighlighter = class extends Disposable {
  constructor(_editor, _options, _updateState) {
    super();
    this._editor = _editor;
    this._options = _options;
    this._updateState = _updateState;
    this._model = this._editor.getModel();
    this._decorationIds = new Set();
    this._updateSoon = this._register(new RunOnceScheduler(() => this._update(), 250));
    this._register(this._editor.onDidLayoutChange(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidScrollChange(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidChangeHiddenAreas(() => {
      this._updateSoon.schedule();
    }));
    this._register(this._editor.onDidChangeModelContent(() => {
      this._updateSoon.schedule();
    }));
    this._updateSoon.schedule();
  }
  dispose() {
    this._decorationIds = new Set(this._model.deltaDecorations(Array.from(this._decorationIds), []));
    super.dispose();
  }
  _update() {
    if (!this._model.mightContainNonBasicASCII()) {
      this._decorationIds = new Set(this._editor.deltaDecorations(Array.from(this._decorationIds), []));
      return;
    }
    const ranges = this._editor.getVisibleRanges();
    const decorations = [];
    const totalResult = {
      ranges: [],
      ambiguousCharacterCount: 0,
      invisibleCharacterCount: 0,
      nonBasicAsciiCharacterCount: 0,
      hasMore: false
    };
    for (const range of ranges) {
      const result = UnicodeTextModelHighlighter.computeUnicodeHighlights(this._model, this._options, range);
      for (const r of result.ranges) {
        totalResult.ranges.push(r);
      }
      totalResult.ambiguousCharacterCount += totalResult.ambiguousCharacterCount;
      totalResult.invisibleCharacterCount += totalResult.invisibleCharacterCount;
      totalResult.nonBasicAsciiCharacterCount += totalResult.nonBasicAsciiCharacterCount;
      totalResult.hasMore = totalResult.hasMore || result.hasMore;
    }
    if (!totalResult.hasMore) {
      for (const range of totalResult.ranges) {
        decorations.push({ range, options: this._options.includeComments ? DECORATION : DECORATION_HIDE_IN_COMMENTS });
      }
    }
    this._updateState(totalResult);
    this._decorationIds = new Set(this._editor.deltaDecorations(Array.from(this._decorationIds), decorations));
  }
  getDecorationInfo(decorationId) {
    if (!this._decorationIds.has(decorationId)) {
      return null;
    }
    const model = this._editor.getModel();
    const range = model.getDecorationRange(decorationId);
    const text2 = model.getValueInRange(range);
    if (!isModelDecorationVisible(model, {
      range,
      options: this._options.includeComments ? DECORATION : DECORATION_HIDE_IN_COMMENTS,
      id: decorationId,
      ownerId: 0
    })) {
      return null;
    }
    return {
      reason: computeReason(text2, this._options)
    };
  }
};
var UnicodeHighlighterHoverParticipant = class UnicodeHighlighterHoverParticipant2 {
  constructor(_editor, _hover, _modeService, _openerService) {
    this._editor = _editor;
    this._hover = _hover;
    this._modeService = _modeService;
    this._openerService = _openerService;
  }
  computeSync(anchor, lineDecorations) {
    if (!this._editor.hasModel() || anchor.type !== 1) {
      return [];
    }
    const model = this._editor.getModel();
    const unicodeHighlighter = this._editor.getContribution(UnicodeHighlighter.ID);
    const result = [];
    let index = 300;
    for (const d of lineDecorations) {
      let formatCodePoint = function(codePoint2) {
        let value = `\`U+${codePoint2.toString(16).padStart(4, "0")}\``;
        if (!InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
          value += ` "${`${renderCodePointAsInlineCode(codePoint2)}`}"`;
        }
        return value;
      };
      const highlightInfo = unicodeHighlighter.getDecorationInfo(d.id);
      if (!highlightInfo) {
        continue;
      }
      const char = model.getValueInRange(d.range);
      const codePoint = char.codePointAt(0);
      const codePointStr = formatCodePoint(codePoint);
      let reason;
      switch (highlightInfo.reason.kind) {
        case 0:
          reason = localize("unicodeHighlight.characterIsAmbiguous", "The character {0} could be confused with the character {1}, which is more common in source code.", codePointStr, formatCodePoint(highlightInfo.reason.confusableWith.codePointAt(0)));
          break;
        case 1:
          reason = localize("unicodeHighlight.characterIsInvisible", "The character {0} is invisible.", codePointStr);
          break;
        case 2:
          reason = localize("unicodeHighlight.characterIsNonBasicAscii", "The character {0} is not a basic ASCII character.", codePointStr);
          break;
      }
      const adjustSettingsArgs = {
        codePoint,
        reason: highlightInfo.reason.kind
      };
      const adjustSettings = localize("unicodeHighlight.adjustSettings", "Adjust settings");
      const contents = [{
        value: `${reason} [${adjustSettings}](command:${ShowExcludeOptions.ID}?${encodeURIComponent(JSON.stringify(adjustSettingsArgs))})`,
        isTrusted: true
      }];
      result.push(new MarkdownHover(this, d.range, contents, index++));
    }
    return result;
  }
  renderHoverParts(hoverParts, fragment, statusBar) {
    return renderMarkdownHovers(hoverParts, fragment, this._editor, this._hover, this._modeService, this._openerService);
  }
};
UnicodeHighlighterHoverParticipant = __decorate42([
  __param42(2, IModeService),
  __param42(3, IOpenerService)
], UnicodeHighlighterHoverParticipant);
function renderCodePointAsInlineCode(codePoint) {
  if (codePoint === 96) {
    return "`` ` ``";
  }
  return "`" + String.fromCodePoint(codePoint) + "`";
}
function computeReason(char, options) {
  return UnicodeTextModelHighlighter.computeUnicodeHighlightReason(char, options);
}
var DECORATION_HIDE_IN_COMMENTS = ModelDecorationOptions.register({
  description: "unicode-highlight",
  stickiness: 1,
  className: "unicode-highlight",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerUnicodeHighlightForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapUnicodeHighlight),
    position: MinimapPosition.Inline
  },
  hideInCommentTokens: true
});
var DECORATION = ModelDecorationOptions.register({
  description: "unicode-highlight",
  stickiness: 1,
  className: "unicode-highlight",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: MinimapPosition.Inline
  }
});
var DisableHighlightingOfAmbiguousCharactersAction = class extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfAmbiguousCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters", "Disable highlighting of ambiguous characters"),
      alias: "Disable highlighting of ambiguous characters",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingOfAmbiguousCharacters.shortLabel", "Disable Ambiguous Highlight");
  }
  run(accessor, editor2, args) {
    return __awaiter29(this, void 0, void 0, function* () {
      let configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter29(this, void 0, void 0, function* () {
      yield configurationService.updateValue(unicodeHighlightConfigKeys.ambiguousCharacters, false, 1);
    });
  }
};
DisableHighlightingOfAmbiguousCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfAmbiguousCharacters";
var DisableHighlightingOfInvisibleCharactersAction = class extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfInvisibleCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingOfInvisibleCharacters", "Disable highlighting of invisible characters"),
      alias: "Disable highlighting of invisible characters",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingOfInvisibleCharacters.shortLabel", "Disable Invisible Highlight");
  }
  run(accessor, editor2, args) {
    return __awaiter29(this, void 0, void 0, function* () {
      let configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter29(this, void 0, void 0, function* () {
      yield configurationService.updateValue(unicodeHighlightConfigKeys.invisibleCharacters, false, 1);
    });
  }
};
DisableHighlightingOfInvisibleCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfInvisibleCharacters";
var DisableHighlightingOfNonBasicAsciiCharactersAction = class extends EditorAction {
  constructor() {
    super({
      id: DisableHighlightingOfNonBasicAsciiCharactersAction.ID,
      label: localize("action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters", "Disable highlighting of non basic ASCII characters"),
      alias: "Disable highlighting of non basic ASCII characters",
      precondition: void 0
    });
    this.shortLabel = localize("unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters.shortLabel", "Disable Non ASCII Highlight");
  }
  run(accessor, editor2, args) {
    return __awaiter29(this, void 0, void 0, function* () {
      let configurationService = accessor === null || accessor === void 0 ? void 0 : accessor.get(IConfigurationService);
      if (configurationService) {
        this.runAction(configurationService);
      }
    });
  }
  runAction(configurationService) {
    return __awaiter29(this, void 0, void 0, function* () {
      yield configurationService.updateValue(unicodeHighlightConfigKeys.nonBasicASCII, false, 1);
    });
  }
};
DisableHighlightingOfNonBasicAsciiCharactersAction.ID = "editor.action.unicodeHighlight.disableHighlightingOfNonBasicAsciiCharacters";
var ShowExcludeOptions = class extends EditorAction {
  constructor() {
    super({
      id: ShowExcludeOptions.ID,
      label: localize("action.unicodeHighlight.showExcludeOptions", "Show Exclude Options"),
      alias: "Show Exclude Options",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    return __awaiter29(this, void 0, void 0, function* () {
      const { codePoint, reason } = args;
      const char = String.fromCodePoint(codePoint);
      const quickPickService = accessor.get(IQuickInputService);
      const configurationService = accessor.get(IConfigurationService);
      function getExcludeCharFromBeingHighlightedLabel(codePoint2) {
        if (InvisibleCharacters.isInvisibleCharacter(codePoint2)) {
          return localize("unicodeHighlight.excludeInvisibleCharFromBeingHighlighted", "Exclude {0} (invisible character) from being highlighted", `U+${codePoint2.toString(16)}`);
        }
        return localize("unicodeHighlight.excludeCharFromBeingHighlighted", "Exclude {0} from being highlighted", `U+${codePoint2.toString(16)} "${char}"`);
      }
      const options = [
        {
          label: getExcludeCharFromBeingHighlightedLabel(codePoint),
          run: () => excludeCharFromBeingHighlighted(configurationService, [codePoint])
        }
      ];
      if (reason === 0) {
        const action = new DisableHighlightingOfAmbiguousCharactersAction();
        options.push({ label: action.label, run: () => __awaiter29(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else if (reason === 1) {
        const action = new DisableHighlightingOfInvisibleCharactersAction();
        options.push({ label: action.label, run: () => __awaiter29(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else if (reason === 2) {
        const action = new DisableHighlightingOfNonBasicAsciiCharactersAction();
        options.push({ label: action.label, run: () => __awaiter29(this, void 0, void 0, function* () {
          return action.runAction(configurationService);
        }) });
      } else {
        expectNever(reason);
      }
      const result = yield quickPickService.pick(options, { title: localize("unicodeHighlight.configureUnicodeHighlightOptions", "Configure Unicode Highlight Options") });
      if (result) {
        yield result.run();
      }
    });
  }
};
ShowExcludeOptions.ID = "editor.action.unicodeHighlight.showExcludeOptions";
function excludeCharFromBeingHighlighted(configurationService, charCodes) {
  return __awaiter29(this, void 0, void 0, function* () {
    const existingValue = configurationService.getValue(unicodeHighlightConfigKeys.allowedCharacters);
    let value;
    if (typeof existingValue === "object" && existingValue) {
      value = existingValue;
    } else {
      value = {};
    }
    for (const charCode of charCodes) {
      value[String.fromCodePoint(charCode)] = true;
    }
    yield configurationService.updateValue(unicodeHighlightConfigKeys.allowedCharacters, value, 1);
  });
}
function expectNever(value) {
  throw new Error(`Unexpected value: ${value}`);
}
registerEditorAction(DisableHighlightingOfAmbiguousCharactersAction);
registerEditorAction(DisableHighlightingOfInvisibleCharactersAction);
registerEditorAction(DisableHighlightingOfNonBasicAsciiCharactersAction);
registerEditorAction(ShowExcludeOptions);
registerEditorContribution(UnicodeHighlighter.ID, UnicodeHighlighter);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/modesContentHover.js
var __decorate43 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param43 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $6 = $;
var EditorHoverStatusBar = class EditorHoverStatusBar2 extends Disposable {
  constructor(_keybindingService) {
    super();
    this._keybindingService = _keybindingService;
    this._hasContent = false;
    this.hoverElement = $6("div.hover-row.status-bar");
    this.actionsElement = append(this.hoverElement, $6("div.actions"));
  }
  get hasContent() {
    return this._hasContent;
  }
  addAction(actionOptions) {
    const keybinding = this._keybindingService.lookupKeybinding(actionOptions.commandId);
    const keybindingLabel = keybinding ? keybinding.getLabel() : null;
    this._hasContent = true;
    return this._register(HoverAction.render(this.actionsElement, actionOptions, keybindingLabel));
  }
  append(element) {
    const result = append(this.actionsElement, element);
    this._hasContent = true;
    return result;
  }
};
EditorHoverStatusBar = __decorate43([
  __param43(0, IKeybindingService)
], EditorHoverStatusBar);
var ModesContentComputer = class {
  constructor(editor2, _participants) {
    this._participants = _participants;
    this._editor = editor2;
    this._result = [];
    this._anchor = null;
  }
  setAnchor(anchor) {
    this._anchor = anchor;
    this._result = [];
  }
  clearResult() {
    this._result = [];
  }
  static _getLineDecorations(editor2, anchor) {
    if (anchor.type !== 1) {
      return [];
    }
    const model = editor2.getModel();
    const lineNumber = anchor.range.startLineNumber;
    const maxColumn = model.getLineMaxColumn(lineNumber);
    return editor2.getLineDecorations(lineNumber).filter((d) => {
      if (d.options.isWholeLine) {
        return true;
      }
      const startColumn = d.range.startLineNumber === lineNumber ? d.range.startColumn : 1;
      const endColumn = d.range.endLineNumber === lineNumber ? d.range.endColumn : maxColumn;
      if (d.options.showIfCollapsed) {
        if (startColumn > anchor.range.startColumn + 1 || anchor.range.endColumn - 1 > endColumn) {
          return false;
        }
      } else {
        if (startColumn > anchor.range.startColumn || anchor.range.endColumn > endColumn) {
          return false;
        }
      }
      return true;
    });
  }
  computeAsync(token) {
    const anchor = this._anchor;
    if (!this._editor.hasModel() || !anchor) {
      return AsyncIterableObject.EMPTY;
    }
    const lineDecorations = ModesContentComputer._getLineDecorations(this._editor, anchor);
    return AsyncIterableObject.merge(this._participants.map((participant) => this._computeAsync(participant, lineDecorations, anchor, token)));
  }
  _computeAsync(participant, lineDecorations, anchor, token) {
    if (!participant.computeAsync) {
      return AsyncIterableObject.EMPTY;
    }
    return participant.computeAsync(anchor, lineDecorations, token);
  }
  computeSync() {
    if (!this._editor.hasModel() || !this._anchor) {
      return [];
    }
    const lineDecorations = ModesContentComputer._getLineDecorations(this._editor, this._anchor);
    let result = [];
    for (const participant of this._participants) {
      result = result.concat(participant.computeSync(this._anchor, lineDecorations));
    }
    return coalesce(result);
  }
  onResult(result, isFromSynchronousComputation) {
    if (isFromSynchronousComputation) {
      this._result = result.concat(this._result);
    } else {
      this._result = this._result.concat(result);
    }
  }
  getResult() {
    return this._result.slice(0);
  }
  getResultWithLoadingMessage() {
    if (this._anchor) {
      for (const participant of this._participants) {
        if (participant.createLoadingMessage) {
          const loadingMessage = participant.createLoadingMessage(this._anchor);
          if (loadingMessage) {
            return this._result.slice(0).concat([loadingMessage]);
          }
        }
      }
    }
    return this._result.slice(0);
  }
};
var ModesContentHoverWidget = class ModesContentHoverWidget2 extends Widget {
  constructor(editor2, _hoverVisibleKey, instantiationService, _keybindingService, _contextKeyService) {
    super();
    this._hoverVisibleKey = _hoverVisibleKey;
    this._keybindingService = _keybindingService;
    this._contextKeyService = _contextKeyService;
    this.allowEditorOverflow = true;
    this._participants = [
      instantiationService.createInstance(ColorHoverParticipant, editor2, this),
      instantiationService.createInstance(MarkdownHoverParticipant, editor2, this),
      instantiationService.createInstance(InlineCompletionsHoverParticipant, editor2, this),
      instantiationService.createInstance(UnicodeHighlighterHoverParticipant, editor2, this),
      instantiationService.createInstance(MarkerHoverParticipant, editor2, this)
    ];
    this._editor = editor2;
    this._isVisible = false;
    this._stoleFocus = false;
    this._renderDisposable = null;
    this._hover = this._register(new HoverWidget());
    this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
    this.onkeydown(this._hover.containerDomNode, (e) => {
      if (e.equals(9)) {
        this.hide();
      }
    });
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(43)) {
        this._updateFont();
      }
    }));
    this._editor.onDidLayoutChange(() => this.layout());
    this.layout();
    this._editor.addContentWidget(this);
    this._showAtPosition = null;
    this._showAtRange = null;
    this._stoleFocus = false;
    this._messages = [];
    this._messagesAreComplete = false;
    this._lastAnchor = null;
    this._computer = new ModesContentComputer(this._editor, this._participants);
    this._highlightDecorations = [];
    this._isChangingDecorations = false;
    this._shouldFocus = false;
    this._colorPicker = null;
    this._preferAbove = this._editor.getOption(52).above;
    this._hoverOperation = new HoverOperation(this._computer, (result) => this._withResult(result, true), null, (result) => this._withResult(result, false), this._editor.getOption(52).delay);
    this._register(addStandardDisposableListener(this.getDomNode(), EventType.FOCUS, () => {
      if (this._colorPicker) {
        this.getDomNode().classList.add("colorpicker-hover");
      }
    }));
    this._register(addStandardDisposableListener(this.getDomNode(), EventType.BLUR, () => {
      this.getDomNode().classList.remove("colorpicker-hover");
    }));
    this._register(editor2.onDidChangeConfiguration(() => {
      this._hoverOperation.setHoverTime(this._editor.getOption(52).delay);
      this._preferAbove = this._editor.getOption(52).above;
    }));
    this._register(TokenizationRegistry.onDidChange(() => {
      if (this._isVisible && this._lastAnchor && this._messages.length > 0) {
        this._hover.contentsDomNode.textContent = "";
        this._renderMessages(this._lastAnchor, this._messages);
      }
    }));
  }
  dispose() {
    this._hoverOperation.cancel();
    this._editor.removeContentWidget(this);
    super.dispose();
  }
  getId() {
    return ModesContentHoverWidget2.ID;
  }
  getDomNode() {
    return this._hover.containerDomNode;
  }
  _shouldShowAt(mouseEvent) {
    const targetType = mouseEvent.target.type;
    if (targetType === 6) {
      return true;
    }
    if (targetType === 7) {
      const epsilon = this._editor.getOption(43).typicalHalfwidthCharacterWidth / 2;
      const data = mouseEvent.target.detail;
      if (data && !data.isAfterLines && typeof data.horizontalDistanceToText === "number" && data.horizontalDistanceToText < epsilon) {
        return true;
      }
    }
    return false;
  }
  maybeShowAt(mouseEvent) {
    var _a5;
    const anchorCandidates = [];
    for (const participant of this._participants) {
      if (typeof participant.suggestHoverAnchor === "function") {
        const anchor = participant.suggestHoverAnchor(mouseEvent);
        if (anchor) {
          anchorCandidates.push(anchor);
        }
      }
    }
    if (this._shouldShowAt(mouseEvent) && mouseEvent.target.range) {
      const hoverOnColorDecorator = [...((_a5 = mouseEvent.target.element) === null || _a5 === void 0 ? void 0 : _a5.classList.values()) || []].find((className) => className.startsWith("ced-colorBox")) && mouseEvent.target.range.endColumn - mouseEvent.target.range.startColumn === 1;
      const showAtRange = hoverOnColorDecorator ? new Range(mouseEvent.target.range.startLineNumber, mouseEvent.target.range.startColumn + 1, mouseEvent.target.range.endLineNumber, mouseEvent.target.range.endColumn + 1) : mouseEvent.target.range;
      anchorCandidates.push(new HoverRangeAnchor(0, showAtRange));
    }
    if (anchorCandidates.length === 0) {
      return false;
    }
    anchorCandidates.sort((a, b) => b.priority - a.priority);
    this._startShowingAt(anchorCandidates[0], 0, false);
    return true;
  }
  _showAt(position, range, focus) {
    this._showAtPosition = position;
    this._showAtRange = range;
    this._hoverVisibleKey.set(true);
    this._isVisible = true;
    this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
    this._editor.layoutContentWidget(this);
    this._editor.render();
    this._stoleFocus = focus;
    if (focus) {
      this._hover.containerDomNode.focus();
    }
  }
  getPosition() {
    if (this._isVisible) {
      let preferAbove = this._preferAbove;
      if (!preferAbove && this._contextKeyService.getContextKeyValue(Context.Visible.key)) {
        preferAbove = true;
      }
      return {
        position: this._showAtPosition,
        range: this._showAtRange,
        preference: preferAbove ? [
          1,
          2
        ] : [
          2,
          1
        ]
      };
    }
    return null;
  }
  _updateFont() {
    const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code"));
    codeClasses.forEach((node) => this._editor.applyFontInfo(node));
  }
  _updateContents(node) {
    this._hover.contentsDomNode.textContent = "";
    this._hover.contentsDomNode.appendChild(node);
    this._updateFont();
    this._editor.layoutContentWidget(this);
    this._hover.onContentsChanged();
  }
  layout() {
    const height = Math.max(this._editor.getLayoutInfo().height / 4, 250);
    const { fontSize, lineHeight } = this._editor.getOption(43);
    this._hover.contentsDomNode.style.fontSize = `${fontSize}px`;
    this._hover.contentsDomNode.style.lineHeight = `${lineHeight / fontSize}`;
    this._hover.contentsDomNode.style.maxHeight = `${height}px`;
    this._hover.contentsDomNode.style.maxWidth = `${Math.max(this._editor.getLayoutInfo().width * 0.66, 500)}px`;
  }
  onModelDecorationsChanged() {
    if (this._isChangingDecorations) {
      return;
    }
    if (this._isVisible) {
      this._hoverOperation.cancel();
      this._computer.clearResult();
      if (!this._colorPicker) {
        this._hoverOperation.start(0);
      }
    }
  }
  startShowingAtRange(range, mode, focus) {
    this._startShowingAt(new HoverRangeAnchor(0, range), mode, focus);
  }
  _startShowingAt(anchor, mode, focus) {
    if (this._lastAnchor && this._lastAnchor.equals(anchor)) {
      return;
    }
    this._hoverOperation.cancel();
    if (this._isVisible) {
      if (!this._showAtPosition || !this._lastAnchor || !anchor.canAdoptVisibleHover(this._lastAnchor, this._showAtPosition)) {
        this.hide();
      } else {
        const filteredMessages = this._messages.filter((m) => m.isValidForHoverAnchor(anchor));
        if (filteredMessages.length === 0) {
          this.hide();
        } else if (filteredMessages.length === this._messages.length && this._messagesAreComplete) {
          return;
        } else {
          this._renderMessages(anchor, filteredMessages);
        }
      }
    }
    this._lastAnchor = anchor;
    this._computer.setAnchor(anchor);
    this._shouldFocus = focus;
    this._hoverOperation.start(mode);
  }
  hide() {
    this._lastAnchor = null;
    this._hoverOperation.cancel();
    if (this._isVisible) {
      setTimeout(() => {
        if (!this._isVisible) {
          this._hoverVisibleKey.set(false);
        }
      }, 0);
      this._isVisible = false;
      this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
      this._editor.layoutContentWidget(this);
      if (this._stoleFocus) {
        this._editor.focus();
      }
    }
    this._isChangingDecorations = true;
    this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, []);
    this._isChangingDecorations = false;
    if (this._renderDisposable) {
      this._renderDisposable.dispose();
      this._renderDisposable = null;
    }
    this._colorPicker = null;
  }
  isColorPickerVisible() {
    return !!this._colorPicker;
  }
  setColorPicker(widget) {
    this._colorPicker = widget;
  }
  onContentsChanged() {
    this._hover.onContentsChanged();
  }
  _withResult(result, complete) {
    this._messages = result;
    this._messagesAreComplete = complete;
    if (this._lastAnchor && this._messages.length > 0) {
      this._renderMessages(this._lastAnchor, this._messages);
    } else if (complete) {
      this.hide();
    }
  }
  _renderMessages(anchor, messages) {
    if (this._renderDisposable) {
      this._renderDisposable.dispose();
      this._renderDisposable = null;
    }
    this._colorPicker = null;
    let renderColumn = 1073741824;
    let highlightRange = messages[0].range;
    let forceShowAtRange = null;
    let fragment = document.createDocumentFragment();
    const disposables = new DisposableStore();
    const hoverParts = new Map();
    for (const msg of messages) {
      renderColumn = Math.min(renderColumn, msg.range.startColumn);
      highlightRange = Range.plusRange(highlightRange, msg.range);
      if (msg.forceShowAtRange) {
        forceShowAtRange = msg.range;
      }
      if (!hoverParts.has(msg.owner)) {
        hoverParts.set(msg.owner, []);
      }
      const dest = hoverParts.get(msg.owner);
      dest.push(msg);
    }
    const statusBar = disposables.add(new EditorHoverStatusBar(this._keybindingService));
    for (const participant of this._participants) {
      if (hoverParts.has(participant)) {
        const participantHoverParts = hoverParts.get(participant);
        disposables.add(participant.renderHoverParts(participantHoverParts, fragment, statusBar));
      }
    }
    if (statusBar.hasContent) {
      fragment.appendChild(statusBar.hoverElement);
    }
    this._renderDisposable = disposables;
    if (fragment.hasChildNodes()) {
      if (forceShowAtRange) {
        this._showAt(forceShowAtRange.getStartPosition(), forceShowAtRange, this._shouldFocus);
      } else {
        this._showAt(new Position(anchor.range.startLineNumber, renderColumn), highlightRange, this._shouldFocus);
      }
      this._updateContents(fragment);
    }
    if (this._colorPicker) {
      this._colorPicker.layout();
    }
    this._isChangingDecorations = true;
    this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, highlightRange ? [{
      range: highlightRange,
      options: ModesContentHoverWidget2._DECORATION_OPTIONS
    }] : []);
    this._isChangingDecorations = false;
  }
};
ModesContentHoverWidget.ID = "editor.contrib.modesContentHoverWidget";
ModesContentHoverWidget._DECORATION_OPTIONS = ModelDecorationOptions.register({
  description: "content-hover-highlight",
  className: "hoverHighlight"
});
ModesContentHoverWidget = __decorate43([
  __param43(2, IInstantiationService),
  __param43(3, IKeybindingService),
  __param43(4, IContextKeyService)
], ModesContentHoverWidget);

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/modesGlyphHover.js
var $7 = $;
var MarginComputer = class {
  constructor(editor2) {
    this._editor = editor2;
    this._lineNumber = -1;
    this._result = [];
  }
  setLineNumber(lineNumber) {
    this._lineNumber = lineNumber;
    this._result = [];
  }
  clearResult() {
    this._result = [];
  }
  computeSync() {
    const toHoverMessage = (contents) => {
      return {
        value: contents
      };
    };
    const lineDecorations = this._editor.getLineDecorations(this._lineNumber);
    const result = [];
    if (!lineDecorations) {
      return result;
    }
    for (const d of lineDecorations) {
      if (!d.options.glyphMarginClassName) {
        continue;
      }
      const hoverMessage = d.options.glyphMarginHoverMessage;
      if (!hoverMessage || isEmptyMarkdownString(hoverMessage)) {
        continue;
      }
      result.push(...asArray(hoverMessage).map(toHoverMessage));
    }
    return result;
  }
  onResult(result, isFromSynchronousComputation) {
    this._result = this._result.concat(result);
  }
  getResult() {
    return this._result;
  }
  getResultWithLoadingMessage() {
    return this.getResult();
  }
};
var ModesGlyphHoverWidget = class extends Widget {
  constructor(editor2, modeService, openerService = NullOpenerService) {
    super();
    this._renderDisposeables = this._register(new DisposableStore());
    this._editor = editor2;
    this._isVisible = false;
    this._messages = [];
    this._lastLineNumber = -1;
    this._hover = this._register(new HoverWidget());
    this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
    this._markdownRenderer = this._register(new MarkdownRenderer({ editor: this._editor }, modeService, openerService));
    this._computer = new MarginComputer(this._editor);
    this._hoverOperation = new HoverOperation(this._computer, (result) => this._withResult(result), void 0, (result) => this._withResult(result), 300);
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(43)) {
        this._updateFont();
      }
    }));
    this._editor.addOverlayWidget(this);
  }
  dispose() {
    this._hoverOperation.cancel();
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  getId() {
    return ModesGlyphHoverWidget.ID;
  }
  getDomNode() {
    return this._hover.containerDomNode;
  }
  getPosition() {
    return null;
  }
  _showAt(lineNumber) {
    if (!this._isVisible) {
      this._isVisible = true;
      this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
    }
    const editorLayout = this._editor.getLayoutInfo();
    const topForLineNumber = this._editor.getTopForLineNumber(lineNumber);
    const editorScrollTop = this._editor.getScrollTop();
    const lineHeight = this._editor.getOption(58);
    const nodeHeight = this._hover.containerDomNode.clientHeight;
    const top = topForLineNumber - editorScrollTop - (nodeHeight - lineHeight) / 2;
    this._hover.containerDomNode.style.left = `${editorLayout.glyphMarginLeft + editorLayout.glyphMarginWidth}px`;
    this._hover.containerDomNode.style.top = `${Math.max(Math.round(top), 0)}px`;
  }
  _updateFont() {
    const codeClasses = Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code"));
    codeClasses.forEach((node) => this._editor.applyFontInfo(node));
  }
  _updateContents(node) {
    this._hover.contentsDomNode.textContent = "";
    this._hover.contentsDomNode.appendChild(node);
    this._updateFont();
  }
  onModelDecorationsChanged() {
    if (this._isVisible) {
      this._hoverOperation.cancel();
      this._computer.clearResult();
      this._hoverOperation.start(0);
    }
  }
  startShowingAt(lineNumber) {
    if (this._lastLineNumber === lineNumber) {
      return;
    }
    this._hoverOperation.cancel();
    this.hide();
    this._lastLineNumber = lineNumber;
    this._computer.setLineNumber(lineNumber);
    this._hoverOperation.start(0);
  }
  hide() {
    this._lastLineNumber = -1;
    this._hoverOperation.cancel();
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible);
  }
  _withResult(result) {
    this._messages = result;
    if (this._messages.length > 0) {
      this._renderMessages(this._lastLineNumber, this._messages);
    } else {
      this.hide();
    }
  }
  _renderMessages(lineNumber, messages) {
    this._renderDisposeables.clear();
    const fragment = document.createDocumentFragment();
    for (const msg of messages) {
      const markdownHoverElement = $7("div.hover-row.markdown-hover");
      const hoverContentsElement = append(markdownHoverElement, $7("div.hover-contents"));
      const renderedContents = this._renderDisposeables.add(this._markdownRenderer.render(msg.value));
      hoverContentsElement.appendChild(renderedContents.element);
      fragment.appendChild(markdownHoverElement);
    }
    this._updateContents(fragment);
    this._showAt(lineNumber);
  }
};
ModesGlyphHoverWidget.ID = "editor.contrib.modesGlyphHoverWidget";

// node_modules/monaco-editor/esm/vs/editor/contrib/hover/hover.js
var __decorate44 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param44 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ModesHoverController = class ModesHoverController2 {
  constructor(_editor, _instantiationService, _openerService, _modeService, _contextKeyService) {
    this._editor = _editor;
    this._instantiationService = _instantiationService;
    this._openerService = _openerService;
    this._modeService = _modeService;
    this._toUnhook = new DisposableStore();
    this._isMouseDown = false;
    this._hoverClicked = false;
    this._contentWidget = null;
    this._glyphWidget = null;
    this._hookEvents();
    this._didChangeConfigurationHandler = this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(52)) {
        this._unhookEvents();
        this._hookEvents();
      }
    });
    this._hoverVisibleKey = EditorContextKeys.hoverVisible.bindTo(_contextKeyService);
  }
  static get(editor2) {
    return editor2.getContribution(ModesHoverController2.ID);
  }
  _hookEvents() {
    const hideWidgetsEventHandler = () => this._hideWidgets();
    const hoverOpts = this._editor.getOption(52);
    this._isHoverEnabled = hoverOpts.enabled;
    this._isHoverSticky = hoverOpts.sticky;
    if (this._isHoverEnabled) {
      this._toUnhook.add(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
      this._toUnhook.add(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
      this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
      this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
      this._toUnhook.add(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged()));
    } else {
      this._toUnhook.add(this._editor.onMouseMove((e) => this._onEditorMouseMove(e)));
      this._toUnhook.add(this._editor.onKeyDown((e) => this._onKeyDown(e)));
    }
    this._toUnhook.add(this._editor.onMouseLeave(hideWidgetsEventHandler));
    this._toUnhook.add(this._editor.onDidChangeModel(hideWidgetsEventHandler));
    this._toUnhook.add(this._editor.onDidScrollChange((e) => this._onEditorScrollChanged(e)));
  }
  _unhookEvents() {
    this._toUnhook.clear();
  }
  _onModelDecorationsChanged() {
    var _a5, _b2;
    (_a5 = this._contentWidget) === null || _a5 === void 0 ? void 0 : _a5.onModelDecorationsChanged();
    (_b2 = this._glyphWidget) === null || _b2 === void 0 ? void 0 : _b2.onModelDecorationsChanged();
  }
  _onEditorScrollChanged(e) {
    if (e.scrollTopChanged || e.scrollLeftChanged) {
      this._hideWidgets();
    }
  }
  _onEditorMouseDown(mouseEvent) {
    this._isMouseDown = true;
    const targetType = mouseEvent.target.type;
    if (targetType === 9 && mouseEvent.target.detail === ModesContentHoverWidget.ID) {
      this._hoverClicked = true;
      return;
    }
    if (targetType === 12 && mouseEvent.target.detail === ModesGlyphHoverWidget.ID) {
      return;
    }
    if (targetType !== 12 && mouseEvent.target.detail !== ModesGlyphHoverWidget.ID) {
      this._hoverClicked = false;
    }
    this._hideWidgets();
  }
  _onEditorMouseUp(mouseEvent) {
    this._isMouseDown = false;
  }
  _onEditorMouseMove(mouseEvent) {
    var _a5, _b2, _c2, _d2, _e2;
    let targetType = mouseEvent.target.type;
    if (this._isMouseDown && this._hoverClicked) {
      return;
    }
    if (this._isHoverSticky && targetType === 9 && mouseEvent.target.detail === ModesContentHoverWidget.ID) {
      return;
    }
    if (this._isHoverSticky && !((_b2 = (_a5 = mouseEvent.event.browserEvent.view) === null || _a5 === void 0 ? void 0 : _a5.getSelection()) === null || _b2 === void 0 ? void 0 : _b2.isCollapsed)) {
      return;
    }
    if (!this._isHoverSticky && targetType === 9 && mouseEvent.target.detail === ModesContentHoverWidget.ID && ((_c2 = this._contentWidget) === null || _c2 === void 0 ? void 0 : _c2.isColorPickerVisible())) {
      return;
    }
    if (this._isHoverSticky && targetType === 12 && mouseEvent.target.detail === ModesGlyphHoverWidget.ID) {
      return;
    }
    if (!this._isHoverEnabled) {
      this._hideWidgets();
      return;
    }
    const contentWidget = this._getOrCreateContentWidget();
    if (contentWidget.maybeShowAt(mouseEvent)) {
      (_d2 = this._glyphWidget) === null || _d2 === void 0 ? void 0 : _d2.hide();
      return;
    }
    if (targetType === 2 && mouseEvent.target.position) {
      (_e2 = this._contentWidget) === null || _e2 === void 0 ? void 0 : _e2.hide();
      if (!this._glyphWidget) {
        this._glyphWidget = new ModesGlyphHoverWidget(this._editor, this._modeService, this._openerService);
      }
      this._glyphWidget.startShowingAt(mouseEvent.target.position.lineNumber);
      return;
    }
    this._hideWidgets();
  }
  _onKeyDown(e) {
    if (e.keyCode !== 5 && e.keyCode !== 6 && e.keyCode !== 57 && e.keyCode !== 4) {
      this._hideWidgets();
    }
  }
  _hideWidgets() {
    var _a5, _b2, _c2;
    if (this._isMouseDown && this._hoverClicked && ((_a5 = this._contentWidget) === null || _a5 === void 0 ? void 0 : _a5.isColorPickerVisible())) {
      return;
    }
    this._hoverClicked = false;
    (_b2 = this._glyphWidget) === null || _b2 === void 0 ? void 0 : _b2.hide();
    (_c2 = this._contentWidget) === null || _c2 === void 0 ? void 0 : _c2.hide();
  }
  _getOrCreateContentWidget() {
    if (!this._contentWidget) {
      this._contentWidget = this._instantiationService.createInstance(ModesContentHoverWidget, this._editor, this._hoverVisibleKey);
    }
    return this._contentWidget;
  }
  isColorPickerVisible() {
    var _a5;
    return ((_a5 = this._contentWidget) === null || _a5 === void 0 ? void 0 : _a5.isColorPickerVisible()) || false;
  }
  showContentHover(range, mode, focus) {
    this._getOrCreateContentWidget().startShowingAtRange(range, mode, focus);
  }
  dispose() {
    var _a5, _b2;
    this._unhookEvents();
    this._toUnhook.dispose();
    this._didChangeConfigurationHandler.dispose();
    (_a5 = this._glyphWidget) === null || _a5 === void 0 ? void 0 : _a5.dispose();
    (_b2 = this._contentWidget) === null || _b2 === void 0 ? void 0 : _b2.dispose();
  }
};
ModesHoverController.ID = "editor.contrib.hover";
ModesHoverController = __decorate44([
  __param44(1, IInstantiationService),
  __param44(2, IOpenerService),
  __param44(3, IModeService),
  __param44(4, IContextKeyService)
], ModesHoverController);
var ShowHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showHover",
      label: localize({
        key: "showHover",
        comment: [
          "Label for action that will trigger the showing of a hover in the editor.",
          "This allows for users to show the hover without using the mouse."
        ]
      }, "Show Hover"),
      alias: "Show Hover",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 39),
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    let controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    const position = editor2.getPosition();
    const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
    const focus = editor2.getOption(2) === 2;
    controller.showContentHover(range, 1, focus);
  }
};
var ShowDefinitionPreviewHoverAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showDefinitionPreviewHover",
      label: localize({
        key: "showDefinitionPreviewHover",
        comment: [
          "Label for action that will trigger the showing of definition preview hover in the editor.",
          "This allows for users to show the definition preview hover without using the mouse."
        ]
      }, "Show Definition Preview Hover"),
      alias: "Show Definition Preview Hover",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    let controller = ModesHoverController.get(editor2);
    if (!controller) {
      return;
    }
    const position = editor2.getPosition();
    if (!position) {
      return;
    }
    const range = new Range(position.lineNumber, position.column, position.lineNumber, position.column);
    const goto = GotoDefinitionAtPositionEditorContribution.get(editor2);
    const promise = goto.startFindDefinitionFromCursor(position);
    promise.then(() => {
      controller.showContentHover(range, 1, true);
    });
  }
};
registerEditorContribution(ModesHoverController.ID, ModesHoverController);
registerEditorAction(ShowHoverAction);
registerEditorAction(ShowDefinitionPreviewHoverAction);
registerThemingParticipant((theme, collector) => {
  const editorHoverHighlightColor = theme.getColor(editorHoverHighlight);
  if (editorHoverHighlightColor) {
    collector.addRule(`.monaco-editor .hoverHighlight { background-color: ${editorHoverHighlightColor}; }`);
  }
  const hoverBackground = theme.getColor(editorHoverBackground);
  if (hoverBackground) {
    collector.addRule(`.monaco-editor .monaco-hover { background-color: ${hoverBackground}; }`);
  }
  const hoverBorder = theme.getColor(editorHoverBorder);
  if (hoverBorder) {
    collector.addRule(`.monaco-editor .monaco-hover { border: 1px solid ${hoverBorder}; }`);
    collector.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${hoverBorder.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${hoverBorder.transparent(0.5)}; }`);
  }
  const link = theme.getColor(textLinkForeground);
  if (link) {
    collector.addRule(`.monaco-editor .monaco-hover a { color: ${link}; }`);
  }
  const linkHover = theme.getColor(textLinkActiveForeground);
  if (linkHover) {
    collector.addRule(`.monaco-editor .monaco-hover a:hover { color: ${linkHover}; }`);
  }
  const hoverForeground = theme.getColor(editorHoverForeground);
  if (hoverForeground) {
    collector.addRule(`.monaco-editor .monaco-hover { color: ${hoverForeground}; }`);
  }
  const actionsBackground = theme.getColor(editorHoverStatusBarBackground);
  if (actionsBackground) {
    collector.addRule(`.monaco-editor .monaco-hover .hover-row .actions { background-color: ${actionsBackground}; }`);
  }
  const codeBackground = theme.getColor(textCodeBlockBackground);
  if (codeBackground) {
    collector.addRule(`.monaco-editor .monaco-hover code { background-color: ${codeBackground}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/colorPicker/colorContributions.js
var ColorContribution = class extends Disposable {
  constructor(_editor) {
    super();
    this._editor = _editor;
    this._register(_editor.onMouseDown((e) => this.onMouseDown(e)));
  }
  dispose() {
    super.dispose();
  }
  onMouseDown(mouseEvent) {
    var _a5;
    const targetType = mouseEvent.target.type;
    if (targetType !== 6) {
      return;
    }
    const hoverOnColorDecorator = [...((_a5 = mouseEvent.target.element) === null || _a5 === void 0 ? void 0 : _a5.classList.values()) || []].find((className) => className.startsWith("ced-colorBox"));
    if (!hoverOnColorDecorator) {
      return;
    }
    if (!mouseEvent.target.range) {
      return;
    }
    const hoverController = this._editor.getContribution(ModesHoverController.ID);
    if (!hoverController.isColorPickerVisible()) {
      const range = new Range(mouseEvent.target.range.startLineNumber, mouseEvent.target.range.startColumn + 1, mouseEvent.target.range.endLineNumber, mouseEvent.target.range.endColumn + 1);
      hoverController.showContentHover(range, 0, false);
    }
  }
};
ColorContribution.ID = "editor.contrib.colorContribution";
registerEditorContribution(ColorContribution.ID, ColorContribution);

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/blockCommentCommand.js
var BlockCommentCommand = class {
  constructor(selection, insertSpace) {
    this._selection = selection;
    this._insertSpace = insertSpace;
    this._usedEndToken = null;
  }
  static _haystackHasNeedleAtOffset(haystack, needle, offset) {
    if (offset < 0) {
      return false;
    }
    const needleLength = needle.length;
    const haystackLength = haystack.length;
    if (offset + needleLength > haystackLength) {
      return false;
    }
    for (let i = 0; i < needleLength; i++) {
      const codeA = haystack.charCodeAt(offset + i);
      const codeB = needle.charCodeAt(i);
      if (codeA === codeB) {
        continue;
      }
      if (codeA >= 65 && codeA <= 90 && codeA + 32 === codeB) {
        continue;
      }
      if (codeB >= 65 && codeB <= 90 && codeB + 32 === codeA) {
        continue;
      }
      return false;
    }
    return true;
  }
  _createOperationsForBlockComment(selection, startToken, endToken, insertSpace, model, builder) {
    const startLineNumber = selection.startLineNumber;
    const startColumn = selection.startColumn;
    const endLineNumber = selection.endLineNumber;
    const endColumn = selection.endColumn;
    const startLineText = model.getLineContent(startLineNumber);
    const endLineText = model.getLineContent(endLineNumber);
    let startTokenIndex = startLineText.lastIndexOf(startToken, startColumn - 1 + startToken.length);
    let endTokenIndex = endLineText.indexOf(endToken, endColumn - 1 - endToken.length);
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      if (startLineNumber === endLineNumber) {
        const lineBetweenTokens = startLineText.substring(startTokenIndex + startToken.length, endTokenIndex);
        if (lineBetweenTokens.indexOf(endToken) >= 0) {
          startTokenIndex = -1;
          endTokenIndex = -1;
        }
      } else {
        const startLineAfterStartToken = startLineText.substring(startTokenIndex + startToken.length);
        const endLineBeforeEndToken = endLineText.substring(0, endTokenIndex);
        if (startLineAfterStartToken.indexOf(endToken) >= 0 || endLineBeforeEndToken.indexOf(endToken) >= 0) {
          startTokenIndex = -1;
          endTokenIndex = -1;
        }
      }
    }
    let ops;
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      if (insertSpace && startTokenIndex + startToken.length < startLineText.length && startLineText.charCodeAt(startTokenIndex + startToken.length) === 32) {
        startToken = startToken + " ";
      }
      if (insertSpace && endTokenIndex > 0 && endLineText.charCodeAt(endTokenIndex - 1) === 32) {
        endToken = " " + endToken;
        endTokenIndex -= 1;
      }
      ops = BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
    } else {
      ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken, this._insertSpace);
      this._usedEndToken = ops.length === 1 ? endToken : null;
    }
    for (const op of ops) {
      builder.addTrackedEditOperation(op.range, op.text);
    }
  }
  static _createRemoveBlockCommentOperations(r, startToken, endToken) {
    let res = [];
    if (!Range.isEmpty(r)) {
      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));
      res.push(EditOperation.delete(new Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));
    } else {
      res.push(EditOperation.delete(new Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));
    }
    return res;
  }
  static _createAddBlockCommentOperations(r, startToken, endToken, insertSpace) {
    let res = [];
    if (!Range.isEmpty(r)) {
      res.push(EditOperation.insert(new Position(r.startLineNumber, r.startColumn), startToken + (insertSpace ? " " : "")));
      res.push(EditOperation.insert(new Position(r.endLineNumber, r.endColumn), (insertSpace ? " " : "") + endToken));
    } else {
      res.push(EditOperation.replace(new Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + "  " + endToken));
    }
    return res;
  }
  getEditOperations(model, builder) {
    const startLineNumber = this._selection.startLineNumber;
    const startColumn = this._selection.startColumn;
    model.tokenizeIfCheap(startLineNumber);
    const languageId = model.getLanguageIdAtPosition(startLineNumber, startColumn);
    const config = LanguageConfigurationRegistry.getComments(languageId);
    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
      return;
    }
    this._createOperationsForBlockComment(this._selection, config.blockCommentStartToken, config.blockCommentEndToken, this._insertSpace, model, builder);
  }
  computeCursorState(model, helper) {
    const inverseEditOperations = helper.getInverseEditOperations();
    if (inverseEditOperations.length === 2) {
      const startTokenEditOperation = inverseEditOperations[0];
      const endTokenEditOperation = inverseEditOperations[1];
      return new Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);
    } else {
      const srcRange = inverseEditOperations[0].range;
      const deltaColumn = this._usedEndToken ? -this._usedEndToken.length - 1 : 0;
      return new Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/lineCommentCommand.js
var LineCommentCommand = class {
  constructor(selection, tabSize, type, insertSpace, ignoreEmptyLines, ignoreFirstLine) {
    this._selection = selection;
    this._tabSize = tabSize;
    this._type = type;
    this._insertSpace = insertSpace;
    this._selectionId = null;
    this._deltaColumn = 0;
    this._moveEndPositionDown = false;
    this._ignoreEmptyLines = ignoreEmptyLines;
    this._ignoreFirstLine = ignoreFirstLine || false;
  }
  static _gatherPreflightCommentStrings(model, startLineNumber, endLineNumber) {
    model.tokenizeIfCheap(startLineNumber);
    const languageId = model.getLanguageIdAtPosition(startLineNumber, 1);
    const config = LanguageConfigurationRegistry.getComments(languageId);
    const commentStr = config ? config.lineCommentToken : null;
    if (!commentStr) {
      return null;
    }
    let lines = [];
    for (let i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {
      lines[i] = {
        ignore: false,
        commentStr,
        commentStrOffset: 0,
        commentStrLength: commentStr.length
      };
    }
    return lines;
  }
  static _analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine) {
    let onlyWhitespaceLines = true;
    let shouldRemoveComments;
    if (type === 0) {
      shouldRemoveComments = true;
    } else if (type === 1) {
      shouldRemoveComments = false;
    } else {
      shouldRemoveComments = true;
    }
    for (let i = 0, lineCount = lines.length; i < lineCount; i++) {
      const lineData = lines[i];
      const lineNumber = startLineNumber + i;
      if (lineNumber === startLineNumber && ignoreFirstLine) {
        lineData.ignore = true;
        continue;
      }
      const lineContent = model.getLineContent(lineNumber);
      const lineContentStartOffset = firstNonWhitespaceIndex(lineContent);
      if (lineContentStartOffset === -1) {
        lineData.ignore = ignoreEmptyLines;
        lineData.commentStrOffset = lineContent.length;
        continue;
      }
      onlyWhitespaceLines = false;
      lineData.ignore = false;
      lineData.commentStrOffset = lineContentStartOffset;
      if (shouldRemoveComments && !BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {
        if (type === 0) {
          shouldRemoveComments = false;
        } else if (type === 1) {
        } else {
          lineData.ignore = true;
        }
      }
      if (shouldRemoveComments && insertSpace) {
        const commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;
        if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === 32) {
          lineData.commentStrLength += 1;
        }
      }
    }
    if (type === 0 && onlyWhitespaceLines) {
      shouldRemoveComments = false;
      for (let i = 0, lineCount = lines.length; i < lineCount; i++) {
        lines[i].ignore = false;
      }
    }
    return {
      supported: true,
      shouldRemoveComments,
      lines
    };
  }
  static _gatherPreflightData(type, insertSpace, model, startLineNumber, endLineNumber, ignoreEmptyLines, ignoreFirstLine) {
    const lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);
    if (lines === null) {
      return {
        supported: false
      };
    }
    return LineCommentCommand._analyzeLines(type, insertSpace, model, lines, startLineNumber, ignoreEmptyLines, ignoreFirstLine);
  }
  _executeLineComments(model, builder, data, s) {
    let ops;
    if (data.shouldRemoveComments) {
      ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);
    } else {
      LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);
      ops = this._createAddLineCommentsOperations(data.lines, s.startLineNumber);
    }
    const cursorPosition = new Position(s.positionLineNumber, s.positionColumn);
    for (let i = 0, len = ops.length; i < len; i++) {
      builder.addEditOperation(ops[i].range, ops[i].text);
      if (Range.isEmpty(ops[i].range) && Range.getStartPosition(ops[i].range).equals(cursorPosition)) {
        const lineContent = model.getLineContent(cursorPosition.lineNumber);
        if (lineContent.length + 1 === cursorPosition.column) {
          this._deltaColumn = (ops[i].text || "").length;
        }
      }
    }
    this._selectionId = builder.trackSelection(s);
  }
  _attemptRemoveBlockComment(model, s, startToken, endToken) {
    let startLineNumber = s.startLineNumber;
    let endLineNumber = s.endLineNumber;
    let startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);
    let startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);
    let endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);
    if (startTokenIndex !== -1 && endTokenIndex === -1) {
      endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
      endLineNumber = startLineNumber;
    }
    if (startTokenIndex === -1 && endTokenIndex !== -1) {
      startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);
      startLineNumber = endLineNumber;
    }
    if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {
      startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);
      if (startTokenIndex !== -1) {
        endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
      }
    }
    if (startTokenIndex !== -1 && model.getLineContent(startLineNumber).charCodeAt(startTokenIndex + startToken.length) === 32) {
      startToken += " ";
    }
    if (endTokenIndex !== -1 && model.getLineContent(endLineNumber).charCodeAt(endTokenIndex - 1) === 32) {
      endToken = " " + endToken;
      endTokenIndex -= 1;
    }
    if (startTokenIndex !== -1 && endTokenIndex !== -1) {
      return BlockCommentCommand._createRemoveBlockCommentOperations(new Range(startLineNumber, startTokenIndex + startToken.length + 1, endLineNumber, endTokenIndex + 1), startToken, endToken);
    }
    return null;
  }
  _executeBlockComment(model, builder, s) {
    model.tokenizeIfCheap(s.startLineNumber);
    let languageId = model.getLanguageIdAtPosition(s.startLineNumber, 1);
    let config = LanguageConfigurationRegistry.getComments(languageId);
    if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
      return;
    }
    const startToken = config.blockCommentStartToken;
    const endToken = config.blockCommentEndToken;
    let ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);
    if (!ops) {
      if (s.isEmpty()) {
        const lineContent = model.getLineContent(s.startLineNumber);
        let firstNonWhitespaceIndex2 = firstNonWhitespaceIndex(lineContent);
        if (firstNonWhitespaceIndex2 === -1) {
          firstNonWhitespaceIndex2 = lineContent.length;
        }
        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, firstNonWhitespaceIndex2 + 1, s.startLineNumber, lineContent.length + 1), startToken, endToken, this._insertSpace);
      } else {
        ops = BlockCommentCommand._createAddBlockCommentOperations(new Range(s.startLineNumber, model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), startToken, endToken, this._insertSpace);
      }
      if (ops.length === 1) {
        this._deltaColumn = startToken.length + 1;
      }
    }
    this._selectionId = builder.trackSelection(s);
    for (const op of ops) {
      builder.addEditOperation(op.range, op.text);
    }
  }
  getEditOperations(model, builder) {
    let s = this._selection;
    this._moveEndPositionDown = false;
    if (s.startLineNumber === s.endLineNumber && this._ignoreFirstLine) {
      builder.addEditOperation(new Range(s.startLineNumber, model.getLineMaxColumn(s.startLineNumber), s.startLineNumber + 1, 1), s.startLineNumber === model.getLineCount() ? "" : "\n");
      this._selectionId = builder.trackSelection(s);
      return;
    }
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._moveEndPositionDown = true;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const data = LineCommentCommand._gatherPreflightData(this._type, this._insertSpace, model, s.startLineNumber, s.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine);
    if (data.supported) {
      return this._executeLineComments(model, builder, data, s);
    }
    return this._executeBlockComment(model, builder, s);
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._moveEndPositionDown) {
      result = result.setEndPosition(result.endLineNumber + 1, 1);
    }
    return new Selection(result.selectionStartLineNumber, result.selectionStartColumn + this._deltaColumn, result.positionLineNumber, result.positionColumn + this._deltaColumn);
  }
  static _createRemoveLineCommentsOperations(lines, startLineNumber) {
    let res = [];
    for (let i = 0, len = lines.length; i < len; i++) {
      const lineData = lines[i];
      if (lineData.ignore) {
        continue;
      }
      res.push(EditOperation.delete(new Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));
    }
    return res;
  }
  _createAddLineCommentsOperations(lines, startLineNumber) {
    let res = [];
    const afterCommentStr = this._insertSpace ? " " : "";
    for (let i = 0, len = lines.length; i < len; i++) {
      const lineData = lines[i];
      if (lineData.ignore) {
        continue;
      }
      res.push(EditOperation.insert(new Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + afterCommentStr));
    }
    return res;
  }
  static nextVisibleColumn(currentVisibleColumn, tabSize, isTab, columnSize) {
    if (isTab) {
      return currentVisibleColumn + (tabSize - currentVisibleColumn % tabSize);
    }
    return currentVisibleColumn + columnSize;
  }
  static _normalizeInsertionPoint(model, lines, startLineNumber, tabSize) {
    let minVisibleColumn = 1073741824;
    let j;
    let lenJ;
    for (let i = 0, len = lines.length; i < len; i++) {
      if (lines[i].ignore) {
        continue;
      }
      const lineContent = model.getLineContent(startLineNumber + i);
      let currentVisibleColumn = 0;
      for (let j2 = 0, lenJ2 = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j2 < lenJ2; j2++) {
        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j2) === 9, 1);
      }
      if (currentVisibleColumn < minVisibleColumn) {
        minVisibleColumn = currentVisibleColumn;
      }
    }
    minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;
    for (let i = 0, len = lines.length; i < len; i++) {
      if (lines[i].ignore) {
        continue;
      }
      const lineContent = model.getLineContent(startLineNumber + i);
      let currentVisibleColumn = 0;
      for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {
        currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === 9, 1);
      }
      if (currentVisibleColumn > minVisibleColumn) {
        lines[i].commentStrOffset = j - 1;
      } else {
        lines[i].commentStrOffset = j;
      }
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/comment/comment.js
var CommentLineAction = class extends EditorAction {
  constructor(type, opts) {
    super(opts);
    this._type = type;
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const commands = [];
    const modelOptions = model.getOptions();
    const commentsOptions = editor2.getOption(19);
    const selections = editor2.getSelections().map((selection, index) => ({ selection, index, ignoreFirstLine: false }));
    selections.sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
    let prev = selections[0];
    for (let i = 1; i < selections.length; i++) {
      const curr = selections[i];
      if (prev.selection.endLineNumber === curr.selection.startLineNumber) {
        if (prev.index < curr.index) {
          curr.ignoreFirstLine = true;
        } else {
          prev.ignoreFirstLine = true;
          prev = curr;
        }
      }
    }
    for (const selection of selections) {
      commands.push(new LineCommentCommand(selection.selection, modelOptions.tabSize, this._type, commentsOptions.insertSpace, commentsOptions.ignoreEmptyLines, selection.ignoreFirstLine));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var ToggleCommentLineAction = class extends CommentLineAction {
  constructor() {
    super(0, {
      id: "editor.action.commentLine",
      label: localize("comment.line", "Toggle Line Comment"),
      alias: "Toggle Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 85,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "5_insert",
        title: localize({ key: "miToggleLineComment", comment: ["&& denotes a mnemonic"] }, "&&Toggle Line Comment"),
        order: 1
      }
    });
  }
};
var AddLineCommentAction = class extends CommentLineAction {
  constructor() {
    super(1, {
      id: "editor.action.addCommentLine",
      label: localize("comment.line.add", "Add Line Comment"),
      alias: "Add Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 33),
        weight: 100
      }
    });
  }
};
var RemoveLineCommentAction = class extends CommentLineAction {
  constructor() {
    super(2, {
      id: "editor.action.removeCommentLine",
      label: localize("comment.line.remove", "Remove Line Comment"),
      alias: "Remove Line Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 51),
        weight: 100
      }
    });
  }
};
var BlockCommentAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.blockComment",
      label: localize("comment.block", "Toggle Block Comment"),
      alias: "Toggle Block Comment",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 31,
        linux: { primary: 2048 | 1024 | 31 },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarEditMenu,
        group: "5_insert",
        title: localize({ key: "miToggleBlockComment", comment: ["&& denotes a mnemonic"] }, "Toggle &&Block Comment"),
        order: 2
      }
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const commentsOptions = editor2.getOption(19);
    const commands = [];
    const selections = editor2.getSelections();
    for (const selection of selections) {
      commands.push(new BlockCommentCommand(selection, commentsOptions.insertSpace));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
registerEditorAction(ToggleCommentLineAction);
registerEditorAction(AddLineCommentAction);
registerEditorAction(RemoveLineCommentAction);
registerEditorAction(BlockCommentAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/contextmenu/contextmenu.js
var __decorate45 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param45 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ContextMenuController = class ContextMenuController2 {
  constructor(editor2, _contextMenuService, _contextViewService, _contextKeyService, _keybindingService, _menuService) {
    this._contextMenuService = _contextMenuService;
    this._contextViewService = _contextViewService;
    this._contextKeyService = _contextKeyService;
    this._keybindingService = _keybindingService;
    this._menuService = _menuService;
    this._toDispose = new DisposableStore();
    this._contextMenuIsBeingShownCount = 0;
    this._editor = editor2;
    this._toDispose.add(this._editor.onContextMenu((e) => this._onContextMenu(e)));
    this._toDispose.add(this._editor.onMouseWheel((e) => {
      if (this._contextMenuIsBeingShownCount > 0) {
        const view = this._contextViewService.getContextViewElement();
        const target = e.srcElement;
        if (!(target.shadowRoot && getShadowRoot(view) === target.shadowRoot)) {
          this._contextViewService.hideContextView();
        }
      }
    }));
    this._toDispose.add(this._editor.onKeyDown((e) => {
      if (e.keyCode === 58) {
        e.preventDefault();
        e.stopPropagation();
        this.showContextMenu();
      }
    }));
  }
  static get(editor2) {
    return editor2.getContribution(ContextMenuController2.ID);
  }
  _onContextMenu(e) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._editor.getOption(20)) {
      this._editor.focus();
      if (e.target.position && !this._editor.getSelection().containsPosition(e.target.position)) {
        this._editor.setPosition(e.target.position);
      }
      return;
    }
    if (e.target.type === 12) {
      return;
    }
    e.event.preventDefault();
    e.event.stopPropagation();
    if (e.target.type !== 6 && e.target.type !== 7 && e.target.type !== 1) {
      return;
    }
    this._editor.focus();
    if (e.target.position) {
      let hasSelectionAtPosition = false;
      for (const selection of this._editor.getSelections()) {
        if (selection.containsPosition(e.target.position)) {
          hasSelectionAtPosition = true;
          break;
        }
      }
      if (!hasSelectionAtPosition) {
        this._editor.setPosition(e.target.position);
      }
    }
    let anchor = null;
    if (e.target.type !== 1) {
      anchor = { x: e.event.posx - 1, width: 2, y: e.event.posy - 1, height: 2 };
    }
    this.showContextMenu(anchor);
  }
  showContextMenu(anchor) {
    if (!this._editor.getOption(20)) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._contextMenuService) {
      this._editor.focus();
      return;
    }
    const menuActions = this._getMenuActions(this._editor.getModel(), this._editor.isSimpleWidget ? MenuId.SimpleEditorContext : MenuId.EditorContext);
    if (menuActions.length > 0) {
      this._doShowContextMenu(menuActions, anchor);
    }
  }
  _getMenuActions(model, menuId) {
    const result = [];
    const menu = this._menuService.createMenu(menuId, this._contextKeyService);
    const groups = menu.getActions({ arg: model.uri });
    menu.dispose();
    for (let group of groups) {
      const [, actions] = group;
      let addedItems = 0;
      for (const action of actions) {
        if (action instanceof SubmenuItemAction) {
          const subActions = this._getMenuActions(model, action.item.submenu);
          if (subActions.length > 0) {
            result.push(new SubmenuAction(action.id, action.label, subActions));
            addedItems++;
          }
        } else {
          result.push(action);
          addedItems++;
        }
      }
      if (addedItems) {
        result.push(new Separator());
      }
    }
    if (result.length) {
      result.pop();
    }
    return result;
  }
  _doShowContextMenu(actions, anchor = null) {
    if (!this._editor.hasModel()) {
      return;
    }
    const oldHoverSetting = this._editor.getOption(52);
    this._editor.updateOptions({
      hover: {
        enabled: false
      }
    });
    if (!anchor) {
      this._editor.revealPosition(this._editor.getPosition(), 1);
      this._editor.render();
      const cursorCoords = this._editor.getScrolledVisiblePosition(this._editor.getPosition());
      const editorCoords = getDomNodePagePosition(this._editor.getDomNode());
      const posx = editorCoords.left + cursorCoords.left;
      const posy = editorCoords.top + cursorCoords.top + cursorCoords.height;
      anchor = { x: posx, y: posy };
    }
    const useShadowDOM = this._editor.getOption(114) && !isIOS;
    this._contextMenuIsBeingShownCount++;
    this._contextMenuService.showContextMenu({
      domForShadowRoot: useShadowDOM ? this._editor.getDomNode() : void 0,
      getAnchor: () => anchor,
      getActions: () => actions,
      getActionViewItem: (action) => {
        const keybinding = this._keybindingFor(action);
        if (keybinding) {
          return new ActionViewItem(action, action, { label: true, keybinding: keybinding.getLabel(), isMenu: true });
        }
        const customActionViewItem = action;
        if (typeof customActionViewItem.getActionViewItem === "function") {
          return customActionViewItem.getActionViewItem();
        }
        return new ActionViewItem(action, action, { icon: true, label: true, isMenu: true });
      },
      getKeyBinding: (action) => {
        return this._keybindingFor(action);
      },
      onHide: (wasCancelled) => {
        this._contextMenuIsBeingShownCount--;
        this._editor.focus();
        this._editor.updateOptions({
          hover: oldHoverSetting
        });
      }
    });
  }
  _keybindingFor(action) {
    return this._keybindingService.lookupKeybinding(action.id);
  }
  dispose() {
    if (this._contextMenuIsBeingShownCount > 0) {
      this._contextViewService.hideContextView();
    }
    this._toDispose.dispose();
  }
};
ContextMenuController.ID = "editor.contrib.contextmenu";
ContextMenuController = __decorate45([
  __param45(1, IContextMenuService),
  __param45(2, IContextViewService),
  __param45(3, IContextKeyService),
  __param45(4, IKeybindingService),
  __param45(5, IMenuService)
], ContextMenuController);
var ShowContextMenu = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showContextMenu",
      label: localize("action.showContextMenu.label", "Show Editor Context Menu"),
      alias: "Show Editor Context Menu",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 1024 | 68,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    let contribution = ContextMenuController.get(editor2);
    contribution.showContextMenu();
  }
};
registerEditorContribution(ContextMenuController.ID, ContextMenuController);
registerEditorAction(ShowContextMenu);

// node_modules/monaco-editor/esm/vs/editor/contrib/cursorUndo/cursorUndo.js
var CursorState2 = class {
  constructor(selections) {
    this.selections = selections;
  }
  equals(other) {
    const thisLen = this.selections.length;
    const otherLen = other.selections.length;
    if (thisLen !== otherLen) {
      return false;
    }
    for (let i = 0; i < thisLen; i++) {
      if (!this.selections[i].equalsSelection(other.selections[i])) {
        return false;
      }
    }
    return true;
  }
};
var StackElement = class {
  constructor(cursorState, scrollTop, scrollLeft) {
    this.cursorState = cursorState;
    this.scrollTop = scrollTop;
    this.scrollLeft = scrollLeft;
  }
};
var CursorUndoRedoController = class extends Disposable {
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._isCursorUndoRedo = false;
    this._undoStack = [];
    this._redoStack = [];
    this._register(editor2.onDidChangeModel((e) => {
      this._undoStack = [];
      this._redoStack = [];
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      this._undoStack = [];
      this._redoStack = [];
    }));
    this._register(editor2.onDidChangeCursorSelection((e) => {
      if (this._isCursorUndoRedo) {
        return;
      }
      if (!e.oldSelections) {
        return;
      }
      if (e.oldModelVersionId !== e.modelVersionId) {
        return;
      }
      const prevState = new CursorState2(e.oldSelections);
      const isEqualToLastUndoStack = this._undoStack.length > 0 && this._undoStack[this._undoStack.length - 1].cursorState.equals(prevState);
      if (!isEqualToLastUndoStack) {
        this._undoStack.push(new StackElement(prevState, editor2.getScrollTop(), editor2.getScrollLeft()));
        this._redoStack = [];
        if (this._undoStack.length > 50) {
          this._undoStack.shift();
        }
      }
    }));
  }
  static get(editor2) {
    return editor2.getContribution(CursorUndoRedoController.ID);
  }
  cursorUndo() {
    if (!this._editor.hasModel() || this._undoStack.length === 0) {
      return;
    }
    this._redoStack.push(new StackElement(new CursorState2(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
    this._applyState(this._undoStack.pop());
  }
  cursorRedo() {
    if (!this._editor.hasModel() || this._redoStack.length === 0) {
      return;
    }
    this._undoStack.push(new StackElement(new CursorState2(this._editor.getSelections()), this._editor.getScrollTop(), this._editor.getScrollLeft()));
    this._applyState(this._redoStack.pop());
  }
  _applyState(stackElement) {
    this._isCursorUndoRedo = true;
    this._editor.setSelections(stackElement.cursorState.selections);
    this._editor.setScrollPosition({
      scrollTop: stackElement.scrollTop,
      scrollLeft: stackElement.scrollLeft
    });
    this._isCursorUndoRedo = false;
  }
};
CursorUndoRedoController.ID = "editor.contrib.cursorUndoRedoController";
var CursorUndo = class extends EditorAction {
  constructor() {
    super({
      id: "cursorUndo",
      label: localize("cursor.undo", "Cursor Undo"),
      alias: "Cursor Undo",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 51,
        weight: 100
      }
    });
  }
  run(accessor, editor2, args) {
    CursorUndoRedoController.get(editor2).cursorUndo();
  }
};
var CursorRedo = class extends EditorAction {
  constructor() {
    super({
      id: "cursorRedo",
      label: localize("cursor.redo", "Cursor Redo"),
      alias: "Cursor Redo",
      precondition: void 0
    });
  }
  run(accessor, editor2, args) {
    CursorUndoRedoController.get(editor2).cursorRedo();
  }
};
registerEditorContribution(CursorUndoRedoController.ID, CursorUndoRedoController);
registerEditorAction(CursorUndo);
registerEditorAction(CursorRedo);

// node_modules/monaco-editor/esm/vs/editor/contrib/dnd/dnd.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/dnd/dnd.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/dnd/dragAndDropCommand.js
var DragAndDropCommand = class {
  constructor(selection, targetPosition, copy) {
    this.selection = selection;
    this.targetPosition = targetPosition;
    this.copy = copy;
    this.targetSelection = null;
  }
  getEditOperations(model, builder) {
    let text2 = model.getValueInRange(this.selection);
    if (!this.copy) {
      builder.addEditOperation(this.selection, null);
    }
    builder.addEditOperation(new Range(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column), text2);
    if (this.selection.containsPosition(this.targetPosition) && !(this.copy && (this.selection.getEndPosition().equals(this.targetPosition) || this.selection.getStartPosition().equals(this.targetPosition)))) {
      this.targetSelection = this.selection;
      return;
    }
    if (this.copy) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.selection.endLineNumber - this.selection.startLineNumber + this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber > this.selection.endLineNumber) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.targetPosition.lineNumber < this.selection.endLineNumber) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber, this.targetPosition.column, this.targetPosition.lineNumber + this.selection.endLineNumber - this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column + this.selection.endColumn - this.selection.startColumn : this.selection.endColumn);
      return;
    }
    if (this.selection.endColumn <= this.targetPosition.column) {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column - this.selection.endColumn + this.selection.startColumn : this.targetPosition.column - this.selection.endColumn + this.selection.startColumn, this.targetPosition.lineNumber, this.selection.startLineNumber === this.selection.endLineNumber ? this.targetPosition.column : this.selection.endColumn);
    } else {
      this.targetSelection = new Selection(this.targetPosition.lineNumber - this.selection.endLineNumber + this.selection.startLineNumber, this.targetPosition.column, this.targetPosition.lineNumber, this.targetPosition.column + this.selection.endColumn - this.selection.startColumn);
    }
  }
  computeCursorState(model, helper) {
    return this.targetSelection;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/dnd/dnd.js
function hasTriggerModifier(e) {
  if (isMacintosh) {
    return e.altKey;
  } else {
    return e.ctrlKey;
  }
}
var DragAndDropController = class extends Disposable {
  constructor(editor2) {
    super();
    this._editor = editor2;
    this._register(this._editor.onMouseDown((e) => this._onEditorMouseDown(e)));
    this._register(this._editor.onMouseUp((e) => this._onEditorMouseUp(e)));
    this._register(this._editor.onMouseDrag((e) => this._onEditorMouseDrag(e)));
    this._register(this._editor.onMouseDrop((e) => this._onEditorMouseDrop(e)));
    this._register(this._editor.onMouseDropCanceled(() => this._onEditorMouseDropCanceled()));
    this._register(this._editor.onKeyDown((e) => this.onEditorKeyDown(e)));
    this._register(this._editor.onKeyUp((e) => this.onEditorKeyUp(e)));
    this._register(this._editor.onDidBlurEditorWidget(() => this.onEditorBlur()));
    this._register(this._editor.onDidBlurEditorText(() => this.onEditorBlur()));
    this._dndDecorationIds = [];
    this._mouseDown = false;
    this._modifierPressed = false;
    this._dragSelection = null;
  }
  onEditorBlur() {
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
    this._modifierPressed = false;
  }
  onEditorKeyDown(e) {
    if (!this._editor.getOption(31) || this._editor.getOption(18)) {
      return;
    }
    if (hasTriggerModifier(e)) {
      this._modifierPressed = true;
    }
    if (this._mouseDown && hasTriggerModifier(e)) {
      this._editor.updateOptions({
        mouseStyle: "copy"
      });
    }
  }
  onEditorKeyUp(e) {
    if (!this._editor.getOption(31) || this._editor.getOption(18)) {
      return;
    }
    if (hasTriggerModifier(e)) {
      this._modifierPressed = false;
    }
    if (this._mouseDown && e.keyCode === DragAndDropController.TRIGGER_KEY_VALUE) {
      this._editor.updateOptions({
        mouseStyle: "default"
      });
    }
  }
  _onEditorMouseDown(mouseEvent) {
    this._mouseDown = true;
  }
  _onEditorMouseUp(mouseEvent) {
    this._mouseDown = false;
    this._editor.updateOptions({
      mouseStyle: "text"
    });
  }
  _onEditorMouseDrag(mouseEvent) {
    let target = mouseEvent.target;
    if (this._dragSelection === null) {
      const selections = this._editor.getSelections() || [];
      let possibleSelections = selections.filter((selection) => target.position && selection.containsPosition(target.position));
      if (possibleSelections.length === 1) {
        this._dragSelection = possibleSelections[0];
      } else {
        return;
      }
    }
    if (hasTriggerModifier(mouseEvent.event)) {
      this._editor.updateOptions({
        mouseStyle: "copy"
      });
    } else {
      this._editor.updateOptions({
        mouseStyle: "default"
      });
    }
    if (target.position) {
      if (this._dragSelection.containsPosition(target.position)) {
        this._removeDecoration();
      } else {
        this.showAt(target.position);
      }
    }
  }
  _onEditorMouseDropCanceled() {
    this._editor.updateOptions({
      mouseStyle: "text"
    });
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
  }
  _onEditorMouseDrop(mouseEvent) {
    if (mouseEvent.target && (this._hitContent(mouseEvent.target) || this._hitMargin(mouseEvent.target)) && mouseEvent.target.position) {
      let newCursorPosition = new Position(mouseEvent.target.position.lineNumber, mouseEvent.target.position.column);
      if (this._dragSelection === null) {
        let newSelections = null;
        if (mouseEvent.event.shiftKey) {
          let primarySelection = this._editor.getSelection();
          if (primarySelection) {
            const { selectionStartLineNumber, selectionStartColumn } = primarySelection;
            newSelections = [new Selection(selectionStartLineNumber, selectionStartColumn, newCursorPosition.lineNumber, newCursorPosition.column)];
          }
        } else {
          newSelections = (this._editor.getSelections() || []).map((selection) => {
            if (selection.containsPosition(newCursorPosition)) {
              return new Selection(newCursorPosition.lineNumber, newCursorPosition.column, newCursorPosition.lineNumber, newCursorPosition.column);
            } else {
              return selection;
            }
          });
        }
        this._editor.setSelections(newSelections || [], "mouse", 3);
      } else if (!this._dragSelection.containsPosition(newCursorPosition) || (hasTriggerModifier(mouseEvent.event) || this._modifierPressed) && (this._dragSelection.getEndPosition().equals(newCursorPosition) || this._dragSelection.getStartPosition().equals(newCursorPosition))) {
        this._editor.pushUndoStop();
        this._editor.executeCommand(DragAndDropController.ID, new DragAndDropCommand(this._dragSelection, newCursorPosition, hasTriggerModifier(mouseEvent.event) || this._modifierPressed));
        this._editor.pushUndoStop();
      }
    }
    this._editor.updateOptions({
      mouseStyle: "text"
    });
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
  }
  showAt(position) {
    let newDecorations = [{
      range: new Range(position.lineNumber, position.column, position.lineNumber, position.column),
      options: DragAndDropController._DECORATION_OPTIONS
    }];
    this._dndDecorationIds = this._editor.deltaDecorations(this._dndDecorationIds, newDecorations);
    this._editor.revealPosition(position, 1);
  }
  _removeDecoration() {
    this._dndDecorationIds = this._editor.deltaDecorations(this._dndDecorationIds, []);
  }
  _hitContent(target) {
    return target.type === 6 || target.type === 7;
  }
  _hitMargin(target) {
    return target.type === 2 || target.type === 3 || target.type === 4;
  }
  dispose() {
    this._removeDecoration();
    this._dragSelection = null;
    this._mouseDown = false;
    this._modifierPressed = false;
    super.dispose();
  }
};
DragAndDropController.ID = "editor.contrib.dragAndDrop";
DragAndDropController.TRIGGER_KEY_VALUE = isMacintosh ? 6 : 5;
DragAndDropController._DECORATION_OPTIONS = ModelDecorationOptions.register({
  description: "dnd-target",
  className: "dnd-target"
});
registerEditorContribution(DragAndDropController.ID, DragAndDropController);

// node_modules/monaco-editor/esm/vs/editor/contrib/find/findDecorations.js
var FindDecorations = class {
  constructor(editor2) {
    this._editor = editor2;
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
    this._startPosition = this._editor.getPosition();
  }
  dispose() {
    this._editor.deltaDecorations(this._allDecorations(), []);
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
  }
  reset() {
    this._decorations = [];
    this._overviewRulerApproximateDecorations = [];
    this._findScopeDecorationIds = [];
    this._rangeHighlightDecorationId = null;
    this._highlightedDecorationId = null;
  }
  getCount() {
    return this._decorations.length;
  }
  getFindScope() {
    if (this._findScopeDecorationIds[0]) {
      return this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]);
    }
    return null;
  }
  getFindScopes() {
    if (this._findScopeDecorationIds.length) {
      const scopes = this._findScopeDecorationIds.map((findScopeDecorationId) => this._editor.getModel().getDecorationRange(findScopeDecorationId)).filter((element) => !!element);
      if (scopes.length) {
        return scopes;
      }
    }
    return null;
  }
  getStartPosition() {
    return this._startPosition;
  }
  setStartPosition(newStartPosition) {
    this._startPosition = newStartPosition;
    this.setCurrentFindMatch(null);
  }
  _getDecorationIndex(decorationId) {
    const index = this._decorations.indexOf(decorationId);
    if (index >= 0) {
      return index + 1;
    }
    return 1;
  }
  getCurrentMatchesPosition(desiredRange) {
    let candidates = this._editor.getModel().getDecorationsInRange(desiredRange);
    for (const candidate of candidates) {
      const candidateOpts = candidate.options;
      if (candidateOpts === FindDecorations._FIND_MATCH_DECORATION || candidateOpts === FindDecorations._CURRENT_FIND_MATCH_DECORATION) {
        return this._getDecorationIndex(candidate.id);
      }
    }
    return 0;
  }
  setCurrentFindMatch(nextMatch) {
    let newCurrentDecorationId = null;
    let matchPosition = 0;
    if (nextMatch) {
      for (let i = 0, len = this._decorations.length; i < len; i++) {
        let range = this._editor.getModel().getDecorationRange(this._decorations[i]);
        if (nextMatch.equalsRange(range)) {
          newCurrentDecorationId = this._decorations[i];
          matchPosition = i + 1;
          break;
        }
      }
    }
    if (this._highlightedDecorationId !== null || newCurrentDecorationId !== null) {
      this._editor.changeDecorations((changeAccessor) => {
        if (this._highlightedDecorationId !== null) {
          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._FIND_MATCH_DECORATION);
          this._highlightedDecorationId = null;
        }
        if (newCurrentDecorationId !== null) {
          this._highlightedDecorationId = newCurrentDecorationId;
          changeAccessor.changeDecorationOptions(this._highlightedDecorationId, FindDecorations._CURRENT_FIND_MATCH_DECORATION);
        }
        if (this._rangeHighlightDecorationId !== null) {
          changeAccessor.removeDecoration(this._rangeHighlightDecorationId);
          this._rangeHighlightDecorationId = null;
        }
        if (newCurrentDecorationId !== null) {
          let rng = this._editor.getModel().getDecorationRange(newCurrentDecorationId);
          if (rng.startLineNumber !== rng.endLineNumber && rng.endColumn === 1) {
            let lineBeforeEnd = rng.endLineNumber - 1;
            let lineBeforeEndMaxColumn = this._editor.getModel().getLineMaxColumn(lineBeforeEnd);
            rng = new Range(rng.startLineNumber, rng.startColumn, lineBeforeEnd, lineBeforeEndMaxColumn);
          }
          this._rangeHighlightDecorationId = changeAccessor.addDecoration(rng, FindDecorations._RANGE_HIGHLIGHT_DECORATION);
        }
      });
    }
    return matchPosition;
  }
  set(findMatches, findScopes) {
    this._editor.changeDecorations((accessor) => {
      let findMatchesOptions = FindDecorations._FIND_MATCH_DECORATION;
      let newOverviewRulerApproximateDecorations = [];
      if (findMatches.length > 1e3) {
        findMatchesOptions = FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION;
        const lineCount = this._editor.getModel().getLineCount();
        const height = this._editor.getLayoutInfo().height;
        const approxPixelsPerLine = height / lineCount;
        const mergeLinesDelta = Math.max(2, Math.ceil(3 / approxPixelsPerLine));
        let prevStartLineNumber = findMatches[0].range.startLineNumber;
        let prevEndLineNumber = findMatches[0].range.endLineNumber;
        for (let i = 1, len = findMatches.length; i < len; i++) {
          const range = findMatches[i].range;
          if (prevEndLineNumber + mergeLinesDelta >= range.startLineNumber) {
            if (range.endLineNumber > prevEndLineNumber) {
              prevEndLineNumber = range.endLineNumber;
            }
          } else {
            newOverviewRulerApproximateDecorations.push({
              range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),
              options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
            });
            prevStartLineNumber = range.startLineNumber;
            prevEndLineNumber = range.endLineNumber;
          }
        }
        newOverviewRulerApproximateDecorations.push({
          range: new Range(prevStartLineNumber, 1, prevEndLineNumber, 1),
          options: FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION
        });
      }
      let newFindMatchesDecorations = new Array(findMatches.length);
      for (let i = 0, len = findMatches.length; i < len; i++) {
        newFindMatchesDecorations[i] = {
          range: findMatches[i].range,
          options: findMatchesOptions
        };
      }
      this._decorations = accessor.deltaDecorations(this._decorations, newFindMatchesDecorations);
      this._overviewRulerApproximateDecorations = accessor.deltaDecorations(this._overviewRulerApproximateDecorations, newOverviewRulerApproximateDecorations);
      if (this._rangeHighlightDecorationId) {
        accessor.removeDecoration(this._rangeHighlightDecorationId);
        this._rangeHighlightDecorationId = null;
      }
      if (this._findScopeDecorationIds.length) {
        this._findScopeDecorationIds.forEach((findScopeDecorationId) => accessor.removeDecoration(findScopeDecorationId));
        this._findScopeDecorationIds = [];
      }
      if (findScopes === null || findScopes === void 0 ? void 0 : findScopes.length) {
        this._findScopeDecorationIds = findScopes.map((findScope) => accessor.addDecoration(findScope, FindDecorations._FIND_SCOPE_DECORATION));
      }
    });
  }
  matchBeforePosition(position) {
    if (this._decorations.length === 0) {
      return null;
    }
    for (let i = this._decorations.length - 1; i >= 0; i--) {
      let decorationId = this._decorations[i];
      let r = this._editor.getModel().getDecorationRange(decorationId);
      if (!r || r.endLineNumber > position.lineNumber) {
        continue;
      }
      if (r.endLineNumber < position.lineNumber) {
        return r;
      }
      if (r.endColumn > position.column) {
        continue;
      }
      return r;
    }
    return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);
  }
  matchAfterPosition(position) {
    if (this._decorations.length === 0) {
      return null;
    }
    for (let i = 0, len = this._decorations.length; i < len; i++) {
      let decorationId = this._decorations[i];
      let r = this._editor.getModel().getDecorationRange(decorationId);
      if (!r || r.startLineNumber < position.lineNumber) {
        continue;
      }
      if (r.startLineNumber > position.lineNumber) {
        return r;
      }
      if (r.startColumn < position.column) {
        continue;
      }
      return r;
    }
    return this._editor.getModel().getDecorationRange(this._decorations[0]);
  }
  _allDecorations() {
    let result = [];
    result = result.concat(this._decorations);
    result = result.concat(this._overviewRulerApproximateDecorations);
    if (this._findScopeDecorationIds.length) {
      result.push(...this._findScopeDecorationIds);
    }
    if (this._rangeHighlightDecorationId) {
      result.push(this._rangeHighlightDecorationId);
    }
    return result;
  }
};
FindDecorations._CURRENT_FIND_MATCH_DECORATION = ModelDecorationOptions.register({
  description: "current-find-match",
  stickiness: 1,
  zIndex: 13,
  className: "currentFindMatch",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: MinimapPosition.Inline
  }
});
FindDecorations._FIND_MATCH_DECORATION = ModelDecorationOptions.register({
  description: "find-match",
  stickiness: 1,
  zIndex: 10,
  className: "findMatch",
  showIfCollapsed: true,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapFindMatch),
    position: MinimapPosition.Inline
  }
});
FindDecorations._FIND_MATCH_NO_OVERVIEW_DECORATION = ModelDecorationOptions.register({
  description: "find-match-no-overview",
  stickiness: 1,
  className: "findMatch",
  showIfCollapsed: true
});
FindDecorations._FIND_MATCH_ONLY_OVERVIEW_DECORATION = ModelDecorationOptions.register({
  description: "find-match-only-overview",
  stickiness: 1,
  overviewRuler: {
    color: themeColorFromId(overviewRulerFindMatchForeground),
    position: OverviewRulerLane.Center
  }
});
FindDecorations._RANGE_HIGHLIGHT_DECORATION = ModelDecorationOptions.register({
  description: "find-range-highlight",
  stickiness: 1,
  className: "rangeHighlight",
  isWholeLine: true
});
FindDecorations._FIND_SCOPE_DECORATION = ModelDecorationOptions.register({
  description: "find-scope",
  className: "findScope",
  isWholeLine: true
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/replaceAllCommand.js
var ReplaceAllCommand = class {
  constructor(editorSelection, ranges, replaceStrings) {
    this._editorSelection = editorSelection;
    this._ranges = ranges;
    this._replaceStrings = replaceStrings;
    this._trackedEditorSelectionId = null;
  }
  getEditOperations(model, builder) {
    if (this._ranges.length > 0) {
      let ops = [];
      for (let i = 0; i < this._ranges.length; i++) {
        ops.push({
          range: this._ranges[i],
          text: this._replaceStrings[i]
        });
      }
      ops.sort((o1, o2) => {
        return Range.compareRangesUsingStarts(o1.range, o2.range);
      });
      let resultOps = [];
      let previousOp = ops[0];
      for (let i = 1; i < ops.length; i++) {
        if (previousOp.range.endLineNumber === ops[i].range.startLineNumber && previousOp.range.endColumn === ops[i].range.startColumn) {
          previousOp.range = previousOp.range.plusRange(ops[i].range);
          previousOp.text = previousOp.text + ops[i].text;
        } else {
          resultOps.push(previousOp);
          previousOp = ops[i];
        }
      }
      resultOps.push(previousOp);
      for (const op of resultOps) {
        builder.addEditOperation(op.range, op.text);
      }
    }
    this._trackedEditorSelectionId = builder.trackSelection(this._editorSelection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._trackedEditorSelectionId);
  }
};

// node_modules/monaco-editor/esm/vs/base/common/search.js
function buildReplaceStringWithCasePreserved(matches, pattern) {
  if (matches && matches[0] !== "") {
    const containsHyphens = validateSpecificSpecialCharacter(matches, pattern, "-");
    const containsUnderscores = validateSpecificSpecialCharacter(matches, pattern, "_");
    if (containsHyphens && !containsUnderscores) {
      return buildReplaceStringForSpecificSpecialCharacter(matches, pattern, "-");
    } else if (!containsHyphens && containsUnderscores) {
      return buildReplaceStringForSpecificSpecialCharacter(matches, pattern, "_");
    }
    if (matches[0].toUpperCase() === matches[0]) {
      return pattern.toUpperCase();
    } else if (matches[0].toLowerCase() === matches[0]) {
      return pattern.toLowerCase();
    } else if (containsUppercaseCharacter(matches[0][0]) && pattern.length > 0) {
      return pattern[0].toUpperCase() + pattern.substr(1);
    } else if (matches[0][0].toUpperCase() !== matches[0][0] && pattern.length > 0) {
      return pattern[0].toLowerCase() + pattern.substr(1);
    } else {
      return pattern;
    }
  } else {
    return pattern;
  }
}
function validateSpecificSpecialCharacter(matches, pattern, specialCharacter) {
  const doesContainSpecialCharacter = matches[0].indexOf(specialCharacter) !== -1 && pattern.indexOf(specialCharacter) !== -1;
  return doesContainSpecialCharacter && matches[0].split(specialCharacter).length === pattern.split(specialCharacter).length;
}
function buildReplaceStringForSpecificSpecialCharacter(matches, pattern, specialCharacter) {
  const splitPatternAtSpecialCharacter = pattern.split(specialCharacter);
  const splitMatchAtSpecialCharacter = matches[0].split(specialCharacter);
  let replaceString = "";
  splitPatternAtSpecialCharacter.forEach((splitValue, index) => {
    replaceString += buildReplaceStringWithCasePreserved([splitMatchAtSpecialCharacter[index]], splitValue) + specialCharacter;
  });
  return replaceString.slice(0, -1);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/find/replacePattern.js
var StaticValueReplacePattern = class {
  constructor(staticValue) {
    this.staticValue = staticValue;
    this.kind = 0;
  }
};
var DynamicPiecesReplacePattern = class {
  constructor(pieces) {
    this.pieces = pieces;
    this.kind = 1;
  }
};
var ReplacePattern = class {
  constructor(pieces) {
    if (!pieces || pieces.length === 0) {
      this._state = new StaticValueReplacePattern("");
    } else if (pieces.length === 1 && pieces[0].staticValue !== null) {
      this._state = new StaticValueReplacePattern(pieces[0].staticValue);
    } else {
      this._state = new DynamicPiecesReplacePattern(pieces);
    }
  }
  static fromStaticValue(value) {
    return new ReplacePattern([ReplacePiece.staticValue(value)]);
  }
  get hasReplacementPatterns() {
    return this._state.kind === 1;
  }
  buildReplaceString(matches, preserveCase) {
    if (this._state.kind === 0) {
      if (preserveCase) {
        return buildReplaceStringWithCasePreserved(matches, this._state.staticValue);
      } else {
        return this._state.staticValue;
      }
    }
    let result = "";
    for (let i = 0, len = this._state.pieces.length; i < len; i++) {
      let piece = this._state.pieces[i];
      if (piece.staticValue !== null) {
        result += piece.staticValue;
        continue;
      }
      let match = ReplacePattern._substitute(piece.matchIndex, matches);
      if (piece.caseOps !== null && piece.caseOps.length > 0) {
        let repl = [];
        let lenOps = piece.caseOps.length;
        let opIdx = 0;
        for (let idx = 0, len2 = match.length; idx < len2; idx++) {
          if (opIdx >= lenOps) {
            repl.push(match.slice(idx));
            break;
          }
          switch (piece.caseOps[opIdx]) {
            case "U":
              repl.push(match[idx].toUpperCase());
              break;
            case "u":
              repl.push(match[idx].toUpperCase());
              opIdx++;
              break;
            case "L":
              repl.push(match[idx].toLowerCase());
              break;
            case "l":
              repl.push(match[idx].toLowerCase());
              opIdx++;
              break;
            default:
              repl.push(match[idx]);
          }
        }
        match = repl.join("");
      }
      result += match;
    }
    return result;
  }
  static _substitute(matchIndex, matches) {
    if (matches === null) {
      return "";
    }
    if (matchIndex === 0) {
      return matches[0];
    }
    let remainder = "";
    while (matchIndex > 0) {
      if (matchIndex < matches.length) {
        let match = matches[matchIndex] || "";
        return match + remainder;
      }
      remainder = String(matchIndex % 10) + remainder;
      matchIndex = Math.floor(matchIndex / 10);
    }
    return "$" + remainder;
  }
};
var ReplacePiece = class {
  constructor(staticValue, matchIndex, caseOps) {
    this.staticValue = staticValue;
    this.matchIndex = matchIndex;
    if (!caseOps || caseOps.length === 0) {
      this.caseOps = null;
    } else {
      this.caseOps = caseOps.slice(0);
    }
  }
  static staticValue(value) {
    return new ReplacePiece(value, -1, null);
  }
  static caseOps(index, caseOps) {
    return new ReplacePiece(null, index, caseOps);
  }
};
var ReplacePieceBuilder = class {
  constructor(source) {
    this._source = source;
    this._lastCharIndex = 0;
    this._result = [];
    this._resultLen = 0;
    this._currentStaticPiece = "";
  }
  emitUnchanged(toCharIndex) {
    this._emitStatic(this._source.substring(this._lastCharIndex, toCharIndex));
    this._lastCharIndex = toCharIndex;
  }
  emitStatic(value, toCharIndex) {
    this._emitStatic(value);
    this._lastCharIndex = toCharIndex;
  }
  _emitStatic(value) {
    if (value.length === 0) {
      return;
    }
    this._currentStaticPiece += value;
  }
  emitMatchIndex(index, toCharIndex, caseOps) {
    if (this._currentStaticPiece.length !== 0) {
      this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
      this._currentStaticPiece = "";
    }
    this._result[this._resultLen++] = ReplacePiece.caseOps(index, caseOps);
    this._lastCharIndex = toCharIndex;
  }
  finalize() {
    this.emitUnchanged(this._source.length);
    if (this._currentStaticPiece.length !== 0) {
      this._result[this._resultLen++] = ReplacePiece.staticValue(this._currentStaticPiece);
      this._currentStaticPiece = "";
    }
    return new ReplacePattern(this._result);
  }
};
function parseReplaceString(replaceString) {
  if (!replaceString || replaceString.length === 0) {
    return new ReplacePattern(null);
  }
  let caseOps = [];
  let result = new ReplacePieceBuilder(replaceString);
  for (let i = 0, len = replaceString.length; i < len; i++) {
    let chCode = replaceString.charCodeAt(i);
    if (chCode === 92) {
      i++;
      if (i >= len) {
        break;
      }
      let nextChCode = replaceString.charCodeAt(i);
      switch (nextChCode) {
        case 92:
          result.emitUnchanged(i - 1);
          result.emitStatic("\\", i + 1);
          break;
        case 110:
          result.emitUnchanged(i - 1);
          result.emitStatic("\n", i + 1);
          break;
        case 116:
          result.emitUnchanged(i - 1);
          result.emitStatic("	", i + 1);
          break;
        case 117:
        case 85:
        case 108:
        case 76:
          result.emitUnchanged(i - 1);
          result.emitStatic("", i + 1);
          caseOps.push(String.fromCharCode(nextChCode));
          break;
      }
      continue;
    }
    if (chCode === 36) {
      i++;
      if (i >= len) {
        break;
      }
      let nextChCode = replaceString.charCodeAt(i);
      if (nextChCode === 36) {
        result.emitUnchanged(i - 1);
        result.emitStatic("$", i + 1);
        continue;
      }
      if (nextChCode === 48 || nextChCode === 38) {
        result.emitUnchanged(i - 1);
        result.emitMatchIndex(0, i + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
      if (49 <= nextChCode && nextChCode <= 57) {
        let matchIndex = nextChCode - 48;
        if (i + 1 < len) {
          let nextNextChCode = replaceString.charCodeAt(i + 1);
          if (48 <= nextNextChCode && nextNextChCode <= 57) {
            i++;
            matchIndex = matchIndex * 10 + (nextNextChCode - 48);
            result.emitUnchanged(i - 2);
            result.emitMatchIndex(matchIndex, i + 1, caseOps);
            caseOps.length = 0;
            continue;
          }
        }
        result.emitUnchanged(i - 1);
        result.emitMatchIndex(matchIndex, i + 1, caseOps);
        caseOps.length = 0;
        continue;
      }
    }
  }
  return result.finalize();
}

// node_modules/monaco-editor/esm/vs/editor/contrib/find/findModel.js
var CONTEXT_FIND_WIDGET_VISIBLE = new RawContextKey("findWidgetVisible", false);
var CONTEXT_FIND_WIDGET_NOT_VISIBLE = CONTEXT_FIND_WIDGET_VISIBLE.toNegated();
var CONTEXT_FIND_INPUT_FOCUSED = new RawContextKey("findInputFocussed", false);
var CONTEXT_REPLACE_INPUT_FOCUSED = new RawContextKey("replaceInputFocussed", false);
var ToggleCaseSensitiveKeybinding = {
  primary: 512 | 33,
  mac: { primary: 2048 | 512 | 33 }
};
var ToggleWholeWordKeybinding = {
  primary: 512 | 53,
  mac: { primary: 2048 | 512 | 53 }
};
var ToggleRegexKeybinding = {
  primary: 512 | 48,
  mac: { primary: 2048 | 512 | 48 }
};
var ToggleSearchScopeKeybinding = {
  primary: 512 | 42,
  mac: { primary: 2048 | 512 | 42 }
};
var TogglePreserveCaseKeybinding = {
  primary: 512 | 46,
  mac: { primary: 2048 | 512 | 46 }
};
var FIND_IDS = {
  StartFindAction: "actions.find",
  StartFindWithSelection: "actions.findWithSelection",
  StartFindWithArgs: "editor.actions.findWithArgs",
  NextMatchFindAction: "editor.action.nextMatchFindAction",
  PreviousMatchFindAction: "editor.action.previousMatchFindAction",
  NextSelectionMatchFindAction: "editor.action.nextSelectionMatchFindAction",
  PreviousSelectionMatchFindAction: "editor.action.previousSelectionMatchFindAction",
  StartFindReplaceAction: "editor.action.startFindReplaceAction",
  CloseFindWidgetCommand: "closeFindWidget",
  ToggleCaseSensitiveCommand: "toggleFindCaseSensitive",
  ToggleWholeWordCommand: "toggleFindWholeWord",
  ToggleRegexCommand: "toggleFindRegex",
  ToggleSearchScopeCommand: "toggleFindInSelection",
  TogglePreserveCaseCommand: "togglePreserveCase",
  ReplaceOneAction: "editor.action.replaceOne",
  ReplaceAllAction: "editor.action.replaceAll",
  SelectAllMatchesAction: "editor.action.selectAllMatches"
};
var MATCHES_LIMIT = 19999;
var RESEARCH_DELAY = 240;
var FindModelBoundToEditorModel = class {
  constructor(editor2, state) {
    this._toDispose = new DisposableStore();
    this._editor = editor2;
    this._state = state;
    this._isDisposed = false;
    this._startSearchingTimer = new TimeoutTimer();
    this._decorations = new FindDecorations(editor2);
    this._toDispose.add(this._decorations);
    this._updateDecorationsScheduler = new RunOnceScheduler(() => this.research(false), 100);
    this._toDispose.add(this._updateDecorationsScheduler);
    this._toDispose.add(this._editor.onDidChangeCursorPosition((e) => {
      if (e.reason === 3 || e.reason === 5 || e.reason === 6) {
        this._decorations.setStartPosition(this._editor.getPosition());
      }
    }));
    this._ignoreModelContentChanged = false;
    this._toDispose.add(this._editor.onDidChangeModelContent((e) => {
      if (this._ignoreModelContentChanged) {
        return;
      }
      if (e.isFlush) {
        this._decorations.reset();
      }
      this._decorations.setStartPosition(this._editor.getPosition());
      this._updateDecorationsScheduler.schedule();
    }));
    this._toDispose.add(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this.research(false, this._state.searchScope);
  }
  dispose() {
    this._isDisposed = true;
    dispose(this._startSearchingTimer);
    this._toDispose.dispose();
  }
  _onStateChanged(e) {
    if (this._isDisposed) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {
      let model = this._editor.getModel();
      if (model.isTooLargeForSyncing()) {
        this._startSearchingTimer.cancel();
        this._startSearchingTimer.setIfNotSet(() => {
          if (e.searchScope) {
            this.research(e.moveCursor, this._state.searchScope);
          } else {
            this.research(e.moveCursor);
          }
        }, RESEARCH_DELAY);
      } else {
        if (e.searchScope) {
          this.research(e.moveCursor, this._state.searchScope);
        } else {
          this.research(e.moveCursor);
        }
      }
    }
  }
  static _getSearchRange(model, findScope) {
    if (findScope) {
      return findScope;
    }
    return model.getFullModelRange();
  }
  research(moveCursor, newFindScope) {
    let findScopes = null;
    if (typeof newFindScope !== "undefined") {
      if (newFindScope !== null) {
        if (!Array.isArray(newFindScope)) {
          findScopes = [newFindScope];
        } else {
          findScopes = newFindScope;
        }
      }
    } else {
      findScopes = this._decorations.getFindScopes();
    }
    if (findScopes !== null) {
      findScopes = findScopes.map((findScope) => {
        if (findScope.startLineNumber !== findScope.endLineNumber) {
          let endLineNumber = findScope.endLineNumber;
          if (findScope.endColumn === 1) {
            endLineNumber = endLineNumber - 1;
          }
          return new Range(findScope.startLineNumber, 1, endLineNumber, this._editor.getModel().getLineMaxColumn(endLineNumber));
        }
        return findScope;
      });
    }
    let findMatches = this._findMatches(findScopes, false, MATCHES_LIMIT);
    this._decorations.set(findMatches, findScopes);
    const editorSelection = this._editor.getSelection();
    let currentMatchesPosition = this._decorations.getCurrentMatchesPosition(editorSelection);
    if (currentMatchesPosition === 0 && findMatches.length > 0) {
      const matchAfterSelection = findFirstInSorted(findMatches.map((match) => match.range), (range) => Range.compareRangesUsingStarts(range, editorSelection) >= 0);
      currentMatchesPosition = matchAfterSelection > 0 ? matchAfterSelection - 1 + 1 : currentMatchesPosition;
    }
    this._state.changeMatchInfo(currentMatchesPosition, this._decorations.getCount(), void 0);
    if (moveCursor && this._editor.getOption(35).cursorMoveOnType) {
      this._moveToNextMatch(this._decorations.getStartPosition());
    }
  }
  _hasMatches() {
    return this._state.matchesCount > 0;
  }
  _cannotFind() {
    if (!this._hasMatches()) {
      let findScope = this._decorations.getFindScope();
      if (findScope) {
        this._editor.revealRangeInCenterIfOutsideViewport(findScope, 0);
      }
      return true;
    }
    return false;
  }
  _setCurrentFindMatch(match) {
    let matchesPosition = this._decorations.setCurrentFindMatch(match);
    this._state.changeMatchInfo(matchesPosition, this._decorations.getCount(), match);
    this._editor.setSelection(match);
    this._editor.revealRangeInCenterIfOutsideViewport(match, 0);
  }
  _prevSearchPosition(before) {
    let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber, column } = before;
    let model = this._editor.getModel();
    if (isUsingLineStops || column === 1) {
      if (lineNumber === 1) {
        lineNumber = model.getLineCount();
      } else {
        lineNumber--;
      }
      column = model.getLineMaxColumn(lineNumber);
    } else {
      column--;
    }
    return new Position(lineNumber, column);
  }
  _moveToPrevMatch(before, isRecursed = false) {
    if (!this._state.canNavigateBack()) {
      const nextMatchRange = this._decorations.matchAfterPosition(before);
      if (nextMatchRange) {
        this._setCurrentFindMatch(nextMatchRange);
      }
      return;
    }
    if (this._decorations.getCount() < MATCHES_LIMIT) {
      let prevMatchRange = this._decorations.matchBeforePosition(before);
      if (prevMatchRange && prevMatchRange.isEmpty() && prevMatchRange.getStartPosition().equals(before)) {
        before = this._prevSearchPosition(before);
        prevMatchRange = this._decorations.matchBeforePosition(before);
      }
      if (prevMatchRange) {
        this._setCurrentFindMatch(prevMatchRange);
      }
      return;
    }
    if (this._cannotFind()) {
      return;
    }
    let findScope = this._decorations.getFindScope();
    let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
    if (searchRange.getEndPosition().isBefore(before)) {
      before = searchRange.getEndPosition();
    }
    if (before.isBefore(searchRange.getStartPosition())) {
      before = searchRange.getEndPosition();
    }
    let { lineNumber, column } = before;
    let model = this._editor.getModel();
    let position = new Position(lineNumber, column);
    let prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(116) : null, false);
    if (prevMatch && prevMatch.range.isEmpty() && prevMatch.range.getStartPosition().equals(position)) {
      position = this._prevSearchPosition(position);
      prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(116) : null, false);
    }
    if (!prevMatch) {
      return;
    }
    if (!isRecursed && !searchRange.containsRange(prevMatch.range)) {
      return this._moveToPrevMatch(prevMatch.range.getStartPosition(), true);
    }
    this._setCurrentFindMatch(prevMatch.range);
  }
  moveToPrevMatch() {
    this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
  }
  _nextSearchPosition(after) {
    let isUsingLineStops = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber, column } = after;
    let model = this._editor.getModel();
    if (isUsingLineStops || column === model.getLineMaxColumn(lineNumber)) {
      if (lineNumber === model.getLineCount()) {
        lineNumber = 1;
      } else {
        lineNumber++;
      }
      column = 1;
    } else {
      column++;
    }
    return new Position(lineNumber, column);
  }
  _moveToNextMatch(after) {
    if (!this._state.canNavigateForward()) {
      const prevMatchRange = this._decorations.matchBeforePosition(after);
      if (prevMatchRange) {
        this._setCurrentFindMatch(prevMatchRange);
      }
      return;
    }
    if (this._decorations.getCount() < MATCHES_LIMIT) {
      let nextMatchRange = this._decorations.matchAfterPosition(after);
      if (nextMatchRange && nextMatchRange.isEmpty() && nextMatchRange.getStartPosition().equals(after)) {
        after = this._nextSearchPosition(after);
        nextMatchRange = this._decorations.matchAfterPosition(after);
      }
      if (nextMatchRange) {
        this._setCurrentFindMatch(nextMatchRange);
      }
      return;
    }
    let nextMatch = this._getNextMatch(after, false, true);
    if (nextMatch) {
      this._setCurrentFindMatch(nextMatch.range);
    }
  }
  _getNextMatch(after, captureMatches, forceMove, isRecursed = false) {
    if (this._cannotFind()) {
      return null;
    }
    let findScope = this._decorations.getFindScope();
    let searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), findScope);
    if (searchRange.getEndPosition().isBefore(after)) {
      after = searchRange.getStartPosition();
    }
    if (after.isBefore(searchRange.getStartPosition())) {
      after = searchRange.getStartPosition();
    }
    let { lineNumber, column } = after;
    let model = this._editor.getModel();
    let position = new Position(lineNumber, column);
    let nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(116) : null, captureMatches);
    if (forceMove && nextMatch && nextMatch.range.isEmpty() && nextMatch.range.getStartPosition().equals(position)) {
      position = this._nextSearchPosition(position);
      nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(116) : null, captureMatches);
    }
    if (!nextMatch) {
      return null;
    }
    if (!isRecursed && !searchRange.containsRange(nextMatch.range)) {
      return this._getNextMatch(nextMatch.range.getEndPosition(), captureMatches, forceMove, true);
    }
    return nextMatch;
  }
  moveToNextMatch() {
    this._moveToNextMatch(this._editor.getSelection().getEndPosition());
  }
  _getReplacePattern() {
    if (this._state.isRegex) {
      return parseReplaceString(this._state.replaceString);
    }
    return ReplacePattern.fromStaticValue(this._state.replaceString);
  }
  replace() {
    if (!this._hasMatches()) {
      return;
    }
    let replacePattern = this._getReplacePattern();
    let selection = this._editor.getSelection();
    let nextMatch = this._getNextMatch(selection.getStartPosition(), true, false);
    if (nextMatch) {
      if (selection.equalsRange(nextMatch.range)) {
        let replaceString = replacePattern.buildReplaceString(nextMatch.matches, this._state.preserveCase);
        let command = new ReplaceCommand(selection, replaceString);
        this._executeEditorCommand("replace", command);
        this._decorations.setStartPosition(new Position(selection.startLineNumber, selection.startColumn + replaceString.length));
        this.research(true);
      } else {
        this._decorations.setStartPosition(this._editor.getPosition());
        this._setCurrentFindMatch(nextMatch.range);
      }
    }
  }
  _findMatches(findScopes, captureMatches, limitResultCount) {
    const searchRanges = (findScopes || [null]).map((scope) => FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), scope));
    return this._editor.getModel().findMatches(this._state.searchString, searchRanges, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(116) : null, captureMatches, limitResultCount);
  }
  replaceAll() {
    if (!this._hasMatches()) {
      return;
    }
    const findScopes = this._decorations.getFindScopes();
    if (findScopes === null && this._state.matchesCount >= MATCHES_LIMIT) {
      this._largeReplaceAll();
    } else {
      this._regularReplaceAll(findScopes);
    }
    this.research(false);
  }
  _largeReplaceAll() {
    const searchParams = new SearchParams(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(116) : null);
    const searchData = searchParams.parseSearchRequest();
    if (!searchData) {
      return;
    }
    let searchRegex = searchData.regex;
    if (!searchRegex.multiline) {
      let mod = "mu";
      if (searchRegex.ignoreCase) {
        mod += "i";
      }
      if (searchRegex.global) {
        mod += "g";
      }
      searchRegex = new RegExp(searchRegex.source, mod);
    }
    const model = this._editor.getModel();
    const modelText = model.getValue(1);
    const fullModelRange = model.getFullModelRange();
    const replacePattern = this._getReplacePattern();
    let resultText;
    const preserveCase = this._state.preserveCase;
    if (replacePattern.hasReplacementPatterns || preserveCase) {
      resultText = modelText.replace(searchRegex, function() {
        return replacePattern.buildReplaceString(arguments, preserveCase);
      });
    } else {
      resultText = modelText.replace(searchRegex, replacePattern.buildReplaceString(null, preserveCase));
    }
    let command = new ReplaceCommandThatPreservesSelection(fullModelRange, resultText, this._editor.getSelection());
    this._executeEditorCommand("replaceAll", command);
  }
  _regularReplaceAll(findScopes) {
    const replacePattern = this._getReplacePattern();
    let matches = this._findMatches(findScopes, replacePattern.hasReplacementPatterns || this._state.preserveCase, 1073741824);
    let replaceStrings = [];
    for (let i = 0, len = matches.length; i < len; i++) {
      replaceStrings[i] = replacePattern.buildReplaceString(matches[i].matches, this._state.preserveCase);
    }
    let command = new ReplaceAllCommand(this._editor.getSelection(), matches.map((m) => m.range), replaceStrings);
    this._executeEditorCommand("replaceAll", command);
  }
  selectAllMatches() {
    if (!this._hasMatches()) {
      return;
    }
    let findScopes = this._decorations.getFindScopes();
    let matches = this._findMatches(findScopes, false, 1073741824);
    let selections = matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn));
    let editorSelection = this._editor.getSelection();
    for (let i = 0, len = selections.length; i < len; i++) {
      let sel = selections[i];
      if (sel.equalsRange(editorSelection)) {
        selections = [editorSelection].concat(selections.slice(0, i)).concat(selections.slice(i + 1));
        break;
      }
    }
    this._editor.setSelections(selections);
  }
  _executeEditorCommand(source, command) {
    try {
      this._ignoreModelContentChanged = true;
      this._editor.pushUndoStop();
      this._editor.executeCommand(source, command);
      this._editor.pushUndoStop();
    } finally {
      this._ignoreModelContentChanged = false;
    }
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/checkbox/checkbox.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/base/browser/ui/checkbox/checkbox.css";
var defaultOpts = {
  inputActiveOptionBorder: Color.fromHex("#007ACC00"),
  inputActiveOptionForeground: Color.fromHex("#FFFFFF"),
  inputActiveOptionBackground: Color.fromHex("#0E639C50")
};
var Checkbox = class extends Widget {
  constructor(opts) {
    super();
    this._onChange = this._register(new Emitter());
    this.onChange = this._onChange.event;
    this._onKeyDown = this._register(new Emitter());
    this.onKeyDown = this._onKeyDown.event;
    this._opts = Object.assign(Object.assign({}, defaultOpts), opts);
    this._checked = this._opts.isChecked;
    const classes = ["monaco-custom-checkbox"];
    if (this._opts.icon) {
      classes.push(...CSSIcon.asClassNameArray(this._opts.icon));
    }
    if (this._opts.actionClassName) {
      classes.push(...this._opts.actionClassName.split(" "));
    }
    if (this._checked) {
      classes.push("checked");
    }
    this.domNode = document.createElement("div");
    this.domNode.title = this._opts.title;
    this.domNode.classList.add(...classes);
    if (!this._opts.notFocusable) {
      this.domNode.tabIndex = 0;
    }
    this.domNode.setAttribute("role", "checkbox");
    this.domNode.setAttribute("aria-checked", String(this._checked));
    this.domNode.setAttribute("aria-label", this._opts.title);
    this.applyStyles();
    this.onclick(this.domNode, (ev) => {
      this.checked = !this._checked;
      this._onChange.fire(false);
      ev.preventDefault();
    });
    this.ignoreGesture(this.domNode);
    this.onkeydown(this.domNode, (keyboardEvent) => {
      if (keyboardEvent.keyCode === 10 || keyboardEvent.keyCode === 3) {
        this.checked = !this._checked;
        this._onChange.fire(true);
        keyboardEvent.preventDefault();
        return;
      }
      this._onKeyDown.fire(keyboardEvent);
    });
  }
  get enabled() {
    return this.domNode.getAttribute("aria-disabled") !== "true";
  }
  focus() {
    this.domNode.focus();
  }
  get checked() {
    return this._checked;
  }
  set checked(newIsChecked) {
    this._checked = newIsChecked;
    this.domNode.setAttribute("aria-checked", String(this._checked));
    this.domNode.classList.toggle("checked", this._checked);
    this.applyStyles();
  }
  width() {
    return 2 + 2 + 2 + 16;
  }
  style(styles) {
    if (styles.inputActiveOptionBorder) {
      this._opts.inputActiveOptionBorder = styles.inputActiveOptionBorder;
    }
    if (styles.inputActiveOptionForeground) {
      this._opts.inputActiveOptionForeground = styles.inputActiveOptionForeground;
    }
    if (styles.inputActiveOptionBackground) {
      this._opts.inputActiveOptionBackground = styles.inputActiveOptionBackground;
    }
    this.applyStyles();
  }
  applyStyles() {
    if (this.domNode) {
      this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder ? this._opts.inputActiveOptionBorder.toString() : "";
      this.domNode.style.color = this._checked && this._opts.inputActiveOptionForeground ? this._opts.inputActiveOptionForeground.toString() : "inherit";
      this.domNode.style.backgroundColor = this._checked && this._opts.inputActiveOptionBackground ? this._opts.inputActiveOptionBackground.toString() : "";
    }
  }
  enable() {
    this.domNode.setAttribute("aria-disabled", String(false));
  }
  disable() {
    this.domNode.setAttribute("aria-disabled", String(true));
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInputCheckboxes.js
var NLS_CASE_SENSITIVE_CHECKBOX_LABEL = localize("caseDescription", "Match Case");
var NLS_WHOLE_WORD_CHECKBOX_LABEL = localize("wordsDescription", "Match Whole Word");
var NLS_REGEX_CHECKBOX_LABEL = localize("regexDescription", "Use Regular Expression");
var CaseSensitiveCheckbox = class extends Checkbox {
  constructor(opts) {
    super({
      icon: Codicon.caseSensitive,
      title: NLS_CASE_SENSITIVE_CHECKBOX_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }
};
var WholeWordsCheckbox = class extends Checkbox {
  constructor(opts) {
    super({
      icon: Codicon.wholeWord,
      title: NLS_WHOLE_WORD_CHECKBOX_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }
};
var RegexCheckbox = class extends Checkbox {
  constructor(opts) {
    super({
      icon: Codicon.regex,
      title: NLS_REGEX_CHECKBOX_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/find/findOptionsWidget.js
var FindOptionsWidget = class extends Widget {
  constructor(editor2, state, keybindingService, themeService) {
    super();
    this._hideSoon = this._register(new RunOnceScheduler(() => this._hide(), 2e3));
    this._isVisible = false;
    this._editor = editor2;
    this._state = state;
    this._keybindingService = keybindingService;
    this._domNode = document.createElement("div");
    this._domNode.className = "findOptionsWidget";
    this._domNode.style.display = "none";
    this._domNode.style.top = "10px";
    this._domNode.setAttribute("role", "presentation");
    this._domNode.setAttribute("aria-hidden", "true");
    const inputActiveOptionBorderColor = themeService.getColorTheme().getColor(inputActiveOptionBorder);
    const inputActiveOptionForegroundColor = themeService.getColorTheme().getColor(inputActiveOptionForeground);
    const inputActiveOptionBackgroundColor = themeService.getColorTheme().getColor(inputActiveOptionBackground);
    this.caseSensitive = this._register(new CaseSensitiveCheckbox({
      appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
      isChecked: this._state.matchCase,
      inputActiveOptionBorder: inputActiveOptionBorderColor,
      inputActiveOptionForeground: inputActiveOptionForegroundColor,
      inputActiveOptionBackground: inputActiveOptionBackgroundColor
    }));
    this._domNode.appendChild(this.caseSensitive.domNode);
    this._register(this.caseSensitive.onChange(() => {
      this._state.change({
        matchCase: this.caseSensitive.checked
      }, false);
    }));
    this.wholeWords = this._register(new WholeWordsCheckbox({
      appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
      isChecked: this._state.wholeWord,
      inputActiveOptionBorder: inputActiveOptionBorderColor,
      inputActiveOptionForeground: inputActiveOptionForegroundColor,
      inputActiveOptionBackground: inputActiveOptionBackgroundColor
    }));
    this._domNode.appendChild(this.wholeWords.domNode);
    this._register(this.wholeWords.onChange(() => {
      this._state.change({
        wholeWord: this.wholeWords.checked
      }, false);
    }));
    this.regex = this._register(new RegexCheckbox({
      appendTitle: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
      isChecked: this._state.isRegex,
      inputActiveOptionBorder: inputActiveOptionBorderColor,
      inputActiveOptionForeground: inputActiveOptionForegroundColor,
      inputActiveOptionBackground: inputActiveOptionBackgroundColor
    }));
    this._domNode.appendChild(this.regex.domNode);
    this._register(this.regex.onChange(() => {
      this._state.change({
        isRegex: this.regex.checked
      }, false);
    }));
    this._editor.addOverlayWidget(this);
    this._register(this._state.onFindReplaceStateChange((e) => {
      let somethingChanged = false;
      if (e.isRegex) {
        this.regex.checked = this._state.isRegex;
        somethingChanged = true;
      }
      if (e.wholeWord) {
        this.wholeWords.checked = this._state.wholeWord;
        somethingChanged = true;
      }
      if (e.matchCase) {
        this.caseSensitive.checked = this._state.matchCase;
        somethingChanged = true;
      }
      if (!this._state.isRevealed && somethingChanged) {
        this._revealTemporarily();
      }
    }));
    this._register(addDisposableNonBubblingMouseOutListener(this._domNode, (e) => this._onMouseOut()));
    this._register(addDisposableListener(this._domNode, "mouseover", (e) => this._onMouseOver()));
    this._applyTheme(themeService.getColorTheme());
    this._register(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
  }
  _keybindingLabelFor(actionId) {
    let kb = this._keybindingService.lookupKeybinding(actionId);
    if (!kb) {
      return "";
    }
    return ` (${kb.getLabel()})`;
  }
  dispose() {
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  getId() {
    return FindOptionsWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 0
    };
  }
  highlightFindOptions() {
    this._revealTemporarily();
  }
  _revealTemporarily() {
    this._show();
    this._hideSoon.schedule();
  }
  _onMouseOut() {
    this._hideSoon.schedule();
  }
  _onMouseOver() {
    this._hideSoon.cancel();
  }
  _show() {
    if (this._isVisible) {
      return;
    }
    this._isVisible = true;
    this._domNode.style.display = "block";
  }
  _hide() {
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    this._domNode.style.display = "none";
  }
  _applyTheme(theme) {
    let inputStyles = {
      inputActiveOptionBorder: theme.getColor(inputActiveOptionBorder),
      inputActiveOptionForeground: theme.getColor(inputActiveOptionForeground),
      inputActiveOptionBackground: theme.getColor(inputActiveOptionBackground)
    };
    this.caseSensitive.style(inputStyles);
    this.wholeWords.style(inputStyles);
    this.regex.style(inputStyles);
  }
};
FindOptionsWidget.ID = "editor.contrib.findOptionsWidget";
registerThemingParticipant((theme, collector) => {
  const widgetBackground = theme.getColor(editorWidgetBackground);
  if (widgetBackground) {
    collector.addRule(`.monaco-editor .findOptionsWidget { background-color: ${widgetBackground}; }`);
  }
  const widgetForeground = theme.getColor(editorWidgetForeground);
  if (widgetForeground) {
    collector.addRule(`.monaco-editor .findOptionsWidget { color: ${widgetForeground}; }`);
  }
  const widgetShadowColor = theme.getColor(widgetShadow);
  if (widgetShadowColor) {
    collector.addRule(`.monaco-editor .findOptionsWidget { box-shadow: 0 0 8px 2px ${widgetShadowColor}; }`);
  }
  const hcBorder = theme.getColor(contrastBorder);
  if (hcBorder) {
    collector.addRule(`.monaco-editor .findOptionsWidget { border: 2px solid ${hcBorder}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/findState.js
function effectiveOptionValue(override, value) {
  if (override === 1) {
    return true;
  }
  if (override === 2) {
    return false;
  }
  return value;
}
var FindReplaceState = class extends Disposable {
  constructor() {
    super();
    this._onFindReplaceStateChange = this._register(new Emitter());
    this.onFindReplaceStateChange = this._onFindReplaceStateChange.event;
    this._searchString = "";
    this._replaceString = "";
    this._isRevealed = false;
    this._isReplaceRevealed = false;
    this._isRegex = false;
    this._isRegexOverride = 0;
    this._wholeWord = false;
    this._wholeWordOverride = 0;
    this._matchCase = false;
    this._matchCaseOverride = 0;
    this._preserveCase = false;
    this._preserveCaseOverride = 0;
    this._searchScope = null;
    this._matchesPosition = 0;
    this._matchesCount = 0;
    this._currentMatch = null;
    this._loop = true;
  }
  get searchString() {
    return this._searchString;
  }
  get replaceString() {
    return this._replaceString;
  }
  get isRevealed() {
    return this._isRevealed;
  }
  get isReplaceRevealed() {
    return this._isReplaceRevealed;
  }
  get isRegex() {
    return effectiveOptionValue(this._isRegexOverride, this._isRegex);
  }
  get wholeWord() {
    return effectiveOptionValue(this._wholeWordOverride, this._wholeWord);
  }
  get matchCase() {
    return effectiveOptionValue(this._matchCaseOverride, this._matchCase);
  }
  get preserveCase() {
    return effectiveOptionValue(this._preserveCaseOverride, this._preserveCase);
  }
  get actualIsRegex() {
    return this._isRegex;
  }
  get actualWholeWord() {
    return this._wholeWord;
  }
  get actualMatchCase() {
    return this._matchCase;
  }
  get actualPreserveCase() {
    return this._preserveCase;
  }
  get searchScope() {
    return this._searchScope;
  }
  get matchesPosition() {
    return this._matchesPosition;
  }
  get matchesCount() {
    return this._matchesCount;
  }
  get currentMatch() {
    return this._currentMatch;
  }
  changeMatchInfo(matchesPosition, matchesCount, currentMatch) {
    let changeEvent = {
      moveCursor: false,
      updateHistory: false,
      searchString: false,
      replaceString: false,
      isRevealed: false,
      isReplaceRevealed: false,
      isRegex: false,
      wholeWord: false,
      matchCase: false,
      preserveCase: false,
      searchScope: false,
      matchesPosition: false,
      matchesCount: false,
      currentMatch: false,
      loop: false
    };
    let somethingChanged = false;
    if (matchesCount === 0) {
      matchesPosition = 0;
    }
    if (matchesPosition > matchesCount) {
      matchesPosition = matchesCount;
    }
    if (this._matchesPosition !== matchesPosition) {
      this._matchesPosition = matchesPosition;
      changeEvent.matchesPosition = true;
      somethingChanged = true;
    }
    if (this._matchesCount !== matchesCount) {
      this._matchesCount = matchesCount;
      changeEvent.matchesCount = true;
      somethingChanged = true;
    }
    if (typeof currentMatch !== "undefined") {
      if (!Range.equalsRange(this._currentMatch, currentMatch)) {
        this._currentMatch = currentMatch;
        changeEvent.currentMatch = true;
        somethingChanged = true;
      }
    }
    if (somethingChanged) {
      this._onFindReplaceStateChange.fire(changeEvent);
    }
  }
  change(newState, moveCursor, updateHistory = true) {
    var _a5;
    let changeEvent = {
      moveCursor,
      updateHistory,
      searchString: false,
      replaceString: false,
      isRevealed: false,
      isReplaceRevealed: false,
      isRegex: false,
      wholeWord: false,
      matchCase: false,
      preserveCase: false,
      searchScope: false,
      matchesPosition: false,
      matchesCount: false,
      currentMatch: false,
      loop: false
    };
    let somethingChanged = false;
    const oldEffectiveIsRegex = this.isRegex;
    const oldEffectiveWholeWords = this.wholeWord;
    const oldEffectiveMatchCase = this.matchCase;
    const oldEffectivePreserveCase = this.preserveCase;
    if (typeof newState.searchString !== "undefined") {
      if (this._searchString !== newState.searchString) {
        this._searchString = newState.searchString;
        changeEvent.searchString = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.replaceString !== "undefined") {
      if (this._replaceString !== newState.replaceString) {
        this._replaceString = newState.replaceString;
        changeEvent.replaceString = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isRevealed !== "undefined") {
      if (this._isRevealed !== newState.isRevealed) {
        this._isRevealed = newState.isRevealed;
        changeEvent.isRevealed = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isReplaceRevealed !== "undefined") {
      if (this._isReplaceRevealed !== newState.isReplaceRevealed) {
        this._isReplaceRevealed = newState.isReplaceRevealed;
        changeEvent.isReplaceRevealed = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.isRegex !== "undefined") {
      this._isRegex = newState.isRegex;
    }
    if (typeof newState.wholeWord !== "undefined") {
      this._wholeWord = newState.wholeWord;
    }
    if (typeof newState.matchCase !== "undefined") {
      this._matchCase = newState.matchCase;
    }
    if (typeof newState.preserveCase !== "undefined") {
      this._preserveCase = newState.preserveCase;
    }
    if (typeof newState.searchScope !== "undefined") {
      if (!((_a5 = newState.searchScope) === null || _a5 === void 0 ? void 0 : _a5.every((newSearchScope) => {
        var _a6;
        return (_a6 = this._searchScope) === null || _a6 === void 0 ? void 0 : _a6.some((existingSearchScope) => {
          return !Range.equalsRange(existingSearchScope, newSearchScope);
        });
      }))) {
        this._searchScope = newState.searchScope;
        changeEvent.searchScope = true;
        somethingChanged = true;
      }
    }
    if (typeof newState.loop !== "undefined") {
      if (this._loop !== newState.loop) {
        this._loop = newState.loop;
        changeEvent.loop = true;
        somethingChanged = true;
      }
    }
    this._isRegexOverride = typeof newState.isRegexOverride !== "undefined" ? newState.isRegexOverride : 0;
    this._wholeWordOverride = typeof newState.wholeWordOverride !== "undefined" ? newState.wholeWordOverride : 0;
    this._matchCaseOverride = typeof newState.matchCaseOverride !== "undefined" ? newState.matchCaseOverride : 0;
    this._preserveCaseOverride = typeof newState.preserveCaseOverride !== "undefined" ? newState.preserveCaseOverride : 0;
    if (oldEffectiveIsRegex !== this.isRegex) {
      somethingChanged = true;
      changeEvent.isRegex = true;
    }
    if (oldEffectiveWholeWords !== this.wholeWord) {
      somethingChanged = true;
      changeEvent.wholeWord = true;
    }
    if (oldEffectiveMatchCase !== this.matchCase) {
      somethingChanged = true;
      changeEvent.matchCase = true;
    }
    if (oldEffectivePreserveCase !== this.preserveCase) {
      somethingChanged = true;
      changeEvent.preserveCase = true;
    }
    if (somethingChanged) {
      this._onFindReplaceStateChange.fire(changeEvent);
    }
  }
  canNavigateBack() {
    return this.canNavigateInLoop() || this.matchesPosition !== 1;
  }
  canNavigateForward() {
    return this.canNavigateInLoop() || this.matchesPosition < this.matchesCount;
  }
  canNavigateInLoop() {
    return this._loop || this.matchesCount >= MATCHES_LIMIT;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/find/findWidget.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/find/findWidget.css";

// node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInput.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInput.css";
var NLS_DEFAULT_LABEL = localize("defaultLabel", "input");
var FindInput = class extends Widget {
  constructor(parent, contextViewProvider, _showOptionButtons, options) {
    super();
    this._showOptionButtons = _showOptionButtons;
    this.fixFocusOnOptionClickEnabled = true;
    this.imeSessionInProgress = false;
    this._onDidOptionChange = this._register(new Emitter());
    this.onDidOptionChange = this._onDidOptionChange.event;
    this._onKeyDown = this._register(new Emitter());
    this.onKeyDown = this._onKeyDown.event;
    this._onMouseDown = this._register(new Emitter());
    this.onMouseDown = this._onMouseDown.event;
    this._onInput = this._register(new Emitter());
    this._onKeyUp = this._register(new Emitter());
    this._onCaseSensitiveKeyDown = this._register(new Emitter());
    this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event;
    this._onRegexKeyDown = this._register(new Emitter());
    this.onRegexKeyDown = this._onRegexKeyDown.event;
    this._lastHighlightFindOptions = 0;
    this.contextViewProvider = contextViewProvider;
    this.placeholder = options.placeholder || "";
    this.validation = options.validation;
    this.label = options.label || NLS_DEFAULT_LABEL;
    this.inputActiveOptionBorder = options.inputActiveOptionBorder;
    this.inputActiveOptionForeground = options.inputActiveOptionForeground;
    this.inputActiveOptionBackground = options.inputActiveOptionBackground;
    this.inputBackground = options.inputBackground;
    this.inputForeground = options.inputForeground;
    this.inputBorder = options.inputBorder;
    this.inputValidationInfoBorder = options.inputValidationInfoBorder;
    this.inputValidationInfoBackground = options.inputValidationInfoBackground;
    this.inputValidationInfoForeground = options.inputValidationInfoForeground;
    this.inputValidationWarningBorder = options.inputValidationWarningBorder;
    this.inputValidationWarningBackground = options.inputValidationWarningBackground;
    this.inputValidationWarningForeground = options.inputValidationWarningForeground;
    this.inputValidationErrorBorder = options.inputValidationErrorBorder;
    this.inputValidationErrorBackground = options.inputValidationErrorBackground;
    this.inputValidationErrorForeground = options.inputValidationErrorForeground;
    const appendCaseSensitiveLabel = options.appendCaseSensitiveLabel || "";
    const appendWholeWordsLabel = options.appendWholeWordsLabel || "";
    const appendRegexLabel = options.appendRegexLabel || "";
    const history = options.history || [];
    const flexibleHeight = !!options.flexibleHeight;
    const flexibleWidth = !!options.flexibleWidth;
    const flexibleMaxHeight = options.flexibleMaxHeight;
    this.domNode = document.createElement("div");
    this.domNode.classList.add("monaco-findInput");
    this.inputBox = this._register(new HistoryInputBox(this.domNode, this.contextViewProvider, {
      placeholder: this.placeholder || "",
      ariaLabel: this.label || "",
      validationOptions: {
        validation: this.validation
      },
      inputBackground: this.inputBackground,
      inputForeground: this.inputForeground,
      inputBorder: this.inputBorder,
      inputValidationInfoBackground: this.inputValidationInfoBackground,
      inputValidationInfoForeground: this.inputValidationInfoForeground,
      inputValidationInfoBorder: this.inputValidationInfoBorder,
      inputValidationWarningBackground: this.inputValidationWarningBackground,
      inputValidationWarningForeground: this.inputValidationWarningForeground,
      inputValidationWarningBorder: this.inputValidationWarningBorder,
      inputValidationErrorBackground: this.inputValidationErrorBackground,
      inputValidationErrorForeground: this.inputValidationErrorForeground,
      inputValidationErrorBorder: this.inputValidationErrorBorder,
      history,
      showHistoryHint: options.showHistoryHint,
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight
    }));
    this.regex = this._register(new RegexCheckbox({
      appendTitle: appendRegexLabel,
      isChecked: false,
      inputActiveOptionBorder: this.inputActiveOptionBorder,
      inputActiveOptionForeground: this.inputActiveOptionForeground,
      inputActiveOptionBackground: this.inputActiveOptionBackground
    }));
    this._register(this.regex.onChange((viaKeyboard) => {
      this._onDidOptionChange.fire(viaKeyboard);
      if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
        this.inputBox.focus();
      }
      this.validate();
    }));
    this._register(this.regex.onKeyDown((e) => {
      this._onRegexKeyDown.fire(e);
    }));
    this.wholeWords = this._register(new WholeWordsCheckbox({
      appendTitle: appendWholeWordsLabel,
      isChecked: false,
      inputActiveOptionBorder: this.inputActiveOptionBorder,
      inputActiveOptionForeground: this.inputActiveOptionForeground,
      inputActiveOptionBackground: this.inputActiveOptionBackground
    }));
    this._register(this.wholeWords.onChange((viaKeyboard) => {
      this._onDidOptionChange.fire(viaKeyboard);
      if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
        this.inputBox.focus();
      }
      this.validate();
    }));
    this.caseSensitive = this._register(new CaseSensitiveCheckbox({
      appendTitle: appendCaseSensitiveLabel,
      isChecked: false,
      inputActiveOptionBorder: this.inputActiveOptionBorder,
      inputActiveOptionForeground: this.inputActiveOptionForeground,
      inputActiveOptionBackground: this.inputActiveOptionBackground
    }));
    this._register(this.caseSensitive.onChange((viaKeyboard) => {
      this._onDidOptionChange.fire(viaKeyboard);
      if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
        this.inputBox.focus();
      }
      this.validate();
    }));
    this._register(this.caseSensitive.onKeyDown((e) => {
      this._onCaseSensitiveKeyDown.fire(e);
    }));
    if (this._showOptionButtons) {
      this.inputBox.paddingRight = this.caseSensitive.width() + this.wholeWords.width() + this.regex.width();
    }
    let indexes = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];
    this.onkeydown(this.domNode, (event) => {
      if (event.equals(15) || event.equals(17) || event.equals(9)) {
        let index = indexes.indexOf(document.activeElement);
        if (index >= 0) {
          let newIndex = -1;
          if (event.equals(17)) {
            newIndex = (index + 1) % indexes.length;
          } else if (event.equals(15)) {
            if (index === 0) {
              newIndex = indexes.length - 1;
            } else {
              newIndex = index - 1;
            }
          }
          if (event.equals(9)) {
            indexes[index].blur();
            this.inputBox.focus();
          } else if (newIndex >= 0) {
            indexes[newIndex].focus();
          }
          EventHelper.stop(event, true);
        }
      }
    });
    let controls = document.createElement("div");
    controls.className = "controls";
    controls.style.display = this._showOptionButtons ? "block" : "none";
    controls.appendChild(this.caseSensitive.domNode);
    controls.appendChild(this.wholeWords.domNode);
    controls.appendChild(this.regex.domNode);
    this.domNode.appendChild(controls);
    if (parent) {
      parent.appendChild(this.domNode);
    }
    this._register(addDisposableListener(this.inputBox.inputElement, "compositionstart", (e) => {
      this.imeSessionInProgress = true;
    }));
    this._register(addDisposableListener(this.inputBox.inputElement, "compositionend", (e) => {
      this.imeSessionInProgress = false;
      this._onInput.fire();
    }));
    this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));
    this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));
    this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());
    this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));
  }
  enable() {
    this.domNode.classList.remove("disabled");
    this.inputBox.enable();
    this.regex.enable();
    this.wholeWords.enable();
    this.caseSensitive.enable();
  }
  disable() {
    this.domNode.classList.add("disabled");
    this.inputBox.disable();
    this.regex.disable();
    this.wholeWords.disable();
    this.caseSensitive.disable();
  }
  setFocusInputOnOptionClick(value) {
    this.fixFocusOnOptionClickEnabled = value;
  }
  setEnabled(enabled) {
    if (enabled) {
      this.enable();
    } else {
      this.disable();
    }
  }
  getValue() {
    return this.inputBox.value;
  }
  setValue(value) {
    if (this.inputBox.value !== value) {
      this.inputBox.value = value;
    }
  }
  style(styles) {
    this.inputActiveOptionBorder = styles.inputActiveOptionBorder;
    this.inputActiveOptionForeground = styles.inputActiveOptionForeground;
    this.inputActiveOptionBackground = styles.inputActiveOptionBackground;
    this.inputBackground = styles.inputBackground;
    this.inputForeground = styles.inputForeground;
    this.inputBorder = styles.inputBorder;
    this.inputValidationInfoBackground = styles.inputValidationInfoBackground;
    this.inputValidationInfoForeground = styles.inputValidationInfoForeground;
    this.inputValidationInfoBorder = styles.inputValidationInfoBorder;
    this.inputValidationWarningBackground = styles.inputValidationWarningBackground;
    this.inputValidationWarningForeground = styles.inputValidationWarningForeground;
    this.inputValidationWarningBorder = styles.inputValidationWarningBorder;
    this.inputValidationErrorBackground = styles.inputValidationErrorBackground;
    this.inputValidationErrorForeground = styles.inputValidationErrorForeground;
    this.inputValidationErrorBorder = styles.inputValidationErrorBorder;
    this.applyStyles();
  }
  applyStyles() {
    if (this.domNode) {
      const checkBoxStyles = {
        inputActiveOptionBorder: this.inputActiveOptionBorder,
        inputActiveOptionForeground: this.inputActiveOptionForeground,
        inputActiveOptionBackground: this.inputActiveOptionBackground
      };
      this.regex.style(checkBoxStyles);
      this.wholeWords.style(checkBoxStyles);
      this.caseSensitive.style(checkBoxStyles);
      const inputBoxStyles = {
        inputBackground: this.inputBackground,
        inputForeground: this.inputForeground,
        inputBorder: this.inputBorder,
        inputValidationInfoBackground: this.inputValidationInfoBackground,
        inputValidationInfoForeground: this.inputValidationInfoForeground,
        inputValidationInfoBorder: this.inputValidationInfoBorder,
        inputValidationWarningBackground: this.inputValidationWarningBackground,
        inputValidationWarningForeground: this.inputValidationWarningForeground,
        inputValidationWarningBorder: this.inputValidationWarningBorder,
        inputValidationErrorBackground: this.inputValidationErrorBackground,
        inputValidationErrorForeground: this.inputValidationErrorForeground,
        inputValidationErrorBorder: this.inputValidationErrorBorder
      };
      this.inputBox.style(inputBoxStyles);
    }
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getCaseSensitive() {
    return this.caseSensitive.checked;
  }
  setCaseSensitive(value) {
    this.caseSensitive.checked = value;
  }
  getWholeWords() {
    return this.wholeWords.checked;
  }
  setWholeWords(value) {
    this.wholeWords.checked = value;
  }
  getRegex() {
    return this.regex.checked;
  }
  setRegex(value) {
    this.regex.checked = value;
    this.validate();
  }
  focusOnCaseSensitive() {
    this.caseSensitive.focus();
  }
  highlightFindOptions() {
    this.domNode.classList.remove("highlight-" + this._lastHighlightFindOptions);
    this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions;
    this.domNode.classList.add("highlight-" + this._lastHighlightFindOptions);
  }
  validate() {
    this.inputBox.validate();
  }
  clearMessage() {
    this.inputBox.hideMessage();
  }
};

// node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/replaceInput.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/base/browser/ui/findinput/findInput.css";
var NLS_DEFAULT_LABEL2 = localize("defaultLabel", "input");
var NLS_PRESERVE_CASE_LABEL = localize("label.preserveCaseCheckbox", "Preserve Case");
var PreserveCaseCheckbox = class extends Checkbox {
  constructor(opts) {
    super({
      icon: Codicon.preserveCase,
      title: NLS_PRESERVE_CASE_LABEL + opts.appendTitle,
      isChecked: opts.isChecked,
      inputActiveOptionBorder: opts.inputActiveOptionBorder,
      inputActiveOptionForeground: opts.inputActiveOptionForeground,
      inputActiveOptionBackground: opts.inputActiveOptionBackground
    });
  }
};
var ReplaceInput = class extends Widget {
  constructor(parent, contextViewProvider, _showOptionButtons, options) {
    super();
    this._showOptionButtons = _showOptionButtons;
    this.fixFocusOnOptionClickEnabled = true;
    this.cachedOptionsWidth = 0;
    this._onDidOptionChange = this._register(new Emitter());
    this.onDidOptionChange = this._onDidOptionChange.event;
    this._onKeyDown = this._register(new Emitter());
    this.onKeyDown = this._onKeyDown.event;
    this._onMouseDown = this._register(new Emitter());
    this._onInput = this._register(new Emitter());
    this._onKeyUp = this._register(new Emitter());
    this._onPreserveCaseKeyDown = this._register(new Emitter());
    this.onPreserveCaseKeyDown = this._onPreserveCaseKeyDown.event;
    this.contextViewProvider = contextViewProvider;
    this.placeholder = options.placeholder || "";
    this.validation = options.validation;
    this.label = options.label || NLS_DEFAULT_LABEL2;
    this.inputActiveOptionBorder = options.inputActiveOptionBorder;
    this.inputActiveOptionForeground = options.inputActiveOptionForeground;
    this.inputActiveOptionBackground = options.inputActiveOptionBackground;
    this.inputBackground = options.inputBackground;
    this.inputForeground = options.inputForeground;
    this.inputBorder = options.inputBorder;
    this.inputValidationInfoBorder = options.inputValidationInfoBorder;
    this.inputValidationInfoBackground = options.inputValidationInfoBackground;
    this.inputValidationInfoForeground = options.inputValidationInfoForeground;
    this.inputValidationWarningBorder = options.inputValidationWarningBorder;
    this.inputValidationWarningBackground = options.inputValidationWarningBackground;
    this.inputValidationWarningForeground = options.inputValidationWarningForeground;
    this.inputValidationErrorBorder = options.inputValidationErrorBorder;
    this.inputValidationErrorBackground = options.inputValidationErrorBackground;
    this.inputValidationErrorForeground = options.inputValidationErrorForeground;
    const appendPreserveCaseLabel = options.appendPreserveCaseLabel || "";
    const history = options.history || [];
    const flexibleHeight = !!options.flexibleHeight;
    const flexibleWidth = !!options.flexibleWidth;
    const flexibleMaxHeight = options.flexibleMaxHeight;
    this.domNode = document.createElement("div");
    this.domNode.classList.add("monaco-findInput");
    this.inputBox = this._register(new HistoryInputBox(this.domNode, this.contextViewProvider, {
      ariaLabel: this.label || "",
      placeholder: this.placeholder || "",
      validationOptions: {
        validation: this.validation
      },
      inputBackground: this.inputBackground,
      inputForeground: this.inputForeground,
      inputBorder: this.inputBorder,
      inputValidationInfoBackground: this.inputValidationInfoBackground,
      inputValidationInfoForeground: this.inputValidationInfoForeground,
      inputValidationInfoBorder: this.inputValidationInfoBorder,
      inputValidationWarningBackground: this.inputValidationWarningBackground,
      inputValidationWarningForeground: this.inputValidationWarningForeground,
      inputValidationWarningBorder: this.inputValidationWarningBorder,
      inputValidationErrorBackground: this.inputValidationErrorBackground,
      inputValidationErrorForeground: this.inputValidationErrorForeground,
      inputValidationErrorBorder: this.inputValidationErrorBorder,
      history,
      showHistoryHint: options.showHistoryHint,
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight
    }));
    this.preserveCase = this._register(new PreserveCaseCheckbox({
      appendTitle: appendPreserveCaseLabel,
      isChecked: false,
      inputActiveOptionBorder: this.inputActiveOptionBorder,
      inputActiveOptionForeground: this.inputActiveOptionForeground,
      inputActiveOptionBackground: this.inputActiveOptionBackground
    }));
    this._register(this.preserveCase.onChange((viaKeyboard) => {
      this._onDidOptionChange.fire(viaKeyboard);
      if (!viaKeyboard && this.fixFocusOnOptionClickEnabled) {
        this.inputBox.focus();
      }
      this.validate();
    }));
    this._register(this.preserveCase.onKeyDown((e) => {
      this._onPreserveCaseKeyDown.fire(e);
    }));
    if (this._showOptionButtons) {
      this.cachedOptionsWidth = this.preserveCase.width();
    } else {
      this.cachedOptionsWidth = 0;
    }
    let indexes = [this.preserveCase.domNode];
    this.onkeydown(this.domNode, (event) => {
      if (event.equals(15) || event.equals(17) || event.equals(9)) {
        let index = indexes.indexOf(document.activeElement);
        if (index >= 0) {
          let newIndex = -1;
          if (event.equals(17)) {
            newIndex = (index + 1) % indexes.length;
          } else if (event.equals(15)) {
            if (index === 0) {
              newIndex = indexes.length - 1;
            } else {
              newIndex = index - 1;
            }
          }
          if (event.equals(9)) {
            indexes[index].blur();
            this.inputBox.focus();
          } else if (newIndex >= 0) {
            indexes[newIndex].focus();
          }
          EventHelper.stop(event, true);
        }
      }
    });
    let controls = document.createElement("div");
    controls.className = "controls";
    controls.style.display = this._showOptionButtons ? "block" : "none";
    controls.appendChild(this.preserveCase.domNode);
    this.domNode.appendChild(controls);
    if (parent) {
      parent.appendChild(this.domNode);
    }
    this.onkeydown(this.inputBox.inputElement, (e) => this._onKeyDown.fire(e));
    this.onkeyup(this.inputBox.inputElement, (e) => this._onKeyUp.fire(e));
    this.oninput(this.inputBox.inputElement, (e) => this._onInput.fire());
    this.onmousedown(this.inputBox.inputElement, (e) => this._onMouseDown.fire(e));
  }
  enable() {
    this.domNode.classList.remove("disabled");
    this.inputBox.enable();
    this.preserveCase.enable();
  }
  disable() {
    this.domNode.classList.add("disabled");
    this.inputBox.disable();
    this.preserveCase.disable();
  }
  setEnabled(enabled) {
    if (enabled) {
      this.enable();
    } else {
      this.disable();
    }
  }
  style(styles) {
    this.inputActiveOptionBorder = styles.inputActiveOptionBorder;
    this.inputActiveOptionForeground = styles.inputActiveOptionForeground;
    this.inputActiveOptionBackground = styles.inputActiveOptionBackground;
    this.inputBackground = styles.inputBackground;
    this.inputForeground = styles.inputForeground;
    this.inputBorder = styles.inputBorder;
    this.inputValidationInfoBackground = styles.inputValidationInfoBackground;
    this.inputValidationInfoForeground = styles.inputValidationInfoForeground;
    this.inputValidationInfoBorder = styles.inputValidationInfoBorder;
    this.inputValidationWarningBackground = styles.inputValidationWarningBackground;
    this.inputValidationWarningForeground = styles.inputValidationWarningForeground;
    this.inputValidationWarningBorder = styles.inputValidationWarningBorder;
    this.inputValidationErrorBackground = styles.inputValidationErrorBackground;
    this.inputValidationErrorForeground = styles.inputValidationErrorForeground;
    this.inputValidationErrorBorder = styles.inputValidationErrorBorder;
    this.applyStyles();
  }
  applyStyles() {
    if (this.domNode) {
      const checkBoxStyles = {
        inputActiveOptionBorder: this.inputActiveOptionBorder,
        inputActiveOptionForeground: this.inputActiveOptionForeground,
        inputActiveOptionBackground: this.inputActiveOptionBackground
      };
      this.preserveCase.style(checkBoxStyles);
      const inputBoxStyles = {
        inputBackground: this.inputBackground,
        inputForeground: this.inputForeground,
        inputBorder: this.inputBorder,
        inputValidationInfoBackground: this.inputValidationInfoBackground,
        inputValidationInfoForeground: this.inputValidationInfoForeground,
        inputValidationInfoBorder: this.inputValidationInfoBorder,
        inputValidationWarningBackground: this.inputValidationWarningBackground,
        inputValidationWarningForeground: this.inputValidationWarningForeground,
        inputValidationWarningBorder: this.inputValidationWarningBorder,
        inputValidationErrorBackground: this.inputValidationErrorBackground,
        inputValidationErrorForeground: this.inputValidationErrorForeground,
        inputValidationErrorBorder: this.inputValidationErrorBorder
      };
      this.inputBox.style(inputBoxStyles);
    }
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getPreserveCase() {
    return this.preserveCase.checked;
  }
  setPreserveCase(value) {
    this.preserveCase.checked = value;
  }
  focusOnPreserve() {
    this.preserveCase.focus();
  }
  validate() {
    if (this.inputBox) {
      this.inputBox.validate();
    }
  }
  set width(newWidth) {
    this.inputBox.paddingRight = this.cachedOptionsWidth;
    this.inputBox.width = newWidth;
    this.domNode.style.width = newWidth + "px";
  }
  dispose() {
    super.dispose();
  }
};

// node_modules/monaco-editor/esm/vs/platform/browser/contextScopedHistoryWidget.js
var __decorate46 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param46 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var HistoryNavigationWidgetContext = "historyNavigationWidget";
var HistoryNavigationForwardsEnablementContext = "historyNavigationForwardsEnabled";
var HistoryNavigationBackwardsEnablementContext = "historyNavigationBackwardsEnabled";
function bindContextScopedWidget(contextKeyService, widget, contextKey) {
  new RawContextKey(contextKey, widget).bindTo(contextKeyService);
}
function createWidgetScopedContextKeyService(contextKeyService, widget) {
  return contextKeyService.createScoped(widget.target);
}
function getContextScopedWidget(contextKeyService, contextKey) {
  return contextKeyService.getContext(document.activeElement).getValue(contextKey);
}
function createAndBindHistoryNavigationWidgetScopedContextKeyService(contextKeyService, widget) {
  const scopedContextKeyService = createWidgetScopedContextKeyService(contextKeyService, widget);
  bindContextScopedWidget(scopedContextKeyService, widget, HistoryNavigationWidgetContext);
  const historyNavigationForwardsEnablement = new RawContextKey(HistoryNavigationForwardsEnablementContext, true).bindTo(scopedContextKeyService);
  const historyNavigationBackwardsEnablement = new RawContextKey(HistoryNavigationBackwardsEnablementContext, true).bindTo(scopedContextKeyService);
  return {
    scopedContextKeyService,
    historyNavigationForwardsEnablement,
    historyNavigationBackwardsEnablement
  };
}
var ContextScopedFindInput = class ContextScopedFindInput2 extends FindInput {
  constructor(container, contextViewProvider, options, contextKeyService, showFindOptions = false) {
    super(container, contextViewProvider, showFindOptions, options);
    this._register(createAndBindHistoryNavigationWidgetScopedContextKeyService(contextKeyService, { target: this.inputBox.element, historyNavigator: this.inputBox }).scopedContextKeyService);
  }
};
ContextScopedFindInput = __decorate46([
  __param46(3, IContextKeyService)
], ContextScopedFindInput);
var ContextScopedReplaceInput = class ContextScopedReplaceInput2 extends ReplaceInput {
  constructor(container, contextViewProvider, options, contextKeyService, showReplaceOptions = false) {
    super(container, contextViewProvider, showReplaceOptions, options);
    this._register(createAndBindHistoryNavigationWidgetScopedContextKeyService(contextKeyService, { target: this.inputBox.element, historyNavigator: this.inputBox }).scopedContextKeyService);
  }
};
ContextScopedReplaceInput = __decorate46([
  __param46(3, IContextKeyService)
], ContextScopedReplaceInput);
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "history.showPrevious",
  weight: 200,
  when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetContext), ContextKeyExpr.equals(HistoryNavigationBackwardsEnablementContext, true), Context.Visible.isEqualTo(false)),
  primary: 16,
  secondary: [512 | 16],
  handler: (accessor) => {
    const widget = getContextScopedWidget(accessor.get(IContextKeyService), HistoryNavigationWidgetContext);
    if (widget) {
      const historyInputBox = widget.historyNavigator;
      historyInputBox.showPreviousValue();
    }
  }
});
KeybindingsRegistry.registerCommandAndKeybindingRule({
  id: "history.showNext",
  weight: 200,
  when: ContextKeyExpr.and(ContextKeyExpr.has(HistoryNavigationWidgetContext), ContextKeyExpr.equals(HistoryNavigationForwardsEnablementContext, true), Context.Visible.isEqualTo(false)),
  primary: 18,
  secondary: [512 | 18],
  handler: (accessor) => {
    const widget = getContextScopedWidget(accessor.get(IContextKeyService), HistoryNavigationWidgetContext);
    if (widget) {
      const historyInputBox = widget.historyNavigator;
      historyInputBox.showNextValue();
    }
  }
});

// node_modules/monaco-editor/esm/vs/platform/browser/historyWidgetKeybindingHint.js
function showHistoryKeybindingHint(keybindingService) {
  var _a5, _b2;
  return ((_a5 = keybindingService.lookupKeybinding("history.showPrevious")) === null || _a5 === void 0 ? void 0 : _a5.getElectronAccelerator()) === "Up" && ((_b2 = keybindingService.lookupKeybinding("history.showNext")) === null || _b2 === void 0 ? void 0 : _b2.getElectronAccelerator()) === "Down";
}

// node_modules/monaco-editor/esm/vs/editor/contrib/find/findWidget.js
var __awaiter30 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var findSelectionIcon = registerIcon("find-selection", Codicon.selection, localize("findSelectionIcon", "Icon for 'Find in Selection' in the editor find widget."));
var findCollapsedIcon = registerIcon("find-collapsed", Codicon.chevronRight, localize("findCollapsedIcon", "Icon to indicate that the editor find widget is collapsed."));
var findExpandedIcon = registerIcon("find-expanded", Codicon.chevronDown, localize("findExpandedIcon", "Icon to indicate that the editor find widget is expanded."));
var findReplaceIcon = registerIcon("find-replace", Codicon.replace, localize("findReplaceIcon", "Icon for 'Replace' in the editor find widget."));
var findReplaceAllIcon = registerIcon("find-replace-all", Codicon.replaceAll, localize("findReplaceAllIcon", "Icon for 'Replace All' in the editor find widget."));
var findPreviousMatchIcon = registerIcon("find-previous-match", Codicon.arrowUp, localize("findPreviousMatchIcon", "Icon for 'Find Previous' in the editor find widget."));
var findNextMatchIcon = registerIcon("find-next-match", Codicon.arrowDown, localize("findNextMatchIcon", "Icon for 'Find Next' in the editor find widget."));
var NLS_FIND_INPUT_LABEL = localize("label.find", "Find");
var NLS_FIND_INPUT_PLACEHOLDER = localize("placeholder.find", "Find");
var NLS_PREVIOUS_MATCH_BTN_LABEL = localize("label.previousMatchButton", "Previous Match");
var NLS_NEXT_MATCH_BTN_LABEL = localize("label.nextMatchButton", "Next Match");
var NLS_TOGGLE_SELECTION_FIND_TITLE = localize("label.toggleSelectionFind", "Find in Selection");
var NLS_CLOSE_BTN_LABEL = localize("label.closeButton", "Close");
var NLS_REPLACE_INPUT_LABEL = localize("label.replace", "Replace");
var NLS_REPLACE_INPUT_PLACEHOLDER = localize("placeholder.replace", "Replace");
var NLS_REPLACE_BTN_LABEL = localize("label.replaceButton", "Replace");
var NLS_REPLACE_ALL_BTN_LABEL = localize("label.replaceAllButton", "Replace All");
var NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = localize("label.toggleReplaceButton", "Toggle Replace");
var NLS_MATCHES_COUNT_LIMIT_TITLE = localize("title.matchesCountLimit", "Only the first {0} results are highlighted, but all find operations work on the entire text.", MATCHES_LIMIT);
var NLS_MATCHES_LOCATION = localize("label.matchesLocation", "{0} of {1}");
var NLS_NO_RESULTS = localize("label.noResults", "No results");
var FIND_WIDGET_INITIAL_WIDTH = 419;
var PART_WIDTH = 275;
var FIND_INPUT_AREA_WIDTH = PART_WIDTH - 54;
var MAX_MATCHES_COUNT_WIDTH = 69;
var FIND_INPUT_AREA_HEIGHT = 33;
var ctrlEnterReplaceAllWarningPromptedKey = "ctrlEnterReplaceAll.windows.donotask";
var ctrlKeyMod = isMacintosh ? 256 : 2048;
var FindWidgetViewZone = class {
  constructor(afterLineNumber) {
    this.afterLineNumber = afterLineNumber;
    this.heightInPx = FIND_INPUT_AREA_HEIGHT;
    this.suppressMouseDown = false;
    this.domNode = document.createElement("div");
    this.domNode.className = "dock-find-viewzone";
  }
};
function stopPropagationForMultiLineUpwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionStart > 0) {
    event.stopPropagation();
    return;
  }
}
function stopPropagationForMultiLineDownwards(event, value, textarea) {
  const isMultiline = !!value.match(/\n/);
  if (textarea && isMultiline && textarea.selectionEnd < textarea.value.length) {
    event.stopPropagation();
    return;
  }
}
var FindWidget = class extends Widget {
  constructor(codeEditor, controller, state, contextViewProvider, keybindingService, contextKeyService, themeService, storageService, notificationService) {
    super();
    this._cachedHeight = null;
    this._revealTimeouts = [];
    this._codeEditor = codeEditor;
    this._controller = controller;
    this._state = state;
    this._contextViewProvider = contextViewProvider;
    this._keybindingService = keybindingService;
    this._contextKeyService = contextKeyService;
    this._storageService = storageService;
    this._notificationService = notificationService;
    this._ctrlEnterReplaceAllWarningPrompted = !!storageService.getBoolean(ctrlEnterReplaceAllWarningPromptedKey, 0);
    this._isVisible = false;
    this._isReplaceVisible = false;
    this._ignoreChangeEvent = false;
    this._updateHistoryDelayer = new Delayer(500);
    this._register(toDisposable(() => this._updateHistoryDelayer.cancel()));
    this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this._buildDomNode();
    this._updateButtons();
    this._tryUpdateWidgetWidth();
    this._findInput.inputBox.layout();
    this._register(this._codeEditor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(80)) {
        if (this._codeEditor.getOption(80)) {
          this._state.change({ isReplaceRevealed: false }, false);
        }
        this._updateButtons();
      }
      if (e.hasChanged(130)) {
        this._tryUpdateWidgetWidth();
      }
      if (e.hasChanged(2)) {
        this.updateAccessibilitySupport();
      }
      if (e.hasChanged(35)) {
        const addExtraSpaceOnTop = this._codeEditor.getOption(35).addExtraSpaceOnTop;
        if (addExtraSpaceOnTop && !this._viewZone) {
          this._viewZone = new FindWidgetViewZone(0);
          this._showViewZone();
        }
        if (!addExtraSpaceOnTop && this._viewZone) {
          this._removeViewZone();
        }
      }
    }));
    this.updateAccessibilitySupport();
    this._register(this._codeEditor.onDidChangeCursorSelection(() => {
      if (this._isVisible) {
        this._updateToggleSelectionFindButton();
      }
    }));
    this._register(this._codeEditor.onDidFocusEditorWidget(() => __awaiter30(this, void 0, void 0, function* () {
      if (this._isVisible) {
        let globalBufferTerm = yield this._controller.getGlobalBufferTerm();
        if (globalBufferTerm && globalBufferTerm !== this._state.searchString) {
          this._state.change({ searchString: globalBufferTerm }, false);
          this._findInput.select();
        }
      }
    })));
    this._findInputFocused = CONTEXT_FIND_INPUT_FOCUSED.bindTo(contextKeyService);
    this._findFocusTracker = this._register(trackFocus(this._findInput.inputBox.inputElement));
    this._register(this._findFocusTracker.onDidFocus(() => {
      this._findInputFocused.set(true);
      this._updateSearchScope();
    }));
    this._register(this._findFocusTracker.onDidBlur(() => {
      this._findInputFocused.set(false);
    }));
    this._replaceInputFocused = CONTEXT_REPLACE_INPUT_FOCUSED.bindTo(contextKeyService);
    this._replaceFocusTracker = this._register(trackFocus(this._replaceInput.inputBox.inputElement));
    this._register(this._replaceFocusTracker.onDidFocus(() => {
      this._replaceInputFocused.set(true);
      this._updateSearchScope();
    }));
    this._register(this._replaceFocusTracker.onDidBlur(() => {
      this._replaceInputFocused.set(false);
    }));
    this._codeEditor.addOverlayWidget(this);
    if (this._codeEditor.getOption(35).addExtraSpaceOnTop) {
      this._viewZone = new FindWidgetViewZone(0);
    }
    this._applyTheme(themeService.getColorTheme());
    this._register(themeService.onDidColorThemeChange(this._applyTheme.bind(this)));
    this._register(this._codeEditor.onDidChangeModel(() => {
      if (!this._isVisible) {
        return;
      }
      this._viewZoneId = void 0;
    }));
    this._register(this._codeEditor.onDidScrollChange((e) => {
      if (e.scrollTopChanged) {
        this._layoutViewZone();
        return;
      }
      setTimeout(() => {
        this._layoutViewZone();
      }, 0);
    }));
  }
  getId() {
    return FindWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    if (this._isVisible) {
      return {
        preference: 0
      };
    }
    return null;
  }
  _onStateChanged(e) {
    if (e.searchString) {
      try {
        this._ignoreChangeEvent = true;
        this._findInput.setValue(this._state.searchString);
      } finally {
        this._ignoreChangeEvent = false;
      }
      this._updateButtons();
    }
    if (e.replaceString) {
      this._replaceInput.inputBox.value = this._state.replaceString;
    }
    if (e.isRevealed) {
      if (this._state.isRevealed) {
        this._reveal();
      } else {
        this._hide(true);
      }
    }
    if (e.isReplaceRevealed) {
      if (this._state.isReplaceRevealed) {
        if (!this._codeEditor.getOption(80) && !this._isReplaceVisible) {
          this._isReplaceVisible = true;
          this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          this._updateButtons();
          this._replaceInput.inputBox.layout();
        }
      } else {
        if (this._isReplaceVisible) {
          this._isReplaceVisible = false;
          this._updateButtons();
        }
      }
    }
    if ((e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed)) {
      if (this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }
    if (e.isRegex) {
      this._findInput.setRegex(this._state.isRegex);
    }
    if (e.wholeWord) {
      this._findInput.setWholeWords(this._state.wholeWord);
    }
    if (e.matchCase) {
      this._findInput.setCaseSensitive(this._state.matchCase);
    }
    if (e.preserveCase) {
      this._replaceInput.setPreserveCase(this._state.preserveCase);
    }
    if (e.searchScope) {
      if (this._state.searchScope) {
        this._toggleSelectionFind.checked = true;
      } else {
        this._toggleSelectionFind.checked = false;
      }
      this._updateToggleSelectionFindButton();
    }
    if (e.searchString || e.matchesCount || e.matchesPosition) {
      let showRedOutline = this._state.searchString.length > 0 && this._state.matchesCount === 0;
      this._domNode.classList.toggle("no-results", showRedOutline);
      this._updateMatchesCount();
      this._updateButtons();
    }
    if (e.searchString || e.currentMatch) {
      this._layoutViewZone();
    }
    if (e.updateHistory) {
      this._delayedUpdateHistory();
    }
    if (e.loop) {
      this._updateButtons();
    }
  }
  _delayedUpdateHistory() {
    this._updateHistoryDelayer.trigger(this._updateHistory.bind(this)).then(void 0, onUnexpectedError);
  }
  _updateHistory() {
    if (this._state.searchString) {
      this._findInput.inputBox.addToHistory();
    }
    if (this._state.replaceString) {
      this._replaceInput.inputBox.addToHistory();
    }
  }
  _updateMatchesCount() {
    this._matchesCount.style.minWidth = MAX_MATCHES_COUNT_WIDTH + "px";
    if (this._state.matchesCount >= MATCHES_LIMIT) {
      this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;
    } else {
      this._matchesCount.title = "";
    }
    if (this._matchesCount.firstChild) {
      this._matchesCount.removeChild(this._matchesCount.firstChild);
    }
    let label;
    if (this._state.matchesCount > 0) {
      let matchesCount = String(this._state.matchesCount);
      if (this._state.matchesCount >= MATCHES_LIMIT) {
        matchesCount += "+";
      }
      let matchesPosition = String(this._state.matchesPosition);
      if (matchesPosition === "0") {
        matchesPosition = "?";
      }
      label = format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);
    } else {
      label = NLS_NO_RESULTS;
    }
    this._matchesCount.appendChild(document.createTextNode(label));
    alert(this._getAriaLabel(label, this._state.currentMatch, this._state.searchString));
    MAX_MATCHES_COUNT_WIDTH = Math.max(MAX_MATCHES_COUNT_WIDTH, this._matchesCount.clientWidth);
  }
  _getAriaLabel(label, currentMatch, searchString) {
    if (label === NLS_NO_RESULTS) {
      return searchString === "" ? localize("ariaSearchNoResultEmpty", "{0} found", label) : localize("ariaSearchNoResult", "{0} found for '{1}'", label, searchString);
    }
    if (currentMatch) {
      const ariaLabel = localize("ariaSearchNoResultWithLineNum", "{0} found for '{1}', at {2}", label, searchString, currentMatch.startLineNumber + ":" + currentMatch.startColumn);
      const model = this._codeEditor.getModel();
      if (model && currentMatch.startLineNumber <= model.getLineCount() && currentMatch.startLineNumber >= 1) {
        const lineContent = model.getLineContent(currentMatch.startLineNumber);
        return `${lineContent}, ${ariaLabel}`;
      }
      return ariaLabel;
    }
    return localize("ariaSearchNoResultWithLineNumNoCurrentMatch", "{0} found for '{1}'", label, searchString);
  }
  _updateToggleSelectionFindButton() {
    let selection = this._codeEditor.getSelection();
    let isSelection = selection ? selection.startLineNumber !== selection.endLineNumber || selection.startColumn !== selection.endColumn : false;
    let isChecked = this._toggleSelectionFind.checked;
    if (this._isVisible && (isChecked || isSelection)) {
      this._toggleSelectionFind.enable();
    } else {
      this._toggleSelectionFind.disable();
    }
  }
  _updateButtons() {
    this._findInput.setEnabled(this._isVisible);
    this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible);
    this._updateToggleSelectionFindButton();
    this._closeBtn.setEnabled(this._isVisible);
    let findInputIsNonEmpty = this._state.searchString.length > 0;
    let matchesCount = this._state.matchesCount ? true : false;
    this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateBack());
    this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty && matchesCount && this._state.canNavigateForward());
    this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
    this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
    this._domNode.classList.toggle("replaceToggled", this._isReplaceVisible);
    this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    let canReplace = !this._codeEditor.getOption(80);
    this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);
  }
  _reveal() {
    this._revealTimeouts.forEach((e) => {
      clearTimeout(e);
    });
    this._revealTimeouts = [];
    if (!this._isVisible) {
      this._isVisible = true;
      const selection = this._codeEditor.getSelection();
      switch (this._codeEditor.getOption(35).autoFindInSelection) {
        case "always":
          this._toggleSelectionFind.checked = true;
          break;
        case "never":
          this._toggleSelectionFind.checked = false;
          break;
        case "multiline":
          const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
          this._toggleSelectionFind.checked = isSelectionMultipleLine;
          break;
        default:
          break;
      }
      this._tryUpdateWidgetWidth();
      this._updateButtons();
      this._revealTimeouts.push(setTimeout(() => {
        this._domNode.classList.add("visible");
        this._domNode.setAttribute("aria-hidden", "false");
      }, 0));
      this._revealTimeouts.push(setTimeout(() => {
        this._findInput.validate();
      }, 200));
      this._codeEditor.layoutOverlayWidget(this);
      let adjustEditorScrollTop = true;
      if (this._codeEditor.getOption(35).seedSearchStringFromSelection && selection) {
        const domNode = this._codeEditor.getDomNode();
        if (domNode) {
          const editorCoords = getDomNodePagePosition(domNode);
          const startCoords = this._codeEditor.getScrolledVisiblePosition(selection.getStartPosition());
          const startLeft = editorCoords.left + (startCoords ? startCoords.left : 0);
          const startTop = startCoords ? startCoords.top : 0;
          if (this._viewZone && startTop < this._viewZone.heightInPx) {
            if (selection.endLineNumber > selection.startLineNumber) {
              adjustEditorScrollTop = false;
            }
            const leftOfFindWidget = getTopLeftOffset(this._domNode).left;
            if (startLeft > leftOfFindWidget) {
              adjustEditorScrollTop = false;
            }
            const endCoords = this._codeEditor.getScrolledVisiblePosition(selection.getEndPosition());
            const endLeft = editorCoords.left + (endCoords ? endCoords.left : 0);
            if (endLeft > leftOfFindWidget) {
              adjustEditorScrollTop = false;
            }
          }
        }
      }
      this._showViewZone(adjustEditorScrollTop);
    }
  }
  _hide(focusTheEditor) {
    this._revealTimeouts.forEach((e) => {
      clearTimeout(e);
    });
    this._revealTimeouts = [];
    if (this._isVisible) {
      this._isVisible = false;
      this._updateButtons();
      this._domNode.classList.remove("visible");
      this._domNode.setAttribute("aria-hidden", "true");
      this._findInput.clearMessage();
      if (focusTheEditor) {
        this._codeEditor.focus();
      }
      this._codeEditor.layoutOverlayWidget(this);
      this._removeViewZone();
    }
  }
  _layoutViewZone(targetScrollTop) {
    const addExtraSpaceOnTop = this._codeEditor.getOption(35).addExtraSpaceOnTop;
    if (!addExtraSpaceOnTop) {
      this._removeViewZone();
      return;
    }
    if (!this._isVisible) {
      return;
    }
    const viewZone = this._viewZone;
    if (this._viewZoneId !== void 0 || !viewZone) {
      return;
    }
    this._codeEditor.changeViewZones((accessor) => {
      viewZone.heightInPx = this._getHeight();
      this._viewZoneId = accessor.addZone(viewZone);
      this._codeEditor.setScrollTop(targetScrollTop || this._codeEditor.getScrollTop() + viewZone.heightInPx);
    });
  }
  _showViewZone(adjustScroll = true) {
    if (!this._isVisible) {
      return;
    }
    const addExtraSpaceOnTop = this._codeEditor.getOption(35).addExtraSpaceOnTop;
    if (!addExtraSpaceOnTop) {
      return;
    }
    if (this._viewZone === void 0) {
      this._viewZone = new FindWidgetViewZone(0);
    }
    const viewZone = this._viewZone;
    this._codeEditor.changeViewZones((accessor) => {
      if (this._viewZoneId !== void 0) {
        const newHeight = this._getHeight();
        if (newHeight === viewZone.heightInPx) {
          return;
        }
        let scrollAdjustment = newHeight - viewZone.heightInPx;
        viewZone.heightInPx = newHeight;
        accessor.layoutZone(this._viewZoneId);
        if (adjustScroll) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
        }
        return;
      } else {
        let scrollAdjustment = this._getHeight();
        scrollAdjustment -= this._codeEditor.getOption(74).top;
        if (scrollAdjustment <= 0) {
          return;
        }
        viewZone.heightInPx = scrollAdjustment;
        this._viewZoneId = accessor.addZone(viewZone);
        if (adjustScroll) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + scrollAdjustment);
        }
      }
    });
  }
  _removeViewZone() {
    this._codeEditor.changeViewZones((accessor) => {
      if (this._viewZoneId !== void 0) {
        accessor.removeZone(this._viewZoneId);
        this._viewZoneId = void 0;
        if (this._viewZone) {
          this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx);
          this._viewZone = void 0;
        }
      }
    });
  }
  _applyTheme(theme) {
    let inputStyles = {
      inputActiveOptionBorder: theme.getColor(inputActiveOptionBorder),
      inputActiveOptionBackground: theme.getColor(inputActiveOptionBackground),
      inputActiveOptionForeground: theme.getColor(inputActiveOptionForeground),
      inputBackground: theme.getColor(inputBackground),
      inputForeground: theme.getColor(inputForeground),
      inputBorder: theme.getColor(inputBorder),
      inputValidationInfoBackground: theme.getColor(inputValidationInfoBackground),
      inputValidationInfoForeground: theme.getColor(inputValidationInfoForeground),
      inputValidationInfoBorder: theme.getColor(inputValidationInfoBorder),
      inputValidationWarningBackground: theme.getColor(inputValidationWarningBackground),
      inputValidationWarningForeground: theme.getColor(inputValidationWarningForeground),
      inputValidationWarningBorder: theme.getColor(inputValidationWarningBorder),
      inputValidationErrorBackground: theme.getColor(inputValidationErrorBackground),
      inputValidationErrorForeground: theme.getColor(inputValidationErrorForeground),
      inputValidationErrorBorder: theme.getColor(inputValidationErrorBorder)
    };
    this._findInput.style(inputStyles);
    this._replaceInput.style(inputStyles);
    this._toggleSelectionFind.style(inputStyles);
  }
  _tryUpdateWidgetWidth() {
    if (!this._isVisible) {
      return;
    }
    if (!isInDOM(this._domNode)) {
      return;
    }
    const layoutInfo = this._codeEditor.getLayoutInfo();
    const editorContentWidth = layoutInfo.contentWidth;
    if (editorContentWidth <= 0) {
      this._domNode.classList.add("hiddenEditor");
      return;
    } else if (this._domNode.classList.contains("hiddenEditor")) {
      this._domNode.classList.remove("hiddenEditor");
    }
    const editorWidth = layoutInfo.width;
    const minimapWidth = layoutInfo.minimap.minimapWidth;
    let collapsedFindWidget = false;
    let reducedFindWidget = false;
    let narrowFindWidget = false;
    if (this._resized) {
      let widgetWidth = getTotalWidth(this._domNode);
      if (widgetWidth > FIND_WIDGET_INITIAL_WIDTH) {
        this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
        return;
      }
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth >= editorWidth) {
      reducedFindWidget = true;
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth) {
      narrowFindWidget = true;
    }
    if (FIND_WIDGET_INITIAL_WIDTH + 28 + minimapWidth - MAX_MATCHES_COUNT_WIDTH >= editorWidth + 50) {
      collapsedFindWidget = true;
    }
    this._domNode.classList.toggle("collapsed-find-widget", collapsedFindWidget);
    this._domNode.classList.toggle("narrow-find-widget", narrowFindWidget);
    this._domNode.classList.toggle("reduced-find-widget", reducedFindWidget);
    if (!narrowFindWidget && !collapsedFindWidget) {
      this._domNode.style.maxWidth = `${editorWidth - 28 - minimapWidth - 15}px`;
    }
    if (this._resized) {
      this._findInput.inputBox.layout();
      let findInputWidth = this._findInput.inputBox.element.clientWidth;
      if (findInputWidth > 0) {
        this._replaceInput.width = findInputWidth;
      }
    } else if (this._isReplaceVisible) {
      this._replaceInput.width = getTotalWidth(this._findInput.domNode);
    }
  }
  _getHeight() {
    let totalheight = 0;
    totalheight += 4;
    totalheight += this._findInput.inputBox.height + 2;
    if (this._isReplaceVisible) {
      totalheight += 4;
      totalheight += this._replaceInput.inputBox.height + 2;
    }
    totalheight += 4;
    return totalheight;
  }
  _tryUpdateHeight() {
    const totalHeight = this._getHeight();
    if (this._cachedHeight !== null && this._cachedHeight === totalHeight) {
      return false;
    }
    this._cachedHeight = totalHeight;
    this._domNode.style.height = `${totalHeight}px`;
    return true;
  }
  focusFindInput() {
    this._findInput.select();
    this._findInput.focus();
  }
  focusReplaceInput() {
    this._replaceInput.select();
    this._replaceInput.focus();
  }
  highlightFindOptions() {
    this._findInput.highlightFindOptions();
  }
  _updateSearchScope() {
    if (!this._codeEditor.hasModel()) {
      return;
    }
    if (this._toggleSelectionFind.checked) {
      let selections = this._codeEditor.getSelections();
      selections.map((selection) => {
        if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
          selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
        }
        const currentMatch = this._state.currentMatch;
        if (selection.startLineNumber !== selection.endLineNumber) {
          if (!Range.equalsRange(selection, currentMatch)) {
            return selection;
          }
        }
        return null;
      }).filter((element) => !!element);
      if (selections.length) {
        this._state.change({ searchScope: selections }, true);
      }
    }
  }
  _onFindInputMouseDown(e) {
    if (e.middleButton) {
      e.stopPropagation();
    }
  }
  _onFindInputKeyDown(e) {
    if (e.equals(ctrlKeyMod | 3)) {
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        this._findInput.inputBox.insertAtCursor("\n");
        e.preventDefault();
        return;
      }
    }
    if (e.equals(2)) {
      if (this._isReplaceVisible) {
        this._replaceInput.focus();
      } else {
        this._findInput.focusOnCaseSensitive();
      }
      e.preventDefault();
      return;
    }
    if (e.equals(2048 | 18)) {
      this._codeEditor.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(16)) {
      return stopPropagationForMultiLineUpwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    }
    if (e.equals(18)) {
      return stopPropagationForMultiLineDownwards(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    }
  }
  _onReplaceInputKeyDown(e) {
    if (e.equals(ctrlKeyMod | 3)) {
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        if (isWindows && isNative && !this._ctrlEnterReplaceAllWarningPrompted) {
          this._notificationService.info(localize("ctrlEnter.keybindingChanged", "Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior."));
          this._ctrlEnterReplaceAllWarningPrompted = true;
          this._storageService.store(ctrlEnterReplaceAllWarningPromptedKey, true, 0, 0);
        }
        this._replaceInput.inputBox.insertAtCursor("\n");
        e.preventDefault();
        return;
      }
    }
    if (e.equals(2)) {
      this._findInput.focusOnCaseSensitive();
      e.preventDefault();
      return;
    }
    if (e.equals(1024 | 2)) {
      this._findInput.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(2048 | 18)) {
      this._codeEditor.focus();
      e.preventDefault();
      return;
    }
    if (e.equals(16)) {
      return stopPropagationForMultiLineUpwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    }
    if (e.equals(18)) {
      return stopPropagationForMultiLineDownwards(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    }
  }
  getVerticalSashLeft(_sash) {
    return 0;
  }
  _keybindingLabelFor(actionId) {
    let kb = this._keybindingService.lookupKeybinding(actionId);
    if (!kb) {
      return "";
    }
    return ` (${kb.getLabel()})`;
  }
  _buildDomNode() {
    const flexibleHeight = true;
    const flexibleWidth = true;
    this._findInput = this._register(new ContextScopedFindInput(null, this._contextViewProvider, {
      width: FIND_INPUT_AREA_WIDTH,
      label: NLS_FIND_INPUT_LABEL,
      placeholder: NLS_FIND_INPUT_PLACEHOLDER,
      appendCaseSensitiveLabel: this._keybindingLabelFor(FIND_IDS.ToggleCaseSensitiveCommand),
      appendWholeWordsLabel: this._keybindingLabelFor(FIND_IDS.ToggleWholeWordCommand),
      appendRegexLabel: this._keybindingLabelFor(FIND_IDS.ToggleRegexCommand),
      validation: (value) => {
        if (value.length === 0 || !this._findInput.getRegex()) {
          return null;
        }
        try {
          new RegExp(value, "gu");
          return null;
        } catch (e) {
          return { content: e.message };
        }
      },
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight: 118,
      showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService)
    }, this._contextKeyService, true));
    this._findInput.setRegex(!!this._state.isRegex);
    this._findInput.setCaseSensitive(!!this._state.matchCase);
    this._findInput.setWholeWords(!!this._state.wholeWord);
    this._register(this._findInput.onKeyDown((e) => this._onFindInputKeyDown(e)));
    this._register(this._findInput.inputBox.onDidChange(() => {
      if (this._ignoreChangeEvent) {
        return;
      }
      this._state.change({ searchString: this._findInput.getValue() }, true);
    }));
    this._register(this._findInput.onDidOptionChange(() => {
      this._state.change({
        isRegex: this._findInput.getRegex(),
        wholeWord: this._findInput.getWholeWords(),
        matchCase: this._findInput.getCaseSensitive()
      }, true);
    }));
    this._register(this._findInput.onCaseSensitiveKeyDown((e) => {
      if (e.equals(1024 | 2)) {
        if (this._isReplaceVisible) {
          this._replaceInput.focus();
          e.preventDefault();
        }
      }
    }));
    this._register(this._findInput.onRegexKeyDown((e) => {
      if (e.equals(2)) {
        if (this._isReplaceVisible) {
          this._replaceInput.focusOnPreserve();
          e.preventDefault();
        }
      }
    }));
    this._register(this._findInput.inputBox.onDidHeightChange((e) => {
      if (this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }));
    if (isLinux) {
      this._register(this._findInput.onMouseDown((e) => this._onFindInputMouseDown(e)));
    }
    this._matchesCount = document.createElement("div");
    this._matchesCount.className = "matchesCount";
    this._updateMatchesCount();
    this._prevBtn = this._register(new SimpleButton({
      label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.PreviousMatchFindAction),
      icon: findPreviousMatchIcon,
      onTrigger: () => {
        this._codeEditor.getAction(FIND_IDS.PreviousMatchFindAction).run().then(void 0, onUnexpectedError);
      }
    }));
    this._nextBtn = this._register(new SimpleButton({
      label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.NextMatchFindAction),
      icon: findNextMatchIcon,
      onTrigger: () => {
        this._codeEditor.getAction(FIND_IDS.NextMatchFindAction).run().then(void 0, onUnexpectedError);
      }
    }));
    let findPart = document.createElement("div");
    findPart.className = "find-part";
    findPart.appendChild(this._findInput.domNode);
    const actionsContainer = document.createElement("div");
    actionsContainer.className = "find-actions";
    findPart.appendChild(actionsContainer);
    actionsContainer.appendChild(this._matchesCount);
    actionsContainer.appendChild(this._prevBtn.domNode);
    actionsContainer.appendChild(this._nextBtn.domNode);
    this._toggleSelectionFind = this._register(new Checkbox({
      icon: findSelectionIcon,
      title: NLS_TOGGLE_SELECTION_FIND_TITLE + this._keybindingLabelFor(FIND_IDS.ToggleSearchScopeCommand),
      isChecked: false
    }));
    this._register(this._toggleSelectionFind.onChange(() => {
      if (this._toggleSelectionFind.checked) {
        if (this._codeEditor.hasModel()) {
          let selections = this._codeEditor.getSelections();
          selections.map((selection) => {
            if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
              selection = selection.setEndPosition(selection.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
            }
            if (!selection.isEmpty()) {
              return selection;
            }
            return null;
          }).filter((element) => !!element);
          if (selections.length) {
            this._state.change({ searchScope: selections }, true);
          }
        }
      } else {
        this._state.change({ searchScope: null }, true);
      }
    }));
    actionsContainer.appendChild(this._toggleSelectionFind.domNode);
    this._closeBtn = this._register(new SimpleButton({
      label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.CloseFindWidgetCommand),
      icon: widgetClose,
      onTrigger: () => {
        this._state.change({ isRevealed: false, searchScope: null }, false);
      },
      onKeyDown: (e) => {
        if (e.equals(2)) {
          if (this._isReplaceVisible) {
            if (this._replaceBtn.isEnabled()) {
              this._replaceBtn.focus();
            } else {
              this._codeEditor.focus();
            }
            e.preventDefault();
          }
        }
      }
    }));
    actionsContainer.appendChild(this._closeBtn.domNode);
    this._replaceInput = this._register(new ContextScopedReplaceInput(null, void 0, {
      label: NLS_REPLACE_INPUT_LABEL,
      placeholder: NLS_REPLACE_INPUT_PLACEHOLDER,
      appendPreserveCaseLabel: this._keybindingLabelFor(FIND_IDS.TogglePreserveCaseCommand),
      history: [],
      flexibleHeight,
      flexibleWidth,
      flexibleMaxHeight: 118,
      showHistoryHint: () => showHistoryKeybindingHint(this._keybindingService)
    }, this._contextKeyService, true));
    this._replaceInput.setPreserveCase(!!this._state.preserveCase);
    this._register(this._replaceInput.onKeyDown((e) => this._onReplaceInputKeyDown(e)));
    this._register(this._replaceInput.inputBox.onDidChange(() => {
      this._state.change({ replaceString: this._replaceInput.inputBox.value }, false);
    }));
    this._register(this._replaceInput.inputBox.onDidHeightChange((e) => {
      if (this._isReplaceVisible && this._tryUpdateHeight()) {
        this._showViewZone();
      }
    }));
    this._register(this._replaceInput.onDidOptionChange(() => {
      this._state.change({
        preserveCase: this._replaceInput.getPreserveCase()
      }, true);
    }));
    this._register(this._replaceInput.onPreserveCaseKeyDown((e) => {
      if (e.equals(2)) {
        if (this._prevBtn.isEnabled()) {
          this._prevBtn.focus();
        } else if (this._nextBtn.isEnabled()) {
          this._nextBtn.focus();
        } else if (this._toggleSelectionFind.enabled) {
          this._toggleSelectionFind.focus();
        } else if (this._closeBtn.isEnabled()) {
          this._closeBtn.focus();
        }
        e.preventDefault();
      }
    }));
    this._replaceBtn = this._register(new SimpleButton({
      label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceOneAction),
      icon: findReplaceIcon,
      onTrigger: () => {
        this._controller.replace();
      },
      onKeyDown: (e) => {
        if (e.equals(1024 | 2)) {
          this._closeBtn.focus();
          e.preventDefault();
        }
      }
    }));
    this._replaceAllBtn = this._register(new SimpleButton({
      label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(FIND_IDS.ReplaceAllAction),
      icon: findReplaceAllIcon,
      onTrigger: () => {
        this._controller.replaceAll();
      }
    }));
    let replacePart = document.createElement("div");
    replacePart.className = "replace-part";
    replacePart.appendChild(this._replaceInput.domNode);
    const replaceActionsContainer = document.createElement("div");
    replaceActionsContainer.className = "replace-actions";
    replacePart.appendChild(replaceActionsContainer);
    replaceActionsContainer.appendChild(this._replaceBtn.domNode);
    replaceActionsContainer.appendChild(this._replaceAllBtn.domNode);
    this._toggleReplaceBtn = this._register(new SimpleButton({
      label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,
      className: "codicon toggle left",
      onTrigger: () => {
        this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, false);
        if (this._isReplaceVisible) {
          this._replaceInput.width = getTotalWidth(this._findInput.domNode);
          this._replaceInput.inputBox.layout();
        }
        this._showViewZone();
      }
    }));
    this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    this._domNode = document.createElement("div");
    this._domNode.className = "editor-widget find-widget";
    this._domNode.setAttribute("aria-hidden", "true");
    this._domNode.style.width = `${FIND_WIDGET_INITIAL_WIDTH}px`;
    this._domNode.appendChild(this._toggleReplaceBtn.domNode);
    this._domNode.appendChild(findPart);
    this._domNode.appendChild(replacePart);
    this._resizeSash = new Sash(this._domNode, this, { orientation: 0, size: 2 });
    this._resized = false;
    let originalWidth = FIND_WIDGET_INITIAL_WIDTH;
    this._register(this._resizeSash.onDidStart(() => {
      originalWidth = getTotalWidth(this._domNode);
    }));
    this._register(this._resizeSash.onDidChange((evt) => {
      this._resized = true;
      let width = originalWidth + evt.startX - evt.currentX;
      if (width < FIND_WIDGET_INITIAL_WIDTH) {
        return;
      }
      const maxWidth = parseFloat(getComputedStyle(this._domNode).maxWidth) || 0;
      if (width > maxWidth) {
        return;
      }
      this._domNode.style.width = `${width}px`;
      if (this._isReplaceVisible) {
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
      }
      this._findInput.inputBox.layout();
      this._tryUpdateHeight();
    }));
    this._register(this._resizeSash.onDidReset(() => {
      const currentWidth = getTotalWidth(this._domNode);
      if (currentWidth < FIND_WIDGET_INITIAL_WIDTH) {
        return;
      }
      let width = FIND_WIDGET_INITIAL_WIDTH;
      if (!this._resized || currentWidth === FIND_WIDGET_INITIAL_WIDTH) {
        const layoutInfo = this._codeEditor.getLayoutInfo();
        width = layoutInfo.width - 28 - layoutInfo.minimap.minimapWidth - 15;
        this._resized = true;
      } else {
      }
      this._domNode.style.width = `${width}px`;
      if (this._isReplaceVisible) {
        this._replaceInput.width = getTotalWidth(this._findInput.domNode);
      }
      this._findInput.inputBox.layout();
    }));
  }
  updateAccessibilitySupport() {
    const value = this._codeEditor.getOption(2);
    this._findInput.setFocusInputOnOptionClick(value !== 2);
  }
};
FindWidget.ID = "editor.contrib.findWidget";
var SimpleButton = class extends Widget {
  constructor(opts) {
    super();
    this._opts = opts;
    let className = "button";
    if (this._opts.className) {
      className = className + " " + this._opts.className;
    }
    if (this._opts.icon) {
      className = className + " " + ThemeIcon.asClassName(this._opts.icon);
    }
    this._domNode = document.createElement("div");
    this._domNode.title = this._opts.label;
    this._domNode.tabIndex = 0;
    this._domNode.className = className;
    this._domNode.setAttribute("role", "button");
    this._domNode.setAttribute("aria-label", this._opts.label);
    this.onclick(this._domNode, (e) => {
      this._opts.onTrigger();
      e.preventDefault();
    });
    this.onkeydown(this._domNode, (e) => {
      if (e.equals(10) || e.equals(3)) {
        this._opts.onTrigger();
        e.preventDefault();
        return;
      }
      if (this._opts.onKeyDown) {
        this._opts.onKeyDown(e);
      }
    });
  }
  get domNode() {
    return this._domNode;
  }
  isEnabled() {
    return this._domNode.tabIndex >= 0;
  }
  focus() {
    this._domNode.focus();
  }
  setEnabled(enabled) {
    this._domNode.classList.toggle("disabled", !enabled);
    this._domNode.setAttribute("aria-disabled", String(!enabled));
    this._domNode.tabIndex = enabled ? 0 : -1;
  }
  setExpanded(expanded) {
    this._domNode.setAttribute("aria-expanded", String(!!expanded));
    if (expanded) {
      this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findCollapsedIcon));
      this._domNode.classList.add(...ThemeIcon.asClassNameArray(findExpandedIcon));
    } else {
      this._domNode.classList.remove(...ThemeIcon.asClassNameArray(findExpandedIcon));
      this._domNode.classList.add(...ThemeIcon.asClassNameArray(findCollapsedIcon));
    }
  }
};
registerThemingParticipant((theme, collector) => {
  const addBackgroundColorRule = (selector, color) => {
    if (color) {
      collector.addRule(`.monaco-editor ${selector} { background-color: ${color}; }`);
    }
  };
  addBackgroundColorRule(".findMatch", theme.getColor(editorFindMatchHighlight));
  addBackgroundColorRule(".currentFindMatch", theme.getColor(editorFindMatch));
  addBackgroundColorRule(".findScope", theme.getColor(editorFindRangeHighlight));
  const widgetBackground = theme.getColor(editorWidgetBackground);
  addBackgroundColorRule(".find-widget", widgetBackground);
  const widgetShadowColor = theme.getColor(widgetShadow);
  if (widgetShadowColor) {
    collector.addRule(`.monaco-editor .find-widget { box-shadow: 0 0 8px 2px ${widgetShadowColor}; }`);
  }
  const findMatchHighlightBorder = theme.getColor(editorFindMatchHighlightBorder);
  if (findMatchHighlightBorder) {
    collector.addRule(`.monaco-editor .findMatch { border: 1px ${theme.type === "hc" ? "dotted" : "solid"} ${findMatchHighlightBorder}; box-sizing: border-box; }`);
  }
  const findMatchBorder = theme.getColor(editorFindMatchBorder);
  if (findMatchBorder) {
    collector.addRule(`.monaco-editor .currentFindMatch { border: 2px solid ${findMatchBorder}; padding: 1px; box-sizing: border-box; }`);
  }
  const findRangeHighlightBorder = theme.getColor(editorFindRangeHighlightBorder);
  if (findRangeHighlightBorder) {
    collector.addRule(`.monaco-editor .findScope { border: 1px ${theme.type === "hc" ? "dashed" : "solid"} ${findRangeHighlightBorder}; }`);
  }
  const hcBorder = theme.getColor(contrastBorder);
  if (hcBorder) {
    collector.addRule(`.monaco-editor .find-widget { border: 1px solid ${hcBorder}; }`);
  }
  const foreground2 = theme.getColor(editorWidgetForeground);
  if (foreground2) {
    collector.addRule(`.monaco-editor .find-widget { color: ${foreground2}; }`);
  }
  const error = theme.getColor(errorForeground);
  if (error) {
    collector.addRule(`.monaco-editor .find-widget.no-results .matchesCount { color: ${error}; }`);
  }
  const resizeBorderBackground = theme.getColor(editorWidgetResizeBorder);
  if (resizeBorderBackground) {
    collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${resizeBorderBackground}; }`);
  } else {
    const border = theme.getColor(editorWidgetBorder);
    if (border) {
      collector.addRule(`.monaco-editor .find-widget .monaco-sash { background-color: ${border}; }`);
    }
  }
  const toolbarHoverBackgroundColor = theme.getColor(toolbarHoverBackground);
  if (toolbarHoverBackgroundColor) {
    collector.addRule(`
		.monaco-editor .find-widget .button:not(.disabled):hover,
		.monaco-editor .find-widget .codicon-find-selection:hover {
			background-color: ${toolbarHoverBackgroundColor} !important;
		}
	`);
  }
  const focusOutline = theme.getColor(focusBorder);
  if (focusOutline) {
    collector.addRule(`.monaco-editor .find-widget .monaco-inputbox.synthetic-focus { outline-color: ${focusOutline}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/find/findController.js
var __decorate47 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param47 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter31 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SEARCH_STRING_MAX_LENGTH = 524288;
function getSelectionSearchString(editor2, seedSearchStringFromSelection = "single", seedSearchStringFromNonEmptySelection = false) {
  if (!editor2.hasModel()) {
    return null;
  }
  const selection = editor2.getSelection();
  if (seedSearchStringFromSelection === "single" && selection.startLineNumber === selection.endLineNumber || seedSearchStringFromSelection === "multiple") {
    if (selection.isEmpty()) {
      const wordAtPosition = editor2.getConfiguredWordAtPosition(selection.getStartPosition());
      if (wordAtPosition && seedSearchStringFromNonEmptySelection === false) {
        return wordAtPosition.word;
      }
    } else {
      if (editor2.getModel().getValueLengthInRange(selection) < SEARCH_STRING_MAX_LENGTH) {
        return editor2.getModel().getValueInRange(selection);
      }
    }
  }
  return null;
}
var CommonFindController = class CommonFindController2 extends Disposable {
  constructor(editor2, contextKeyService, storageService, clipboardService) {
    super();
    this._editor = editor2;
    this._findWidgetVisible = CONTEXT_FIND_WIDGET_VISIBLE.bindTo(contextKeyService);
    this._contextKeyService = contextKeyService;
    this._storageService = storageService;
    this._clipboardService = clipboardService;
    this._updateHistoryDelayer = new Delayer(500);
    this._state = this._register(new FindReplaceState());
    this.loadQueryState();
    this._register(this._state.onFindReplaceStateChange((e) => this._onStateChanged(e)));
    this._model = null;
    this._register(this._editor.onDidChangeModel(() => {
      let shouldRestartFind = this._editor.getModel() && this._state.isRevealed;
      this.disposeModel();
      this._state.change({
        searchScope: null,
        matchCase: this._storageService.getBoolean("editor.matchCase", 1, false),
        wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, false),
        isRegex: this._storageService.getBoolean("editor.isRegex", 1, false),
        preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, false)
      }, false);
      if (shouldRestartFind) {
        this._start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: "none",
          seedSearchStringFromNonEmptySelection: false,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: false,
          updateSearchScope: false,
          loop: this._editor.getOption(35).loop
        });
      }
    }));
  }
  get editor() {
    return this._editor;
  }
  static get(editor2) {
    return editor2.getContribution(CommonFindController2.ID);
  }
  dispose() {
    this.disposeModel();
    super.dispose();
  }
  disposeModel() {
    if (this._model) {
      this._model.dispose();
      this._model = null;
    }
  }
  _onStateChanged(e) {
    this.saveQueryState(e);
    if (e.isRevealed) {
      if (this._state.isRevealed) {
        this._findWidgetVisible.set(true);
      } else {
        this._findWidgetVisible.reset();
        this.disposeModel();
      }
    }
    if (e.searchString) {
      this.setGlobalBufferTerm(this._state.searchString);
    }
  }
  saveQueryState(e) {
    if (e.isRegex) {
      this._storageService.store("editor.isRegex", this._state.actualIsRegex, 1, 0);
    }
    if (e.wholeWord) {
      this._storageService.store("editor.wholeWord", this._state.actualWholeWord, 1, 0);
    }
    if (e.matchCase) {
      this._storageService.store("editor.matchCase", this._state.actualMatchCase, 1, 0);
    }
    if (e.preserveCase) {
      this._storageService.store("editor.preserveCase", this._state.actualPreserveCase, 1, 0);
    }
  }
  loadQueryState() {
    this._state.change({
      matchCase: this._storageService.getBoolean("editor.matchCase", 1, this._state.matchCase),
      wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, this._state.wholeWord),
      isRegex: this._storageService.getBoolean("editor.isRegex", 1, this._state.isRegex),
      preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, this._state.preserveCase)
    }, false);
  }
  isFindInputFocused() {
    return !!CONTEXT_FIND_INPUT_FOCUSED.getValue(this._contextKeyService);
  }
  getState() {
    return this._state;
  }
  closeFindWidget() {
    this._state.change({
      isRevealed: false,
      searchScope: null
    }, false);
    this._editor.focus();
  }
  toggleCaseSensitive() {
    this._state.change({ matchCase: !this._state.matchCase }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleWholeWords() {
    this._state.change({ wholeWord: !this._state.wholeWord }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleRegex() {
    this._state.change({ isRegex: !this._state.isRegex }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  togglePreserveCase() {
    this._state.change({ preserveCase: !this._state.preserveCase }, false);
    if (!this._state.isRevealed) {
      this.highlightFindOptions();
    }
  }
  toggleSearchScope() {
    if (this._state.searchScope) {
      this._state.change({ searchScope: null }, true);
    } else {
      if (this._editor.hasModel()) {
        let selections = this._editor.getSelections();
        selections.map((selection) => {
          if (selection.endColumn === 1 && selection.endLineNumber > selection.startLineNumber) {
            selection = selection.setEndPosition(selection.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(selection.endLineNumber - 1));
          }
          if (!selection.isEmpty()) {
            return selection;
          }
          return null;
        }).filter((element) => !!element);
        if (selections.length) {
          this._state.change({ searchScope: selections }, true);
        }
      }
    }
  }
  setSearchString(searchString) {
    if (this._state.isRegex) {
      searchString = escapeRegExpCharacters(searchString);
    }
    this._state.change({ searchString }, false);
  }
  highlightFindOptions(ignoreWhenVisible = false) {
  }
  _start(opts, newState) {
    return __awaiter31(this, void 0, void 0, function* () {
      this.disposeModel();
      if (!this._editor.hasModel()) {
        return;
      }
      let stateChanges = Object.assign(Object.assign({}, newState), { isRevealed: true });
      if (opts.seedSearchStringFromSelection === "single") {
        let selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection, opts.seedSearchStringFromNonEmptySelection);
        if (selectionSearchString) {
          if (this._state.isRegex) {
            stateChanges.searchString = escapeRegExpCharacters(selectionSearchString);
          } else {
            stateChanges.searchString = selectionSearchString;
          }
        }
      } else if (opts.seedSearchStringFromSelection === "multiple" && !opts.updateSearchScope) {
        let selectionSearchString = getSelectionSearchString(this._editor, opts.seedSearchStringFromSelection);
        if (selectionSearchString) {
          stateChanges.searchString = selectionSearchString;
        }
      }
      if (!stateChanges.searchString && opts.seedSearchStringFromGlobalClipboard) {
        let selectionSearchString = yield this.getGlobalBufferTerm();
        if (!this._editor.hasModel()) {
          return;
        }
        if (selectionSearchString) {
          stateChanges.searchString = selectionSearchString;
        }
      }
      if (opts.forceRevealReplace || stateChanges.isReplaceRevealed) {
        stateChanges.isReplaceRevealed = true;
      } else if (!this._findWidgetVisible.get()) {
        stateChanges.isReplaceRevealed = false;
      }
      if (opts.updateSearchScope) {
        let currentSelections = this._editor.getSelections();
        if (currentSelections.some((selection) => !selection.isEmpty())) {
          stateChanges.searchScope = currentSelections;
        }
      }
      stateChanges.loop = opts.loop;
      this._state.change(stateChanges, false);
      if (!this._model) {
        this._model = new FindModelBoundToEditorModel(this._editor, this._state);
      }
    });
  }
  start(opts, newState) {
    return this._start(opts, newState);
  }
  moveToNextMatch() {
    if (this._model) {
      this._model.moveToNextMatch();
      return true;
    }
    return false;
  }
  moveToPrevMatch() {
    if (this._model) {
      this._model.moveToPrevMatch();
      return true;
    }
    return false;
  }
  replace() {
    if (this._model) {
      this._model.replace();
      return true;
    }
    return false;
  }
  replaceAll() {
    if (this._model) {
      this._model.replaceAll();
      return true;
    }
    return false;
  }
  selectAllMatches() {
    if (this._model) {
      this._model.selectAllMatches();
      this._editor.focus();
      return true;
    }
    return false;
  }
  getGlobalBufferTerm() {
    return __awaiter31(this, void 0, void 0, function* () {
      if (this._editor.getOption(35).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
        return this._clipboardService.readFindText();
      }
      return "";
    });
  }
  setGlobalBufferTerm(text2) {
    if (this._editor.getOption(35).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing()) {
      this._clipboardService.writeFindText(text2);
    }
  }
};
CommonFindController.ID = "editor.contrib.findController";
CommonFindController = __decorate47([
  __param47(1, IContextKeyService),
  __param47(2, IStorageService),
  __param47(3, IClipboardService)
], CommonFindController);
var FindController = class FindController2 extends CommonFindController {
  constructor(editor2, _contextViewService, _contextKeyService, _keybindingService, _themeService, _notificationService, _storageService, clipboardService) {
    super(editor2, _contextKeyService, _storageService, clipboardService);
    this._contextViewService = _contextViewService;
    this._keybindingService = _keybindingService;
    this._themeService = _themeService;
    this._notificationService = _notificationService;
    this._widget = null;
    this._findOptionsWidget = null;
  }
  _start(opts, newState) {
    const _super = Object.create(null, {
      _start: { get: () => super._start }
    });
    return __awaiter31(this, void 0, void 0, function* () {
      if (!this._widget) {
        this._createFindWidget();
      }
      const selection = this._editor.getSelection();
      let updateSearchScope = false;
      switch (this._editor.getOption(35).autoFindInSelection) {
        case "always":
          updateSearchScope = true;
          break;
        case "never":
          updateSearchScope = false;
          break;
        case "multiline":
          const isSelectionMultipleLine = !!selection && selection.startLineNumber !== selection.endLineNumber;
          updateSearchScope = isSelectionMultipleLine;
          break;
        default:
          break;
      }
      opts.updateSearchScope = opts.updateSearchScope || updateSearchScope;
      yield _super._start.call(this, opts, newState);
      if (this._widget) {
        if (opts.shouldFocus === 2) {
          this._widget.focusReplaceInput();
        } else if (opts.shouldFocus === 1) {
          this._widget.focusFindInput();
        }
      }
    });
  }
  highlightFindOptions(ignoreWhenVisible = false) {
    if (!this._widget) {
      this._createFindWidget();
    }
    if (this._state.isRevealed && !ignoreWhenVisible) {
      this._widget.highlightFindOptions();
    } else {
      this._findOptionsWidget.highlightFindOptions();
    }
  }
  _createFindWidget() {
    this._widget = this._register(new FindWidget(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService));
    this._findOptionsWidget = this._register(new FindOptionsWidget(this._editor, this._state, this._keybindingService, this._themeService));
  }
};
FindController = __decorate47([
  __param47(1, IContextViewService),
  __param47(2, IContextKeyService),
  __param47(3, IKeybindingService),
  __param47(4, IThemeService),
  __param47(5, INotificationService),
  __param47(6, IStorageService),
  __param47(7, IClipboardService)
], FindController);
var StartFindAction = registerMultiEditorAction(new MultiEditorAction({
  id: FIND_IDS.StartFindAction,
  label: localize("startFindAction", "Find"),
  alias: "Find",
  precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2048 | 36,
    weight: 100
  },
  menuOpts: {
    menuId: MenuId.MenubarEditMenu,
    group: "3_find",
    title: localize({ key: "miFind", comment: ["&& denotes a mnemonic"] }, "&&Find"),
    order: 1
  }
}));
StartFindAction.addImplementation(0, (accessor, editor2, args) => {
  const controller = CommonFindController.get(editor2);
  if (!controller) {
    return false;
  }
  return controller.start({
    forceRevealReplace: false,
    seedSearchStringFromSelection: editor2.getOption(35).seedSearchStringFromSelection !== "never" ? "single" : "none",
    seedSearchStringFromNonEmptySelection: editor2.getOption(35).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: editor2.getOption(35).globalFindClipboard,
    shouldFocus: 1,
    shouldAnimate: true,
    updateSearchScope: false,
    loop: editor2.getOption(35).loop
  });
});
var findArgDescription = {
  description: "Open a new In-Editor Find Widget.",
  args: [{
    name: "Open a new In-Editor Find Widget args",
    schema: {
      properties: {
        searchString: { type: "string" },
        replaceString: { type: "string" },
        regex: { type: "boolean" },
        regexOverride: {
          type: "number",
          description: localize("actions.find.isRegexOverride", 'Overrides "Use Regular Expression" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        wholeWord: { type: "boolean" },
        wholeWordOverride: {
          type: "number",
          description: localize("actions.find.wholeWordOverride", 'Overrides "Match Whole Word" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        matchCase: { type: "boolean" },
        matchCaseOverride: {
          type: "number",
          description: localize("actions.find.matchCaseOverride", 'Overrides "Math Case" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        preserveCase: { type: "boolean" },
        preserveCaseOverride: {
          type: "number",
          description: localize("actions.find.preserveCaseOverride", 'Overrides "Preserve Case" flag.\nThe flag will not be saved for the future.\n0: Do Nothing\n1: True\n2: False')
        },
        findInSelection: { type: "boolean" }
      }
    }
  }]
};
var StartFindWithArgsAction = class extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.StartFindWithArgs,
      label: localize("startFindWithArgsAction", "Find With Arguments"),
      alias: "Find With Arguments",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        weight: 100
      },
      description: findArgDescription
    });
  }
  run(accessor, editor2, args) {
    return __awaiter31(this, void 0, void 0, function* () {
      let controller = CommonFindController.get(editor2);
      if (controller) {
        const newState = args ? {
          searchString: args.searchString,
          replaceString: args.replaceString,
          isReplaceRevealed: args.replaceString !== void 0,
          isRegex: args.isRegex,
          wholeWord: args.matchWholeWord,
          matchCase: args.isCaseSensitive,
          preserveCase: args.preserveCase
        } : {};
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor2.getOption(35).seedSearchStringFromSelection !== "never" ? "single" : "none",
          seedSearchStringFromNonEmptySelection: editor2.getOption(35).seedSearchStringFromSelection === "selection",
          seedSearchStringFromGlobalClipboard: true,
          shouldFocus: 1,
          shouldAnimate: true,
          updateSearchScope: (args === null || args === void 0 ? void 0 : args.findInSelection) || false,
          loop: editor2.getOption(35).loop
        }, newState);
        controller.setGlobalBufferTerm(controller.getState().searchString);
      }
    });
  }
};
var StartFindWithSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: FIND_IDS.StartFindWithSelection,
      label: localize("startFindWithSelectionAction", "Find With Selection"),
      alias: "Find With Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        mac: {
          primary: 2048 | 35
        },
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter31(this, void 0, void 0, function* () {
      let controller = CommonFindController.get(editor2);
      if (controller) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: "multiple",
          seedSearchStringFromNonEmptySelection: false,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor2.getOption(35).loop
        });
        controller.setGlobalBufferTerm(controller.getState().searchString);
      }
    });
  }
};
var MatchFindAction = class extends EditorAction {
  run(accessor, editor2) {
    return __awaiter31(this, void 0, void 0, function* () {
      let controller = CommonFindController.get(editor2);
      if (controller && !this._run(controller)) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: controller.getState().searchString.length === 0 && editor2.getOption(35).seedSearchStringFromSelection !== "never" ? "single" : "none",
          seedSearchStringFromNonEmptySelection: editor2.getOption(35).seedSearchStringFromSelection === "selection",
          seedSearchStringFromGlobalClipboard: true,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor2.getOption(35).loop
        });
        this._run(controller);
      }
    });
  }
};
var NextMatchFindAction = class extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.NextMatchFindAction,
      label: localize("findNextMatchAction", "Find Next"),
      alias: "Find Next",
      precondition: void 0,
      kbOpts: [{
        kbExpr: EditorContextKeys.focus,
        primary: 61,
        mac: { primary: 2048 | 37, secondary: [61] },
        weight: 100
      }, {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
        primary: 3,
        weight: 100
      }]
    });
  }
  _run(controller) {
    const result = controller.moveToNextMatch();
    if (result) {
      controller.editor.pushUndoStop();
      return true;
    }
    return false;
  }
};
var PreviousMatchFindAction = class extends MatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.PreviousMatchFindAction,
      label: localize("findPreviousMatchAction", "Find Previous"),
      alias: "Find Previous",
      precondition: void 0,
      kbOpts: [
        {
          kbExpr: EditorContextKeys.focus,
          primary: 1024 | 61,
          mac: { primary: 2048 | 1024 | 37, secondary: [1024 | 61] },
          weight: 100
        },
        {
          kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_FIND_INPUT_FOCUSED),
          primary: 1024 | 3,
          weight: 100
        }
      ]
    });
  }
  _run(controller) {
    return controller.moveToPrevMatch();
  }
};
var SelectionMatchFindAction = class extends EditorAction {
  run(accessor, editor2) {
    return __awaiter31(this, void 0, void 0, function* () {
      let controller = CommonFindController.get(editor2);
      if (!controller) {
        return;
      }
      const seedSearchStringFromNonEmptySelection = editor2.getOption(35).seedSearchStringFromSelection === "selection";
      let selectionSearchString = null;
      if (editor2.getOption(35).seedSearchStringFromSelection !== "never") {
        selectionSearchString = getSelectionSearchString(editor2, "single", seedSearchStringFromNonEmptySelection);
      }
      if (selectionSearchString) {
        controller.setSearchString(selectionSearchString);
      }
      if (!this._run(controller)) {
        yield controller.start({
          forceRevealReplace: false,
          seedSearchStringFromSelection: editor2.getOption(35).seedSearchStringFromSelection !== "never" ? "single" : "none",
          seedSearchStringFromNonEmptySelection,
          seedSearchStringFromGlobalClipboard: false,
          shouldFocus: 0,
          shouldAnimate: true,
          updateSearchScope: false,
          loop: editor2.getOption(35).loop
        });
        this._run(controller);
      }
    });
  }
};
var NextSelectionMatchFindAction = class extends SelectionMatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.NextSelectionMatchFindAction,
      label: localize("nextSelectionMatchFindAction", "Find Next Selection"),
      alias: "Find Next Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 61,
        weight: 100
      }
    });
  }
  _run(controller) {
    return controller.moveToNextMatch();
  }
};
var PreviousSelectionMatchFindAction = class extends SelectionMatchFindAction {
  constructor() {
    super({
      id: FIND_IDS.PreviousSelectionMatchFindAction,
      label: localize("previousSelectionMatchFindAction", "Find Previous Selection"),
      alias: "Find Previous Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 61,
        weight: 100
      }
    });
  }
  _run(controller) {
    return controller.moveToPrevMatch();
  }
};
var StartFindReplaceAction = registerMultiEditorAction(new MultiEditorAction({
  id: FIND_IDS.StartFindReplaceAction,
  label: localize("startReplace", "Replace"),
  alias: "Replace",
  precondition: ContextKeyExpr.or(EditorContextKeys.focus, ContextKeyExpr.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2048 | 38,
    mac: { primary: 2048 | 512 | 36 },
    weight: 100
  },
  menuOpts: {
    menuId: MenuId.MenubarEditMenu,
    group: "3_find",
    title: localize({ key: "miReplace", comment: ["&& denotes a mnemonic"] }, "&&Replace"),
    order: 2
  }
}));
StartFindReplaceAction.addImplementation(0, (accessor, editor2, args) => {
  if (!editor2.hasModel() || editor2.getOption(80)) {
    return false;
  }
  const controller = CommonFindController.get(editor2);
  if (!controller) {
    return false;
  }
  const currentSelection = editor2.getSelection();
  const findInputFocused = controller.isFindInputFocused();
  const seedSearchStringFromSelection = !currentSelection.isEmpty() && currentSelection.startLineNumber === currentSelection.endLineNumber && editor2.getOption(35).seedSearchStringFromSelection !== "never" && !findInputFocused;
  const shouldFocus = findInputFocused || seedSearchStringFromSelection ? 2 : 1;
  return controller.start({
    forceRevealReplace: true,
    seedSearchStringFromSelection: seedSearchStringFromSelection ? "single" : "none",
    seedSearchStringFromNonEmptySelection: editor2.getOption(35).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: editor2.getOption(35).seedSearchStringFromSelection !== "never",
    shouldFocus,
    shouldAnimate: true,
    updateSearchScope: false,
    loop: editor2.getOption(35).loop
  });
});
registerEditorContribution(CommonFindController.ID, FindController);
registerEditorAction(StartFindWithArgsAction);
registerEditorAction(StartFindWithSelectionAction);
registerEditorAction(NextMatchFindAction);
registerEditorAction(PreviousMatchFindAction);
registerEditorAction(NextSelectionMatchFindAction);
registerEditorAction(PreviousSelectionMatchFindAction);
var FindCommand = EditorCommand.bindToContribution(CommonFindController.get);
registerEditorCommand(new FindCommand({
  id: FIND_IDS.CloseFindWidgetCommand,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.closeFindWidget(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, ContextKeyExpr.not("isComposing")),
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleCaseSensitiveCommand,
  precondition: void 0,
  handler: (x) => x.toggleCaseSensitive(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleCaseSensitiveKeybinding.primary,
    mac: ToggleCaseSensitiveKeybinding.mac,
    win: ToggleCaseSensitiveKeybinding.win,
    linux: ToggleCaseSensitiveKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleWholeWordCommand,
  precondition: void 0,
  handler: (x) => x.toggleWholeWords(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleWholeWordKeybinding.primary,
    mac: ToggleWholeWordKeybinding.mac,
    win: ToggleWholeWordKeybinding.win,
    linux: ToggleWholeWordKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleRegexCommand,
  precondition: void 0,
  handler: (x) => x.toggleRegex(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleRegexKeybinding.primary,
    mac: ToggleRegexKeybinding.mac,
    win: ToggleRegexKeybinding.win,
    linux: ToggleRegexKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ToggleSearchScopeCommand,
  precondition: void 0,
  handler: (x) => x.toggleSearchScope(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: ToggleSearchScopeKeybinding.primary,
    mac: ToggleSearchScopeKeybinding.mac,
    win: ToggleSearchScopeKeybinding.win,
    linux: ToggleSearchScopeKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.TogglePreserveCaseCommand,
  precondition: void 0,
  handler: (x) => x.togglePreserveCase(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: TogglePreserveCaseKeybinding.primary,
    mac: TogglePreserveCaseKeybinding.mac,
    win: TogglePreserveCaseKeybinding.win,
    linux: TogglePreserveCaseKeybinding.linux
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceOneAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replace(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 2048 | 1024 | 22
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceOneAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replace(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
    primary: 3
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceAllAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replaceAll(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 2048 | 512 | 3
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.ReplaceAllAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.replaceAll(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: ContextKeyExpr.and(EditorContextKeys.focus, CONTEXT_REPLACE_INPUT_FOCUSED),
    primary: void 0,
    mac: {
      primary: 2048 | 3
    }
  }
}));
registerEditorCommand(new FindCommand({
  id: FIND_IDS.SelectAllMatchesAction,
  precondition: CONTEXT_FIND_WIDGET_VISIBLE,
  handler: (x) => x.selectAllMatches(),
  kbOpts: {
    weight: 100 + 5,
    kbExpr: EditorContextKeys.focus,
    primary: 512 | 3
  }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/folding.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/folding/folding.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingRanges.js
var MAX_FOLDING_REGIONS = 65535;
var MAX_LINE_NUMBER = 16777215;
var MASK_INDENT = 4278190080;
var FoldingRegions = class {
  constructor(startIndexes, endIndexes, types3) {
    if (startIndexes.length !== endIndexes.length || startIndexes.length > MAX_FOLDING_REGIONS) {
      throw new Error("invalid startIndexes or endIndexes size");
    }
    this._startIndexes = startIndexes;
    this._endIndexes = endIndexes;
    this._collapseStates = new Uint32Array(Math.ceil(startIndexes.length / 32));
    this._types = types3;
    this._parentsComputed = false;
  }
  ensureParentIndices() {
    if (!this._parentsComputed) {
      this._parentsComputed = true;
      let parentIndexes = [];
      let isInsideLast = (startLineNumber, endLineNumber) => {
        let index = parentIndexes[parentIndexes.length - 1];
        return this.getStartLineNumber(index) <= startLineNumber && this.getEndLineNumber(index) >= endLineNumber;
      };
      for (let i = 0, len = this._startIndexes.length; i < len; i++) {
        let startLineNumber = this._startIndexes[i];
        let endLineNumber = this._endIndexes[i];
        if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
          throw new Error("startLineNumber or endLineNumber must not exceed " + MAX_LINE_NUMBER);
        }
        while (parentIndexes.length > 0 && !isInsideLast(startLineNumber, endLineNumber)) {
          parentIndexes.pop();
        }
        let parentIndex = parentIndexes.length > 0 ? parentIndexes[parentIndexes.length - 1] : -1;
        parentIndexes.push(i);
        this._startIndexes[i] = startLineNumber + ((parentIndex & 255) << 24);
        this._endIndexes[i] = endLineNumber + ((parentIndex & 65280) << 16);
      }
    }
  }
  get length() {
    return this._startIndexes.length;
  }
  getStartLineNumber(index) {
    return this._startIndexes[index] & MAX_LINE_NUMBER;
  }
  getEndLineNumber(index) {
    return this._endIndexes[index] & MAX_LINE_NUMBER;
  }
  getType(index) {
    return this._types ? this._types[index] : void 0;
  }
  hasTypes() {
    return !!this._types;
  }
  isCollapsed(index) {
    let arrayIndex = index / 32 | 0;
    let bit = index % 32;
    return (this._collapseStates[arrayIndex] & 1 << bit) !== 0;
  }
  setCollapsed(index, newState) {
    let arrayIndex = index / 32 | 0;
    let bit = index % 32;
    let value = this._collapseStates[arrayIndex];
    if (newState) {
      this._collapseStates[arrayIndex] = value | 1 << bit;
    } else {
      this._collapseStates[arrayIndex] = value & ~(1 << bit);
    }
  }
  setCollapsedAllOfType(type, newState) {
    let hasChanged = false;
    if (this._types) {
      for (let i = 0; i < this._types.length; i++) {
        if (this._types[i] === type) {
          this.setCollapsed(i, newState);
          hasChanged = true;
        }
      }
    }
    return hasChanged;
  }
  toRegion(index) {
    return new FoldingRegion(this, index);
  }
  getParentIndex(index) {
    this.ensureParentIndices();
    let parent = ((this._startIndexes[index] & MASK_INDENT) >>> 24) + ((this._endIndexes[index] & MASK_INDENT) >>> 16);
    if (parent === MAX_FOLDING_REGIONS) {
      return -1;
    }
    return parent;
  }
  contains(index, line) {
    return this.getStartLineNumber(index) <= line && this.getEndLineNumber(index) >= line;
  }
  findIndex(line) {
    let low = 0, high = this._startIndexes.length;
    if (high === 0) {
      return -1;
    }
    while (low < high) {
      let mid = Math.floor((low + high) / 2);
      if (line < this.getStartLineNumber(mid)) {
        high = mid;
      } else {
        low = mid + 1;
      }
    }
    return low - 1;
  }
  findRange(line) {
    let index = this.findIndex(line);
    if (index >= 0) {
      let endLineNumber = this.getEndLineNumber(index);
      if (endLineNumber >= line) {
        return index;
      }
      index = this.getParentIndex(index);
      while (index !== -1) {
        if (this.contains(index, line)) {
          return index;
        }
        index = this.getParentIndex(index);
      }
    }
    return -1;
  }
  toString() {
    let res = [];
    for (let i = 0; i < this.length; i++) {
      res[i] = `[${this.isCollapsed(i) ? "+" : "-"}] ${this.getStartLineNumber(i)}/${this.getEndLineNumber(i)}`;
    }
    return res.join(", ");
  }
};
var FoldingRegion = class {
  constructor(ranges, index) {
    this.ranges = ranges;
    this.index = index;
  }
  get startLineNumber() {
    return this.ranges.getStartLineNumber(this.index);
  }
  get endLineNumber() {
    return this.ranges.getEndLineNumber(this.index);
  }
  get regionIndex() {
    return this.index;
  }
  get parentIndex() {
    return this.ranges.getParentIndex(this.index);
  }
  get isCollapsed() {
    return this.ranges.isCollapsed(this.index);
  }
  containedBy(range) {
    return range.startLineNumber <= this.startLineNumber && range.endLineNumber >= this.endLineNumber;
  }
  containsLine(lineNumber) {
    return this.startLineNumber <= lineNumber && lineNumber <= this.endLineNumber;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingModel.js
var FoldingModel = class {
  constructor(textModel, decorationProvider) {
    this._updateEventEmitter = new Emitter();
    this.onDidChange = this._updateEventEmitter.event;
    this._textModel = textModel;
    this._decorationProvider = decorationProvider;
    this._regions = new FoldingRegions(new Uint32Array(0), new Uint32Array(0));
    this._editorDecorationIds = [];
    this._isInitialized = false;
  }
  get regions() {
    return this._regions;
  }
  get textModel() {
    return this._textModel;
  }
  get isInitialized() {
    return this._isInitialized;
  }
  toggleCollapseState(toggledRegions) {
    if (!toggledRegions.length) {
      return;
    }
    toggledRegions = toggledRegions.sort((r1, r2) => r1.regionIndex - r2.regionIndex);
    const processed = {};
    this._decorationProvider.changeDecorations((accessor) => {
      let k = 0;
      let dirtyRegionEndLine = -1;
      let lastHiddenLine = -1;
      const updateDecorationsUntil = (index) => {
        while (k < index) {
          const endLineNumber = this._regions.getEndLineNumber(k);
          const isCollapsed = this._regions.isCollapsed(k);
          if (endLineNumber <= dirtyRegionEndLine) {
            accessor.changeDecorationOptions(this._editorDecorationIds[k], this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine));
          }
          if (isCollapsed && endLineNumber > lastHiddenLine) {
            lastHiddenLine = endLineNumber;
          }
          k++;
        }
      };
      for (let region of toggledRegions) {
        let index = region.regionIndex;
        let editorDecorationId = this._editorDecorationIds[index];
        if (editorDecorationId && !processed[editorDecorationId]) {
          processed[editorDecorationId] = true;
          updateDecorationsUntil(index);
          let newCollapseState = !this._regions.isCollapsed(index);
          this._regions.setCollapsed(index, newCollapseState);
          dirtyRegionEndLine = Math.max(dirtyRegionEndLine, this._regions.getEndLineNumber(index));
        }
      }
      updateDecorationsUntil(this._regions.length);
    });
    this._updateEventEmitter.fire({ model: this, collapseStateChanged: toggledRegions });
  }
  update(newRegions, blockedLineNumers = []) {
    let newEditorDecorations = [];
    let isBlocked = (startLineNumber, endLineNumber) => {
      for (let blockedLineNumber of blockedLineNumers) {
        if (startLineNumber < blockedLineNumber && blockedLineNumber <= endLineNumber) {
          return true;
        }
      }
      return false;
    };
    let lastHiddenLine = -1;
    let initRange = (index, isCollapsed) => {
      const startLineNumber = newRegions.getStartLineNumber(index);
      const endLineNumber = newRegions.getEndLineNumber(index);
      if (!isCollapsed) {
        isCollapsed = newRegions.isCollapsed(index);
      }
      if (isCollapsed && isBlocked(startLineNumber, endLineNumber)) {
        isCollapsed = false;
      }
      newRegions.setCollapsed(index, isCollapsed);
      const maxColumn = this._textModel.getLineMaxColumn(startLineNumber);
      const decorationRange = {
        startLineNumber,
        startColumn: Math.max(maxColumn - 1, 1),
        endLineNumber: startLineNumber,
        endColumn: maxColumn
      };
      newEditorDecorations.push({ range: decorationRange, options: this._decorationProvider.getDecorationOption(isCollapsed, endLineNumber <= lastHiddenLine) });
      if (isCollapsed && endLineNumber > lastHiddenLine) {
        lastHiddenLine = endLineNumber;
      }
    };
    let i = 0;
    let nextCollapsed = () => {
      while (i < this._regions.length) {
        let isCollapsed = this._regions.isCollapsed(i);
        i++;
        if (isCollapsed) {
          return i - 1;
        }
      }
      return -1;
    };
    let k = 0;
    let collapsedIndex = nextCollapsed();
    while (collapsedIndex !== -1 && k < newRegions.length) {
      let decRange = this._textModel.getDecorationRange(this._editorDecorationIds[collapsedIndex]);
      if (decRange) {
        let collapsedStartLineNumber = decRange.startLineNumber;
        if (decRange.startColumn === Math.max(decRange.endColumn - 1, 1) && this._textModel.getLineMaxColumn(collapsedStartLineNumber) === decRange.endColumn) {
          while (k < newRegions.length) {
            let startLineNumber = newRegions.getStartLineNumber(k);
            if (collapsedStartLineNumber >= startLineNumber) {
              initRange(k, collapsedStartLineNumber === startLineNumber);
              k++;
            } else {
              break;
            }
          }
        }
      }
      collapsedIndex = nextCollapsed();
    }
    while (k < newRegions.length) {
      initRange(k, false);
      k++;
    }
    this._editorDecorationIds = this._decorationProvider.deltaDecorations(this._editorDecorationIds, newEditorDecorations);
    this._regions = newRegions;
    this._isInitialized = true;
    this._updateEventEmitter.fire({ model: this });
  }
  getMemento() {
    let collapsedRanges = [];
    for (let i = 0; i < this._regions.length; i++) {
      if (this._regions.isCollapsed(i)) {
        let range = this._textModel.getDecorationRange(this._editorDecorationIds[i]);
        if (range) {
          let startLineNumber = range.startLineNumber;
          let endLineNumber = range.endLineNumber + this._regions.getEndLineNumber(i) - this._regions.getStartLineNumber(i);
          collapsedRanges.push({ startLineNumber, endLineNumber });
        }
      }
    }
    if (collapsedRanges.length > 0) {
      return collapsedRanges;
    }
    return void 0;
  }
  applyMemento(state) {
    if (!Array.isArray(state)) {
      return;
    }
    let toToogle = [];
    for (let range of state) {
      let region = this.getRegionAtLine(range.startLineNumber);
      if (region && !region.isCollapsed) {
        toToogle.push(region);
      }
    }
    this.toggleCollapseState(toToogle);
  }
  dispose() {
    this._decorationProvider.deltaDecorations(this._editorDecorationIds, []);
  }
  getAllRegionsAtLine(lineNumber, filter) {
    let result = [];
    if (this._regions) {
      let index = this._regions.findRange(lineNumber);
      let level = 1;
      while (index >= 0) {
        let current = this._regions.toRegion(index);
        if (!filter || filter(current, level)) {
          result.push(current);
        }
        level++;
        index = current.parentIndex;
      }
    }
    return result;
  }
  getRegionAtLine(lineNumber) {
    if (this._regions) {
      let index = this._regions.findRange(lineNumber);
      if (index >= 0) {
        return this._regions.toRegion(index);
      }
    }
    return null;
  }
  getRegionsInside(region, filter) {
    let result = [];
    let index = region ? region.regionIndex + 1 : 0;
    let endLineNumber = region ? region.endLineNumber : Number.MAX_VALUE;
    if (filter && filter.length === 2) {
      const levelStack = [];
      for (let i = index, len = this._regions.length; i < len; i++) {
        let current = this._regions.toRegion(i);
        if (this._regions.getStartLineNumber(i) < endLineNumber) {
          while (levelStack.length > 0 && !current.containedBy(levelStack[levelStack.length - 1])) {
            levelStack.pop();
          }
          levelStack.push(current);
          if (filter(current, levelStack.length)) {
            result.push(current);
          }
        } else {
          break;
        }
      }
    } else {
      for (let i = index, len = this._regions.length; i < len; i++) {
        let current = this._regions.toRegion(i);
        if (this._regions.getStartLineNumber(i) < endLineNumber) {
          if (!filter || filter(current)) {
            result.push(current);
          }
        } else {
          break;
        }
      }
    }
    return result;
  }
};
function toggleCollapseState(foldingModel, levels, lineNumbers) {
  let toToggle = [];
  for (let lineNumber of lineNumbers) {
    let region = foldingModel.getRegionAtLine(lineNumber);
    if (region) {
      const doCollapse = !region.isCollapsed;
      toToggle.push(region);
      if (levels > 1) {
        let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
        toToggle.push(...regionsInside);
      }
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateLevelsDown(foldingModel, doCollapse, levels = Number.MAX_VALUE, lineNumbers) {
  let toToggle = [];
  if (lineNumbers && lineNumbers.length > 0) {
    for (let lineNumber of lineNumbers) {
      let region = foldingModel.getRegionAtLine(lineNumber);
      if (region) {
        if (region.isCollapsed !== doCollapse) {
          toToggle.push(region);
        }
        if (levels > 1) {
          let regionsInside = foldingModel.getRegionsInside(region, (r, level) => r.isCollapsed !== doCollapse && level < levels);
          toToggle.push(...regionsInside);
        }
      }
    }
  } else {
    let regionsInside = foldingModel.getRegionsInside(null, (r, level) => r.isCollapsed !== doCollapse && level < levels);
    toToggle.push(...regionsInside);
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateLevelsUp(foldingModel, doCollapse, levels, lineNumbers) {
  let toToggle = [];
  for (let lineNumber of lineNumbers) {
    let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region, level) => region.isCollapsed !== doCollapse && level <= levels);
    toToggle.push(...regions);
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateUp(foldingModel, doCollapse, lineNumbers) {
  let toToggle = [];
  for (let lineNumber of lineNumbers) {
    let regions = foldingModel.getAllRegionsAtLine(lineNumber, (region) => region.isCollapsed !== doCollapse);
    if (regions.length > 0) {
      toToggle.push(regions[0]);
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateAtLevel(foldingModel, foldLevel, doCollapse, blockedLineNumbers) {
  let filter = (region, level) => level === foldLevel && region.isCollapsed !== doCollapse && !blockedLineNumbers.some((line) => region.containsLine(line));
  let toToggle = foldingModel.getRegionsInside(null, filter);
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForRest(foldingModel, doCollapse, blockedLineNumbers) {
  let filteredRegions = [];
  for (let lineNumber of blockedLineNumbers) {
    filteredRegions.push(foldingModel.getAllRegionsAtLine(lineNumber, void 0)[0]);
  }
  let filter = (region) => filteredRegions.every((filteredRegion) => !filteredRegion.containedBy(region) && !region.containedBy(filteredRegion)) && region.isCollapsed !== doCollapse;
  let toToggle = foldingModel.getRegionsInside(null, filter);
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForMatchingLines(foldingModel, regExp, doCollapse) {
  let editorModel = foldingModel.textModel;
  let regions = foldingModel.regions;
  let toToggle = [];
  for (let i = regions.length - 1; i >= 0; i--) {
    if (doCollapse !== regions.isCollapsed(i)) {
      let startLineNumber = regions.getStartLineNumber(i);
      if (regExp.test(editorModel.getLineContent(startLineNumber))) {
        toToggle.push(regions.toRegion(i));
      }
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function setCollapseStateForType(foldingModel, type, doCollapse) {
  let regions = foldingModel.regions;
  let toToggle = [];
  for (let i = regions.length - 1; i >= 0; i--) {
    if (doCollapse !== regions.isCollapsed(i) && type === regions.getType(i)) {
      toToggle.push(regions.toRegion(i));
    }
  }
  foldingModel.toggleCollapseState(toToggle);
}
function getParentFoldLine(lineNumber, foldingModel) {
  let startLineNumber = null;
  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null) {
    startLineNumber = foldingRegion.startLineNumber;
    if (lineNumber === startLineNumber) {
      let parentFoldingIdx = foldingRegion.parentIndex;
      if (parentFoldingIdx !== -1) {
        startLineNumber = foldingModel.regions.getStartLineNumber(parentFoldingIdx);
      } else {
        startLineNumber = null;
      }
    }
  }
  return startLineNumber;
}
function getPreviousFoldLine(lineNumber, foldingModel) {
  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {
    if (lineNumber !== foldingRegion.startLineNumber) {
      return foldingRegion.startLineNumber;
    } else {
      let expectedParentIndex = foldingRegion.parentIndex;
      let minLineNumber = 0;
      if (expectedParentIndex !== -1) {
        minLineNumber = foldingModel.regions.getStartLineNumber(foldingRegion.parentIndex);
      }
      while (foldingRegion !== null) {
        if (foldingRegion.regionIndex > 0) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);
          if (foldingRegion.startLineNumber <= minLineNumber) {
            return null;
          } else if (foldingRegion.parentIndex === expectedParentIndex) {
            return foldingRegion.startLineNumber;
          }
        } else {
          return null;
        }
      }
    }
  } else {
    if (foldingModel.regions.length > 0) {
      foldingRegion = foldingModel.regions.toRegion(foldingModel.regions.length - 1);
      while (foldingRegion !== null) {
        if (foldingRegion.startLineNumber < lineNumber) {
          return foldingRegion.startLineNumber;
        }
        if (foldingRegion.regionIndex > 0) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex - 1);
        } else {
          foldingRegion = null;
        }
      }
    }
  }
  return null;
}
function getNextFoldLine(lineNumber, foldingModel) {
  let foldingRegion = foldingModel.getRegionAtLine(lineNumber);
  if (foldingRegion !== null && foldingRegion.startLineNumber === lineNumber) {
    let expectedParentIndex = foldingRegion.parentIndex;
    let maxLineNumber = 0;
    if (expectedParentIndex !== -1) {
      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingRegion.parentIndex);
    } else if (foldingModel.regions.length === 0) {
      return null;
    } else {
      maxLineNumber = foldingModel.regions.getEndLineNumber(foldingModel.regions.length - 1);
    }
    while (foldingRegion !== null) {
      if (foldingRegion.regionIndex < foldingModel.regions.length) {
        foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);
        if (foldingRegion.startLineNumber >= maxLineNumber) {
          return null;
        } else if (foldingRegion.parentIndex === expectedParentIndex) {
          return foldingRegion.startLineNumber;
        }
      } else {
        return null;
      }
    }
  } else {
    if (foldingModel.regions.length > 0) {
      foldingRegion = foldingModel.regions.toRegion(0);
      while (foldingRegion !== null) {
        if (foldingRegion.startLineNumber > lineNumber) {
          return foldingRegion.startLineNumber;
        }
        if (foldingRegion.regionIndex < foldingModel.regions.length) {
          foldingRegion = foldingModel.regions.toRegion(foldingRegion.regionIndex + 1);
        } else {
          foldingRegion = null;
        }
      }
    }
  }
  return null;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/hiddenRangeModel.js
var HiddenRangeModel = class {
  constructor(model) {
    this._updateEventEmitter = new Emitter();
    this._hasLineChanges = false;
    this._foldingModel = model;
    this._foldingModelListener = model.onDidChange((_) => this.updateHiddenRanges());
    this._hiddenRanges = [];
    if (model.regions.length) {
      this.updateHiddenRanges();
    }
  }
  get onDidChange() {
    return this._updateEventEmitter.event;
  }
  get hiddenRanges() {
    return this._hiddenRanges;
  }
  notifyChangeModelContent(e) {
    if (this._hiddenRanges.length && !this._hasLineChanges) {
      this._hasLineChanges = e.changes.some((change) => {
        return change.range.endLineNumber !== change.range.startLineNumber || countEOL(change.text)[0] !== 0;
      });
    }
  }
  updateHiddenRanges() {
    let updateHiddenAreas = false;
    let newHiddenAreas = [];
    let i = 0;
    let k = 0;
    let lastCollapsedStart = Number.MAX_VALUE;
    let lastCollapsedEnd = -1;
    let ranges = this._foldingModel.regions;
    for (; i < ranges.length; i++) {
      if (!ranges.isCollapsed(i)) {
        continue;
      }
      let startLineNumber = ranges.getStartLineNumber(i) + 1;
      let endLineNumber = ranges.getEndLineNumber(i);
      if (lastCollapsedStart <= startLineNumber && endLineNumber <= lastCollapsedEnd) {
        continue;
      }
      if (!updateHiddenAreas && k < this._hiddenRanges.length && this._hiddenRanges[k].startLineNumber === startLineNumber && this._hiddenRanges[k].endLineNumber === endLineNumber) {
        newHiddenAreas.push(this._hiddenRanges[k]);
        k++;
      } else {
        updateHiddenAreas = true;
        newHiddenAreas.push(new Range(startLineNumber, 1, endLineNumber, 1));
      }
      lastCollapsedStart = startLineNumber;
      lastCollapsedEnd = endLineNumber;
    }
    if (this._hasLineChanges || updateHiddenAreas || k < this._hiddenRanges.length) {
      this.applyHiddenRanges(newHiddenAreas);
    }
  }
  applyMemento(state) {
    if (!Array.isArray(state) || state.length === 0) {
      return false;
    }
    let hiddenRanges = [];
    for (let r of state) {
      if (!r.startLineNumber || !r.endLineNumber) {
        return false;
      }
      hiddenRanges.push(new Range(r.startLineNumber + 1, 1, r.endLineNumber, 1));
    }
    this.applyHiddenRanges(hiddenRanges);
    return true;
  }
  getMemento() {
    return this._hiddenRanges.map((r) => ({ startLineNumber: r.startLineNumber - 1, endLineNumber: r.endLineNumber }));
  }
  applyHiddenRanges(newHiddenAreas) {
    this._hiddenRanges = newHiddenAreas;
    this._hasLineChanges = false;
    this._updateEventEmitter.fire(newHiddenAreas);
  }
  hasRanges() {
    return this._hiddenRanges.length > 0;
  }
  isHidden(line) {
    return findRange(this._hiddenRanges, line) !== null;
  }
  adjustSelections(selections) {
    let hasChanges = false;
    let editorModel = this._foldingModel.textModel;
    let lastRange = null;
    let adjustLine = (line) => {
      if (!lastRange || !isInside(line, lastRange)) {
        lastRange = findRange(this._hiddenRanges, line);
      }
      if (lastRange) {
        return lastRange.startLineNumber - 1;
      }
      return null;
    };
    for (let i = 0, len = selections.length; i < len; i++) {
      let selection = selections[i];
      let adjustedStartLine = adjustLine(selection.startLineNumber);
      if (adjustedStartLine) {
        selection = selection.setStartPosition(adjustedStartLine, editorModel.getLineMaxColumn(adjustedStartLine));
        hasChanges = true;
      }
      let adjustedEndLine = adjustLine(selection.endLineNumber);
      if (adjustedEndLine) {
        selection = selection.setEndPosition(adjustedEndLine, editorModel.getLineMaxColumn(adjustedEndLine));
        hasChanges = true;
      }
      selections[i] = selection;
    }
    return hasChanges;
  }
  dispose() {
    if (this.hiddenRanges.length > 0) {
      this._hiddenRanges = [];
      this._updateEventEmitter.fire(this._hiddenRanges);
    }
    if (this._foldingModelListener) {
      this._foldingModelListener.dispose();
      this._foldingModelListener = null;
    }
  }
};
function isInside(line, range) {
  return line >= range.startLineNumber && line <= range.endLineNumber;
}
function findRange(ranges, line) {
  let i = findFirstInSorted(ranges, (r) => line < r.startLineNumber) - 1;
  if (i >= 0 && ranges[i].endLineNumber >= line) {
    return ranges[i];
  }
  return null;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/indentRangeProvider.js
var MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT = 5e3;
var ID_INDENT_PROVIDER = "indent";
var IndentRangeProvider = class {
  constructor(editorModel) {
    this.editorModel = editorModel;
    this.id = ID_INDENT_PROVIDER;
  }
  dispose() {
  }
  compute(cancelationToken) {
    let foldingRules = LanguageConfigurationRegistry.getFoldingRules(this.editorModel.getLanguageId());
    let offSide = foldingRules && !!foldingRules.offSide;
    let markers = foldingRules && foldingRules.markers;
    return Promise.resolve(computeRanges(this.editorModel, offSide, markers));
  }
};
var RangesCollector = class {
  constructor(foldingRangesLimit) {
    this._startIndexes = [];
    this._endIndexes = [];
    this._indentOccurrences = [];
    this._length = 0;
    this._foldingRangesLimit = foldingRangesLimit;
  }
  insertFirst(startLineNumber, endLineNumber, indent) {
    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
      return;
    }
    let index = this._length;
    this._startIndexes[index] = startLineNumber;
    this._endIndexes[index] = endLineNumber;
    this._length++;
    if (indent < 1e3) {
      this._indentOccurrences[indent] = (this._indentOccurrences[indent] || 0) + 1;
    }
  }
  toIndentRanges(model) {
    if (this._length <= this._foldingRangesLimit) {
      let startIndexes = new Uint32Array(this._length);
      let endIndexes = new Uint32Array(this._length);
      for (let i = this._length - 1, k = 0; i >= 0; i--, k++) {
        startIndexes[k] = this._startIndexes[i];
        endIndexes[k] = this._endIndexes[i];
      }
      return new FoldingRegions(startIndexes, endIndexes);
    } else {
      let entries = 0;
      let maxIndent = this._indentOccurrences.length;
      for (let i = 0; i < this._indentOccurrences.length; i++) {
        let n = this._indentOccurrences[i];
        if (n) {
          if (n + entries > this._foldingRangesLimit) {
            maxIndent = i;
            break;
          }
          entries += n;
        }
      }
      const tabSize = model.getOptions().tabSize;
      let startIndexes = new Uint32Array(this._foldingRangesLimit);
      let endIndexes = new Uint32Array(this._foldingRangesLimit);
      for (let i = this._length - 1, k = 0; i >= 0; i--) {
        let startIndex = this._startIndexes[i];
        let lineContent = model.getLineContent(startIndex);
        let indent = TextModel.computeIndentLevel(lineContent, tabSize);
        if (indent < maxIndent || indent === maxIndent && entries++ < this._foldingRangesLimit) {
          startIndexes[k] = startIndex;
          endIndexes[k] = this._endIndexes[i];
          k++;
        }
      }
      return new FoldingRegions(startIndexes, endIndexes);
    }
  }
};
function computeRanges(model, offSide, markers, foldingRangesLimit = MAX_FOLDING_REGIONS_FOR_INDENT_LIMIT) {
  const tabSize = model.getOptions().tabSize;
  let result = new RangesCollector(foldingRangesLimit);
  let pattern = void 0;
  if (markers) {
    pattern = new RegExp(`(${markers.start.source})|(?:${markers.end.source})`);
  }
  let previousRegions = [];
  let line = model.getLineCount() + 1;
  previousRegions.push({ indent: -1, endAbove: line, line });
  for (let line2 = model.getLineCount(); line2 > 0; line2--) {
    let lineContent = model.getLineContent(line2);
    let indent = TextModel.computeIndentLevel(lineContent, tabSize);
    let previous = previousRegions[previousRegions.length - 1];
    if (indent === -1) {
      if (offSide) {
        previous.endAbove = line2;
      }
      continue;
    }
    let m;
    if (pattern && (m = lineContent.match(pattern))) {
      if (m[1]) {
        let i = previousRegions.length - 1;
        while (i > 0 && previousRegions[i].indent !== -2) {
          i--;
        }
        if (i > 0) {
          previousRegions.length = i + 1;
          previous = previousRegions[i];
          result.insertFirst(line2, previous.line, indent);
          previous.line = line2;
          previous.indent = indent;
          previous.endAbove = line2;
          continue;
        } else {
        }
      } else {
        previousRegions.push({ indent: -2, endAbove: line2, line: line2 });
        continue;
      }
    }
    if (previous.indent > indent) {
      do {
        previousRegions.pop();
        previous = previousRegions[previousRegions.length - 1];
      } while (previous.indent > indent);
      let endLineNumber = previous.endAbove - 1;
      if (endLineNumber - line2 >= 1) {
        result.insertFirst(line2, endLineNumber, indent);
      }
    }
    if (previous.indent === indent) {
      previous.endAbove = line2;
    } else {
      previousRegions.push({ indent, endAbove: line2, line: line2 });
    }
  }
  return result.toIndentRanges(model);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/syntaxRangeProvider.js
var MAX_FOLDING_REGIONS2 = 5e3;
var foldingContext = {};
var ID_SYNTAX_PROVIDER = "syntax";
var SyntaxRangeProvider = class {
  constructor(editorModel, providers, handleFoldingRangesChange, limit = MAX_FOLDING_REGIONS2) {
    this.editorModel = editorModel;
    this.providers = providers;
    this.limit = limit;
    this.id = ID_SYNTAX_PROVIDER;
    for (const provider of providers) {
      if (typeof provider.onDidChange === "function") {
        if (!this.disposables) {
          this.disposables = new DisposableStore();
        }
        this.disposables.add(provider.onDidChange(handleFoldingRangesChange));
      }
    }
  }
  compute(cancellationToken) {
    return collectSyntaxRanges(this.providers, this.editorModel, cancellationToken).then((ranges) => {
      if (ranges) {
        let res = sanitizeRanges(ranges, this.limit);
        return res;
      }
      return null;
    });
  }
  dispose() {
    var _a5;
    (_a5 = this.disposables) === null || _a5 === void 0 ? void 0 : _a5.dispose();
  }
};
function collectSyntaxRanges(providers, model, cancellationToken) {
  let rangeData = null;
  let promises = providers.map((provider, i) => {
    return Promise.resolve(provider.provideFoldingRanges(model, foldingContext, cancellationToken)).then((ranges) => {
      if (cancellationToken.isCancellationRequested) {
        return;
      }
      if (Array.isArray(ranges)) {
        if (!Array.isArray(rangeData)) {
          rangeData = [];
        }
        let nLines = model.getLineCount();
        for (let r of ranges) {
          if (r.start > 0 && r.end > r.start && r.end <= nLines) {
            rangeData.push({ start: r.start, end: r.end, rank: i, kind: r.kind });
          }
        }
      }
    }, onUnexpectedExternalError);
  });
  return Promise.all(promises).then((_) => {
    return rangeData;
  });
}
var RangesCollector2 = class {
  constructor(foldingRangesLimit) {
    this._startIndexes = [];
    this._endIndexes = [];
    this._nestingLevels = [];
    this._nestingLevelCounts = [];
    this._types = [];
    this._length = 0;
    this._foldingRangesLimit = foldingRangesLimit;
  }
  add(startLineNumber, endLineNumber, type, nestingLevel) {
    if (startLineNumber > MAX_LINE_NUMBER || endLineNumber > MAX_LINE_NUMBER) {
      return;
    }
    let index = this._length;
    this._startIndexes[index] = startLineNumber;
    this._endIndexes[index] = endLineNumber;
    this._nestingLevels[index] = nestingLevel;
    this._types[index] = type;
    this._length++;
    if (nestingLevel < 30) {
      this._nestingLevelCounts[nestingLevel] = (this._nestingLevelCounts[nestingLevel] || 0) + 1;
    }
  }
  toIndentRanges() {
    if (this._length <= this._foldingRangesLimit) {
      let startIndexes = new Uint32Array(this._length);
      let endIndexes = new Uint32Array(this._length);
      for (let i = 0; i < this._length; i++) {
        startIndexes[i] = this._startIndexes[i];
        endIndexes[i] = this._endIndexes[i];
      }
      return new FoldingRegions(startIndexes, endIndexes, this._types);
    } else {
      let entries = 0;
      let maxLevel = this._nestingLevelCounts.length;
      for (let i = 0; i < this._nestingLevelCounts.length; i++) {
        let n = this._nestingLevelCounts[i];
        if (n) {
          if (n + entries > this._foldingRangesLimit) {
            maxLevel = i;
            break;
          }
          entries += n;
        }
      }
      let startIndexes = new Uint32Array(this._foldingRangesLimit);
      let endIndexes = new Uint32Array(this._foldingRangesLimit);
      let types3 = [];
      for (let i = 0, k = 0; i < this._length; i++) {
        let level = this._nestingLevels[i];
        if (level < maxLevel || level === maxLevel && entries++ < this._foldingRangesLimit) {
          startIndexes[k] = this._startIndexes[i];
          endIndexes[k] = this._endIndexes[i];
          types3[k] = this._types[i];
          k++;
        }
      }
      return new FoldingRegions(startIndexes, endIndexes, types3);
    }
  }
};
function sanitizeRanges(rangeData, limit) {
  let sorted = rangeData.sort((d1, d2) => {
    let diff = d1.start - d2.start;
    if (diff === 0) {
      diff = d1.rank - d2.rank;
    }
    return diff;
  });
  let collector = new RangesCollector2(limit);
  let top = void 0;
  let previous = [];
  for (let entry of sorted) {
    if (!top) {
      top = entry;
      collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
    } else {
      if (entry.start > top.start) {
        if (entry.end <= top.end) {
          previous.push(top);
          top = entry;
          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
        } else {
          if (entry.start > top.end) {
            do {
              top = previous.pop();
            } while (top && entry.start > top.end);
            if (top) {
              previous.push(top);
            }
            top = entry;
          }
          collector.add(entry.start, entry.end, entry.kind && entry.kind.value, previous.length);
        }
      }
    }
  }
  return collector.toIndentRanges();
}

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/intializingRangeProvider.js
var ID_INIT_PROVIDER = "init";
var InitializingRangeProvider = class {
  constructor(editorModel, initialRanges, onTimeout, timeoutTime) {
    this.editorModel = editorModel;
    this.id = ID_INIT_PROVIDER;
    if (initialRanges.length) {
      let toDecorationRange = (range) => {
        return {
          range: {
            startLineNumber: range.startLineNumber,
            startColumn: 0,
            endLineNumber: range.endLineNumber,
            endColumn: editorModel.getLineLength(range.endLineNumber)
          },
          options: {
            description: "folding-initializing-range-provider",
            stickiness: 1
          }
        };
      };
      this.decorationIds = editorModel.deltaDecorations([], initialRanges.map(toDecorationRange));
      this.timeout = setTimeout(onTimeout, timeoutTime);
    }
  }
  dispose() {
    if (this.decorationIds) {
      this.editorModel.deltaDecorations(this.decorationIds, []);
      this.decorationIds = void 0;
    }
    if (typeof this.timeout === "number") {
      clearTimeout(this.timeout);
      this.timeout = void 0;
    }
  }
  compute(cancelationToken) {
    let foldingRangeData = [];
    if (this.decorationIds) {
      for (let id of this.decorationIds) {
        let range = this.editorModel.getDecorationRange(id);
        if (range) {
          foldingRangeData.push({ start: range.startLineNumber, end: range.endLineNumber, rank: 1 });
        }
      }
    }
    return Promise.resolve(sanitizeRanges(foldingRangeData, Number.MAX_VALUE));
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/foldingDecorations.js
var foldingExpandedIcon = registerIcon("folding-expanded", Codicon.chevronDown, localize("foldingExpandedIcon", "Icon for expanded ranges in the editor glyph margin."));
var foldingCollapsedIcon = registerIcon("folding-collapsed", Codicon.chevronRight, localize("foldingCollapsedIcon", "Icon for collapsed ranges in the editor glyph margin."));
var FoldingDecorationProvider = class {
  constructor(editor2) {
    this.editor = editor2;
    this.autoHideFoldingControls = true;
    this.showFoldingHighlights = true;
  }
  getDecorationOption(isCollapsed, isHidden) {
    if (isHidden) {
      return FoldingDecorationProvider.HIDDEN_RANGE_DECORATION;
    }
    if (isCollapsed) {
      return this.showFoldingHighlights ? FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION;
    } else if (this.autoHideFoldingControls) {
      return FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION;
    } else {
      return FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION;
    }
  }
  deltaDecorations(oldDecorations, newDecorations) {
    return this.editor.deltaDecorations(oldDecorations, newDecorations);
  }
  changeDecorations(callback) {
    return this.editor.changeDecorations(callback);
  }
};
FoldingDecorationProvider.COLLAPSED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-collapsed-visual-decoration",
  stickiness: 1,
  afterContentClassName: "inline-folded",
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)
});
FoldingDecorationProvider.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-collapsed-highlighted-visual-decoration",
  stickiness: 1,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingCollapsedIcon)
});
FoldingDecorationProvider.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-expanded-auto-hide-visual-decoration",
  stickiness: 1,
  isWholeLine: true,
  firstLineDecorationClassName: ThemeIcon.asClassName(foldingExpandedIcon)
});
FoldingDecorationProvider.EXPANDED_VISUAL_DECORATION = ModelDecorationOptions.register({
  description: "folding-expanded-visual-decoration",
  stickiness: 1,
  isWholeLine: true,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + ThemeIcon.asClassName(foldingExpandedIcon)
});
FoldingDecorationProvider.HIDDEN_RANGE_DECORATION = ModelDecorationOptions.register({
  description: "folding-hidden-range-decoration",
  stickiness: 1
});

// node_modules/monaco-editor/esm/vs/editor/contrib/folding/folding.js
var __decorate48 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param48 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CONTEXT_FOLDING_ENABLED = new RawContextKey("foldingEnabled", false);
var FoldingController = class FoldingController2 extends Disposable {
  constructor(editor2, contextKeyService) {
    super();
    this.contextKeyService = contextKeyService;
    this.localToDispose = this._register(new DisposableStore());
    this.editor = editor2;
    const options = this.editor.getOptions();
    this._isEnabled = options.get(37);
    this._useFoldingProviders = options.get(38) !== "indentation";
    this._unfoldOnClickAfterEndOfLine = options.get(41);
    this._restoringViewState = false;
    this._currentModelHasFoldedImports = false;
    this._foldingImportsByDefault = options.get(40);
    this.foldingModel = null;
    this.hiddenRangeModel = null;
    this.rangeProvider = null;
    this.foldingRegionPromise = null;
    this.foldingStateMemento = null;
    this.foldingModelPromise = null;
    this.updateScheduler = null;
    this.cursorChangedScheduler = null;
    this.mouseDownInfo = null;
    this.foldingDecorationProvider = new FoldingDecorationProvider(editor2);
    this.foldingDecorationProvider.autoHideFoldingControls = options.get(98) === "mouseover";
    this.foldingDecorationProvider.showFoldingHighlights = options.get(39);
    this.foldingEnabled = CONTEXT_FOLDING_ENABLED.bindTo(this.contextKeyService);
    this.foldingEnabled.set(this._isEnabled);
    this._register(this.editor.onDidChangeModel(() => this.onModelChanged()));
    this._register(this.editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(37)) {
        this._isEnabled = this.editor.getOptions().get(37);
        this.foldingEnabled.set(this._isEnabled);
        this.onModelChanged();
      }
      if (e.hasChanged(98) || e.hasChanged(39)) {
        const options2 = this.editor.getOptions();
        this.foldingDecorationProvider.autoHideFoldingControls = options2.get(98) === "mouseover";
        this.foldingDecorationProvider.showFoldingHighlights = options2.get(39);
        this.triggerFoldingModelChanged();
      }
      if (e.hasChanged(38)) {
        this._useFoldingProviders = this.editor.getOptions().get(38) !== "indentation";
        this.onFoldingStrategyChanged();
      }
      if (e.hasChanged(41)) {
        this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(41);
      }
      if (e.hasChanged(40)) {
        this._foldingImportsByDefault = this.editor.getOptions().get(40);
      }
    }));
    this.onModelChanged();
  }
  static get(editor2) {
    return editor2.getContribution(FoldingController2.ID);
  }
  saveViewState() {
    let model = this.editor.getModel();
    if (!model || !this._isEnabled || model.isTooLargeForTokenization()) {
      return {};
    }
    if (this.foldingModel) {
      let collapsedRegions = this.foldingModel.isInitialized ? this.foldingModel.getMemento() : this.hiddenRangeModel.getMemento();
      let provider = this.rangeProvider ? this.rangeProvider.id : void 0;
      return { collapsedRegions, lineCount: model.getLineCount(), provider, foldedImports: this._currentModelHasFoldedImports };
    }
    return void 0;
  }
  restoreViewState(state) {
    let model = this.editor.getModel();
    if (!model || !this._isEnabled || model.isTooLargeForTokenization() || !this.hiddenRangeModel) {
      return;
    }
    if (!state || state.lineCount !== model.getLineCount()) {
      return;
    }
    this._currentModelHasFoldedImports = !!state.foldedImports;
    if (!state.collapsedRegions) {
      return;
    }
    if (state.provider === ID_SYNTAX_PROVIDER || state.provider === ID_INIT_PROVIDER) {
      this.foldingStateMemento = state;
    }
    const collapsedRegions = state.collapsedRegions;
    if (this.hiddenRangeModel.applyMemento(collapsedRegions)) {
      const foldingModel = this.getFoldingModel();
      if (foldingModel) {
        foldingModel.then((foldingModel2) => {
          if (foldingModel2) {
            this._restoringViewState = true;
            try {
              foldingModel2.applyMemento(collapsedRegions);
            } finally {
              this._restoringViewState = false;
            }
          }
        }).then(void 0, onUnexpectedError);
      }
    }
  }
  onModelChanged() {
    this.localToDispose.clear();
    let model = this.editor.getModel();
    if (!this._isEnabled || !model || model.isTooLargeForTokenization()) {
      return;
    }
    this._currentModelHasFoldedImports = false;
    this.foldingModel = new FoldingModel(model, this.foldingDecorationProvider);
    this.localToDispose.add(this.foldingModel);
    this.hiddenRangeModel = new HiddenRangeModel(this.foldingModel);
    this.localToDispose.add(this.hiddenRangeModel);
    this.localToDispose.add(this.hiddenRangeModel.onDidChange((hr) => this.onHiddenRangesChanges(hr)));
    this.updateScheduler = new Delayer(200);
    this.cursorChangedScheduler = new RunOnceScheduler(() => this.revealCursor(), 200);
    this.localToDispose.add(this.cursorChangedScheduler);
    this.localToDispose.add(FoldingRangeProviderRegistry.onDidChange(() => this.onFoldingStrategyChanged()));
    this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged()));
    this.localToDispose.add(this.editor.onDidChangeModelContent((e) => this.onDidChangeModelContent(e)));
    this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged()));
    this.localToDispose.add(this.editor.onMouseDown((e) => this.onEditorMouseDown(e)));
    this.localToDispose.add(this.editor.onMouseUp((e) => this.onEditorMouseUp(e)));
    this.localToDispose.add({
      dispose: () => {
        if (this.foldingRegionPromise) {
          this.foldingRegionPromise.cancel();
          this.foldingRegionPromise = null;
        }
        if (this.updateScheduler) {
          this.updateScheduler.cancel();
        }
        this.updateScheduler = null;
        this.foldingModel = null;
        this.foldingModelPromise = null;
        this.hiddenRangeModel = null;
        this.cursorChangedScheduler = null;
        this.foldingStateMemento = null;
        if (this.rangeProvider) {
          this.rangeProvider.dispose();
        }
        this.rangeProvider = null;
      }
    });
    this.triggerFoldingModelChanged();
  }
  onFoldingStrategyChanged() {
    if (this.rangeProvider) {
      this.rangeProvider.dispose();
    }
    this.rangeProvider = null;
    this.triggerFoldingModelChanged();
  }
  getRangeProvider(editorModel) {
    if (this.rangeProvider) {
      return this.rangeProvider;
    }
    this.rangeProvider = new IndentRangeProvider(editorModel);
    if (this._useFoldingProviders && this.foldingModel) {
      let foldingProviders = FoldingRangeProviderRegistry.ordered(this.foldingModel.textModel);
      if (foldingProviders.length === 0 && this.foldingStateMemento && this.foldingStateMemento.collapsedRegions) {
        const rangeProvider = this.rangeProvider = new InitializingRangeProvider(editorModel, this.foldingStateMemento.collapsedRegions, () => {
          this.foldingStateMemento = null;
          this.onFoldingStrategyChanged();
        }, 3e4);
        return rangeProvider;
      } else if (foldingProviders.length > 0) {
        this.rangeProvider = new SyntaxRangeProvider(editorModel, foldingProviders, () => this.triggerFoldingModelChanged());
      }
    }
    this.foldingStateMemento = null;
    return this.rangeProvider;
  }
  getFoldingModel() {
    return this.foldingModelPromise;
  }
  onDidChangeModelContent(e) {
    var _a5;
    (_a5 = this.hiddenRangeModel) === null || _a5 === void 0 ? void 0 : _a5.notifyChangeModelContent(e);
    this.triggerFoldingModelChanged();
  }
  triggerFoldingModelChanged() {
    if (this.updateScheduler) {
      if (this.foldingRegionPromise) {
        this.foldingRegionPromise.cancel();
        this.foldingRegionPromise = null;
      }
      this.foldingModelPromise = this.updateScheduler.trigger(() => {
        const foldingModel = this.foldingModel;
        if (!foldingModel) {
          return null;
        }
        const provider = this.getRangeProvider(foldingModel.textModel);
        let foldingRegionPromise = this.foldingRegionPromise = createCancelablePromise((token) => provider.compute(token));
        return foldingRegionPromise.then((foldingRanges) => {
          if (foldingRanges && foldingRegionPromise === this.foldingRegionPromise) {
            let scrollState;
            if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {
              const hasChanges = foldingRanges.setCollapsedAllOfType(FoldingRangeKind.Imports.value, true);
              if (hasChanges) {
                scrollState = StableEditorScrollState.capture(this.editor);
                this._currentModelHasFoldedImports = hasChanges;
              }
            }
            let selections = this.editor.getSelections();
            let selectionLineNumbers = selections ? selections.map((s) => s.startLineNumber) : [];
            foldingModel.update(foldingRanges, selectionLineNumbers);
            if (scrollState) {
              scrollState.restore(this.editor);
            }
          }
          return foldingModel;
        });
      }).then(void 0, (err) => {
        onUnexpectedError(err);
        return null;
      });
    }
  }
  onHiddenRangesChanges(hiddenRanges) {
    if (this.hiddenRangeModel && hiddenRanges.length && !this._restoringViewState) {
      let selections = this.editor.getSelections();
      if (selections) {
        if (this.hiddenRangeModel.adjustSelections(selections)) {
          this.editor.setSelections(selections);
        }
      }
    }
    this.editor.setHiddenAreas(hiddenRanges);
  }
  onCursorPositionChanged() {
    if (this.hiddenRangeModel && this.hiddenRangeModel.hasRanges()) {
      this.cursorChangedScheduler.schedule();
    }
  }
  revealCursor() {
    const foldingModel = this.getFoldingModel();
    if (!foldingModel) {
      return;
    }
    foldingModel.then((foldingModel2) => {
      if (foldingModel2) {
        let selections = this.editor.getSelections();
        if (selections && selections.length > 0) {
          let toToggle = [];
          for (let selection of selections) {
            let lineNumber = selection.selectionStartLineNumber;
            if (this.hiddenRangeModel && this.hiddenRangeModel.isHidden(lineNumber)) {
              toToggle.push(...foldingModel2.getAllRegionsAtLine(lineNumber, (r) => r.isCollapsed && lineNumber > r.startLineNumber));
            }
          }
          if (toToggle.length) {
            foldingModel2.toggleCollapseState(toToggle);
            this.reveal(selections[0].getPosition());
          }
        }
      }
    }).then(void 0, onUnexpectedError);
  }
  onEditorMouseDown(e) {
    this.mouseDownInfo = null;
    if (!this.hiddenRangeModel || !e.target || !e.target.range) {
      return;
    }
    if (!e.event.leftButton && !e.event.middleButton) {
      return;
    }
    const range = e.target.range;
    let iconClicked = false;
    switch (e.target.type) {
      case 4:
        const data = e.target.detail;
        const offsetLeftInGutter = e.target.element.offsetLeft;
        const gutterOffsetX = data.offsetX - offsetLeftInGutter;
        if (gutterOffsetX < 5) {
          return;
        }
        iconClicked = true;
        break;
      case 7: {
        if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges()) {
          const data2 = e.target.detail;
          if (!data2.isAfterLines) {
            break;
          }
        }
        return;
      }
      case 6: {
        if (this.hiddenRangeModel.hasRanges()) {
          let model = this.editor.getModel();
          if (model && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {
            break;
          }
        }
        return;
      }
      default:
        return;
    }
    this.mouseDownInfo = { lineNumber: range.startLineNumber, iconClicked };
  }
  onEditorMouseUp(e) {
    const foldingModel = this.getFoldingModel();
    if (!foldingModel || !this.mouseDownInfo || !e.target) {
      return;
    }
    let lineNumber = this.mouseDownInfo.lineNumber;
    let iconClicked = this.mouseDownInfo.iconClicked;
    let range = e.target.range;
    if (!range || range.startLineNumber !== lineNumber) {
      return;
    }
    if (iconClicked) {
      if (e.target.type !== 4) {
        return;
      }
    } else {
      let model = this.editor.getModel();
      if (!model || range.startColumn !== model.getLineMaxColumn(lineNumber)) {
        return;
      }
    }
    foldingModel.then((foldingModel2) => {
      if (foldingModel2) {
        let region = foldingModel2.getRegionAtLine(lineNumber);
        if (region && region.startLineNumber === lineNumber) {
          let isCollapsed = region.isCollapsed;
          if (iconClicked || isCollapsed) {
            let surrounding = e.event.altKey;
            let toToggle = [];
            if (surrounding) {
              let filter = (otherRegion) => !otherRegion.containedBy(region) && !region.containedBy(otherRegion);
              let toMaybeToggle = foldingModel2.getRegionsInside(null, filter);
              for (const r of toMaybeToggle) {
                if (r.isCollapsed) {
                  toToggle.push(r);
                }
              }
              if (toToggle.length === 0) {
                toToggle = toMaybeToggle;
              }
            } else {
              let recursive = e.event.middleButton || e.event.shiftKey;
              if (recursive) {
                for (const r of foldingModel2.getRegionsInside(region)) {
                  if (r.isCollapsed === isCollapsed) {
                    toToggle.push(r);
                  }
                }
              }
              if (isCollapsed || !recursive || toToggle.length === 0) {
                toToggle.push(region);
              }
            }
            foldingModel2.toggleCollapseState(toToggle);
            this.reveal({ lineNumber, column: 1 });
          }
        }
      }
    }).then(void 0, onUnexpectedError);
  }
  reveal(position) {
    this.editor.revealPositionInCenterIfOutsideViewport(position, 0);
  }
};
FoldingController.ID = "editor.contrib.folding";
FoldingController = __decorate48([
  __param48(1, IContextKeyService)
], FoldingController);
var FoldingAction = class extends EditorAction {
  runEditorCommand(accessor, editor2, args) {
    let foldingController = FoldingController.get(editor2);
    if (!foldingController) {
      return;
    }
    let foldingModelPromise = foldingController.getFoldingModel();
    if (foldingModelPromise) {
      this.reportTelemetry(accessor, editor2);
      return foldingModelPromise.then((foldingModel) => {
        if (foldingModel) {
          this.invoke(foldingController, foldingModel, editor2, args);
          const selection = editor2.getSelection();
          if (selection) {
            foldingController.reveal(selection.getStartPosition());
          }
        }
      });
    }
  }
  getSelectedLines(editor2) {
    let selections = editor2.getSelections();
    return selections ? selections.map((s) => s.startLineNumber) : [];
  }
  getLineNumbers(args, editor2) {
    if (args && args.selectionLines) {
      return args.selectionLines.map((l) => l + 1);
    }
    return this.getSelectedLines(editor2);
  }
  run(_accessor, _editor) {
  }
};
function foldingArgumentsConstraint(args) {
  if (!isUndefined(args)) {
    if (!isObject(args)) {
      return false;
    }
    const foldingArgs = args;
    if (!isUndefined(foldingArgs.levels) && !isNumber(foldingArgs.levels)) {
      return false;
    }
    if (!isUndefined(foldingArgs.direction) && !isString(foldingArgs.direction)) {
      return false;
    }
    if (!isUndefined(foldingArgs.selectionLines) && (!isArray(foldingArgs.selectionLines) || !foldingArgs.selectionLines.every(isNumber))) {
      return false;
    }
  }
  return true;
}
var UnfoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfold",
      label: localize("unfoldAction.label", "Unfold"),
      alias: "Unfold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 89,
        mac: {
          primary: 2048 | 512 | 89
        },
        weight: 100
      },
      description: {
        description: "Unfold the content in the editor",
        args: [
          {
            name: "Unfold editor argument",
            description: `Property-value pairs that can be passed through this argument:
						* 'levels': Number of levels to unfold. If not set, defaults to 1.
						* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.
						* 'selectionLines': The start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.
						`,
            constraint: foldingArgumentsConstraint,
            schema: {
              "type": "object",
              "properties": {
                "levels": {
                  "type": "number",
                  "default": 1
                },
                "direction": {
                  "type": "string",
                  "enum": ["up", "down"],
                  "default": "down"
                },
                "selectionLines": {
                  "type": "array",
                  "items": {
                    "type": "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args) {
    let levels = args && args.levels || 1;
    let lineNumbers = this.getLineNumbers(args, editor2);
    if (args && args.direction === "up") {
      setCollapseStateLevelsUp(foldingModel, false, levels, lineNumbers);
    } else {
      setCollapseStateLevelsDown(foldingModel, false, levels, lineNumbers);
    }
  }
};
var UnFoldRecursivelyAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldRecursively",
      label: localize("unFoldRecursivelyAction.label", "Unfold Recursively"),
      alias: "Unfold Recursively",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 89),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, _args) {
    setCollapseStateLevelsDown(foldingModel, false, Number.MAX_VALUE, this.getSelectedLines(editor2));
  }
};
var FoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.fold",
      label: localize("foldAction.label", "Fold"),
      alias: "Fold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 87,
        mac: {
          primary: 2048 | 512 | 87
        },
        weight: 100
      },
      description: {
        description: "Fold the content in the editor",
        args: [
          {
            name: "Fold editor argument",
            description: `Property-value pairs that can be passed through this argument:
							* 'levels': Number of levels to fold.
							* 'direction': If 'up', folds given number of levels up otherwise folds down.
							* 'selectionLines': The start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.
							If no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.
						`,
            constraint: foldingArgumentsConstraint,
            schema: {
              "type": "object",
              "properties": {
                "levels": {
                  "type": "number"
                },
                "direction": {
                  "type": "string",
                  "enum": ["up", "down"]
                },
                "selectionLines": {
                  "type": "array",
                  "items": {
                    "type": "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2, args) {
    let lineNumbers = this.getLineNumbers(args, editor2);
    const levels = args && args.levels;
    const direction = args && args.direction;
    if (typeof levels !== "number" && typeof direction !== "string") {
      setCollapseStateUp(foldingModel, true, lineNumbers);
    } else {
      if (direction === "up") {
        setCollapseStateLevelsUp(foldingModel, true, levels || 1, lineNumbers);
      } else {
        setCollapseStateLevelsDown(foldingModel, true, levels || 1, lineNumbers);
      }
    }
  }
};
var ToggleFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.toggleFold",
      label: localize("toggleFoldAction.label", "Toggle Fold"),
      alias: "Toggle Fold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 42),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    let selectedLines = this.getSelectedLines(editor2);
    toggleCollapseState(foldingModel, 1, selectedLines);
  }
};
var FoldRecursivelyAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldRecursively",
      label: localize("foldRecursivelyAction.label", "Fold Recursively"),
      alias: "Fold Recursively",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 87),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    let selectedLines = this.getSelectedLines(editor2);
    setCollapseStateLevelsDown(foldingModel, true, Number.MAX_VALUE, selectedLines);
  }
};
var FoldAllBlockCommentsAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllBlockComments",
      label: localize("foldAllBlockComments.label", "Fold All Block Comments"),
      alias: "Fold All Block Comments",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 85),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind.Comment.value, true);
    } else {
      const editorModel = editor2.getModel();
      if (!editorModel) {
        return;
      }
      const comments = LanguageConfigurationRegistry.getComments(editorModel.getLanguageId());
      if (comments && comments.blockCommentStartToken) {
        let regExp = new RegExp("^\\s*" + escapeRegExpCharacters(comments.blockCommentStartToken));
        setCollapseStateForMatchingLines(foldingModel, regExp, true);
      }
    }
  }
};
var FoldAllRegionsAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllMarkerRegions",
      label: localize("foldAllMarkerRegions.label", "Fold All Regions"),
      alias: "Fold All Regions",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 29),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, true);
    } else {
      const editorModel = editor2.getModel();
      if (!editorModel) {
        return;
      }
      const foldingRules = LanguageConfigurationRegistry.getFoldingRules(editorModel.getLanguageId());
      if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
        let regExp = new RegExp(foldingRules.markers.start);
        setCollapseStateForMatchingLines(foldingModel, regExp, true);
      }
    }
  }
};
var UnfoldAllRegionsAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAllMarkerRegions",
      label: localize("unfoldAllMarkerRegions.label", "Unfold All Regions"),
      alias: "Unfold All Regions",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 30),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    if (foldingModel.regions.hasTypes()) {
      setCollapseStateForType(foldingModel, FoldingRangeKind.Region.value, false);
    } else {
      const editorModel = editor2.getModel();
      if (!editorModel) {
        return;
      }
      const foldingRules = LanguageConfigurationRegistry.getFoldingRules(editorModel.getLanguageId());
      if (foldingRules && foldingRules.markers && foldingRules.markers.start) {
        let regExp = new RegExp(foldingRules.markers.start);
        setCollapseStateForMatchingLines(foldingModel, regExp, false);
      }
    }
  }
};
var FoldAllRegionsExceptAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAllExcept",
      label: localize("foldAllExcept.label", "Fold All Regions Except Selected"),
      alias: "Fold All Regions Except Selected",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 83),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    let selectedLines = this.getSelectedLines(editor2);
    setCollapseStateForRest(foldingModel, true, selectedLines);
  }
};
var UnfoldAllRegionsExceptAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAllExcept",
      label: localize("unfoldAllExcept.label", "Unfold All Regions Except Selected"),
      alias: "Unfold All Regions Except Selected",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 81),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    let selectedLines = this.getSelectedLines(editor2);
    setCollapseStateForRest(foldingModel, false, selectedLines);
  }
};
var FoldAllAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.foldAll",
      label: localize("foldAllAction.label", "Fold All"),
      alias: "Fold All",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 21),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, _editor) {
    setCollapseStateLevelsDown(foldingModel, true);
  }
};
var UnfoldAllAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.unfoldAll",
      label: localize("unfoldAllAction.label", "Unfold All"),
      alias: "Unfold All",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 40),
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, _editor) {
    setCollapseStateLevelsDown(foldingModel, false);
  }
};
var FoldLevelAction = class extends FoldingAction {
  getFoldingLevel() {
    return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));
  }
  invoke(_foldingController, foldingModel, editor2) {
    setCollapseStateAtLevel(foldingModel, this.getFoldingLevel(), true, this.getSelectedLines(editor2));
  }
};
FoldLevelAction.ID_PREFIX = "editor.foldLevel";
FoldLevelAction.ID = (level) => FoldLevelAction.ID_PREFIX + level;
var GotoParentFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.gotoParentFold",
      label: localize("gotoParentFold.label", "Go to Parent Fold"),
      alias: "Go to Parent Fold",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    let selectedLines = this.getSelectedLines(editor2);
    if (selectedLines.length > 0) {
      let startLineNumber = getParentFoldLine(selectedLines[0], foldingModel);
      if (startLineNumber !== null) {
        editor2.setSelection({
          startLineNumber,
          startColumn: 1,
          endLineNumber: startLineNumber,
          endColumn: 1
        });
      }
    }
  }
};
var GotoPreviousFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.gotoPreviousFold",
      label: localize("gotoPreviousFold.label", "Go to Previous Folding Range"),
      alias: "Go to Previous Folding Range",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    let selectedLines = this.getSelectedLines(editor2);
    if (selectedLines.length > 0) {
      let startLineNumber = getPreviousFoldLine(selectedLines[0], foldingModel);
      if (startLineNumber !== null) {
        editor2.setSelection({
          startLineNumber,
          startColumn: 1,
          endLineNumber: startLineNumber,
          endColumn: 1
        });
      }
    }
  }
};
var GotoNextFoldAction = class extends FoldingAction {
  constructor() {
    super({
      id: "editor.gotoNextFold",
      label: localize("gotoNextFold.label", "Go to Next Folding Range"),
      alias: "Go to Next Folding Range",
      precondition: CONTEXT_FOLDING_ENABLED,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        weight: 100
      }
    });
  }
  invoke(_foldingController, foldingModel, editor2) {
    let selectedLines = this.getSelectedLines(editor2);
    if (selectedLines.length > 0) {
      let startLineNumber = getNextFoldLine(selectedLines[0], foldingModel);
      if (startLineNumber !== null) {
        editor2.setSelection({
          startLineNumber,
          startColumn: 1,
          endLineNumber: startLineNumber,
          endColumn: 1
        });
      }
    }
  }
};
registerEditorContribution(FoldingController.ID, FoldingController);
registerEditorAction(UnfoldAction);
registerEditorAction(UnFoldRecursivelyAction);
registerEditorAction(FoldAction);
registerEditorAction(FoldRecursivelyAction);
registerEditorAction(FoldAllAction);
registerEditorAction(UnfoldAllAction);
registerEditorAction(FoldAllBlockCommentsAction);
registerEditorAction(FoldAllRegionsAction);
registerEditorAction(UnfoldAllRegionsAction);
registerEditorAction(FoldAllRegionsExceptAction);
registerEditorAction(UnfoldAllRegionsExceptAction);
registerEditorAction(ToggleFoldAction);
registerEditorAction(GotoParentFoldAction);
registerEditorAction(GotoPreviousFoldAction);
registerEditorAction(GotoNextFoldAction);
for (let i = 1; i <= 7; i++) {
  registerInstantiatedEditorAction(new FoldLevelAction({
    id: FoldLevelAction.ID(i),
    label: localize("foldLevelAction.label", "Fold Level {0}", i),
    alias: `Fold Level ${i}`,
    precondition: CONTEXT_FOLDING_ENABLED,
    kbOpts: {
      kbExpr: EditorContextKeys.editorTextFocus,
      primary: KeyChord(2048 | 41, 2048 | 21 + i),
      weight: 100
    }
  }));
}
var foldBackgroundBackground = registerColor("editor.foldBackground", { light: transparent(editorSelectionBackground, 0.3), dark: transparent(editorSelectionBackground, 0.3), hc: null }, localize("foldBackgroundBackground", "Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations."), true);
var editorFoldForeground = registerColor("editorGutter.foldingControlForeground", { dark: iconForeground, light: iconForeground, hc: iconForeground }, localize("editorGutter.foldingControlForeground", "Color of the folding control in the editor gutter."));
registerThemingParticipant((theme, collector) => {
  const foldBackground = theme.getColor(foldBackgroundBackground);
  if (foldBackground) {
    collector.addRule(`.monaco-editor .folded-background { background-color: ${foldBackground}; }`);
  }
  const editorFoldColor = theme.getColor(editorFoldForeground);
  if (editorFoldColor) {
    collector.addRule(`
		.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingExpandedIcon)},
		.monaco-editor .cldr${ThemeIcon.asCSSSelector(foldingCollapsedIcon)} {
			color: ${editorFoldColor} !important;
		}
		`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/fontZoom/fontZoom.js
var EditorFontZoomIn = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomIn",
      label: localize("EditorFontZoomIn.label", "Editor Font Zoom In"),
      alias: "Editor Font Zoom In",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() + 1);
  }
};
var EditorFontZoomOut = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomOut",
      label: localize("EditorFontZoomOut.label", "Editor Font Zoom Out"),
      alias: "Editor Font Zoom Out",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(EditorZoom.getZoomLevel() - 1);
  }
};
var EditorFontZoomReset = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.fontZoomReset",
      label: localize("EditorFontZoomReset.label", "Editor Font Zoom Reset"),
      alias: "Editor Font Zoom Reset",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    EditorZoom.setZoomLevel(0);
  }
};
registerEditorAction(EditorFontZoomIn);
registerEditorAction(EditorFontZoomOut);
registerEditorAction(EditorFontZoomReset);

// node_modules/monaco-editor/esm/vs/editor/contrib/format/formatActions.js
var __decorate49 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param49 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter32 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var FormatOnType = class FormatOnType2 {
  constructor(editor2, _workerService) {
    this._workerService = _workerService;
    this._callOnDispose = new DisposableStore();
    this._callOnModel = new DisposableStore();
    this._editor = editor2;
    this._callOnDispose.add(editor2.onDidChangeConfiguration(() => this._update()));
    this._callOnDispose.add(editor2.onDidChangeModel(() => this._update()));
    this._callOnDispose.add(editor2.onDidChangeModelLanguage(() => this._update()));
    this._callOnDispose.add(OnTypeFormattingEditProviderRegistry.onDidChange(this._update, this));
  }
  dispose() {
    this._callOnDispose.dispose();
    this._callOnModel.dispose();
  }
  _update() {
    this._callOnModel.clear();
    if (!this._editor.getOption(48)) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    const [support] = OnTypeFormattingEditProviderRegistry.ordered(model);
    if (!support || !support.autoFormatTriggerCharacters) {
      return;
    }
    let triggerChars = new CharacterSet();
    for (let ch of support.autoFormatTriggerCharacters) {
      triggerChars.add(ch.charCodeAt(0));
    }
    this._callOnModel.add(this._editor.onDidType((text2) => {
      let lastCharCode = text2.charCodeAt(text2.length - 1);
      if (triggerChars.has(lastCharCode)) {
        this._trigger(String.fromCharCode(lastCharCode));
      }
    }));
  }
  _trigger(ch) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (this._editor.getSelections().length > 1 || !this._editor.getSelection().isEmpty()) {
      return;
    }
    const model = this._editor.getModel();
    const position = this._editor.getPosition();
    let canceled2 = false;
    const unbind = this._editor.onDidChangeModelContent((e) => {
      if (e.isFlush) {
        canceled2 = true;
        unbind.dispose();
        return;
      }
      for (let i = 0, len = e.changes.length; i < len; i++) {
        const change = e.changes[i];
        if (change.range.endLineNumber <= position.lineNumber) {
          canceled2 = true;
          unbind.dispose();
          return;
        }
      }
    });
    getOnTypeFormattingEdits(this._workerService, model, position, ch, model.getFormattingOptions()).then((edits) => {
      unbind.dispose();
      if (canceled2) {
        return;
      }
      if (isNonEmptyArray(edits)) {
        FormattingEdit.execute(this._editor, edits, true);
        alertFormattingEdits(edits);
      }
    }, (err) => {
      unbind.dispose();
      throw err;
    });
  }
};
FormatOnType.ID = "editor.contrib.autoFormat";
FormatOnType = __decorate49([
  __param49(1, IEditorWorkerService)
], FormatOnType);
var FormatOnPaste = class FormatOnPaste2 {
  constructor(editor2, _instantiationService) {
    this.editor = editor2;
    this._instantiationService = _instantiationService;
    this._callOnDispose = new DisposableStore();
    this._callOnModel = new DisposableStore();
    this._callOnDispose.add(editor2.onDidChangeConfiguration(() => this._update()));
    this._callOnDispose.add(editor2.onDidChangeModel(() => this._update()));
    this._callOnDispose.add(editor2.onDidChangeModelLanguage(() => this._update()));
    this._callOnDispose.add(DocumentRangeFormattingEditProviderRegistry.onDidChange(this._update, this));
  }
  dispose() {
    this._callOnDispose.dispose();
    this._callOnModel.dispose();
  }
  _update() {
    this._callOnModel.clear();
    if (!this.editor.getOption(47)) {
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    if (!DocumentRangeFormattingEditProviderRegistry.has(this.editor.getModel())) {
      return;
    }
    this._callOnModel.add(this.editor.onDidPaste(({ range }) => this._trigger(range)));
  }
  _trigger(range) {
    if (!this.editor.hasModel()) {
      return;
    }
    if (this.editor.getSelections().length > 1) {
      return;
    }
    this._instantiationService.invokeFunction(formatDocumentRangesWithSelectedProvider, this.editor, range, 2, Progress.None, CancellationToken.None).catch(onUnexpectedError);
  }
};
FormatOnPaste.ID = "editor.contrib.formatOnPaste";
FormatOnPaste = __decorate49([
  __param49(1, IInstantiationService)
], FormatOnPaste);
var FormatDocumentAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.formatDocument",
      label: localize("formatDocument.label", "Format Document"),
      alias: "Format Document",
      precondition: ContextKeyExpr.and(EditorContextKeys.notInCompositeEditor, EditorContextKeys.writable, EditorContextKeys.hasDocumentFormattingProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 36,
        linux: { primary: 2048 | 1024 | 39 },
        weight: 100
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.3
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter32(this, void 0, void 0, function* () {
      if (editor2.hasModel()) {
        const instaService = accessor.get(IInstantiationService);
        const progressService = accessor.get(IEditorProgressService);
        yield progressService.showWhile(instaService.invokeFunction(formatDocumentWithSelectedProvider, editor2, 1, Progress.None, CancellationToken.None), 250);
      }
    });
  }
};
var FormatSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.formatSelection",
      label: localize("formatSelection.label", "Format Selection"),
      alias: "Format Selection",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasDocumentSelectionFormattingProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 36),
        weight: 100
      },
      contextMenuOpts: {
        when: EditorContextKeys.hasNonEmptySelection,
        group: "1_modification",
        order: 1.31
      }
    });
  }
  run(accessor, editor2) {
    return __awaiter32(this, void 0, void 0, function* () {
      if (!editor2.hasModel()) {
        return;
      }
      const instaService = accessor.get(IInstantiationService);
      const model = editor2.getModel();
      const ranges = editor2.getSelections().map((range) => {
        return range.isEmpty() ? new Range(range.startLineNumber, 1, range.startLineNumber, model.getLineMaxColumn(range.startLineNumber)) : range;
      });
      const progressService = accessor.get(IEditorProgressService);
      yield progressService.showWhile(instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor2, ranges, 1, Progress.None, CancellationToken.None), 250);
    });
  }
};
registerEditorContribution(FormatOnType.ID, FormatOnType);
registerEditorContribution(FormatOnPaste.ID, FormatOnPaste);
registerEditorAction(FormatDocumentAction);
registerEditorAction(FormatSelectionAction);
CommandsRegistry.registerCommand("editor.action.format", (accessor) => __awaiter32(void 0, void 0, void 0, function* () {
  const editor2 = accessor.get(ICodeEditorService).getFocusedCodeEditor();
  if (!editor2 || !editor2.hasModel()) {
    return;
  }
  const commandService = accessor.get(ICommandService);
  if (editor2.getSelection().isEmpty()) {
    yield commandService.executeCommand("editor.action.formatDocument");
  } else {
    yield commandService.executeCommand("editor.action.formatSelection");
  }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/outlineModel.js
var TreeElement = class {
  remove() {
    if (this.parent) {
      this.parent.children.delete(this.id);
    }
  }
  static findId(candidate, container) {
    let candidateId;
    if (typeof candidate === "string") {
      candidateId = `${container.id}/${candidate}`;
    } else {
      candidateId = `${container.id}/${candidate.name}`;
      if (container.children.get(candidateId) !== void 0) {
        candidateId = `${container.id}/${candidate.name}_${candidate.range.startLineNumber}_${candidate.range.startColumn}`;
      }
    }
    let id = candidateId;
    for (let i = 0; container.children.get(id) !== void 0; i++) {
      id = `${candidateId}_${i}`;
    }
    return id;
  }
  static empty(element) {
    return element.children.size === 0;
  }
};
var OutlineElement = class extends TreeElement {
  constructor(id, parent, symbol) {
    super();
    this.id = id;
    this.parent = parent;
    this.symbol = symbol;
    this.children = new Map();
  }
};
var OutlineGroup = class extends TreeElement {
  constructor(id, parent, label, order) {
    super();
    this.id = id;
    this.parent = parent;
    this.label = label;
    this.order = order;
    this.children = new Map();
  }
};
var OutlineModel = class extends TreeElement {
  constructor(uri) {
    super();
    this.uri = uri;
    this.id = "root";
    this.parent = void 0;
    this._groups = new Map();
    this.children = new Map();
    this.id = "root";
    this.parent = void 0;
  }
  static create(textModel, token) {
    let key = this._keys.for(textModel, true);
    let data = OutlineModel._requests.get(key);
    if (!data) {
      let source = new CancellationTokenSource();
      data = {
        promiseCnt: 0,
        source,
        promise: OutlineModel._create(textModel, source.token),
        model: void 0
      };
      OutlineModel._requests.set(key, data);
      const now = Date.now();
      data.promise.then(() => {
        this._requestDurations.update(textModel, Date.now() - now);
      });
    }
    if (data.model) {
      return Promise.resolve(data.model);
    }
    data.promiseCnt += 1;
    token.onCancellationRequested(() => {
      if (--data.promiseCnt === 0) {
        data.source.cancel();
        OutlineModel._requests.delete(key);
      }
    });
    return new Promise((resolve, reject) => {
      data.promise.then((model) => {
        data.model = model;
        resolve(model);
      }, (err) => {
        OutlineModel._requests.delete(key);
        reject(err);
      });
    });
  }
  static _create(textModel, token) {
    const cts = new CancellationTokenSource(token);
    const result = new OutlineModel(textModel.uri);
    const provider = DocumentSymbolProviderRegistry.ordered(textModel);
    const promises = provider.map((provider2, index) => {
      var _a5;
      let id = TreeElement.findId(`provider_${index}`, result);
      let group = new OutlineGroup(id, result, (_a5 = provider2.displayName) !== null && _a5 !== void 0 ? _a5 : "Unknown Outline Provider", index);
      return Promise.resolve(provider2.provideDocumentSymbols(textModel, cts.token)).then((result2) => {
        for (const info of result2 || []) {
          OutlineModel._makeOutlineElement(info, group);
        }
        return group;
      }, (err) => {
        onUnexpectedExternalError(err);
        return group;
      }).then((group2) => {
        if (!TreeElement.empty(group2)) {
          result._groups.set(id, group2);
        } else {
          group2.remove();
        }
      });
    });
    const listener = DocumentSymbolProviderRegistry.onDidChange(() => {
      const newProvider = DocumentSymbolProviderRegistry.ordered(textModel);
      if (!equals(newProvider, provider)) {
        cts.cancel();
      }
    });
    return Promise.all(promises).then(() => {
      if (cts.token.isCancellationRequested && !token.isCancellationRequested) {
        return OutlineModel._create(textModel, token);
      } else {
        return result._compact();
      }
    }).finally(() => {
      listener.dispose();
    });
  }
  static _makeOutlineElement(info, container) {
    let id = TreeElement.findId(info, container);
    let res = new OutlineElement(id, container, info);
    if (info.children) {
      for (const childInfo of info.children) {
        OutlineModel._makeOutlineElement(childInfo, res);
      }
    }
    container.children.set(res.id, res);
  }
  _compact() {
    let count = 0;
    for (const [key, group] of this._groups) {
      if (group.children.size === 0) {
        this._groups.delete(key);
      } else {
        count += 1;
      }
    }
    if (count !== 1) {
      this.children = this._groups;
    } else {
      let group = Iterable.first(this._groups.values());
      for (let [, child] of group.children) {
        child.parent = this;
        this.children.set(child.id, child);
      }
    }
    return this;
  }
  getTopLevelSymbols() {
    const roots = [];
    for (const child of this.children.values()) {
      if (child instanceof OutlineElement) {
        roots.push(child.symbol);
      } else {
        roots.push(...Iterable.map(child.children.values(), (child2) => child2.symbol));
      }
    }
    return roots.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
  }
  asListOfDocumentSymbols() {
    const roots = this.getTopLevelSymbols();
    const bucket = [];
    OutlineModel._flattenDocumentSymbols(bucket, roots, "");
    return bucket.sort((a, b) => Range.compareRangesUsingStarts(a.range, b.range));
  }
  static _flattenDocumentSymbols(bucket, entries, overrideContainerLabel) {
    for (const entry of entries) {
      bucket.push({
        kind: entry.kind,
        tags: entry.tags,
        name: entry.name,
        detail: entry.detail,
        containerName: entry.containerName || overrideContainerLabel,
        range: entry.range,
        selectionRange: entry.selectionRange,
        children: void 0
      });
      if (entry.children) {
        OutlineModel._flattenDocumentSymbols(bucket, entry.children, entry.name);
      }
    }
  }
};
OutlineModel._requestDurations = new LanguageFeatureRequestDelays(DocumentSymbolProviderRegistry, 350);
OutlineModel._requests = new LRUCache(9, 0.75);
OutlineModel._keys = new class {
  constructor() {
    this._counter = 1;
    this._data = new WeakMap();
  }
  for(textModel, version2) {
    return `${textModel.id}/${version2 ? textModel.getVersionId() : ""}/${this._hash(DocumentSymbolProviderRegistry.all(textModel))}`;
  }
  _hash(providers) {
    let result = "";
    for (const provider of providers) {
      let n = this._data.get(provider);
      if (typeof n === "undefined") {
        n = this._counter++;
        this._data.set(provider, n);
      }
      result += n;
    }
    return result;
  }
}();

// node_modules/monaco-editor/esm/vs/editor/contrib/documentSymbols/documentSymbols.js
var __awaiter33 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getDocumentSymbols(document2, flat, token) {
  return __awaiter33(this, void 0, void 0, function* () {
    const model = yield OutlineModel.create(document2, token);
    return flat ? model.asListOfDocumentSymbols() : model.getTopLevelSymbols();
  });
}
CommandsRegistry.registerCommand("_executeDocumentSymbolProvider", function(accessor, ...args) {
  return __awaiter33(this, void 0, void 0, function* () {
    const [resource] = args;
    assertType(URI.isUri(resource));
    const model = accessor.get(IModelService).getModel(resource);
    if (model) {
      return getDocumentSymbols(model, false, CancellationToken.None);
    }
    const reference = yield accessor.get(ITextModelService).createModelReference(resource);
    try {
      return yield getDocumentSymbols(reference.object.textEditorModel, false, CancellationToken.None);
    } finally {
      reference.dispose();
    }
  });
});

// node_modules/monaco-editor/esm/vs/editor/contrib/indentation/indentUtils.js
function getSpaceCnt(str, tabSize) {
  let spacesCnt = 0;
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) === "	") {
      spacesCnt += tabSize;
    } else {
      spacesCnt++;
    }
  }
  return spacesCnt;
}
function generateIndent(spacesCnt, tabSize, insertSpaces) {
  spacesCnt = spacesCnt < 0 ? 0 : spacesCnt;
  let result = "";
  if (!insertSpaces) {
    let tabsCnt = Math.floor(spacesCnt / tabSize);
    spacesCnt = spacesCnt % tabSize;
    for (let i = 0; i < tabsCnt; i++) {
      result += "	";
    }
  }
  for (let i = 0; i < spacesCnt; i++) {
    result += " ";
  }
  return result;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/indentation/indentation.js
function getReindentEditOperations(model, startLineNumber, endLineNumber, inheritedIndent) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return [];
  }
  const indentationRules = LanguageConfigurationRegistry.getIndentationRules(model.getLanguageId());
  if (!indentationRules) {
    return [];
  }
  endLineNumber = Math.min(endLineNumber, model.getLineCount());
  while (startLineNumber <= endLineNumber) {
    if (!indentationRules.unIndentedLinePattern) {
      break;
    }
    let text2 = model.getLineContent(startLineNumber);
    if (!indentationRules.unIndentedLinePattern.test(text2)) {
      break;
    }
    startLineNumber++;
  }
  if (startLineNumber > endLineNumber - 1) {
    return [];
  }
  const { tabSize, indentSize, insertSpaces } = model.getOptions();
  const shiftIndent = (indentation, count) => {
    count = count || 1;
    return ShiftCommand.shiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  };
  const unshiftIndent = (indentation, count) => {
    count = count || 1;
    return ShiftCommand.unshiftIndent(indentation, indentation.length + count, tabSize, indentSize, insertSpaces);
  };
  let indentEdits = [];
  let globalIndent;
  let currentLineText = model.getLineContent(startLineNumber);
  let adjustedLineContent = currentLineText;
  if (inheritedIndent !== void 0 && inheritedIndent !== null) {
    globalIndent = inheritedIndent;
    let oldIndentation = getLeadingWhitespace(currentLineText);
    adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent)) {
      globalIndent = unshiftIndent(globalIndent);
      adjustedLineContent = globalIndent + currentLineText.substring(oldIndentation.length);
    }
    if (currentLineText !== adjustedLineContent) {
      indentEdits.push(EditOperation.replaceMove(new Selection(startLineNumber, 1, startLineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(globalIndent, indentSize, insertSpaces)));
    }
  } else {
    globalIndent = getLeadingWhitespace(currentLineText);
  }
  let idealIndentForNextLine = globalIndent;
  if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    globalIndent = shiftIndent(globalIndent);
  } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent)) {
    idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
  }
  startLineNumber++;
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    let text2 = model.getLineContent(lineNumber);
    let oldIndentation = getLeadingWhitespace(text2);
    let adjustedLineContent2 = idealIndentForNextLine + text2.substring(oldIndentation.length);
    if (indentationRules.decreaseIndentPattern && indentationRules.decreaseIndentPattern.test(adjustedLineContent2)) {
      idealIndentForNextLine = unshiftIndent(idealIndentForNextLine);
      globalIndent = unshiftIndent(globalIndent);
    }
    if (oldIndentation !== idealIndentForNextLine) {
      indentEdits.push(EditOperation.replaceMove(new Selection(lineNumber, 1, lineNumber, oldIndentation.length + 1), TextModel.normalizeIndentation(idealIndentForNextLine, indentSize, insertSpaces)));
    }
    if (indentationRules.unIndentedLinePattern && indentationRules.unIndentedLinePattern.test(text2)) {
      continue;
    } else if (indentationRules.increaseIndentPattern && indentationRules.increaseIndentPattern.test(adjustedLineContent2)) {
      globalIndent = shiftIndent(globalIndent);
      idealIndentForNextLine = globalIndent;
    } else if (indentationRules.indentNextLinePattern && indentationRules.indentNextLinePattern.test(adjustedLineContent2)) {
      idealIndentForNextLine = shiftIndent(idealIndentForNextLine);
    } else {
      idealIndentForNextLine = globalIndent;
    }
  }
  return indentEdits;
}
var IndentationToSpacesAction = class extends EditorAction {
  constructor() {
    super({
      id: IndentationToSpacesAction.ID,
      label: localize("indentationToSpaces", "Convert Indentation to Spaces"),
      alias: "Convert Indentation to Spaces",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    let model = editor2.getModel();
    if (!model) {
      return;
    }
    let modelOpts = model.getOptions();
    let selection = editor2.getSelection();
    if (!selection) {
      return;
    }
    const command = new IndentationToSpacesCommand(selection, modelOpts.tabSize);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
    model.updateOptions({
      insertSpaces: true
    });
  }
};
IndentationToSpacesAction.ID = "editor.action.indentationToSpaces";
var IndentationToTabsAction = class extends EditorAction {
  constructor() {
    super({
      id: IndentationToTabsAction.ID,
      label: localize("indentationToTabs", "Convert Indentation to Tabs"),
      alias: "Convert Indentation to Tabs",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    let model = editor2.getModel();
    if (!model) {
      return;
    }
    let modelOpts = model.getOptions();
    let selection = editor2.getSelection();
    if (!selection) {
      return;
    }
    const command = new IndentationToTabsCommand(selection, modelOpts.tabSize);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
    model.updateOptions({
      insertSpaces: false
    });
  }
};
IndentationToTabsAction.ID = "editor.action.indentationToTabs";
var ChangeIndentationSizeAction = class extends EditorAction {
  constructor(insertSpaces, opts) {
    super(opts);
    this.insertSpaces = insertSpaces;
  }
  run(accessor, editor2) {
    const quickInputService = accessor.get(IQuickInputService);
    const modelService = accessor.get(IModelService);
    let model = editor2.getModel();
    if (!model) {
      return;
    }
    const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
    const picks = [1, 2, 3, 4, 5, 6, 7, 8].map((n) => ({
      id: n.toString(),
      label: n.toString(),
      description: n === creationOpts.tabSize ? localize("configuredTabSize", "Configured Tab Size") : void 0
    }));
    const autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);
    setTimeout(() => {
      quickInputService.pick(picks, { placeHolder: localize({ key: "selectTabWidth", comment: ["Tab corresponds to the tab key"] }, "Select Tab Size for Current File"), activeItem: picks[autoFocusIndex] }).then((pick) => {
        if (pick) {
          if (model && !model.isDisposed()) {
            model.updateOptions({
              tabSize: parseInt(pick.label, 10),
              insertSpaces: this.insertSpaces
            });
          }
        }
      });
    }, 50);
  }
};
var IndentUsingTabs = class extends ChangeIndentationSizeAction {
  constructor() {
    super(false, {
      id: IndentUsingTabs.ID,
      label: localize("indentUsingTabs", "Indent Using Tabs"),
      alias: "Indent Using Tabs",
      precondition: void 0
    });
  }
};
IndentUsingTabs.ID = "editor.action.indentUsingTabs";
var IndentUsingSpaces = class extends ChangeIndentationSizeAction {
  constructor() {
    super(true, {
      id: IndentUsingSpaces.ID,
      label: localize("indentUsingSpaces", "Indent Using Spaces"),
      alias: "Indent Using Spaces",
      precondition: void 0
    });
  }
};
IndentUsingSpaces.ID = "editor.action.indentUsingSpaces";
var DetectIndentation = class extends EditorAction {
  constructor() {
    super({
      id: DetectIndentation.ID,
      label: localize("detectIndentation", "Detect Indentation from Content"),
      alias: "Detect Indentation from Content",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    const modelService = accessor.get(IModelService);
    let model = editor2.getModel();
    if (!model) {
      return;
    }
    const creationOpts = modelService.getCreationOptions(model.getLanguageId(), model.uri, model.isForSimpleWidget);
    model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);
  }
};
DetectIndentation.ID = "editor.action.detectIndentation";
var ReindentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.reindentlines",
      label: localize("editor.reindentlines", "Reindent Lines"),
      alias: "Reindent Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    let model = editor2.getModel();
    if (!model) {
      return;
    }
    let edits = getReindentEditOperations(model, 1, model.getLineCount());
    if (edits.length > 0) {
      editor2.pushUndoStop();
      editor2.executeEdits(this.id, edits);
      editor2.pushUndoStop();
    }
  }
};
var ReindentSelectedLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.reindentselectedlines",
      label: localize("editor.reindentselectedlines", "Reindent Selected Lines"),
      alias: "Reindent Selected Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(accessor, editor2) {
    let model = editor2.getModel();
    if (!model) {
      return;
    }
    let selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    let edits = [];
    for (let selection of selections) {
      let startLineNumber = selection.startLineNumber;
      let endLineNumber = selection.endLineNumber;
      if (startLineNumber !== endLineNumber && selection.endColumn === 1) {
        endLineNumber--;
      }
      if (startLineNumber === 1) {
        if (startLineNumber === endLineNumber) {
          continue;
        }
      } else {
        startLineNumber--;
      }
      let editOperations = getReindentEditOperations(model, startLineNumber, endLineNumber);
      edits.push(...editOperations);
    }
    if (edits.length > 0) {
      editor2.pushUndoStop();
      editor2.executeEdits(this.id, edits);
      editor2.pushUndoStop();
    }
  }
};
var AutoIndentOnPasteCommand = class {
  constructor(edits, initialSelection) {
    this._initialSelection = initialSelection;
    this._edits = [];
    this._selectionId = null;
    for (let edit of edits) {
      if (edit.range && typeof edit.text === "string") {
        this._edits.push(edit);
      }
    }
  }
  getEditOperations(model, builder) {
    for (let edit of this._edits) {
      builder.addEditOperation(Range.lift(edit.range), edit.text);
    }
    let selectionIsSet = false;
    if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {
      if (this._edits[0].range.startColumn === this._initialSelection.endColumn && this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {
        selectionIsSet = true;
        this._selectionId = builder.trackSelection(this._initialSelection, true);
      } else if (this._edits[0].range.endColumn === this._initialSelection.startColumn && this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {
        selectionIsSet = true;
        this._selectionId = builder.trackSelection(this._initialSelection, false);
      }
    }
    if (!selectionIsSet) {
      this._selectionId = builder.trackSelection(this._initialSelection);
    }
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
};
var AutoIndentOnPaste = class {
  constructor(editor2) {
    this.callOnDispose = new DisposableStore();
    this.callOnModel = new DisposableStore();
    this.editor = editor2;
    this.callOnDispose.add(editor2.onDidChangeConfiguration(() => this.update()));
    this.callOnDispose.add(editor2.onDidChangeModel(() => this.update()));
    this.callOnDispose.add(editor2.onDidChangeModelLanguage(() => this.update()));
  }
  update() {
    this.callOnModel.clear();
    if (this.editor.getOption(9) < 4 || this.editor.getOption(47)) {
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    this.callOnModel.add(this.editor.onDidPaste(({ range }) => {
      this.trigger(range);
    }));
  }
  trigger(range) {
    let selections = this.editor.getSelections();
    if (selections === null || selections.length > 1) {
      return;
    }
    const model = this.editor.getModel();
    if (!model) {
      return;
    }
    if (!model.isCheapToTokenize(range.getStartPosition().lineNumber)) {
      return;
    }
    const autoIndent = this.editor.getOption(9);
    const { tabSize, indentSize, insertSpaces } = model.getOptions();
    let textEdits = [];
    let indentConverter = {
      shiftIndent: (indentation) => {
        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      },
      unshiftIndent: (indentation) => {
        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      }
    };
    let startLineNumber = range.startLineNumber;
    while (startLineNumber <= range.endLineNumber) {
      if (this.shouldIgnoreLine(model, startLineNumber)) {
        startLineNumber++;
        continue;
      }
      break;
    }
    if (startLineNumber > range.endLineNumber) {
      return;
    }
    let firstLineText = model.getLineContent(startLineNumber);
    if (!/\S/.test(firstLineText.substring(0, range.startColumn - 1))) {
      const indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, model, model.getLanguageId(), startLineNumber, indentConverter);
      if (indentOfFirstLine !== null) {
        let oldIndentation = getLeadingWhitespace(firstLineText);
        let newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
        let oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
        if (newSpaceCnt !== oldSpaceCnt) {
          let newIndent = generateIndent(newSpaceCnt, tabSize, insertSpaces);
          textEdits.push({
            range: new Range(startLineNumber, 1, startLineNumber, oldIndentation.length + 1),
            text: newIndent
          });
          firstLineText = newIndent + firstLineText.substr(oldIndentation.length);
        } else {
          let indentMetadata = LanguageConfigurationRegistry.getIndentMetadata(model, startLineNumber);
          if (indentMetadata === 0 || indentMetadata === 8) {
            return;
          }
        }
      }
    }
    const firstLineNumber = startLineNumber;
    while (startLineNumber < range.endLineNumber) {
      if (!/\S/.test(model.getLineContent(startLineNumber + 1))) {
        startLineNumber++;
        continue;
      }
      break;
    }
    if (startLineNumber !== range.endLineNumber) {
      let virtualModel = {
        getLineTokens: (lineNumber) => {
          return model.getLineTokens(lineNumber);
        },
        getLanguageId: () => {
          return model.getLanguageId();
        },
        getLanguageIdAtPosition: (lineNumber, column) => {
          return model.getLanguageIdAtPosition(lineNumber, column);
        },
        getLineContent: (lineNumber) => {
          if (lineNumber === firstLineNumber) {
            return firstLineText;
          } else {
            return model.getLineContent(lineNumber);
          }
        }
      };
      let indentOfSecondLine = LanguageConfigurationRegistry.getGoodIndentForLine(autoIndent, virtualModel, model.getLanguageId(), startLineNumber + 1, indentConverter);
      if (indentOfSecondLine !== null) {
        let newSpaceCntOfSecondLine = getSpaceCnt(indentOfSecondLine, tabSize);
        let oldSpaceCntOfSecondLine = getSpaceCnt(getLeadingWhitespace(model.getLineContent(startLineNumber + 1)), tabSize);
        if (newSpaceCntOfSecondLine !== oldSpaceCntOfSecondLine) {
          let spaceCntOffset = newSpaceCntOfSecondLine - oldSpaceCntOfSecondLine;
          for (let i = startLineNumber + 1; i <= range.endLineNumber; i++) {
            let lineContent = model.getLineContent(i);
            let originalIndent = getLeadingWhitespace(lineContent);
            let originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
            let newSpacesCnt = originalSpacesCnt + spaceCntOffset;
            let newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
            if (newIndent !== originalIndent) {
              textEdits.push({
                range: new Range(i, 1, i, originalIndent.length + 1),
                text: newIndent
              });
            }
          }
        }
      }
    }
    if (textEdits.length > 0) {
      this.editor.pushUndoStop();
      let cmd = new AutoIndentOnPasteCommand(textEdits, this.editor.getSelection());
      this.editor.executeCommand("autoIndentOnPaste", cmd);
      this.editor.pushUndoStop();
    }
  }
  shouldIgnoreLine(model, lineNumber) {
    model.forceTokenization(lineNumber);
    let nonWhitespaceColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
    if (nonWhitespaceColumn === 0) {
      return true;
    }
    let tokens = model.getLineTokens(lineNumber);
    if (tokens.getCount() > 0) {
      let firstNonWhitespaceTokenIndex = tokens.findTokenIndexAtOffset(nonWhitespaceColumn);
      if (firstNonWhitespaceTokenIndex >= 0 && tokens.getStandardTokenType(firstNonWhitespaceTokenIndex) === 1) {
        return true;
      }
    }
    return false;
  }
  dispose() {
    this.callOnDispose.dispose();
    this.callOnModel.dispose();
  }
};
AutoIndentOnPaste.ID = "editor.contrib.autoIndentOnPaste";
function getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {
  if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
    return;
  }
  let spaces = "";
  for (let i = 0; i < tabSize; i++) {
    spaces += " ";
  }
  let spacesRegExp = new RegExp(spaces, "gi");
  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
    let lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(lineNumber);
    if (lastIndentationColumn === 0) {
      lastIndentationColumn = model.getLineMaxColumn(lineNumber);
    }
    if (lastIndentationColumn === 1) {
      continue;
    }
    const originalIndentationRange = new Range(lineNumber, 1, lineNumber, lastIndentationColumn);
    const originalIndentation = model.getValueInRange(originalIndentationRange);
    const newIndentation = tabsToSpaces ? originalIndentation.replace(/\t/ig, spaces) : originalIndentation.replace(spacesRegExp, "	");
    builder.addEditOperation(originalIndentationRange, newIndentation);
  }
}
var IndentationToSpacesCommand = class {
  constructor(selection, tabSize) {
    this.selection = selection;
    this.tabSize = tabSize;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    this.selectionId = builder.trackSelection(this.selection);
    getIndentationEditOperations(model, builder, this.tabSize, true);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
};
var IndentationToTabsCommand = class {
  constructor(selection, tabSize) {
    this.selection = selection;
    this.tabSize = tabSize;
    this.selectionId = null;
  }
  getEditOperations(model, builder) {
    this.selectionId = builder.trackSelection(this.selection);
    getIndentationEditOperations(model, builder, this.tabSize, false);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
};
registerEditorContribution(AutoIndentOnPaste.ID, AutoIndentOnPaste);
registerEditorAction(IndentationToSpacesAction);
registerEditorAction(IndentationToTabsAction);
registerEditorAction(IndentUsingTabs);
registerEditorAction(IndentUsingSpaces);
registerEditorAction(DetectIndentation);
registerEditorAction(ReindentLinesAction);
registerEditorAction(ReindentSelectedLinesAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/inlayHints/inlayHintsController.js
var __awaiter34 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var MAX_DECORATORS2 = 1500;
var RequestMap = class {
  constructor() {
    this._data = new ResourceMap();
  }
  push(model, provider) {
    const value = this._data.get(model.uri);
    if (value === void 0) {
      this._data.set(model.uri, new Set([provider]));
    } else {
      value.add(provider);
    }
  }
  pop(model, provider) {
    const value = this._data.get(model.uri);
    if (value) {
      value.delete(provider);
      if (value.size === 0) {
        this._data.delete(model.uri);
      }
    }
  }
  has(model, provider) {
    var _a5;
    return Boolean((_a5 = this._data.get(model.uri)) === null || _a5 === void 0 ? void 0 : _a5.has(provider));
  }
};
function getInlayHints(model, ranges, requests, token) {
  return __awaiter34(this, void 0, void 0, function* () {
    const all = [];
    const providers = InlayHintsProviderRegistry.ordered(model).reverse();
    const promises = providers.map((provider) => ranges.map((range) => __awaiter34(this, void 0, void 0, function* () {
      try {
        requests.push(model, provider);
        const result = yield provider.provideInlayHints(model, range, token);
        if (result === null || result === void 0 ? void 0 : result.length) {
          all.push(result.filter((hint) => range.containsPosition(hint.position)));
        }
      } catch (err) {
        onUnexpectedExternalError(err);
      } finally {
        requests.pop(model, provider);
      }
    })));
    yield Promise.all(promises.flat());
    return all.flat().sort((a, b) => Position.compare(a.position, b.position));
  });
}
var InlayHintsCache = class {
  constructor() {
    this._entries = new LRUCache(50);
  }
  get(model) {
    const key = InlayHintsCache._key(model);
    return this._entries.get(key);
  }
  set(model, value) {
    const key = InlayHintsCache._key(model);
    this._entries.set(key, value);
  }
  static _key(model) {
    return `${model.uri.toString()}/${model.getVersionId()}`;
  }
};
var InlayHintsController = class {
  constructor(_editor) {
    this._editor = _editor;
    this._decorationOwnerId = ++InlayHintsController._decorationOwnerIdPool;
    this._disposables = new DisposableStore();
    this._sessionDisposables = new DisposableStore();
    this._getInlayHintsDelays = new LanguageFeatureRequestDelays(InlayHintsProviderRegistry, 25, 500);
    this._cache = new InlayHintsCache();
    this._decorationsMetadata = new Map();
    this._ruleFactory = new DynamicCssRules(this._editor);
    this._disposables.add(InlayHintsProviderRegistry.onDidChange(() => this._update()));
    this._disposables.add(_editor.onDidChangeModel(() => this._update()));
    this._disposables.add(_editor.onDidChangeModelLanguage(() => this._update()));
    this._disposables.add(_editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(126)) {
        this._update();
      }
    }));
    this._update();
  }
  dispose() {
    this._sessionDisposables.dispose();
    this._removeAllDecorations();
    this._disposables.dispose();
  }
  _update() {
    this._sessionDisposables.clear();
    this._removeAllDecorations();
    if (!this._editor.getOption(126).enabled) {
      return;
    }
    const model = this._editor.getModel();
    if (!model || !InlayHintsProviderRegistry.has(model)) {
      return;
    }
    const cached = this._cache.get(model);
    if (cached) {
      this._updateHintsDecorators([model.getFullModelRange()], cached);
    }
    const requests = new RequestMap();
    const scheduler = new RunOnceScheduler(() => __awaiter34(this, void 0, void 0, function* () {
      const t1 = Date.now();
      const cts = new CancellationTokenSource();
      this._sessionDisposables.add(toDisposable(() => cts.dispose(true)));
      const ranges = this._getHintsRanges();
      const result = yield getInlayHints(model, ranges, requests, cts.token);
      scheduler.delay = this._getInlayHintsDelays.update(model, Date.now() - t1);
      if (cts.token.isCancellationRequested) {
        return;
      }
      this._updateHintsDecorators(ranges, result);
      this._cache.set(model, Array.from(this._decorationsMetadata.values()).map((obj) => obj.hint));
    }), this._getInlayHintsDelays.get(model));
    this._sessionDisposables.add(scheduler);
    this._sessionDisposables.add(this._editor.onDidChangeModelContent(() => scheduler.schedule()));
    this._sessionDisposables.add(this._editor.onDidScrollChange(() => scheduler.schedule()));
    scheduler.schedule();
    const providerListener = new DisposableStore();
    this._sessionDisposables.add(providerListener);
    for (const provider of InlayHintsProviderRegistry.all(model)) {
      if (typeof provider.onDidChangeInlayHints === "function") {
        providerListener.add(provider.onDidChangeInlayHints(() => {
          if (!requests.has(model, provider)) {
            scheduler.schedule();
          }
        }));
      }
    }
  }
  _getHintsRanges() {
    const extra = 30;
    const model = this._editor.getModel();
    const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
    const result = [];
    for (const range of visibleRanges.sort(Range.compareRangesUsingStarts)) {
      const extendedRange = model.validateRange(new Range(range.startLineNumber - extra, range.startColumn, range.endLineNumber + extra, range.endColumn));
      if (result.length === 0 || !Range.areIntersectingOrTouching(result[result.length - 1], extendedRange)) {
        result.push(extendedRange);
      } else {
        result[result.length - 1] = Range.plusRange(result[result.length - 1], extendedRange);
      }
    }
    return result;
  }
  _updateHintsDecorators(ranges, hints) {
    const { fontSize, fontFamily } = this._getLayoutInfo();
    const model = this._editor.getModel();
    const newDecorationsData = [];
    const fontFamilyVar = "--code-editorInlayHintsFontFamily";
    this._editor.getContainerDomNode().style.setProperty(fontFamilyVar, fontFamily);
    for (const hint of hints) {
      const { text: text2, position, whitespaceBefore, whitespaceAfter } = hint;
      const marginBefore = whitespaceBefore ? fontSize / 3 | 0 : 0;
      const marginAfter = whitespaceAfter ? fontSize / 3 | 0 : 0;
      let backgroundColor;
      let color;
      if (hint.kind === InlayHintKind.Parameter) {
        backgroundColor = themeColorFromId(editorInlayHintParameterBackground);
        color = themeColorFromId(editorInlayHintParameterForeground);
      } else if (hint.kind === InlayHintKind.Type) {
        backgroundColor = themeColorFromId(editorInlayHintTypeBackground);
        color = themeColorFromId(editorInlayHintTypeForeground);
      } else {
        backgroundColor = themeColorFromId(editorInlayHintBackground);
        color = themeColorFromId(editorInlayHintForeground);
      }
      const classNameRef = this._ruleFactory.createClassNameRef({
        fontSize: `${fontSize}px`,
        margin: `0px ${marginAfter}px 0px ${marginBefore}px`,
        fontFamily: `var(${fontFamilyVar}), ${EDITOR_FONT_DEFAULTS.fontFamily}`,
        padding: `1px ${Math.max(1, fontSize / 4) | 0}px`,
        borderRadius: `${fontSize / 4 | 0}px`,
        verticalAlign: "middle",
        backgroundColor,
        color
      });
      let direction = "before";
      let range = Range.fromPositions(position);
      let word = model.getWordAtPosition(position);
      let usesWordRange = false;
      if (word) {
        if (word.endColumn === position.column) {
          direction = "after";
          usesWordRange = true;
          range = wordToRange(word, position.lineNumber);
        } else if (word.startColumn === position.column) {
          usesWordRange = true;
          range = wordToRange(word, position.lineNumber);
        }
      }
      newDecorationsData.push({
        decoration: {
          range,
          options: {
            [direction]: {
              content: fixSpace(text2),
              inlineClassNameAffectsLetterSpacing: true,
              inlineClassName: classNameRef.className
            },
            description: "InlayHint",
            showIfCollapsed: !usesWordRange,
            stickiness: 0
          }
        },
        classNameRef
      });
      if (newDecorationsData.length > MAX_DECORATORS2) {
        break;
      }
    }
    const decorationIdsToReplace = [];
    for (const range of ranges) {
      for (const { id } of model.getDecorationsInRange(range, this._decorationOwnerId, true)) {
        const metadata = this._decorationsMetadata.get(id);
        if (metadata) {
          decorationIdsToReplace.push(id);
          metadata.classNameRef.dispose();
          this._decorationsMetadata.delete(id);
        }
      }
    }
    const newDecorationIds = model.deltaDecorations(decorationIdsToReplace, newDecorationsData.map((d) => d.decoration), this._decorationOwnerId);
    for (let i = 0; i < newDecorationIds.length; i++) {
      this._decorationsMetadata.set(newDecorationIds[i], { hint: hints[i], classNameRef: newDecorationsData[i].classNameRef });
    }
  }
  _getLayoutInfo() {
    const options = this._editor.getOption(126);
    const editorFontSize = this._editor.getOption(45);
    let fontSize = options.fontSize;
    if (!fontSize || fontSize < 5 || fontSize > editorFontSize) {
      fontSize = editorFontSize * 0.9 | 0;
    }
    const fontFamily = options.fontFamily || this._editor.getOption(42);
    return { fontSize, fontFamily };
  }
  _removeAllDecorations() {
    this._editor.deltaDecorations(Array.from(this._decorationsMetadata.keys()), []);
    for (let obj of this._decorationsMetadata.values()) {
      obj.classNameRef.dispose();
    }
    this._decorationsMetadata.clear();
  }
};
InlayHintsController.ID = "editor.contrib.InlayHints";
InlayHintsController._decorationOwnerIdPool = 0;
function wordToRange(word, lineNumber) {
  return new Range(lineNumber, word.startColumn, lineNumber, word.endColumn);
}
function fixSpace(str) {
  const noBreakWhitespace2 = "\xA0";
  return str.replace(/[ \t]/g, noBreakWhitespace2);
}
registerEditorContribution(InlayHintsController.ID, InlayHintsController);
CommandsRegistry.registerCommand("_executeInlayHintProvider", (accessor, ...args) => __awaiter34(void 0, void 0, void 0, function* () {
  const [uri, range] = args;
  assertType(URI.isUri(uri));
  assertType(Range.isIRange(range));
  const ref = yield accessor.get(ITextModelService).createModelReference(uri);
  try {
    const data = yield getInlayHints(ref.object.textEditorModel, [Range.lift(range)], new RequestMap(), CancellationToken.None);
    return data;
  } finally {
    ref.dispose();
  }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/inPlaceReplaceCommand.js
var InPlaceReplaceCommand = class {
  constructor(editRange, originalSelection, text2) {
    this._editRange = editRange;
    this._originalSelection = originalSelection;
    this._text = text2;
  }
  getEditOperations(model, builder) {
    builder.addTrackedEditOperation(this._editRange, this._text);
  }
  computeCursorState(model, helper) {
    const inverseEditOperations = helper.getInverseEditOperations();
    const srcRange = inverseEditOperations[0].range;
    if (!this._originalSelection.isEmpty()) {
      return new Selection(srcRange.endLineNumber, srcRange.endColumn - this._text.length, srcRange.endLineNumber, srcRange.endColumn);
    }
    return new Selection(srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn), srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn));
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/inPlaceReplace/inPlaceReplace.js
var __decorate50 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param50 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InPlaceReplaceController = class InPlaceReplaceController2 {
  constructor(editor2, editorWorkerService) {
    this.decorationIds = [];
    this.editor = editor2;
    this.editorWorkerService = editorWorkerService;
  }
  static get(editor2) {
    return editor2.getContribution(InPlaceReplaceController2.ID);
  }
  dispose() {
  }
  run(source, up) {
    if (this.currentRequest) {
      this.currentRequest.cancel();
    }
    const editorSelection = this.editor.getSelection();
    const model = this.editor.getModel();
    if (!model || !editorSelection) {
      return void 0;
    }
    let selection = editorSelection;
    if (selection.startLineNumber !== selection.endLineNumber) {
      return void 0;
    }
    const state = new EditorState(this.editor, 1 | 4);
    const modelURI = model.uri;
    if (!this.editorWorkerService.canNavigateValueSet(modelURI)) {
      return Promise.resolve(void 0);
    }
    this.currentRequest = createCancelablePromise((token) => this.editorWorkerService.navigateValueSet(modelURI, selection, up));
    return this.currentRequest.then((result) => {
      if (!result || !result.range || !result.value) {
        return;
      }
      if (!state.validate(this.editor)) {
        return;
      }
      let editRange = Range.lift(result.range);
      let highlightRange = result.range;
      let diff = result.value.length - (selection.endColumn - selection.startColumn);
      highlightRange = {
        startLineNumber: highlightRange.startLineNumber,
        startColumn: highlightRange.startColumn,
        endLineNumber: highlightRange.endLineNumber,
        endColumn: highlightRange.startColumn + result.value.length
      };
      if (diff > 1) {
        selection = new Selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn + diff - 1);
      }
      const command = new InPlaceReplaceCommand(editRange, selection, result.value);
      this.editor.pushUndoStop();
      this.editor.executeCommand(source, command);
      this.editor.pushUndoStop();
      this.decorationIds = this.editor.deltaDecorations(this.decorationIds, [{
        range: highlightRange,
        options: InPlaceReplaceController2.DECORATION
      }]);
      if (this.decorationRemover) {
        this.decorationRemover.cancel();
      }
      this.decorationRemover = timeout(350);
      this.decorationRemover.then(() => this.decorationIds = this.editor.deltaDecorations(this.decorationIds, [])).catch(onUnexpectedError);
    }).catch(onUnexpectedError);
  }
};
InPlaceReplaceController.ID = "editor.contrib.inPlaceReplaceController";
InPlaceReplaceController.DECORATION = ModelDecorationOptions.register({
  description: "in-place-replace",
  className: "valueSetReplacement"
});
InPlaceReplaceController = __decorate50([
  __param50(1, IEditorWorkerService)
], InPlaceReplaceController);
var InPlaceReplaceUp = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inPlaceReplace.up",
      label: localize("InPlaceReplaceAction.previous.label", "Replace with Previous Value"),
      alias: "Replace with Previous Value",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 82,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    const controller = InPlaceReplaceController.get(editor2);
    if (!controller) {
      return Promise.resolve(void 0);
    }
    return controller.run(this.id, true);
  }
};
var InPlaceReplaceDown = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inPlaceReplace.down",
      label: localize("InPlaceReplaceAction.next.label", "Replace with Next Value"),
      alias: "Replace with Next Value",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 84,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    const controller = InPlaceReplaceController.get(editor2);
    if (!controller) {
      return Promise.resolve(void 0);
    }
    return controller.run(this.id, false);
  }
};
registerEditorContribution(InPlaceReplaceController.ID, InPlaceReplaceController);
registerEditorAction(InPlaceReplaceUp);
registerEditorAction(InPlaceReplaceDown);
registerThemingParticipant((theme, collector) => {
  const border = theme.getColor(editorBracketMatchBorder);
  if (border) {
    collector.addRule(`.monaco-editor.vs .valueSetReplacement { outline: solid 2px ${border}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/lineSelection/lineSelection.js
var ExpandLineSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: "expandLineSelection",
      label: localize("expandLineSelection", "Expand Line Selection"),
      alias: "Expand Line Selection",
      precondition: void 0,
      kbOpts: {
        weight: 0,
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 42
      }
    });
  }
  run(_accessor, editor2, args) {
    args = args || {};
    if (!editor2.hasModel()) {
      return;
    }
    const viewModel = editor2._getViewModel();
    viewModel.model.pushStackElement();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.expandLineSelection(viewModel, viewModel.getCursorStates()));
    viewModel.revealPrimaryCursor(args.source, true);
  }
};
registerEditorAction(ExpandLineSelectionAction);

// node_modules/monaco-editor/esm/vs/editor/common/commands/trimTrailingWhitespaceCommand.js
var TrimTrailingWhitespaceCommand = class {
  constructor(selection, cursors) {
    this._selection = selection;
    this._cursors = cursors;
    this._selectionId = null;
  }
  getEditOperations(model, builder) {
    let ops = trimTrailingWhitespace(model, this._cursors);
    for (let i = 0, len = ops.length; i < len; i++) {
      let op = ops[i];
      builder.addEditOperation(op.range, op.text);
    }
    this._selectionId = builder.trackSelection(this._selection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this._selectionId);
  }
};
function trimTrailingWhitespace(model, cursors) {
  cursors.sort((a, b) => {
    if (a.lineNumber === b.lineNumber) {
      return a.column - b.column;
    }
    return a.lineNumber - b.lineNumber;
  });
  for (let i = cursors.length - 2; i >= 0; i--) {
    if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {
      cursors.splice(i, 1);
    }
  }
  let r = [];
  let rLen = 0;
  let cursorIndex = 0;
  let cursorLen = cursors.length;
  for (let lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
    let lineContent = model.getLineContent(lineNumber);
    let maxLineColumn = lineContent.length + 1;
    let minEditColumn = 0;
    if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {
      minEditColumn = cursors[cursorIndex].column;
      cursorIndex++;
      if (minEditColumn === maxLineColumn) {
        continue;
      }
    }
    if (lineContent.length === 0) {
      continue;
    }
    let lastNonWhitespaceIndex2 = lastNonWhitespaceIndex(lineContent);
    let fromColumn = 0;
    if (lastNonWhitespaceIndex2 === -1) {
      fromColumn = 1;
    } else if (lastNonWhitespaceIndex2 !== lineContent.length - 1) {
      fromColumn = lastNonWhitespaceIndex2 + 2;
    } else {
      continue;
    }
    fromColumn = Math.max(minEditColumn, fromColumn);
    r[rLen++] = EditOperation.delete(new Range(lineNumber, fromColumn, lineNumber, maxLineColumn));
  }
  return r;
}

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/copyLinesCommand.js
var CopyLinesCommand = class {
  constructor(selection, isCopyingDown, noop) {
    this._selection = selection;
    this._isCopyingDown = isCopyingDown;
    this._noop = noop || false;
    this._selectionDirection = 0;
    this._selectionId = null;
    this._startLineNumberDelta = 0;
    this._endLineNumberDelta = 0;
  }
  getEditOperations(model, builder) {
    let s = this._selection;
    this._startLineNumberDelta = 0;
    this._endLineNumberDelta = 0;
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._endLineNumberDelta = 1;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    let sourceLines = [];
    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {
      sourceLines.push(model.getLineContent(i));
    }
    const sourceText = sourceLines.join("\n");
    if (sourceText === "") {
      if (this._isCopyingDown) {
        this._startLineNumberDelta++;
        this._endLineNumberDelta++;
      }
    }
    if (this._noop) {
      builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber + 1, 1), s.endLineNumber === model.getLineCount() ? "" : "\n");
    } else {
      if (!this._isCopyingDown) {
        builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + sourceText);
      } else {
        builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), sourceText + "\n");
      }
    }
    this._selectionId = builder.trackSelection(s);
    this._selectionDirection = this._selection.getDirection();
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
      let startLineNumber = result.startLineNumber;
      let startColumn = result.startColumn;
      let endLineNumber = result.endLineNumber;
      let endColumn = result.endColumn;
      if (this._startLineNumberDelta !== 0) {
        startLineNumber = startLineNumber + this._startLineNumberDelta;
        startColumn = 1;
      }
      if (this._endLineNumberDelta !== 0) {
        endLineNumber = endLineNumber + this._endLineNumberDelta;
        endColumn = 1;
      }
      result = Selection.createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, this._selectionDirection);
    }
    return result;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/moveLinesCommand.js
var MoveLinesCommand = class {
  constructor(selection, isMovingDown, autoIndent) {
    this._selection = selection;
    this._isMovingDown = isMovingDown;
    this._autoIndent = autoIndent;
    this._selectionId = null;
    this._moveEndLineSelectionShrink = false;
  }
  getEditOperations(model, builder) {
    let modelLineCount = model.getLineCount();
    if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {
      this._selectionId = builder.trackSelection(this._selection);
      return;
    }
    if (!this._isMovingDown && this._selection.startLineNumber === 1) {
      this._selectionId = builder.trackSelection(this._selection);
      return;
    }
    this._moveEndPositionDown = false;
    let s = this._selection;
    if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
      this._moveEndPositionDown = true;
      s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
    }
    const { tabSize, indentSize, insertSpaces } = model.getOptions();
    let indentConverter = this.buildIndentConverter(tabSize, indentSize, insertSpaces);
    let virtualModel = {
      getLineTokens: (lineNumber) => {
        return model.getLineTokens(lineNumber);
      },
      getLanguageId: () => {
        return model.getLanguageId();
      },
      getLanguageIdAtPosition: (lineNumber, column) => {
        return model.getLanguageIdAtPosition(lineNumber, column);
      },
      getLineContent: null
    };
    if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {
      let lineNumber = s.startLineNumber;
      let otherLineNumber = this._isMovingDown ? lineNumber + 1 : lineNumber - 1;
      if (model.getLineMaxColumn(otherLineNumber) === 1) {
        builder.addEditOperation(new Range(1, 1, 1, 1), null);
      } else {
        builder.addEditOperation(new Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));
        builder.addEditOperation(new Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);
      }
      s = new Selection(otherLineNumber, 1, otherLineNumber, 1);
    } else {
      let movingLineNumber;
      let movingLineText;
      if (this._isMovingDown) {
        movingLineNumber = s.endLineNumber + 1;
        movingLineText = model.getLineContent(movingLineNumber);
        builder.addEditOperation(new Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);
        let insertingText = movingLineText;
        if (this.shouldAutoIndent(model, s)) {
          let movingLineMatchResult = this.matchEnterRule(model, indentConverter, tabSize, movingLineNumber, s.startLineNumber - 1);
          if (movingLineMatchResult !== null) {
            let oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
            let newSpaceCnt = movingLineMatchResult + getSpaceCnt(oldIndentation, tabSize);
            let newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
            insertingText = newIndentation + this.trimLeft(movingLineText);
          } else {
            virtualModel.getLineContent = (lineNumber) => {
              if (lineNumber === s.startLineNumber) {
                return model.getLineContent(movingLineNumber);
              } else {
                return model.getLineContent(lineNumber);
              }
            };
            let indentOfMovingLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber, indentConverter);
            if (indentOfMovingLine !== null) {
              let oldIndentation = getLeadingWhitespace(model.getLineContent(movingLineNumber));
              let newSpaceCnt = getSpaceCnt(indentOfMovingLine, tabSize);
              let oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                let newIndentation = generateIndent(newSpaceCnt, tabSize, insertSpaces);
                insertingText = newIndentation + this.trimLeft(movingLineText);
              }
            }
          }
          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
          let ret = this.matchEnterRuleMovingDown(model, indentConverter, tabSize, s.startLineNumber, movingLineNumber, insertingText);
          if (ret !== null) {
            if (ret !== 0) {
              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
            }
          } else {
            virtualModel.getLineContent = (lineNumber) => {
              if (lineNumber === s.startLineNumber) {
                return insertingText;
              } else if (lineNumber >= s.startLineNumber + 1 && lineNumber <= s.endLineNumber + 1) {
                return model.getLineContent(lineNumber - 1);
              } else {
                return model.getLineContent(lineNumber);
              }
            };
            let newIndentatOfMovingBlock = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(movingLineNumber, 1), s.startLineNumber + 1, indentConverter);
            if (newIndentatOfMovingBlock !== null) {
              const oldIndentation = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
              const newSpaceCnt = getSpaceCnt(newIndentatOfMovingBlock, tabSize);
              const oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                const spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
              }
            }
          }
        } else {
          builder.addEditOperation(new Range(s.startLineNumber, 1, s.startLineNumber, 1), insertingText + "\n");
        }
      } else {
        movingLineNumber = s.startLineNumber - 1;
        movingLineText = model.getLineContent(movingLineNumber);
        builder.addEditOperation(new Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);
        builder.addEditOperation(new Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), "\n" + movingLineText);
        if (this.shouldAutoIndent(model, s)) {
          virtualModel.getLineContent = (lineNumber) => {
            if (lineNumber === movingLineNumber) {
              return model.getLineContent(s.startLineNumber);
            } else {
              return model.getLineContent(lineNumber);
            }
          };
          let ret = this.matchEnterRule(model, indentConverter, tabSize, s.startLineNumber, s.startLineNumber - 2);
          if (ret !== null) {
            if (ret !== 0) {
              this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, ret);
            }
          } else {
            let indentOfFirstLine = LanguageConfigurationRegistry.getGoodIndentForLine(this._autoIndent, virtualModel, model.getLanguageIdAtPosition(s.startLineNumber, 1), movingLineNumber, indentConverter);
            if (indentOfFirstLine !== null) {
              let oldIndent = getLeadingWhitespace(model.getLineContent(s.startLineNumber));
              let newSpaceCnt = getSpaceCnt(indentOfFirstLine, tabSize);
              let oldSpaceCnt = getSpaceCnt(oldIndent, tabSize);
              if (newSpaceCnt !== oldSpaceCnt) {
                let spaceCntOffset = newSpaceCnt - oldSpaceCnt;
                this.getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, spaceCntOffset);
              }
            }
          }
        }
      }
    }
    this._selectionId = builder.trackSelection(s);
  }
  buildIndentConverter(tabSize, indentSize, insertSpaces) {
    return {
      shiftIndent: (indentation) => {
        return ShiftCommand.shiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      },
      unshiftIndent: (indentation) => {
        return ShiftCommand.unshiftIndent(indentation, indentation.length + 1, tabSize, indentSize, insertSpaces);
      }
    };
  }
  parseEnterResult(model, indentConverter, tabSize, line, enter) {
    if (enter) {
      let enterPrefix = enter.indentation;
      if (enter.indentAction === IndentAction.None) {
        enterPrefix = enter.indentation + enter.appendText;
      } else if (enter.indentAction === IndentAction.Indent) {
        enterPrefix = enter.indentation + enter.appendText;
      } else if (enter.indentAction === IndentAction.IndentOutdent) {
        enterPrefix = enter.indentation;
      } else if (enter.indentAction === IndentAction.Outdent) {
        enterPrefix = indentConverter.unshiftIndent(enter.indentation) + enter.appendText;
      }
      let movingLineText = model.getLineContent(line);
      if (this.trimLeft(movingLineText).indexOf(this.trimLeft(enterPrefix)) >= 0) {
        let oldIndentation = getLeadingWhitespace(model.getLineContent(line));
        let newIndentation = getLeadingWhitespace(enterPrefix);
        let indentMetadataOfMovelingLine = LanguageConfigurationRegistry.getIndentMetadata(model, line);
        if (indentMetadataOfMovelingLine !== null && indentMetadataOfMovelingLine & 2) {
          newIndentation = indentConverter.unshiftIndent(newIndentation);
        }
        let newSpaceCnt = getSpaceCnt(newIndentation, tabSize);
        let oldSpaceCnt = getSpaceCnt(oldIndentation, tabSize);
        return newSpaceCnt - oldSpaceCnt;
      }
    }
    return null;
  }
  matchEnterRuleMovingDown(model, indentConverter, tabSize, line, futureAboveLineNumber, futureAboveLineText) {
    if (lastNonWhitespaceIndex(futureAboveLineText) >= 0) {
      let maxColumn = model.getLineMaxColumn(futureAboveLineNumber);
      let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(futureAboveLineNumber, maxColumn, futureAboveLineNumber, maxColumn));
      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
    } else {
      let validPrecedingLine = line - 1;
      while (validPrecedingLine >= 1) {
        let lineContent = model.getLineContent(validPrecedingLine);
        let nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
        if (nonWhitespaceIdx >= 0) {
          break;
        }
        validPrecedingLine--;
      }
      if (validPrecedingLine < 1 || line > model.getLineCount()) {
        return null;
      }
      let maxColumn = model.getLineMaxColumn(validPrecedingLine);
      let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));
      return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
    }
  }
  matchEnterRule(model, indentConverter, tabSize, line, oneLineAbove, previousLineText) {
    let validPrecedingLine = oneLineAbove;
    while (validPrecedingLine >= 1) {
      let lineContent;
      if (validPrecedingLine === oneLineAbove && previousLineText !== void 0) {
        lineContent = previousLineText;
      } else {
        lineContent = model.getLineContent(validPrecedingLine);
      }
      let nonWhitespaceIdx = lastNonWhitespaceIndex(lineContent);
      if (nonWhitespaceIdx >= 0) {
        break;
      }
      validPrecedingLine--;
    }
    if (validPrecedingLine < 1 || line > model.getLineCount()) {
      return null;
    }
    let maxColumn = model.getLineMaxColumn(validPrecedingLine);
    let enter = LanguageConfigurationRegistry.getEnterAction(this._autoIndent, model, new Range(validPrecedingLine, maxColumn, validPrecedingLine, maxColumn));
    return this.parseEnterResult(model, indentConverter, tabSize, line, enter);
  }
  trimLeft(str) {
    return str.replace(/^\s+/, "");
  }
  shouldAutoIndent(model, selection) {
    if (this._autoIndent < 4) {
      return false;
    }
    if (!model.isCheapToTokenize(selection.startLineNumber)) {
      return false;
    }
    let languageAtSelectionStart = model.getLanguageIdAtPosition(selection.startLineNumber, 1);
    let languageAtSelectionEnd = model.getLanguageIdAtPosition(selection.endLineNumber, 1);
    if (languageAtSelectionStart !== languageAtSelectionEnd) {
      return false;
    }
    if (LanguageConfigurationRegistry.getIndentRulesSupport(languageAtSelectionStart) === null) {
      return false;
    }
    return true;
  }
  getIndentEditsOfMovingBlock(model, builder, s, tabSize, insertSpaces, offset) {
    for (let i = s.startLineNumber; i <= s.endLineNumber; i++) {
      let lineContent = model.getLineContent(i);
      let originalIndent = getLeadingWhitespace(lineContent);
      let originalSpacesCnt = getSpaceCnt(originalIndent, tabSize);
      let newSpacesCnt = originalSpacesCnt + offset;
      let newIndent = generateIndent(newSpacesCnt, tabSize, insertSpaces);
      if (newIndent !== originalIndent) {
        builder.addEditOperation(new Range(i, 1, i, originalIndent.length + 1), newIndent);
        if (i === s.endLineNumber && s.endColumn <= originalIndent.length + 1 && newIndent === "") {
          this._moveEndLineSelectionShrink = true;
        }
      }
    }
  }
  computeCursorState(model, helper) {
    let result = helper.getTrackedSelection(this._selectionId);
    if (this._moveEndPositionDown) {
      result = result.setEndPosition(result.endLineNumber + 1, 1);
    }
    if (this._moveEndLineSelectionShrink && result.startLineNumber < result.endLineNumber) {
      result = result.setEndPosition(result.endLineNumber, 2);
    }
    return result;
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/sortLinesCommand.js
var SortLinesCommand = class {
  constructor(selection, descending) {
    this.selection = selection;
    this.descending = descending;
    this.selectionId = null;
  }
  static getCollator() {
    if (!SortLinesCommand._COLLATOR) {
      SortLinesCommand._COLLATOR = new Intl.Collator();
    }
    return SortLinesCommand._COLLATOR;
  }
  getEditOperations(model, builder) {
    let op = sortLines(model, this.selection, this.descending);
    if (op) {
      builder.addEditOperation(op.range, op.text);
    }
    this.selectionId = builder.trackSelection(this.selection);
  }
  computeCursorState(model, helper) {
    return helper.getTrackedSelection(this.selectionId);
  }
  static canRun(model, selection, descending) {
    if (model === null) {
      return false;
    }
    let data = getSortData(model, selection, descending);
    if (!data) {
      return false;
    }
    for (let i = 0, len = data.before.length; i < len; i++) {
      if (data.before[i] !== data.after[i]) {
        return true;
      }
    }
    return false;
  }
};
SortLinesCommand._COLLATOR = null;
function getSortData(model, selection, descending) {
  let startLineNumber = selection.startLineNumber;
  let endLineNumber = selection.endLineNumber;
  if (selection.endColumn === 1) {
    endLineNumber--;
  }
  if (startLineNumber >= endLineNumber) {
    return null;
  }
  let linesToSort = [];
  for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
    linesToSort.push(model.getLineContent(lineNumber));
  }
  let sorted = linesToSort.slice(0);
  sorted.sort(SortLinesCommand.getCollator().compare);
  if (descending === true) {
    sorted = sorted.reverse();
  }
  return {
    startLineNumber,
    endLineNumber,
    before: linesToSort,
    after: sorted
  };
}
function sortLines(model, selection, descending) {
  let data = getSortData(model, selection, descending);
  if (!data) {
    return null;
  }
  return EditOperation.replace(new Range(data.startLineNumber, 1, data.endLineNumber, model.getLineMaxColumn(data.endLineNumber)), data.after.join("\n"));
}

// node_modules/monaco-editor/esm/vs/editor/contrib/linesOperations/linesOperations.js
var AbstractCopyLinesAction = class extends EditorAction {
  constructor(down, opts) {
    super(opts);
    this.down = down;
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections().map((selection, index) => ({ selection, index, ignore: false }));
    selections.sort((a, b) => Range.compareRangesUsingStarts(a.selection, b.selection));
    let prev = selections[0];
    for (let i = 1; i < selections.length; i++) {
      const curr = selections[i];
      if (prev.selection.endLineNumber === curr.selection.startLineNumber) {
        if (prev.index < curr.index) {
          curr.ignore = true;
        } else {
          prev.ignore = true;
          prev = curr;
        }
      }
    }
    const commands = [];
    for (const selection of selections) {
      commands.push(new CopyLinesCommand(selection.selection, this.down, selection.ignore));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var CopyLinesUpAction = class extends AbstractCopyLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.copyLinesUpAction",
      label: localize("lines.copyUp", "Copy Line Up"),
      alias: "Copy Line Up",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 16,
        linux: { primary: 2048 | 512 | 1024 | 16 },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miCopyLinesUp", comment: ["&& denotes a mnemonic"] }, "&&Copy Line Up"),
        order: 1
      }
    });
  }
};
var CopyLinesDownAction = class extends AbstractCopyLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.copyLinesDownAction",
      label: localize("lines.copyDown", "Copy Line Down"),
      alias: "Copy Line Down",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 1024 | 18,
        linux: { primary: 2048 | 512 | 1024 | 18 },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miCopyLinesDown", comment: ["&& denotes a mnemonic"] }, "Co&&py Line Down"),
        order: 2
      }
    });
  }
};
var DuplicateSelectionAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.duplicateSelection",
      label: localize("duplicateSelection", "Duplicate Selection"),
      alias: "Duplicate Selection",
      precondition: EditorContextKeys.writable,
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miDuplicateSelection", comment: ["&& denotes a mnemonic"] }, "&&Duplicate Selection"),
        order: 5
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const commands = [];
    const selections = editor2.getSelections();
    const model = editor2.getModel();
    for (const selection of selections) {
      if (selection.isEmpty()) {
        commands.push(new CopyLinesCommand(selection, true));
      } else {
        const insertSelection = new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn);
        commands.push(new ReplaceCommandThatSelectsText(insertSelection, model.getValueInRange(selection)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var AbstractMoveLinesAction = class extends EditorAction {
  constructor(down, opts) {
    super(opts);
    this.down = down;
  }
  run(_accessor, editor2) {
    let commands = [];
    let selections = editor2.getSelections() || [];
    const autoIndent = editor2.getOption(9);
    for (const selection of selections) {
      commands.push(new MoveLinesCommand(selection, this.down, autoIndent));
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var MoveLinesUpAction = class extends AbstractMoveLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.moveLinesUpAction",
      label: localize("lines.moveUp", "Move Line Up"),
      alias: "Move Line Up",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 16,
        linux: { primary: 512 | 16 },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miMoveLinesUp", comment: ["&& denotes a mnemonic"] }, "Mo&&ve Line Up"),
        order: 3
      }
    });
  }
};
var MoveLinesDownAction = class extends AbstractMoveLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.moveLinesDownAction",
      label: localize("lines.moveDown", "Move Line Down"),
      alias: "Move Line Down",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 512 | 18,
        linux: { primary: 512 | 18 },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "2_line",
        title: localize({ key: "miMoveLinesDown", comment: ["&& denotes a mnemonic"] }, "Move &&Line Down"),
        order: 4
      }
    });
  }
};
var AbstractSortLinesAction = class extends EditorAction {
  constructor(descending, opts) {
    super(opts);
    this.descending = descending;
  }
  run(_accessor, editor2) {
    const selections = editor2.getSelections() || [];
    for (const selection of selections) {
      if (!SortLinesCommand.canRun(editor2.getModel(), selection, this.descending)) {
        return;
      }
    }
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      commands[i] = new SortLinesCommand(selections[i], this.descending);
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var SortLinesAscendingAction = class extends AbstractSortLinesAction {
  constructor() {
    super(false, {
      id: "editor.action.sortLinesAscending",
      label: localize("lines.sortAscending", "Sort Lines Ascending"),
      alias: "Sort Lines Ascending",
      precondition: EditorContextKeys.writable
    });
  }
};
var SortLinesDescendingAction = class extends AbstractSortLinesAction {
  constructor() {
    super(true, {
      id: "editor.action.sortLinesDescending",
      label: localize("lines.sortDescending", "Sort Lines Descending"),
      alias: "Sort Lines Descending",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteDuplicateLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.removeDuplicateLines",
      label: localize("lines.deleteDuplicates", "Delete Duplicate Lines"),
      alias: "Delete Duplicate Lines",
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    let model = editor2.getModel();
    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
      return;
    }
    let edits = [];
    let endCursorState = [];
    let linesDeleted = 0;
    for (let selection of editor2.getSelections()) {
      let uniqueLines = new Set();
      let lines = [];
      for (let i = selection.startLineNumber; i <= selection.endLineNumber; i++) {
        let line = model.getLineContent(i);
        if (uniqueLines.has(line)) {
          continue;
        }
        lines.push(line);
        uniqueLines.add(line);
      }
      let selectionToReplace = new Selection(selection.startLineNumber, 1, selection.endLineNumber, model.getLineMaxColumn(selection.endLineNumber));
      let adjustedSelectionStart = selection.startLineNumber - linesDeleted;
      let finalSelection = new Selection(adjustedSelectionStart, 1, adjustedSelectionStart + lines.length - 1, lines[lines.length - 1].length);
      edits.push(EditOperation.replace(selectionToReplace, lines.join("\n")));
      endCursorState.push(finalSelection);
      linesDeleted += selection.endLineNumber - selection.startLineNumber + 1 - lines.length;
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
};
var TrimTrailingWhitespaceAction = class extends EditorAction {
  constructor() {
    super({
      id: TrimTrailingWhitespaceAction.ID,
      label: localize("lines.trimTrailingWhitespace", "Trim Trailing Whitespace"),
      alias: "Trim Trailing Whitespace",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: KeyChord(2048 | 41, 2048 | 54),
        weight: 100
      }
    });
  }
  run(_accessor, editor2, args) {
    let cursors = [];
    if (args.reason === "auto-save") {
      cursors = (editor2.getSelections() || []).map((s) => new Position(s.positionLineNumber, s.positionColumn));
    }
    let selection = editor2.getSelection();
    if (selection === null) {
      return;
    }
    let command = new TrimTrailingWhitespaceCommand(selection, cursors);
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, [command]);
    editor2.pushUndoStop();
  }
};
TrimTrailingWhitespaceAction.ID = "editor.action.trimTrailingWhitespace";
var DeleteLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.deleteLines",
      label: localize("lines.delete", "Delete Line"),
      alias: "Delete Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1024 | 41,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    let ops = this._getLinesToRemove(editor2);
    let model = editor2.getModel();
    if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
      return;
    }
    let linesDeleted = 0;
    let edits = [];
    let cursorState = [];
    for (let i = 0, len = ops.length; i < len; i++) {
      const op = ops[i];
      let startLineNumber = op.startLineNumber;
      let endLineNumber = op.endLineNumber;
      let startColumn = 1;
      let endColumn = model.getLineMaxColumn(endLineNumber);
      if (endLineNumber < model.getLineCount()) {
        endLineNumber += 1;
        endColumn = 1;
      } else if (startLineNumber > 1) {
        startLineNumber -= 1;
        startColumn = model.getLineMaxColumn(startLineNumber);
      }
      edits.push(EditOperation.replace(new Selection(startLineNumber, startColumn, endLineNumber, endColumn), ""));
      cursorState.push(new Selection(startLineNumber - linesDeleted, op.positionColumn, startLineNumber - linesDeleted, op.positionColumn));
      linesDeleted += op.endLineNumber - op.startLineNumber + 1;
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, cursorState);
    editor2.pushUndoStop();
  }
  _getLinesToRemove(editor2) {
    let operations = editor2.getSelections().map((s) => {
      let endLineNumber = s.endLineNumber;
      if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
        endLineNumber -= 1;
      }
      return {
        startLineNumber: s.startLineNumber,
        selectionStartColumn: s.selectionStartColumn,
        endLineNumber,
        positionColumn: s.positionColumn
      };
    });
    operations.sort((a, b) => {
      if (a.startLineNumber === b.startLineNumber) {
        return a.endLineNumber - b.endLineNumber;
      }
      return a.startLineNumber - b.startLineNumber;
    });
    let mergedOperations = [];
    let previousOperation = operations[0];
    for (let i = 1; i < operations.length; i++) {
      if (previousOperation.endLineNumber + 1 >= operations[i].startLineNumber) {
        previousOperation.endLineNumber = operations[i].endLineNumber;
      } else {
        mergedOperations.push(previousOperation);
        previousOperation = operations[i];
      }
    }
    mergedOperations.push(previousOperation);
    return mergedOperations;
  }
};
var IndentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.indentLines",
      label: localize("lines.indent", "Indent Line"),
      alias: "Indent Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 89,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, TypeOperations.indent(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
    editor2.pushUndoStop();
  }
};
var OutdentLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.outdentLines",
      label: localize("lines.outdent", "Outdent Line"),
      alias: "Outdent Line",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 87,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    CoreEditingCommands.Outdent.runEditorCommand(_accessor, editor2, null);
  }
};
var InsertLineBeforeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertLineBefore",
      label: localize("lines.insertBefore", "Insert Line Above"),
      alias: "Insert Line Above",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 3,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, TypeOperations.lineInsertBefore(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
  }
};
var InsertLineAfterAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertLineAfter",
      label: localize("lines.insertAfter", "Insert Line Below"),
      alias: "Insert Line Below",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 3,
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    const viewModel = editor2._getViewModel();
    if (!viewModel) {
      return;
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, TypeOperations.lineInsertAfter(viewModel.cursorConfig, editor2.getModel(), editor2.getSelections()));
  }
};
var AbstractDeleteAllToBoundaryAction = class extends EditorAction {
  run(_accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const primaryCursor = editor2.getSelection();
    let rangesToDelete = this._getRangesToDelete(editor2);
    let effectiveRanges = [];
    for (let i = 0, count = rangesToDelete.length - 1; i < count; i++) {
      let range = rangesToDelete[i];
      let nextRange = rangesToDelete[i + 1];
      if (Range.intersectRanges(range, nextRange) === null) {
        effectiveRanges.push(range);
      } else {
        rangesToDelete[i + 1] = Range.plusRange(range, nextRange);
      }
    }
    effectiveRanges.push(rangesToDelete[rangesToDelete.length - 1]);
    let endCursorState = this._getEndCursorState(primaryCursor, effectiveRanges);
    let edits = effectiveRanges.map((range) => {
      return EditOperation.replace(range, "");
    });
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
};
var DeleteAllLeftAction = class extends AbstractDeleteAllToBoundaryAction {
  constructor() {
    super({
      id: "deleteAllLeft",
      label: localize("lines.deleteAllLeft", "Delete All Left"),
      alias: "Delete All Left",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 2048 | 1 },
        weight: 100
      }
    });
  }
  _getEndCursorState(primaryCursor, rangesToDelete) {
    let endPrimaryCursor = null;
    let endCursorState = [];
    let deletedLines = 0;
    rangesToDelete.forEach((range) => {
      let endCursor;
      if (range.endColumn === 1 && deletedLines > 0) {
        let newStartLine = range.startLineNumber - deletedLines;
        endCursor = new Selection(newStartLine, range.startColumn, newStartLine, range.startColumn);
      } else {
        endCursor = new Selection(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
      }
      deletedLines += range.endLineNumber - range.startLineNumber;
      if (range.intersectRanges(primaryCursor)) {
        endPrimaryCursor = endCursor;
      } else {
        endCursorState.push(endCursor);
      }
    });
    if (endPrimaryCursor) {
      endCursorState.unshift(endPrimaryCursor);
    }
    return endCursorState;
  }
  _getRangesToDelete(editor2) {
    let selections = editor2.getSelections();
    if (selections === null) {
      return [];
    }
    let rangesToDelete = selections;
    let model = editor2.getModel();
    if (model === null) {
      return [];
    }
    rangesToDelete.sort(Range.compareRangesUsingStarts);
    rangesToDelete = rangesToDelete.map((selection) => {
      if (selection.isEmpty()) {
        if (selection.startColumn === 1) {
          let deleteFromLine = Math.max(1, selection.startLineNumber - 1);
          let deleteFromColumn = selection.startLineNumber === 1 ? 1 : model.getLineContent(deleteFromLine).length + 1;
          return new Range(deleteFromLine, deleteFromColumn, selection.startLineNumber, 1);
        } else {
          return new Range(selection.startLineNumber, 1, selection.startLineNumber, selection.startColumn);
        }
      } else {
        return new Range(selection.startLineNumber, 1, selection.endLineNumber, selection.endColumn);
      }
    });
    return rangesToDelete;
  }
};
var DeleteAllRightAction = class extends AbstractDeleteAllToBoundaryAction {
  constructor() {
    super({
      id: "deleteAllRight",
      label: localize("lines.deleteAllRight", "Delete All Right"),
      alias: "Delete All Right",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 41, secondary: [2048 | 20] },
        weight: 100
      }
    });
  }
  _getEndCursorState(primaryCursor, rangesToDelete) {
    let endPrimaryCursor = null;
    let endCursorState = [];
    for (let i = 0, len = rangesToDelete.length, offset = 0; i < len; i++) {
      let range = rangesToDelete[i];
      let endCursor = new Selection(range.startLineNumber - offset, range.startColumn, range.startLineNumber - offset, range.startColumn);
      if (range.intersectRanges(primaryCursor)) {
        endPrimaryCursor = endCursor;
      } else {
        endCursorState.push(endCursor);
      }
    }
    if (endPrimaryCursor) {
      endCursorState.unshift(endPrimaryCursor);
    }
    return endCursorState;
  }
  _getRangesToDelete(editor2) {
    let model = editor2.getModel();
    if (model === null) {
      return [];
    }
    let selections = editor2.getSelections();
    if (selections === null) {
      return [];
    }
    let rangesToDelete = selections.map((sel) => {
      if (sel.isEmpty()) {
        const maxColumn = model.getLineMaxColumn(sel.startLineNumber);
        if (sel.startColumn === maxColumn) {
          return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber + 1, 1);
        } else {
          return new Range(sel.startLineNumber, sel.startColumn, sel.startLineNumber, maxColumn);
        }
      }
      return sel;
    });
    rangesToDelete.sort(Range.compareRangesUsingStarts);
    return rangesToDelete;
  }
};
var JoinLinesAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.joinLines",
      label: localize("lines.joinLines", "Join Lines"),
      alias: "Join Lines",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        mac: { primary: 256 | 40 },
        weight: 100
      }
    });
  }
  run(_accessor, editor2) {
    let selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    let primaryCursor = editor2.getSelection();
    if (primaryCursor === null) {
      return;
    }
    selections.sort(Range.compareRangesUsingStarts);
    let reducedSelections = [];
    let lastSelection = selections.reduce((previousValue, currentValue) => {
      if (previousValue.isEmpty()) {
        if (previousValue.endLineNumber === currentValue.startLineNumber) {
          if (primaryCursor.equalsSelection(previousValue)) {
            primaryCursor = currentValue;
          }
          return currentValue;
        }
        if (currentValue.startLineNumber > previousValue.endLineNumber + 1) {
          reducedSelections.push(previousValue);
          return currentValue;
        } else {
          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
        }
      } else {
        if (currentValue.startLineNumber > previousValue.endLineNumber) {
          reducedSelections.push(previousValue);
          return currentValue;
        } else {
          return new Selection(previousValue.startLineNumber, previousValue.startColumn, currentValue.endLineNumber, currentValue.endColumn);
        }
      }
    });
    reducedSelections.push(lastSelection);
    let model = editor2.getModel();
    if (model === null) {
      return;
    }
    let edits = [];
    let endCursorState = [];
    let endPrimaryCursor = primaryCursor;
    let lineOffset = 0;
    for (let i = 0, len = reducedSelections.length; i < len; i++) {
      let selection = reducedSelections[i];
      let startLineNumber = selection.startLineNumber;
      let startColumn = 1;
      let columnDeltaOffset = 0;
      let endLineNumber, endColumn;
      let selectionEndPositionOffset = model.getLineContent(selection.endLineNumber).length - selection.endColumn;
      if (selection.isEmpty() || selection.startLineNumber === selection.endLineNumber) {
        let position = selection.getStartPosition();
        if (position.lineNumber < model.getLineCount()) {
          endLineNumber = startLineNumber + 1;
          endColumn = model.getLineMaxColumn(endLineNumber);
        } else {
          endLineNumber = position.lineNumber;
          endColumn = model.getLineMaxColumn(position.lineNumber);
        }
      } else {
        endLineNumber = selection.endLineNumber;
        endColumn = model.getLineMaxColumn(endLineNumber);
      }
      let trimmedLinesContent = model.getLineContent(startLineNumber);
      for (let i2 = startLineNumber + 1; i2 <= endLineNumber; i2++) {
        let lineText = model.getLineContent(i2);
        let firstNonWhitespaceIdx = model.getLineFirstNonWhitespaceColumn(i2);
        if (firstNonWhitespaceIdx >= 1) {
          let insertSpace = true;
          if (trimmedLinesContent === "") {
            insertSpace = false;
          }
          if (insertSpace && (trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === " " || trimmedLinesContent.charAt(trimmedLinesContent.length - 1) === "	")) {
            insertSpace = false;
            trimmedLinesContent = trimmedLinesContent.replace(/[\s\uFEFF\xA0]+$/g, " ");
          }
          let lineTextWithoutIndent = lineText.substr(firstNonWhitespaceIdx - 1);
          trimmedLinesContent += (insertSpace ? " " : "") + lineTextWithoutIndent;
          if (insertSpace) {
            columnDeltaOffset = lineTextWithoutIndent.length + 1;
          } else {
            columnDeltaOffset = lineTextWithoutIndent.length;
          }
        } else {
          columnDeltaOffset = 0;
        }
      }
      let deleteSelection = new Range(startLineNumber, startColumn, endLineNumber, endColumn);
      if (!deleteSelection.isEmpty()) {
        let resultSelection;
        if (selection.isEmpty()) {
          edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
          resultSelection = new Selection(deleteSelection.startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1, startLineNumber - lineOffset, trimmedLinesContent.length - columnDeltaOffset + 1);
        } else {
          if (selection.startLineNumber === selection.endLineNumber) {
            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.endLineNumber - lineOffset, selection.endColumn);
          } else {
            edits.push(EditOperation.replace(deleteSelection, trimmedLinesContent));
            resultSelection = new Selection(selection.startLineNumber - lineOffset, selection.startColumn, selection.startLineNumber - lineOffset, trimmedLinesContent.length - selectionEndPositionOffset);
          }
        }
        if (Range.intersectRanges(deleteSelection, primaryCursor) !== null) {
          endPrimaryCursor = resultSelection;
        } else {
          endCursorState.push(resultSelection);
        }
      }
      lineOffset += deleteSelection.endLineNumber - deleteSelection.startLineNumber;
    }
    endCursorState.unshift(endPrimaryCursor);
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, edits, endCursorState);
    editor2.pushUndoStop();
  }
};
var TransposeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.transpose",
      label: localize("editor.transpose", "Transpose characters around the cursor"),
      alias: "Transpose characters around the cursor",
      precondition: EditorContextKeys.writable
    });
  }
  run(_accessor, editor2) {
    let selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    let model = editor2.getModel();
    if (model === null) {
      return;
    }
    let commands = [];
    for (let i = 0, len = selections.length; i < len; i++) {
      let selection = selections[i];
      if (!selection.isEmpty()) {
        continue;
      }
      let cursor = selection.getStartPosition();
      let maxColumn = model.getLineMaxColumn(cursor.lineNumber);
      if (cursor.column >= maxColumn) {
        if (cursor.lineNumber === model.getLineCount()) {
          continue;
        }
        let deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1);
        let chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
        commands.push(new ReplaceCommand(new Selection(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber + 1, 1), chars));
      } else {
        let deleteSelection = new Range(cursor.lineNumber, Math.max(1, cursor.column - 1), cursor.lineNumber, cursor.column + 1);
        let chars = model.getValueInRange(deleteSelection).split("").reverse().join("");
        commands.push(new ReplaceCommandThatPreservesSelection(deleteSelection, chars, new Selection(cursor.lineNumber, cursor.column + 1, cursor.lineNumber, cursor.column + 1)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var AbstractCaseAction = class extends EditorAction {
  run(_accessor, editor2) {
    const selections = editor2.getSelections();
    if (selections === null) {
      return;
    }
    const model = editor2.getModel();
    if (model === null) {
      return;
    }
    const wordSeparators = editor2.getOption(116);
    const textEdits = [];
    for (const selection of selections) {
      if (selection.isEmpty()) {
        const cursor = selection.getStartPosition();
        const word = editor2.getConfiguredWordAtPosition(cursor);
        if (!word) {
          continue;
        }
        const wordRange = new Range(cursor.lineNumber, word.startColumn, cursor.lineNumber, word.endColumn);
        const text2 = model.getValueInRange(wordRange);
        textEdits.push(EditOperation.replace(wordRange, this._modifyText(text2, wordSeparators)));
      } else {
        const text2 = model.getValueInRange(selection);
        textEdits.push(EditOperation.replace(selection, this._modifyText(text2, wordSeparators)));
      }
    }
    editor2.pushUndoStop();
    editor2.executeEdits(this.id, textEdits);
    editor2.pushUndoStop();
  }
};
var UpperCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToUppercase",
      label: localize("editor.transformToUppercase", "Transform to Uppercase"),
      alias: "Transform to Uppercase",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text2, wordSeparators) {
    return text2.toLocaleUpperCase();
  }
};
var LowerCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToLowercase",
      label: localize("editor.transformToLowercase", "Transform to Lowercase"),
      alias: "Transform to Lowercase",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text2, wordSeparators) {
    return text2.toLocaleLowerCase();
  }
};
var BackwardsCompatibleRegExp = class {
  constructor(_pattern, _flags) {
    this._pattern = _pattern;
    this._flags = _flags;
    this._actual = null;
    this._evaluated = false;
  }
  get() {
    if (!this._evaluated) {
      this._evaluated = true;
      try {
        this._actual = new RegExp(this._pattern, this._flags);
      } catch (err) {
      }
    }
    return this._actual;
  }
  isSupported() {
    return this.get() !== null;
  }
};
var TitleCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToTitlecase",
      label: localize("editor.transformToTitlecase", "Transform to Title Case"),
      alias: "Transform to Title Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text2, wordSeparators) {
    const titleBoundary = TitleCaseAction.titleBoundary.get();
    if (!titleBoundary) {
      return text2;
    }
    return text2.toLocaleLowerCase().replace(titleBoundary, (b) => b.toLocaleUpperCase());
  }
};
TitleCaseAction.titleBoundary = new BackwardsCompatibleRegExp("(^|[^\\p{L}\\p{N}']|((^|\\P{L})'))\\p{L}", "gmu");
var SnakeCaseAction = class extends AbstractCaseAction {
  constructor() {
    super({
      id: "editor.action.transformToSnakecase",
      label: localize("editor.transformToSnakecase", "Transform to Snake Case"),
      alias: "Transform to Snake Case",
      precondition: EditorContextKeys.writable
    });
  }
  _modifyText(text2, wordSeparators) {
    const caseBoundary = SnakeCaseAction.caseBoundary.get();
    const singleLetters = SnakeCaseAction.singleLetters.get();
    if (!caseBoundary || !singleLetters) {
      return text2;
    }
    return text2.replace(caseBoundary, "$1_$2").replace(singleLetters, "$1_$2$3").toLocaleLowerCase();
  }
};
SnakeCaseAction.caseBoundary = new BackwardsCompatibleRegExp("(\\p{Ll})(\\p{Lu})", "gmu");
SnakeCaseAction.singleLetters = new BackwardsCompatibleRegExp("(\\p{Lu}|\\p{N})(\\p{Lu})(\\p{Ll})", "gmu");
registerEditorAction(CopyLinesUpAction);
registerEditorAction(CopyLinesDownAction);
registerEditorAction(DuplicateSelectionAction);
registerEditorAction(MoveLinesUpAction);
registerEditorAction(MoveLinesDownAction);
registerEditorAction(SortLinesAscendingAction);
registerEditorAction(SortLinesDescendingAction);
registerEditorAction(DeleteDuplicateLinesAction);
registerEditorAction(TrimTrailingWhitespaceAction);
registerEditorAction(DeleteLinesAction);
registerEditorAction(IndentLinesAction);
registerEditorAction(OutdentLinesAction);
registerEditorAction(InsertLineBeforeAction);
registerEditorAction(InsertLineAfterAction);
registerEditorAction(DeleteAllLeftAction);
registerEditorAction(DeleteAllRightAction);
registerEditorAction(JoinLinesAction);
registerEditorAction(TransposeAction);
registerEditorAction(UpperCaseAction);
registerEditorAction(LowerCaseAction);
if (SnakeCaseAction.caseBoundary.isSupported() && SnakeCaseAction.singleLetters.isSupported()) {
  registerEditorAction(SnakeCaseAction);
}
if (TitleCaseAction.titleBoundary.isSupported()) {
  registerEditorAction(TitleCaseAction);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/linkedEditing/linkedEditing.js
var __decorate51 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param51 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter35 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE = new RawContextKey("LinkedEditingInputVisible", false);
var DECORATION_CLASS_NAME = "linked-editing-decoration";
var LinkedEditingContribution = class LinkedEditingContribution2 extends Disposable {
  constructor(editor2, contextKeyService) {
    super();
    this._debounceDuration = 200;
    this._localToDispose = this._register(new DisposableStore());
    this._editor = editor2;
    this._enabled = false;
    this._visibleContextKey = CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
    this._currentDecorations = [];
    this._languageWordPattern = null;
    this._currentWordPattern = null;
    this._ignoreChangeEvent = false;
    this._localToDispose = this._register(new DisposableStore());
    this._rangeUpdateTriggerPromise = null;
    this._rangeSyncTriggerPromise = null;
    this._currentRequest = null;
    this._currentRequestPosition = null;
    this._currentRequestModelVersion = null;
    this._register(this._editor.onDidChangeModel(() => this.reinitialize(true)));
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(61) || e.hasChanged(81)) {
        this.reinitialize(false);
      }
    }));
    this._register(LinkedEditingRangeProviderRegistry.onDidChange(() => this.reinitialize(false)));
    this._register(this._editor.onDidChangeModelLanguage(() => this.reinitialize(true)));
    this.reinitialize(true);
  }
  static get(editor2) {
    return editor2.getContribution(LinkedEditingContribution2.ID);
  }
  reinitialize(forceRefresh) {
    const model = this._editor.getModel();
    const isEnabled = model !== null && (this._editor.getOption(61) || this._editor.getOption(81)) && LinkedEditingRangeProviderRegistry.has(model);
    if (isEnabled === this._enabled && !forceRefresh) {
      return;
    }
    this._enabled = isEnabled;
    this.clearRanges();
    this._localToDispose.clear();
    if (!isEnabled || model === null) {
      return;
    }
    this._languageWordPattern = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageId());
    this._localToDispose.add(model.onDidChangeLanguageConfiguration(() => {
      this._languageWordPattern = LanguageConfigurationRegistry.getWordDefinition(model.getLanguageId());
    }));
    const rangeUpdateScheduler = new Delayer(this._debounceDuration);
    const triggerRangeUpdate = () => {
      this._rangeUpdateTriggerPromise = rangeUpdateScheduler.trigger(() => this.updateRanges(), this._debounceDuration);
    };
    const rangeSyncScheduler = new Delayer(0);
    const triggerRangeSync = (decorations) => {
      this._rangeSyncTriggerPromise = rangeSyncScheduler.trigger(() => this._syncRanges(decorations));
    };
    this._localToDispose.add(this._editor.onDidChangeCursorPosition(() => {
      triggerRangeUpdate();
    }));
    this._localToDispose.add(this._editor.onDidChangeModelContent((e) => {
      if (!this._ignoreChangeEvent) {
        if (this._currentDecorations.length > 0) {
          const referenceRange = model.getDecorationRange(this._currentDecorations[0]);
          if (referenceRange && e.changes.every((c) => referenceRange.intersectRanges(c.range))) {
            triggerRangeSync(this._currentDecorations);
            return;
          }
        }
      }
      triggerRangeUpdate();
    }));
    this._localToDispose.add({
      dispose: () => {
        rangeUpdateScheduler.cancel();
        rangeSyncScheduler.cancel();
      }
    });
    this.updateRanges();
  }
  _syncRanges(decorations) {
    if (!this._editor.hasModel() || decorations !== this._currentDecorations || decorations.length === 0) {
      return;
    }
    const model = this._editor.getModel();
    const referenceRange = model.getDecorationRange(decorations[0]);
    if (!referenceRange || referenceRange.startLineNumber !== referenceRange.endLineNumber) {
      return this.clearRanges();
    }
    const referenceValue = model.getValueInRange(referenceRange);
    if (this._currentWordPattern) {
      const match = referenceValue.match(this._currentWordPattern);
      const matchLength = match ? match[0].length : 0;
      if (matchLength !== referenceValue.length) {
        return this.clearRanges();
      }
    }
    let edits = [];
    for (let i = 1, len = decorations.length; i < len; i++) {
      const mirrorRange = model.getDecorationRange(decorations[i]);
      if (!mirrorRange) {
        continue;
      }
      if (mirrorRange.startLineNumber !== mirrorRange.endLineNumber) {
        edits.push({
          range: mirrorRange,
          text: referenceValue
        });
      } else {
        let oldValue = model.getValueInRange(mirrorRange);
        let newValue = referenceValue;
        let rangeStartColumn = mirrorRange.startColumn;
        let rangeEndColumn = mirrorRange.endColumn;
        const commonPrefixLength2 = commonPrefixLength(oldValue, newValue);
        rangeStartColumn += commonPrefixLength2;
        oldValue = oldValue.substr(commonPrefixLength2);
        newValue = newValue.substr(commonPrefixLength2);
        const commonSuffixLength2 = commonSuffixLength(oldValue, newValue);
        rangeEndColumn -= commonSuffixLength2;
        oldValue = oldValue.substr(0, oldValue.length - commonSuffixLength2);
        newValue = newValue.substr(0, newValue.length - commonSuffixLength2);
        if (rangeStartColumn !== rangeEndColumn || newValue.length !== 0) {
          edits.push({
            range: new Range(mirrorRange.startLineNumber, rangeStartColumn, mirrorRange.endLineNumber, rangeEndColumn),
            text: newValue
          });
        }
      }
    }
    if (edits.length === 0) {
      return;
    }
    try {
      this._editor.popUndoStop();
      this._ignoreChangeEvent = true;
      const prevEditOperationType = this._editor._getViewModel().getPrevEditOperationType();
      this._editor.executeEdits("linkedEditing", edits);
      this._editor._getViewModel().setPrevEditOperationType(prevEditOperationType);
    } finally {
      this._ignoreChangeEvent = false;
    }
  }
  dispose() {
    this.clearRanges();
    super.dispose();
  }
  clearRanges() {
    this._visibleContextKey.set(false);
    this._currentDecorations = this._editor.deltaDecorations(this._currentDecorations, []);
    if (this._currentRequest) {
      this._currentRequest.cancel();
      this._currentRequest = null;
      this._currentRequestPosition = null;
    }
  }
  updateRanges(force = false) {
    return __awaiter35(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        this.clearRanges();
        return;
      }
      const position = this._editor.getPosition();
      if (!this._enabled && !force || this._editor.getSelections().length > 1) {
        this.clearRanges();
        return;
      }
      const model = this._editor.getModel();
      const modelVersionId = model.getVersionId();
      if (this._currentRequestPosition && this._currentRequestModelVersion === modelVersionId) {
        if (position.equals(this._currentRequestPosition)) {
          return;
        }
        if (this._currentDecorations && this._currentDecorations.length > 0) {
          const range = model.getDecorationRange(this._currentDecorations[0]);
          if (range && range.containsPosition(position)) {
            return;
          }
        }
      }
      this._currentRequestPosition = position;
      this._currentRequestModelVersion = modelVersionId;
      const request = createCancelablePromise((token) => __awaiter35(this, void 0, void 0, function* () {
        try {
          const response = yield getLinkedEditingRanges(model, position, token);
          if (request !== this._currentRequest) {
            return;
          }
          this._currentRequest = null;
          if (modelVersionId !== model.getVersionId()) {
            return;
          }
          let ranges = [];
          if (response === null || response === void 0 ? void 0 : response.ranges) {
            ranges = response.ranges;
          }
          this._currentWordPattern = (response === null || response === void 0 ? void 0 : response.wordPattern) || this._languageWordPattern;
          let foundReferenceRange = false;
          for (let i = 0, len = ranges.length; i < len; i++) {
            if (Range.containsPosition(ranges[i], position)) {
              foundReferenceRange = true;
              if (i !== 0) {
                const referenceRange = ranges[i];
                ranges.splice(i, 1);
                ranges.unshift(referenceRange);
              }
              break;
            }
          }
          if (!foundReferenceRange) {
            this.clearRanges();
            return;
          }
          const decorations = ranges.map((range) => ({ range, options: LinkedEditingContribution2.DECORATION }));
          this._visibleContextKey.set(true);
          this._currentDecorations = this._editor.deltaDecorations(this._currentDecorations, decorations);
        } catch (err) {
          if (!isPromiseCanceledError(err)) {
            onUnexpectedError(err);
          }
          if (this._currentRequest === request || !this._currentRequest) {
            this.clearRanges();
          }
        }
      }));
      this._currentRequest = request;
      return request;
    });
  }
};
LinkedEditingContribution.ID = "editor.contrib.linkedEditing";
LinkedEditingContribution.DECORATION = ModelDecorationOptions.register({
  description: "linked-editing",
  stickiness: 0,
  className: DECORATION_CLASS_NAME
});
LinkedEditingContribution = __decorate51([
  __param51(1, IContextKeyService)
], LinkedEditingContribution);
var LinkedEditingAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.linkedEditing",
      label: localize("linkedEditing.label", "Start Linked Editing"),
      alias: "Start Linked Editing",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 60,
        weight: 100
      }
    });
  }
  runCommand(accessor, args) {
    const editorService = accessor.get(ICodeEditorService);
    const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
    if (URI.isUri(uri) && Position.isIPosition(pos)) {
      return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor2) => {
        if (!editor2) {
          return;
        }
        editor2.setPosition(pos);
        editor2.invokeWithinContext((accessor2) => {
          this.reportTelemetry(accessor2, editor2);
          return this.run(accessor2, editor2);
        });
      }, onUnexpectedError);
    }
    return super.runCommand(accessor, args);
  }
  run(_accessor, editor2) {
    const controller = LinkedEditingContribution.get(editor2);
    if (controller) {
      return Promise.resolve(controller.updateRanges(true));
    }
    return Promise.resolve();
  }
};
var LinkedEditingCommand = EditorCommand.bindToContribution(LinkedEditingContribution.get);
registerEditorCommand(new LinkedEditingCommand({
  id: "cancelLinkedEditingInput",
  precondition: CONTEXT_ONTYPE_RENAME_INPUT_VISIBLE,
  handler: (x) => x.clearRanges(),
  kbOpts: {
    kbExpr: EditorContextKeys.editorTextFocus,
    weight: 100 + 99,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
function getLinkedEditingRanges(model, position, token) {
  const orderedByScore = LinkedEditingRangeProviderRegistry.ordered(model);
  return first(orderedByScore.map((provider) => () => __awaiter35(this, void 0, void 0, function* () {
    try {
      return yield provider.provideLinkedEditingRanges(model, position, token);
    } catch (e) {
      onUnexpectedExternalError(e);
      return void 0;
    }
  })), (result) => !!result && isNonEmptyArray(result === null || result === void 0 ? void 0 : result.ranges));
}
var editorLinkedEditingBackground = registerColor("editor.linkedEditingBackground", { dark: Color.fromHex("#f00").transparent(0.3), light: Color.fromHex("#f00").transparent(0.3), hc: Color.fromHex("#f00").transparent(0.3) }, localize("editorLinkedEditingBackground", "Background color when the editor auto renames on type."));
registerThemingParticipant((theme, collector) => {
  const editorLinkedEditingBackgroundColor = theme.getColor(editorLinkedEditingBackground);
  if (editorLinkedEditingBackgroundColor) {
    collector.addRule(`.monaco-editor .${DECORATION_CLASS_NAME} { background: ${editorLinkedEditingBackgroundColor}; border-left-color: ${editorLinkedEditingBackgroundColor}; }`);
  }
});
registerModelAndPositionCommand("_executeLinkedEditingProvider", (model, position) => getLinkedEditingRanges(model, position, CancellationToken.None));
registerEditorContribution(LinkedEditingContribution.ID, LinkedEditingContribution);
registerEditorAction(LinkedEditingAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/links/links.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/links/links.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/links/getLinks.js
var __awaiter36 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Link3 = class {
  constructor(link, provider) {
    this._link = link;
    this._provider = provider;
  }
  toJSON() {
    return {
      range: this.range,
      url: this.url,
      tooltip: this.tooltip
    };
  }
  get range() {
    return this._link.range;
  }
  get url() {
    return this._link.url;
  }
  get tooltip() {
    return this._link.tooltip;
  }
  resolve(token) {
    return __awaiter36(this, void 0, void 0, function* () {
      if (this._link.url) {
        return this._link.url;
      }
      if (typeof this._provider.resolveLink === "function") {
        return Promise.resolve(this._provider.resolveLink(this._link, token)).then((value) => {
          this._link = value || this._link;
          if (this._link.url) {
            return this.resolve(token);
          }
          return Promise.reject(new Error("missing"));
        });
      }
      return Promise.reject(new Error("missing"));
    });
  }
};
var LinksList = class {
  constructor(tuples) {
    this._disposables = new DisposableStore();
    let links = [];
    for (const [list, provider] of tuples) {
      const newLinks = list.links.map((link) => new Link3(link, provider));
      links = LinksList._union(links, newLinks);
      if (isDisposable(list)) {
        this._disposables.add(list);
      }
    }
    this.links = links;
  }
  dispose() {
    this._disposables.dispose();
    this.links.length = 0;
  }
  static _union(oldLinks, newLinks) {
    let result = [];
    let oldIndex;
    let oldLen;
    let newIndex;
    let newLen;
    for (oldIndex = 0, newIndex = 0, oldLen = oldLinks.length, newLen = newLinks.length; oldIndex < oldLen && newIndex < newLen; ) {
      const oldLink = oldLinks[oldIndex];
      const newLink = newLinks[newIndex];
      if (Range.areIntersectingOrTouching(oldLink.range, newLink.range)) {
        oldIndex++;
        continue;
      }
      const comparisonResult = Range.compareRangesUsingStarts(oldLink.range, newLink.range);
      if (comparisonResult < 0) {
        result.push(oldLink);
        oldIndex++;
      } else {
        result.push(newLink);
        newIndex++;
      }
    }
    for (; oldIndex < oldLen; oldIndex++) {
      result.push(oldLinks[oldIndex]);
    }
    for (; newIndex < newLen; newIndex++) {
      result.push(newLinks[newIndex]);
    }
    return result;
  }
};
function getLinks(model, token) {
  const lists = [];
  const promises = LinkProviderRegistry.ordered(model).reverse().map((provider, i) => {
    return Promise.resolve(provider.provideLinks(model, token)).then((result) => {
      if (result) {
        lists[i] = [result, provider];
      }
    }, onUnexpectedExternalError);
  });
  return Promise.all(promises).then(() => {
    const result = new LinksList(coalesce(lists));
    if (!token.isCancellationRequested) {
      return result;
    }
    result.dispose();
    return new LinksList([]);
  });
}
CommandsRegistry.registerCommand("_executeLinkProvider", (accessor, ...args) => __awaiter36(void 0, void 0, void 0, function* () {
  let [uri, resolveCount] = args;
  assertType(uri instanceof URI);
  if (typeof resolveCount !== "number") {
    resolveCount = 0;
  }
  const model = accessor.get(IModelService).getModel(uri);
  if (!model) {
    return [];
  }
  const list = yield getLinks(model, CancellationToken.None);
  if (!list) {
    return [];
  }
  for (let i = 0; i < Math.min(resolveCount, list.links.length); i++) {
    yield list.links[i].resolve(CancellationToken.None);
  }
  const result = list.links.slice(0);
  list.dispose();
  return result;
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/links/links.js
var __decorate52 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param52 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter37 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function getHoverMessage(link, useMetaKey) {
  const executeCmd = link.url && /^command:/i.test(link.url.toString());
  const label = link.tooltip ? link.tooltip : executeCmd ? localize("links.navigate.executeCmd", "Execute command") : localize("links.navigate.follow", "Follow link");
  const kb = useMetaKey ? isMacintosh ? localize("links.navigate.kb.meta.mac", "cmd + click") : localize("links.navigate.kb.meta", "ctrl + click") : isMacintosh ? localize("links.navigate.kb.alt.mac", "option + click") : localize("links.navigate.kb.alt", "alt + click");
  if (link.url) {
    let nativeLabel = "";
    if (/^command:/i.test(link.url.toString())) {
      const match = link.url.toString().match(/^command:([^?#]+)/);
      if (match) {
        const commandId = match[1];
        const nativeLabelText = localize("tooltip.explanation", "Execute command {0}", commandId);
        nativeLabel = ` "${nativeLabelText}"`;
      }
    }
    const hoverMessage = new MarkdownString("", true).appendMarkdown(`[${label}](${link.url.toString(true).replace(/ /g, "%20")}${nativeLabel}) (${kb})`);
    return hoverMessage;
  } else {
    return new MarkdownString().appendText(`${label} (${kb})`);
  }
}
var decoration = {
  general: ModelDecorationOptions.register({
    description: "detected-link",
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: "detected-link"
  }),
  active: ModelDecorationOptions.register({
    description: "detected-link-active",
    stickiness: 1,
    collapseOnReplaceEdit: true,
    inlineClassName: "detected-link-active"
  })
};
var LinkOccurrence = class {
  constructor(link, decorationId) {
    this.link = link;
    this.decorationId = decorationId;
  }
  static decoration(link, useMetaKey) {
    return {
      range: link.range,
      options: LinkOccurrence._getOptions(link, useMetaKey, false)
    };
  }
  static _getOptions(link, useMetaKey, isActive) {
    const options = Object.assign({}, isActive ? decoration.active : decoration.general);
    options.hoverMessage = getHoverMessage(link, useMetaKey);
    return options;
  }
  activate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, true));
  }
  deactivate(changeAccessor, useMetaKey) {
    changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurrence._getOptions(this.link, useMetaKey, false));
  }
};
var LinkDetector = class LinkDetector2 {
  constructor(editor2, openerService, notificationService) {
    this.listenersToRemove = new DisposableStore();
    this.editor = editor2;
    this.openerService = openerService;
    this.notificationService = notificationService;
    let clickLinkGesture = new ClickLinkGesture(editor2);
    this.listenersToRemove.add(clickLinkGesture);
    this.listenersToRemove.add(clickLinkGesture.onMouseMoveOrRelevantKeyDown(([mouseEvent, keyboardEvent]) => {
      this._onEditorMouseMove(mouseEvent, keyboardEvent);
    }));
    this.listenersToRemove.add(clickLinkGesture.onExecute((e) => {
      this.onEditorMouseUp(e);
    }));
    this.listenersToRemove.add(clickLinkGesture.onCancel((e) => {
      this.cleanUpActiveLinkDecoration();
    }));
    this.enabled = editor2.getOption(62);
    this.listenersToRemove.add(editor2.onDidChangeConfiguration((e) => {
      const enabled = editor2.getOption(62);
      if (this.enabled === enabled) {
        return;
      }
      this.enabled = enabled;
      this.updateDecorations([]);
      this.stop();
      this.beginCompute();
    }));
    this.listenersToRemove.add(editor2.onDidChangeModelContent((e) => this.onChange()));
    this.listenersToRemove.add(editor2.onDidChangeModel((e) => this.onModelChanged()));
    this.listenersToRemove.add(editor2.onDidChangeModelLanguage((e) => this.onModelModeChanged()));
    this.listenersToRemove.add(LinkProviderRegistry.onDidChange((e) => this.onModelModeChanged()));
    this.timeout = new TimeoutTimer();
    this.computePromise = null;
    this.activeLinksList = null;
    this.currentOccurrences = {};
    this.activeLinkDecorationId = null;
    this.beginCompute();
  }
  static get(editor2) {
    return editor2.getContribution(LinkDetector2.ID);
  }
  onModelChanged() {
    this.currentOccurrences = {};
    this.activeLinkDecorationId = null;
    this.stop();
    this.beginCompute();
  }
  onModelModeChanged() {
    this.stop();
    this.beginCompute();
  }
  onChange() {
    this.timeout.setIfNotSet(() => this.beginCompute(), LinkDetector2.RECOMPUTE_TIME);
  }
  beginCompute() {
    return __awaiter37(this, void 0, void 0, function* () {
      if (!this.editor.hasModel() || !this.enabled) {
        return;
      }
      const model = this.editor.getModel();
      if (!LinkProviderRegistry.has(model)) {
        return;
      }
      if (this.activeLinksList) {
        this.activeLinksList.dispose();
        this.activeLinksList = null;
      }
      this.computePromise = createCancelablePromise((token) => getLinks(model, token));
      try {
        this.activeLinksList = yield this.computePromise;
        this.updateDecorations(this.activeLinksList.links);
      } catch (err) {
        onUnexpectedError(err);
      } finally {
        this.computePromise = null;
      }
    });
  }
  updateDecorations(links) {
    const useMetaKey = this.editor.getOption(69) === "altKey";
    let oldDecorations = [];
    let keys = Object.keys(this.currentOccurrences);
    for (let i = 0, len = keys.length; i < len; i++) {
      let decorationId = keys[i];
      let occurance = this.currentOccurrences[decorationId];
      oldDecorations.push(occurance.decorationId);
    }
    let newDecorations = [];
    if (links) {
      for (const link of links) {
        newDecorations.push(LinkOccurrence.decoration(link, useMetaKey));
      }
    }
    let decorations = this.editor.deltaDecorations(oldDecorations, newDecorations);
    this.currentOccurrences = {};
    this.activeLinkDecorationId = null;
    for (let i = 0, len = decorations.length; i < len; i++) {
      let occurance = new LinkOccurrence(links[i], decorations[i]);
      this.currentOccurrences[occurance.decorationId] = occurance;
    }
  }
  _onEditorMouseMove(mouseEvent, withKey) {
    const useMetaKey = this.editor.getOption(69) === "altKey";
    if (this.isEnabled(mouseEvent, withKey)) {
      this.cleanUpActiveLinkDecoration();
      const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
      if (occurrence) {
        this.editor.changeDecorations((changeAccessor) => {
          occurrence.activate(changeAccessor, useMetaKey);
          this.activeLinkDecorationId = occurrence.decorationId;
        });
      }
    } else {
      this.cleanUpActiveLinkDecoration();
    }
  }
  cleanUpActiveLinkDecoration() {
    const useMetaKey = this.editor.getOption(69) === "altKey";
    if (this.activeLinkDecorationId) {
      const occurrence = this.currentOccurrences[this.activeLinkDecorationId];
      if (occurrence) {
        this.editor.changeDecorations((changeAccessor) => {
          occurrence.deactivate(changeAccessor, useMetaKey);
        });
      }
      this.activeLinkDecorationId = null;
    }
  }
  onEditorMouseUp(mouseEvent) {
    if (!this.isEnabled(mouseEvent)) {
      return;
    }
    const occurrence = this.getLinkOccurrence(mouseEvent.target.position);
    if (!occurrence) {
      return;
    }
    this.openLinkOccurrence(occurrence, mouseEvent.hasSideBySideModifier, true);
  }
  openLinkOccurrence(occurrence, openToSide, fromUserGesture = false) {
    if (!this.openerService) {
      return;
    }
    const { link } = occurrence;
    link.resolve(CancellationToken.None).then((uri) => {
      if (typeof uri === "string" && this.editor.hasModel()) {
        const modelUri = this.editor.getModel().uri;
        if (modelUri.scheme === Schemas.file && uri.startsWith(`${Schemas.file}:`)) {
          const parsedUri = URI.parse(uri);
          if (parsedUri.scheme === Schemas.file) {
            const fsPath = originalFSPath(parsedUri);
            let relativePath = null;
            if (fsPath.startsWith("/./")) {
              relativePath = `.${fsPath.substr(1)}`;
            } else if (fsPath.startsWith("//./")) {
              relativePath = `.${fsPath.substr(2)}`;
            }
            if (relativePath) {
              uri = joinPath(modelUri, relativePath);
            }
          }
        }
      }
      return this.openerService.open(uri, { openToSide, fromUserGesture, allowContributedOpeners: true, allowCommands: true });
    }, (err) => {
      const messageOrError = err instanceof Error ? err.message : err;
      if (messageOrError === "invalid") {
        this.notificationService.warn(localize("invalid.url", "Failed to open this link because it is not well-formed: {0}", link.url.toString()));
      } else if (messageOrError === "missing") {
        this.notificationService.warn(localize("missing.url", "Failed to open this link because its target is missing."));
      } else {
        onUnexpectedError(err);
      }
    });
  }
  getLinkOccurrence(position) {
    if (!this.editor.hasModel() || !position) {
      return null;
    }
    const decorations = this.editor.getModel().getDecorationsInRange({
      startLineNumber: position.lineNumber,
      startColumn: position.column,
      endLineNumber: position.lineNumber,
      endColumn: position.column
    }, 0, true);
    for (const decoration2 of decorations) {
      const currentOccurrence = this.currentOccurrences[decoration2.id];
      if (currentOccurrence) {
        return currentOccurrence;
      }
    }
    return null;
  }
  isEnabled(mouseEvent, withKey) {
    return Boolean(mouseEvent.target.type === 6 && (mouseEvent.hasTriggerModifier || withKey && withKey.keyCodeIsTriggerKey));
  }
  stop() {
    var _a5;
    this.timeout.cancel();
    if (this.activeLinksList) {
      (_a5 = this.activeLinksList) === null || _a5 === void 0 ? void 0 : _a5.dispose();
      this.activeLinksList = null;
    }
    if (this.computePromise) {
      this.computePromise.cancel();
      this.computePromise = null;
    }
  }
  dispose() {
    this.listenersToRemove.dispose();
    this.stop();
    this.timeout.dispose();
  }
};
LinkDetector.ID = "editor.linkDetector";
LinkDetector.RECOMPUTE_TIME = 1e3;
LinkDetector = __decorate52([
  __param52(1, IOpenerService),
  __param52(2, INotificationService)
], LinkDetector);
var OpenLinkAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.openLink",
      label: localize("label", "Open Link"),
      alias: "Open Link",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    let linkDetector = LinkDetector.get(editor2);
    if (!linkDetector) {
      return;
    }
    if (!editor2.hasModel()) {
      return;
    }
    let selections = editor2.getSelections();
    for (let sel of selections) {
      let link = linkDetector.getLinkOccurrence(sel.getEndPosition());
      if (link) {
        linkDetector.openLinkOccurrence(link, false);
      }
    }
  }
};
registerEditorContribution(LinkDetector.ID, LinkDetector);
registerEditorAction(OpenLinkAction);
registerThemingParticipant((theme, collector) => {
  const activeLinkForeground = theme.getColor(editorActiveLinkForeground);
  if (activeLinkForeground) {
    collector.addRule(`.monaco-editor .detected-link-active { color: ${activeLinkForeground} !important; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/multicursor/multicursor.js
function announceCursorChange(previousCursorState, cursorState) {
  const cursorDiff = cursorState.filter((cs) => !previousCursorState.find((pcs) => pcs.equals(cs)));
  if (cursorDiff.length >= 1) {
    const cursorPositions = cursorDiff.map((cs) => `line ${cs.viewState.position.lineNumber} column ${cs.viewState.position.column}`).join(", ");
    const msg = cursorDiff.length === 1 ? localize("cursorAdded", "Cursor added: {0}", cursorPositions) : localize("cursorsAdded", "Cursors added: {0}", cursorPositions);
    status(msg);
  }
}
var InsertCursorAbove = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorAbove",
      label: localize("mutlicursor.insertAbove", "Add Cursor Above"),
      alias: "Add Cursor Above",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 16,
        linux: {
          primary: 1024 | 512 | 16,
          secondary: [2048 | 1024 | 16]
        },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miInsertCursorAbove", comment: ["&& denotes a mnemonic"] }, "&&Add Cursor Above"),
        order: 2
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    let useLogicalLine = true;
    if (args && args.logicalLine === false) {
      useLogicalLine = false;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.pushStackElement();
    const previousCursorState = viewModel.getCursorStates();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorUp(viewModel, previousCursorState, useLogicalLine));
    viewModel.revealTopMostCursor(args.source);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var InsertCursorBelow = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorBelow",
      label: localize("mutlicursor.insertBelow", "Add Cursor Below"),
      alias: "Add Cursor Below",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 512 | 18,
        linux: {
          primary: 1024 | 512 | 18,
          secondary: [2048 | 1024 | 18]
        },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miInsertCursorBelow", comment: ["&& denotes a mnemonic"] }, "A&&dd Cursor Below"),
        order: 3
      }
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    let useLogicalLine = true;
    if (args && args.logicalLine === false) {
      useLogicalLine = false;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel.cursorConfig.readOnly) {
      return;
    }
    viewModel.pushStackElement();
    const previousCursorState = viewModel.getCursorStates();
    viewModel.setCursorStates(args.source, 3, CursorMoveCommands.addCursorDown(viewModel, previousCursorState, useLogicalLine));
    viewModel.revealBottomMostCursor(args.source);
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var InsertCursorAtEndOfEachLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.insertCursorAtEndOfEachLineSelected",
      label: localize("mutlicursor.insertAtEndOfEachLineSelected", "Add Cursors to Line Ends"),
      alias: "Add Cursors to Line Ends",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 39,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miInsertCursorAtEndOfEachLineSelected", comment: ["&& denotes a mnemonic"] }, "Add C&&ursors to Line Ends"),
        order: 4
      }
    });
  }
  getCursorsForSelection(selection, model, result) {
    if (selection.isEmpty()) {
      return;
    }
    for (let i = selection.startLineNumber; i < selection.endLineNumber; i++) {
      let currentLineMaxColumn = model.getLineMaxColumn(i);
      result.push(new Selection(i, currentLineMaxColumn, i, currentLineMaxColumn));
    }
    if (selection.endColumn > 1) {
      result.push(new Selection(selection.endLineNumber, selection.endColumn, selection.endLineNumber, selection.endColumn));
    }
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    let newSelections = [];
    selections.forEach((sel) => this.getCursorsForSelection(sel, model, newSelections));
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var InsertCursorAtEndOfLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.addCursorsToBottom",
      label: localize("mutlicursor.addCursorsToBottom", "Add Cursors To Bottom"),
      alias: "Add Cursors To Bottom",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    const lineCount = editor2.getModel().getLineCount();
    let newSelections = [];
    for (let i = selections[0].startLineNumber; i <= lineCount; i++) {
      newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));
    }
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var InsertCursorAtTopOfLineSelected = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.addCursorsToTop",
      label: localize("mutlicursor.addCursorsToTop", "Add Cursors To Top"),
      alias: "Add Cursors To Top",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const selections = editor2.getSelections();
    let newSelections = [];
    for (let i = selections[0].startLineNumber; i >= 1; i--) {
      newSelections.push(new Selection(i, selections[0].startColumn, i, selections[0].endColumn));
    }
    const viewModel = editor2._getViewModel();
    const previousCursorState = viewModel.getCursorStates();
    if (newSelections.length > 0) {
      editor2.setSelections(newSelections);
    }
    announceCursorChange(previousCursorState, viewModel.getCursorStates());
  }
};
var MultiCursorSessionResult = class {
  constructor(selections, revealRange, revealScrollType) {
    this.selections = selections;
    this.revealRange = revealRange;
    this.revealScrollType = revealScrollType;
  }
};
var MultiCursorSession = class {
  constructor(_editor, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch) {
    this._editor = _editor;
    this.findController = findController;
    this.isDisconnectedFromFindController = isDisconnectedFromFindController;
    this.searchText = searchText;
    this.wholeWord = wholeWord;
    this.matchCase = matchCase;
    this.currentMatch = currentMatch;
  }
  static create(editor2, findController) {
    if (!editor2.hasModel()) {
      return null;
    }
    const findState = findController.getState();
    if (!editor2.hasTextFocus() && findState.isRevealed && findState.searchString.length > 0) {
      return new MultiCursorSession(editor2, findController, false, findState.searchString, findState.wholeWord, findState.matchCase, null);
    }
    let isDisconnectedFromFindController = false;
    let wholeWord;
    let matchCase;
    const selections = editor2.getSelections();
    if (selections.length === 1 && selections[0].isEmpty()) {
      isDisconnectedFromFindController = true;
      wholeWord = true;
      matchCase = true;
    } else {
      wholeWord = findState.wholeWord;
      matchCase = findState.matchCase;
    }
    const s = editor2.getSelection();
    let searchText;
    let currentMatch = null;
    if (s.isEmpty()) {
      const word = editor2.getConfiguredWordAtPosition(s.getStartPosition());
      if (!word) {
        return null;
      }
      searchText = word.word;
      currentMatch = new Selection(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);
    } else {
      searchText = editor2.getModel().getValueInRange(s).replace(/\r\n/g, "\n");
    }
    return new MultiCursorSession(editor2, findController, isDisconnectedFromFindController, searchText, wholeWord, matchCase, currentMatch);
  }
  addSelectionToNextFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const nextMatch = this._getNextMatch();
    if (!nextMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(allSelections.concat(nextMatch), nextMatch, 0);
  }
  moveSelectionToNextFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const nextMatch = this._getNextMatch();
    if (!nextMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(nextMatch), nextMatch, 0);
  }
  _getNextMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    if (this.currentMatch) {
      const result = this.currentMatch;
      this.currentMatch = null;
      return result;
    }
    this.findController.highlightFindOptions();
    const allSelections = this._editor.getSelections();
    const lastAddedSelection = allSelections[allSelections.length - 1];
    const nextMatch = this._editor.getModel().findNextMatch(this.searchText, lastAddedSelection.getEndPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(116) : null, false);
    if (!nextMatch) {
      return null;
    }
    return new Selection(nextMatch.range.startLineNumber, nextMatch.range.startColumn, nextMatch.range.endLineNumber, nextMatch.range.endColumn);
  }
  addSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const previousMatch = this._getPreviousMatch();
    if (!previousMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(allSelections.concat(previousMatch), previousMatch, 0);
  }
  moveSelectionToPreviousFindMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    const previousMatch = this._getPreviousMatch();
    if (!previousMatch) {
      return null;
    }
    const allSelections = this._editor.getSelections();
    return new MultiCursorSessionResult(allSelections.slice(0, allSelections.length - 1).concat(previousMatch), previousMatch, 0);
  }
  _getPreviousMatch() {
    if (!this._editor.hasModel()) {
      return null;
    }
    if (this.currentMatch) {
      const result = this.currentMatch;
      this.currentMatch = null;
      return result;
    }
    this.findController.highlightFindOptions();
    const allSelections = this._editor.getSelections();
    const lastAddedSelection = allSelections[allSelections.length - 1];
    const previousMatch = this._editor.getModel().findPreviousMatch(this.searchText, lastAddedSelection.getStartPosition(), false, this.matchCase, this.wholeWord ? this._editor.getOption(116) : null, false);
    if (!previousMatch) {
      return null;
    }
    return new Selection(previousMatch.range.startLineNumber, previousMatch.range.startColumn, previousMatch.range.endLineNumber, previousMatch.range.endColumn);
  }
  selectAll() {
    if (!this._editor.hasModel()) {
      return [];
    }
    this.findController.highlightFindOptions();
    return this._editor.getModel().findMatches(this.searchText, true, false, this.matchCase, this.wholeWord ? this._editor.getOption(116) : null, false, 1073741824);
  }
};
var MultiCursorSelectionController = class extends Disposable {
  constructor(editor2) {
    super();
    this._sessionDispose = this._register(new DisposableStore());
    this._editor = editor2;
    this._ignoreSelectionChange = false;
    this._session = null;
  }
  static get(editor2) {
    return editor2.getContribution(MultiCursorSelectionController.ID);
  }
  dispose() {
    this._endSession();
    super.dispose();
  }
  _beginSessionIfNeeded(findController) {
    if (!this._session) {
      const session = MultiCursorSession.create(this._editor, findController);
      if (!session) {
        return;
      }
      this._session = session;
      const newState = { searchString: this._session.searchText };
      if (this._session.isDisconnectedFromFindController) {
        newState.wholeWordOverride = 1;
        newState.matchCaseOverride = 1;
        newState.isRegexOverride = 2;
      }
      findController.getState().change(newState, false);
      this._sessionDispose.add(this._editor.onDidChangeCursorSelection((e) => {
        if (this._ignoreSelectionChange) {
          return;
        }
        this._endSession();
      }));
      this._sessionDispose.add(this._editor.onDidBlurEditorText(() => {
        this._endSession();
      }));
      this._sessionDispose.add(findController.getState().onFindReplaceStateChange((e) => {
        if (e.matchCase || e.wholeWord) {
          this._endSession();
        }
      }));
    }
  }
  _endSession() {
    this._sessionDispose.clear();
    if (this._session && this._session.isDisconnectedFromFindController) {
      const newState = {
        wholeWordOverride: 0,
        matchCaseOverride: 0,
        isRegexOverride: 0
      };
      this._session.findController.getState().change(newState, false);
    }
    this._session = null;
  }
  _setSelections(selections) {
    this._ignoreSelectionChange = true;
    this._editor.setSelections(selections);
    this._ignoreSelectionChange = false;
  }
  _expandEmptyToWord(model, selection) {
    if (!selection.isEmpty()) {
      return selection;
    }
    const word = this._editor.getConfiguredWordAtPosition(selection.getStartPosition());
    if (!word) {
      return selection;
    }
    return new Selection(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
  }
  _applySessionResult(result) {
    if (!result) {
      return;
    }
    this._setSelections(result.selections);
    if (result.revealRange) {
      this._editor.revealRangeInCenterIfOutsideViewport(result.revealRange, result.revealScrollType);
    }
  }
  getSession(findController) {
    return this._session;
  }
  addSelectionToNextFindMatch(findController) {
    if (!this._editor.hasModel()) {
      return;
    }
    if (!this._session) {
      const allSelections = this._editor.getSelections();
      if (allSelections.length > 1) {
        const findState = findController.getState();
        const matchCase = findState.matchCase;
        const selectionsContainSameText = modelRangesContainSameText(this._editor.getModel(), allSelections, matchCase);
        if (!selectionsContainSameText) {
          const model = this._editor.getModel();
          let resultingSelections = [];
          for (let i = 0, len = allSelections.length; i < len; i++) {
            resultingSelections[i] = this._expandEmptyToWord(model, allSelections[i]);
          }
          this._editor.setSelections(resultingSelections);
          return;
        }
      }
    }
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.addSelectionToNextFindMatch());
    }
  }
  addSelectionToPreviousFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.addSelectionToPreviousFindMatch());
    }
  }
  moveSelectionToNextFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.moveSelectionToNextFindMatch());
    }
  }
  moveSelectionToPreviousFindMatch(findController) {
    this._beginSessionIfNeeded(findController);
    if (this._session) {
      this._applySessionResult(this._session.moveSelectionToPreviousFindMatch());
    }
  }
  selectAll(findController) {
    if (!this._editor.hasModel()) {
      return;
    }
    let matches = null;
    const findState = findController.getState();
    if (findState.isRevealed && findState.searchString.length > 0 && findState.isRegex) {
      matches = this._editor.getModel().findMatches(findState.searchString, true, findState.isRegex, findState.matchCase, findState.wholeWord ? this._editor.getOption(116) : null, false, 1073741824);
    } else {
      this._beginSessionIfNeeded(findController);
      if (!this._session) {
        return;
      }
      matches = this._session.selectAll();
    }
    if (findState.searchScope) {
      const states = findState.searchScope;
      let inSelection = [];
      matches.forEach((match) => {
        states.forEach((state) => {
          if (match.range.endLineNumber <= state.endLineNumber && match.range.startLineNumber >= state.startLineNumber) {
            inSelection.push(match);
          }
        });
      });
      matches = inSelection;
    }
    if (matches.length > 0) {
      const editorSelection = this._editor.getSelection();
      for (let i = 0, len = matches.length; i < len; i++) {
        const match = matches[i];
        const intersection = match.range.intersectRanges(editorSelection);
        if (intersection) {
          matches[i] = matches[0];
          matches[0] = match;
          break;
        }
      }
      this._setSelections(matches.map((m) => new Selection(m.range.startLineNumber, m.range.startColumn, m.range.endLineNumber, m.range.endColumn)));
    }
  }
};
MultiCursorSelectionController.ID = "editor.contrib.multiCursorController";
var MultiCursorSelectionControllerAction = class extends EditorAction {
  run(accessor, editor2) {
    const multiCursorController = MultiCursorSelectionController.get(editor2);
    if (!multiCursorController) {
      return;
    }
    const findController = CommonFindController.get(editor2);
    if (!findController) {
      return;
    }
    const viewModel = editor2._getViewModel();
    if (viewModel) {
      const previousCursorState = viewModel.getCursorStates();
      this._run(multiCursorController, findController);
      announceCursorChange(previousCursorState, viewModel.getCursorStates());
    }
  }
};
var AddSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.addSelectionToNextFindMatch",
      label: localize("addSelectionToNextFindMatch", "Add Selection To Next Find Match"),
      alias: "Add Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 34,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miAddSelectionToNextFindMatch", comment: ["&& denotes a mnemonic"] }, "Add &&Next Occurrence"),
        order: 5
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.addSelectionToNextFindMatch(findController);
  }
};
var AddSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.addSelectionToPreviousFindMatch",
      label: localize("addSelectionToPreviousFindMatch", "Add Selection To Previous Find Match"),
      alias: "Add Selection To Previous Find Match",
      precondition: void 0,
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miAddSelectionToPreviousFindMatch", comment: ["&& denotes a mnemonic"] }, "Add P&&revious Occurrence"),
        order: 6
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.addSelectionToPreviousFindMatch(findController);
  }
};
var MoveSelectionToNextFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.moveSelectionToNextFindMatch",
      label: localize("moveSelectionToNextFindMatch", "Move Last Selection To Next Find Match"),
      alias: "Move Last Selection To Next Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: KeyChord(2048 | 41, 2048 | 34),
        weight: 100
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.moveSelectionToNextFindMatch(findController);
  }
};
var MoveSelectionToPreviousFindMatchAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.moveSelectionToPreviousFindMatch",
      label: localize("moveSelectionToPreviousFindMatch", "Move Last Selection To Previous Find Match"),
      alias: "Move Last Selection To Previous Find Match",
      precondition: void 0
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.moveSelectionToPreviousFindMatch(findController);
  }
};
var SelectHighlightsAction = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.selectHighlights",
      label: localize("selectAllOccurrencesOfFindMatch", "Select All Occurrences of Find Match"),
      alias: "Select All Occurrences of Find Match",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 42,
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "3_multi",
        title: localize({ key: "miSelectHighlights", comment: ["&& denotes a mnemonic"] }, "Select All &&Occurrences"),
        order: 7
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.selectAll(findController);
  }
};
var CompatChangeAll = class extends MultiCursorSelectionControllerAction {
  constructor() {
    super({
      id: "editor.action.changeAll",
      label: localize("changeAll.label", "Change All Occurrences"),
      alias: "Change All Occurrences",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.editorTextFocus),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 60,
        weight: 100
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.2
      }
    });
  }
  _run(multiCursorController, findController) {
    multiCursorController.selectAll(findController);
  }
};
var SelectionHighlighterState = class {
  constructor(_model, _searchText, _matchCase, _wordSeparators, prevState) {
    this._model = _model;
    this._searchText = _searchText;
    this._matchCase = _matchCase;
    this._wordSeparators = _wordSeparators;
    this._modelVersionId = this._model.getVersionId();
    this._cachedFindMatches = null;
    if (prevState && this._model === prevState._model && this._searchText === prevState._searchText && this._matchCase === prevState._matchCase && this._wordSeparators === prevState._wordSeparators && this._modelVersionId === prevState._modelVersionId) {
      this._cachedFindMatches = prevState._cachedFindMatches;
    }
  }
  findMatches() {
    if (this._cachedFindMatches === null) {
      this._cachedFindMatches = this._model.findMatches(this._searchText, true, false, this._matchCase, this._wordSeparators, false).map((m) => m.range);
      this._cachedFindMatches.sort(Range.compareRangesUsingStarts);
    }
    return this._cachedFindMatches;
  }
};
var SelectionHighlighter = class extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this._isEnabled = editor2.getOption(96);
    this.decorations = [];
    this.updateSoon = this._register(new RunOnceScheduler(() => this._update(), 300));
    this.state = null;
    this._register(editor2.onDidChangeConfiguration((e) => {
      this._isEnabled = editor2.getOption(96);
    }));
    this._register(editor2.onDidChangeCursorSelection((e) => {
      if (!this._isEnabled) {
        return;
      }
      if (e.selection.isEmpty()) {
        if (e.reason === 3) {
          if (this.state) {
            this._setState(null);
          }
          this.updateSoon.schedule();
        } else {
          this._setState(null);
        }
      } else {
        this._update();
      }
    }));
    this._register(editor2.onDidChangeModel((e) => {
      this._setState(null);
    }));
    this._register(editor2.onDidChangeModelContent((e) => {
      if (this._isEnabled) {
        this.updateSoon.schedule();
      }
    }));
    this._register(CommonFindController.get(editor2).getState().onFindReplaceStateChange((e) => {
      this._update();
    }));
  }
  _update() {
    this._setState(SelectionHighlighter._createState(this.state, this._isEnabled, this.editor));
  }
  static _createState(oldState, isEnabled, editor2) {
    if (!isEnabled) {
      return null;
    }
    if (!editor2.hasModel()) {
      return null;
    }
    const s = editor2.getSelection();
    if (s.startLineNumber !== s.endLineNumber) {
      return null;
    }
    const multiCursorController = MultiCursorSelectionController.get(editor2);
    if (!multiCursorController) {
      return null;
    }
    const findController = CommonFindController.get(editor2);
    if (!findController) {
      return null;
    }
    let r = multiCursorController.getSession(findController);
    if (!r) {
      const allSelections = editor2.getSelections();
      if (allSelections.length > 1) {
        const findState2 = findController.getState();
        const matchCase = findState2.matchCase;
        const selectionsContainSameText = modelRangesContainSameText(editor2.getModel(), allSelections, matchCase);
        if (!selectionsContainSameText) {
          return null;
        }
      }
      r = MultiCursorSession.create(editor2, findController);
    }
    if (!r) {
      return null;
    }
    if (r.currentMatch) {
      return null;
    }
    if (/^[ \t]+$/.test(r.searchText)) {
      return null;
    }
    if (r.searchText.length > 200) {
      return null;
    }
    const findState = findController.getState();
    const caseSensitive = findState.matchCase;
    if (findState.isRevealed) {
      let findStateSearchString = findState.searchString;
      if (!caseSensitive) {
        findStateSearchString = findStateSearchString.toLowerCase();
      }
      let mySearchString = r.searchText;
      if (!caseSensitive) {
        mySearchString = mySearchString.toLowerCase();
      }
      if (findStateSearchString === mySearchString && r.matchCase === findState.matchCase && r.wholeWord === findState.wholeWord && !findState.isRegex) {
        return null;
      }
    }
    return new SelectionHighlighterState(editor2.getModel(), r.searchText, r.matchCase, r.wholeWord ? editor2.getOption(116) : null, oldState);
  }
  _setState(newState) {
    this.state = newState;
    if (!this.state) {
      this.decorations = this.editor.deltaDecorations(this.decorations, []);
      return;
    }
    if (!this.editor.hasModel()) {
      return;
    }
    const model = this.editor.getModel();
    if (model.isTooLargeForTokenization()) {
      return;
    }
    const allMatches = this.state.findMatches();
    const selections = this.editor.getSelections();
    selections.sort(Range.compareRangesUsingStarts);
    const matches = [];
    for (let i = 0, j = 0, len = allMatches.length, lenJ = selections.length; i < len; ) {
      const match = allMatches[i];
      if (j >= lenJ) {
        matches.push(match);
        i++;
      } else {
        const cmp = Range.compareRangesUsingStarts(match, selections[j]);
        if (cmp < 0) {
          if (selections[j].isEmpty() || !Range.areIntersecting(match, selections[j])) {
            matches.push(match);
          }
          i++;
        } else if (cmp > 0) {
          j++;
        } else {
          i++;
          j++;
        }
      }
    }
    const hasFindOccurrences = DocumentHighlightProviderRegistry.has(model) && this.editor.getOption(71);
    const decorations = matches.map((r) => {
      return {
        range: r,
        options: hasFindOccurrences ? SelectionHighlighter._SELECTION_HIGHLIGHT : SelectionHighlighter._SELECTION_HIGHLIGHT_OVERVIEW
      };
    });
    this.decorations = this.editor.deltaDecorations(this.decorations, decorations);
  }
  dispose() {
    this._setState(null);
    super.dispose();
  }
};
SelectionHighlighter.ID = "editor.contrib.selectionHighlighter";
SelectionHighlighter._SELECTION_HIGHLIGHT_OVERVIEW = ModelDecorationOptions.register({
  description: "selection-highlight-overview",
  stickiness: 1,
  className: "selectionHighlight",
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  },
  overviewRuler: {
    color: themeColorFromId(overviewRulerSelectionHighlightForeground),
    position: OverviewRulerLane.Center
  }
});
SelectionHighlighter._SELECTION_HIGHLIGHT = ModelDecorationOptions.register({
  description: "selection-highlight",
  stickiness: 1,
  className: "selectionHighlight"
});
function modelRangesContainSameText(model, ranges, matchCase) {
  const selectedText = getValueInRange(model, ranges[0], !matchCase);
  for (let i = 1, len = ranges.length; i < len; i++) {
    const range = ranges[i];
    if (range.isEmpty()) {
      return false;
    }
    const thisSelectedText = getValueInRange(model, range, !matchCase);
    if (selectedText !== thisSelectedText) {
      return false;
    }
  }
  return true;
}
function getValueInRange(model, range, toLowerCase) {
  const text2 = model.getValueInRange(range);
  return toLowerCase ? text2.toLowerCase() : text2;
}
registerEditorContribution(MultiCursorSelectionController.ID, MultiCursorSelectionController);
registerEditorContribution(SelectionHighlighter.ID, SelectionHighlighter);
registerEditorAction(InsertCursorAbove);
registerEditorAction(InsertCursorBelow);
registerEditorAction(InsertCursorAtEndOfEachLineSelected);
registerEditorAction(AddSelectionToNextFindMatchAction);
registerEditorAction(AddSelectionToPreviousFindMatchAction);
registerEditorAction(MoveSelectionToNextFindMatchAction);
registerEditorAction(MoveSelectionToPreviousFindMatchAction);
registerEditorAction(SelectHighlightsAction);
registerEditorAction(CompatChangeAll);
registerEditorAction(InsertCursorAtEndOfLineSelected);
registerEditorAction(InsertCursorAtTopOfLineSelected);

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/provideSignatureHelp.js
var __awaiter38 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Context2 = {
  Visible: new RawContextKey("parameterHintsVisible", false),
  MultipleSignatures: new RawContextKey("parameterHintsMultipleSignatures", false)
};
function provideSignatureHelp(model, position, context, token) {
  return __awaiter38(this, void 0, void 0, function* () {
    const supports = SignatureHelpProviderRegistry.ordered(model);
    for (const support of supports) {
      try {
        const result = yield support.provideSignatureHelp(model, position, token, context);
        if (result) {
          return result;
        }
      } catch (err) {
        onUnexpectedExternalError(err);
      }
    }
    return void 0;
  });
}
CommandsRegistry.registerCommand("_executeSignatureHelpProvider", (accessor, ...args) => __awaiter38(void 0, void 0, void 0, function* () {
  const [uri, position, triggerCharacter] = args;
  assertType(URI.isUri(uri));
  assertType(Position.isIPosition(position));
  assertType(typeof triggerCharacter === "string" || !triggerCharacter);
  const ref = yield accessor.get(ITextModelService).createModelReference(uri);
  try {
    const result = yield provideSignatureHelp(ref.object.textEditorModel, Position.lift(position), {
      triggerKind: SignatureHelpTriggerKind.Invoke,
      isRetrigger: false,
      triggerCharacter
    }, CancellationToken.None);
    if (!result) {
      return void 0;
    }
    setTimeout(() => result.dispose(), 0);
    return result.value;
  } finally {
    ref.dispose();
  }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHintsWidget.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHints.css";

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHintsModel.js
var __awaiter39 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ParameterHintState;
(function(ParameterHintState2) {
  ParameterHintState2.Default = { type: 0 };
  class Pending {
    constructor(request, previouslyActiveHints) {
      this.request = request;
      this.previouslyActiveHints = previouslyActiveHints;
      this.type = 2;
    }
  }
  ParameterHintState2.Pending = Pending;
  class Active {
    constructor(hints) {
      this.hints = hints;
      this.type = 1;
    }
  }
  ParameterHintState2.Active = Active;
})(ParameterHintState || (ParameterHintState = {}));
var ParameterHintsModel = class extends Disposable {
  constructor(editor2, delay = ParameterHintsModel.DEFAULT_DELAY) {
    super();
    this._onChangedHints = this._register(new Emitter());
    this.onChangedHints = this._onChangedHints.event;
    this.triggerOnType = false;
    this._state = ParameterHintState.Default;
    this._pendingTriggers = [];
    this._lastSignatureHelpResult = this._register(new MutableDisposable());
    this.triggerChars = new CharacterSet();
    this.retriggerChars = new CharacterSet();
    this.triggerId = 0;
    this.editor = editor2;
    this.throttledDelayer = new Delayer(delay);
    this._register(this.editor.onDidBlurEditorWidget(() => this.cancel()));
    this._register(this.editor.onDidChangeConfiguration(() => this.onEditorConfigurationChange()));
    this._register(this.editor.onDidChangeModel((e) => this.onModelChanged()));
    this._register(this.editor.onDidChangeModelLanguage((_) => this.onModelChanged()));
    this._register(this.editor.onDidChangeCursorSelection((e) => this.onCursorChange(e)));
    this._register(this.editor.onDidChangeModelContent((e) => this.onModelContentChange()));
    this._register(SignatureHelpProviderRegistry.onDidChange(this.onModelChanged, this));
    this._register(this.editor.onDidType((text2) => this.onDidType(text2)));
    this.onEditorConfigurationChange();
    this.onModelChanged();
  }
  get state() {
    return this._state;
  }
  set state(value) {
    if (this._state.type === 2) {
      this._state.request.cancel();
    }
    this._state = value;
  }
  cancel(silent = false) {
    this.state = ParameterHintState.Default;
    this.throttledDelayer.cancel();
    if (!silent) {
      this._onChangedHints.fire(void 0);
    }
  }
  trigger(context, delay) {
    const model = this.editor.getModel();
    if (!model || !SignatureHelpProviderRegistry.has(model)) {
      return;
    }
    const triggerId = ++this.triggerId;
    this._pendingTriggers.push(context);
    this.throttledDelayer.trigger(() => {
      return this.doTrigger(triggerId);
    }, delay).catch(onUnexpectedError);
  }
  next() {
    if (this.state.type !== 1) {
      return;
    }
    const length = this.state.hints.signatures.length;
    const activeSignature = this.state.hints.activeSignature;
    const last = activeSignature % length === length - 1;
    const cycle = this.editor.getOption(75).cycle;
    if ((length < 2 || last) && !cycle) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(last && cycle ? 0 : activeSignature + 1);
  }
  previous() {
    if (this.state.type !== 1) {
      return;
    }
    const length = this.state.hints.signatures.length;
    const activeSignature = this.state.hints.activeSignature;
    const first2 = activeSignature === 0;
    const cycle = this.editor.getOption(75).cycle;
    if ((length < 2 || first2) && !cycle) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(first2 && cycle ? length - 1 : activeSignature - 1);
  }
  updateActiveSignature(activeSignature) {
    if (this.state.type !== 1) {
      return;
    }
    this.state = new ParameterHintState.Active(Object.assign(Object.assign({}, this.state.hints), { activeSignature }));
    this._onChangedHints.fire(this.state.hints);
  }
  doTrigger(triggerId) {
    return __awaiter39(this, void 0, void 0, function* () {
      const isRetrigger = this.state.type === 1 || this.state.type === 2;
      const activeSignatureHelp = this.getLastActiveHints();
      this.cancel(true);
      if (this._pendingTriggers.length === 0) {
        return false;
      }
      const context = this._pendingTriggers.reduce(mergeTriggerContexts);
      this._pendingTriggers = [];
      const triggerContext = {
        triggerKind: context.triggerKind,
        triggerCharacter: context.triggerCharacter,
        isRetrigger,
        activeSignatureHelp
      };
      if (!this.editor.hasModel()) {
        return false;
      }
      const model = this.editor.getModel();
      const position = this.editor.getPosition();
      this.state = new ParameterHintState.Pending(createCancelablePromise((token) => provideSignatureHelp(model, position, triggerContext, token)), activeSignatureHelp);
      try {
        const result = yield this.state.request;
        if (triggerId !== this.triggerId) {
          result === null || result === void 0 ? void 0 : result.dispose();
          return false;
        }
        if (!result || !result.value.signatures || result.value.signatures.length === 0) {
          result === null || result === void 0 ? void 0 : result.dispose();
          this._lastSignatureHelpResult.clear();
          this.cancel();
          return false;
        } else {
          this.state = new ParameterHintState.Active(result.value);
          this._lastSignatureHelpResult.value = result;
          this._onChangedHints.fire(this.state.hints);
          return true;
        }
      } catch (error) {
        if (triggerId === this.triggerId) {
          this.state = ParameterHintState.Default;
        }
        onUnexpectedError(error);
        return false;
      }
    });
  }
  getLastActiveHints() {
    switch (this.state.type) {
      case 1:
        return this.state.hints;
      case 2:
        return this.state.previouslyActiveHints;
      default:
        return void 0;
    }
  }
  get isTriggered() {
    return this.state.type === 1 || this.state.type === 2 || this.throttledDelayer.isTriggered();
  }
  onModelChanged() {
    this.cancel();
    this.triggerChars = new CharacterSet();
    this.retriggerChars = new CharacterSet();
    const model = this.editor.getModel();
    if (!model) {
      return;
    }
    for (const support of SignatureHelpProviderRegistry.ordered(model)) {
      for (const ch of support.signatureHelpTriggerCharacters || []) {
        this.triggerChars.add(ch.charCodeAt(0));
        this.retriggerChars.add(ch.charCodeAt(0));
      }
      for (const ch of support.signatureHelpRetriggerCharacters || []) {
        this.retriggerChars.add(ch.charCodeAt(0));
      }
    }
  }
  onDidType(text2) {
    if (!this.triggerOnType) {
      return;
    }
    const lastCharIndex = text2.length - 1;
    const triggerCharCode = text2.charCodeAt(lastCharIndex);
    if (this.triggerChars.has(triggerCharCode) || this.isTriggered && this.retriggerChars.has(triggerCharCode)) {
      this.trigger({
        triggerKind: SignatureHelpTriggerKind.TriggerCharacter,
        triggerCharacter: text2.charAt(lastCharIndex)
      });
    }
  }
  onCursorChange(e) {
    if (e.source === "mouse") {
      this.cancel();
    } else if (this.isTriggered) {
      this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
    }
  }
  onModelContentChange() {
    if (this.isTriggered) {
      this.trigger({ triggerKind: SignatureHelpTriggerKind.ContentChange });
    }
  }
  onEditorConfigurationChange() {
    this.triggerOnType = this.editor.getOption(75).enabled;
    if (!this.triggerOnType) {
      this.cancel();
    }
  }
  dispose() {
    this.cancel(true);
    super.dispose();
  }
};
ParameterHintsModel.DEFAULT_DELAY = 120;
function mergeTriggerContexts(previous, current) {
  switch (current.triggerKind) {
    case SignatureHelpTriggerKind.Invoke:
      return current;
    case SignatureHelpTriggerKind.ContentChange:
      return previous;
    case SignatureHelpTriggerKind.TriggerCharacter:
    default:
      return current;
  }
}

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHintsWidget.js
var __decorate53 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param53 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var $8 = $;
var parameterHintsNextIcon = registerIcon("parameter-hints-next", Codicon.chevronDown, localize("parameterHintsNextIcon", "Icon for show next parameter hint."));
var parameterHintsPreviousIcon = registerIcon("parameter-hints-previous", Codicon.chevronUp, localize("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
var ParameterHintsWidget = class ParameterHintsWidget2 extends Disposable {
  constructor(editor2, contextKeyService, openerService, modeService) {
    super();
    this.editor = editor2;
    this.renderDisposeables = this._register(new DisposableStore());
    this.visible = false;
    this.announcedLabel = null;
    this.allowEditorOverflow = true;
    this.markdownRenderer = this._register(new MarkdownRenderer({ editor: editor2 }, modeService, openerService));
    this.model = this._register(new ParameterHintsModel(editor2));
    this.keyVisible = Context2.Visible.bindTo(contextKeyService);
    this.keyMultipleSignatures = Context2.MultipleSignatures.bindTo(contextKeyService);
    this._register(this.model.onChangedHints((newParameterHints) => {
      if (newParameterHints) {
        this.show();
        this.render(newParameterHints);
      } else {
        this.hide();
      }
    }));
  }
  createParameterHintDOMNodes() {
    const element = $8(".editor-widget.parameter-hints-widget");
    const wrapper = append(element, $8(".phwrapper"));
    wrapper.tabIndex = -1;
    const controls = append(wrapper, $8(".controls"));
    const previous = append(controls, $8(".button" + ThemeIcon.asCSSSelector(parameterHintsPreviousIcon)));
    const overloads = append(controls, $8(".overloads"));
    const next = append(controls, $8(".button" + ThemeIcon.asCSSSelector(parameterHintsNextIcon)));
    this._register(addDisposableListener(previous, "click", (e) => {
      EventHelper.stop(e);
      this.previous();
    }));
    this._register(addDisposableListener(next, "click", (e) => {
      EventHelper.stop(e);
      this.next();
    }));
    const body = $8(".body");
    const scrollbar = new DomScrollableElement(body, {});
    this._register(scrollbar);
    wrapper.appendChild(scrollbar.getDomNode());
    const signature = append(body, $8(".signature"));
    const docs = append(body, $8(".docs"));
    element.style.userSelect = "text";
    this.domNodes = {
      element,
      signature,
      overloads,
      docs,
      scrollbar
    };
    this.editor.addContentWidget(this);
    this.hide();
    this._register(this.editor.onDidChangeCursorSelection((e) => {
      if (this.visible) {
        this.editor.layoutContentWidget(this);
      }
    }));
    const updateFont = () => {
      if (!this.domNodes) {
        return;
      }
      const fontInfo = this.editor.getOption(43);
      this.domNodes.element.style.fontSize = `${fontInfo.fontSize}px`;
      this.domNodes.element.style.lineHeight = `${fontInfo.lineHeight / fontInfo.fontSize}`;
    };
    updateFont();
    this._register(Event.chain(this.editor.onDidChangeConfiguration.bind(this.editor)).filter((e) => e.hasChanged(43)).on(updateFont, null));
    this._register(this.editor.onDidLayoutChange((e) => this.updateMaxHeight()));
    this.updateMaxHeight();
  }
  show() {
    if (this.visible) {
      return;
    }
    if (!this.domNodes) {
      this.createParameterHintDOMNodes();
    }
    this.keyVisible.set(true);
    this.visible = true;
    setTimeout(() => {
      if (this.domNodes) {
        this.domNodes.element.classList.add("visible");
      }
    }, 100);
    this.editor.layoutContentWidget(this);
  }
  hide() {
    this.renderDisposeables.clear();
    if (!this.visible) {
      return;
    }
    this.keyVisible.reset();
    this.visible = false;
    this.announcedLabel = null;
    if (this.domNodes) {
      this.domNodes.element.classList.remove("visible");
    }
    this.editor.layoutContentWidget(this);
  }
  getPosition() {
    if (this.visible) {
      return {
        position: this.editor.getPosition(),
        preference: [1, 2]
      };
    }
    return null;
  }
  render(hints) {
    var _a5;
    this.renderDisposeables.clear();
    if (!this.domNodes) {
      return;
    }
    const multiple = hints.signatures.length > 1;
    this.domNodes.element.classList.toggle("multiple", multiple);
    this.keyMultipleSignatures.set(multiple);
    this.domNodes.signature.innerText = "";
    this.domNodes.docs.innerText = "";
    const signature = hints.signatures[hints.activeSignature];
    if (!signature) {
      return;
    }
    const code = append(this.domNodes.signature, $8(".code"));
    const fontInfo = this.editor.getOption(43);
    code.style.fontSize = `${fontInfo.fontSize}px`;
    code.style.fontFamily = fontInfo.fontFamily;
    const hasParameters = signature.parameters.length > 0;
    const activeParameterIndex = (_a5 = signature.activeParameter) !== null && _a5 !== void 0 ? _a5 : hints.activeParameter;
    if (!hasParameters) {
      const label = append(code, $8("span"));
      label.textContent = signature.label;
    } else {
      this.renderParameters(code, signature, activeParameterIndex);
    }
    const activeParameter = signature.parameters[activeParameterIndex];
    if (activeParameter === null || activeParameter === void 0 ? void 0 : activeParameter.documentation) {
      const documentation = $8("span.documentation");
      if (typeof activeParameter.documentation === "string") {
        documentation.textContent = activeParameter.documentation;
      } else {
        const renderedContents = this.renderMarkdownDocs(activeParameter.documentation);
        documentation.appendChild(renderedContents.element);
      }
      append(this.domNodes.docs, $8("p", {}, documentation));
    }
    if (signature.documentation === void 0) {
    } else if (typeof signature.documentation === "string") {
      append(this.domNodes.docs, $8("p", {}, signature.documentation));
    } else {
      const renderedContents = this.renderMarkdownDocs(signature.documentation);
      append(this.domNodes.docs, renderedContents.element);
    }
    const hasDocs = this.hasDocs(signature, activeParameter);
    this.domNodes.signature.classList.toggle("has-docs", hasDocs);
    this.domNodes.docs.classList.toggle("empty", !hasDocs);
    this.domNodes.overloads.textContent = String(hints.activeSignature + 1).padStart(hints.signatures.length.toString().length, "0") + "/" + hints.signatures.length;
    if (activeParameter) {
      let labelToAnnounce = "";
      const param = signature.parameters[activeParameterIndex];
      if (Array.isArray(param.label)) {
        labelToAnnounce = signature.label.substring(param.label[0], param.label[1]);
      } else {
        labelToAnnounce = param.label;
      }
      if (param.documentation) {
        labelToAnnounce += typeof param.documentation === "string" ? `, ${param.documentation}` : `, ${param.documentation.value}`;
      }
      if (signature.documentation) {
        labelToAnnounce += typeof signature.documentation === "string" ? `, ${signature.documentation}` : `, ${signature.documentation.value}`;
      }
      if (this.announcedLabel !== labelToAnnounce) {
        alert(localize("hint", "{0}, hint", labelToAnnounce));
        this.announcedLabel = labelToAnnounce;
      }
    }
    this.editor.layoutContentWidget(this);
    this.domNodes.scrollbar.scanDomNode();
  }
  renderMarkdownDocs(markdown) {
    const renderedContents = this.renderDisposeables.add(this.markdownRenderer.render(markdown, {
      asyncRenderCallback: () => {
        var _a5;
        (_a5 = this.domNodes) === null || _a5 === void 0 ? void 0 : _a5.scrollbar.scanDomNode();
      }
    }));
    renderedContents.element.classList.add("markdown-docs");
    return renderedContents;
  }
  hasDocs(signature, activeParameter) {
    if (activeParameter && typeof activeParameter.documentation === "string" && assertIsDefined(activeParameter.documentation).length > 0) {
      return true;
    }
    if (activeParameter && typeof activeParameter.documentation === "object" && assertIsDefined(activeParameter.documentation).value.length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === "string" && assertIsDefined(signature.documentation).length > 0) {
      return true;
    }
    if (signature.documentation && typeof signature.documentation === "object" && assertIsDefined(signature.documentation.value).length > 0) {
      return true;
    }
    return false;
  }
  renderParameters(parent, signature, activeParameterIndex) {
    const [start, end] = this.getParameterLabelOffsets(signature, activeParameterIndex);
    const beforeSpan = document.createElement("span");
    beforeSpan.textContent = signature.label.substring(0, start);
    const paramSpan = document.createElement("span");
    paramSpan.textContent = signature.label.substring(start, end);
    paramSpan.className = "parameter active";
    const afterSpan = document.createElement("span");
    afterSpan.textContent = signature.label.substring(end);
    append(parent, beforeSpan, paramSpan, afterSpan);
  }
  getParameterLabelOffsets(signature, paramIdx) {
    const param = signature.parameters[paramIdx];
    if (!param) {
      return [0, 0];
    } else if (Array.isArray(param.label)) {
      return param.label;
    } else if (!param.label.length) {
      return [0, 0];
    } else {
      const regex = new RegExp(`(\\W|^)${escapeRegExpCharacters(param.label)}(?=\\W|$)`, "g");
      regex.test(signature.label);
      const idx = regex.lastIndex - param.label.length;
      return idx >= 0 ? [idx, regex.lastIndex] : [0, 0];
    }
  }
  next() {
    this.editor.focus();
    this.model.next();
  }
  previous() {
    this.editor.focus();
    this.model.previous();
  }
  cancel() {
    this.model.cancel();
  }
  getDomNode() {
    if (!this.domNodes) {
      this.createParameterHintDOMNodes();
    }
    return this.domNodes.element;
  }
  getId() {
    return ParameterHintsWidget2.ID;
  }
  trigger(context) {
    this.model.trigger(context, 0);
  }
  updateMaxHeight() {
    if (!this.domNodes) {
      return;
    }
    const height = Math.max(this.editor.getLayoutInfo().height / 4, 250);
    const maxHeight = `${height}px`;
    this.domNodes.element.style.maxHeight = maxHeight;
    const wrapper = this.domNodes.element.getElementsByClassName("phwrapper");
    if (wrapper.length) {
      wrapper[0].style.maxHeight = maxHeight;
    }
  }
};
ParameterHintsWidget.ID = "editor.widget.parameterHintsWidget";
ParameterHintsWidget = __decorate53([
  __param53(1, IContextKeyService),
  __param53(2, IOpenerService),
  __param53(3, IModeService)
], ParameterHintsWidget);
var editorHoverWidgetHighlightForeground = registerColor("editorHoverWidget.highlightForeground", { dark: listHighlightForeground, light: listHighlightForeground, hc: listHighlightForeground }, localize("editorHoverWidgetHighlightForeground", "Foreground color of the active item in the parameter hint."));
registerThemingParticipant((theme, collector) => {
  const border = theme.getColor(editorHoverBorder);
  if (border) {
    const borderWidth = theme.type === ColorScheme.HIGH_CONTRAST ? 2 : 1;
    collector.addRule(`.monaco-editor .parameter-hints-widget { border: ${borderWidth}px solid ${border}; }`);
    collector.addRule(`.monaco-editor .parameter-hints-widget.multiple .body { border-left: 1px solid ${border.transparent(0.5)}; }`);
    collector.addRule(`.monaco-editor .parameter-hints-widget .signature.has-docs { border-bottom: 1px solid ${border.transparent(0.5)}; }`);
  }
  const background = theme.getColor(editorHoverBackground);
  if (background) {
    collector.addRule(`.monaco-editor .parameter-hints-widget { background-color: ${background}; }`);
  }
  const link = theme.getColor(textLinkForeground);
  if (link) {
    collector.addRule(`.monaco-editor .parameter-hints-widget a { color: ${link}; }`);
  }
  const linkHover = theme.getColor(textLinkActiveForeground);
  if (linkHover) {
    collector.addRule(`.monaco-editor .parameter-hints-widget a:hover { color: ${linkHover}; }`);
  }
  const foreground2 = theme.getColor(editorHoverForeground);
  if (foreground2) {
    collector.addRule(`.monaco-editor .parameter-hints-widget { color: ${foreground2}; }`);
  }
  const codeBackground = theme.getColor(textCodeBlockBackground);
  if (codeBackground) {
    collector.addRule(`.monaco-editor .parameter-hints-widget code { background-color: ${codeBackground}; }`);
  }
  const parameterHighlightColor = theme.getColor(editorHoverWidgetHighlightForeground);
  if (parameterHighlightColor) {
    collector.addRule(`.monaco-editor .parameter-hints-widget .parameter.active { color: ${parameterHighlightColor}}`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/parameterHints/parameterHints.js
var __decorate54 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param54 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ParameterHintsController = class ParameterHintsController2 extends Disposable {
  constructor(editor2, instantiationService) {
    super();
    this.editor = editor2;
    this.widget = this._register(instantiationService.createInstance(ParameterHintsWidget, this.editor));
  }
  static get(editor2) {
    return editor2.getContribution(ParameterHintsController2.ID);
  }
  cancel() {
    this.widget.cancel();
  }
  previous() {
    this.widget.previous();
  }
  next() {
    this.widget.next();
  }
  trigger(context) {
    this.widget.trigger(context);
  }
};
ParameterHintsController.ID = "editor.controller.parameterHints";
ParameterHintsController = __decorate54([
  __param54(1, IInstantiationService)
], ParameterHintsController);
var TriggerParameterHintsAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.triggerParameterHints",
      label: localize("parameterHints.trigger.label", "Trigger Parameter Hints"),
      alias: "Trigger Parameter Hints",
      precondition: EditorContextKeys.hasSignatureHelpProvider,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 2048 | 1024 | 10,
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    const controller = ParameterHintsController.get(editor2);
    if (controller) {
      controller.trigger({
        triggerKind: SignatureHelpTriggerKind.Invoke
      });
    }
  }
};
registerEditorContribution(ParameterHintsController.ID, ParameterHintsController);
registerEditorAction(TriggerParameterHintsAction);
var weight2 = 100 + 75;
var ParameterHintsCommand = EditorCommand.bindToContribution(ParameterHintsController.get);
registerEditorCommand(new ParameterHintsCommand({
  id: "closeParameterHints",
  precondition: Context2.Visible,
  handler: (x) => x.cancel(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerEditorCommand(new ParameterHintsCommand({
  id: "showPrevParameterHint",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSignatures),
  handler: (x) => x.previous(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.focus,
    primary: 16,
    secondary: [512 | 16],
    mac: { primary: 16, secondary: [512 | 16, 256 | 46] }
  }
}));
registerEditorCommand(new ParameterHintsCommand({
  id: "showNextParameterHint",
  precondition: ContextKeyExpr.and(Context2.Visible, Context2.MultipleSignatures),
  handler: (x) => x.next(),
  kbOpts: {
    weight: weight2,
    kbExpr: EditorContextKeys.focus,
    primary: 18,
    secondary: [512 | 18],
    mac: { primary: 18, secondary: [512 | 18, 256 | 44] }
  }
}));

// node_modules/monaco-editor/esm/vs/editor/contrib/rename/renameInputField.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/contrib/rename/renameInputField.css";
var __decorate55 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param55 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CONTEXT_RENAME_INPUT_VISIBLE = new RawContextKey("renameInputVisible", false, localize("renameInputVisible", "Whether the rename input widget is visible"));
var RenameInputField = class RenameInputField2 {
  constructor(_editor, _acceptKeybindings, _themeService, _keybindingService, contextKeyService) {
    this._editor = _editor;
    this._acceptKeybindings = _acceptKeybindings;
    this._themeService = _themeService;
    this._keybindingService = _keybindingService;
    this._disposables = new DisposableStore();
    this.allowEditorOverflow = true;
    this._visibleContextKey = CONTEXT_RENAME_INPUT_VISIBLE.bindTo(contextKeyService);
    this._editor.addContentWidget(this);
    this._disposables.add(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(43)) {
        this._updateFont();
      }
    }));
    this._disposables.add(_themeService.onDidColorThemeChange(this._updateStyles, this));
  }
  dispose() {
    this._disposables.dispose();
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "__renameInputWidget";
  }
  getDomNode() {
    if (!this._domNode) {
      this._domNode = document.createElement("div");
      this._domNode.className = "monaco-editor rename-box";
      this._input = document.createElement("input");
      this._input.className = "rename-input";
      this._input.type = "text";
      this._input.setAttribute("aria-label", localize("renameAriaLabel", "Rename input. Type new name and press Enter to commit."));
      this._domNode.appendChild(this._input);
      this._label = document.createElement("div");
      this._label.className = "rename-label";
      this._domNode.appendChild(this._label);
      const updateLabel = () => {
        var _a5, _b2;
        const [accept, preview] = this._acceptKeybindings;
        this._keybindingService.lookupKeybinding(accept);
        this._label.innerText = localize({ key: "label", comment: ['placeholders are keybindings, e.g "F2 to Rename, Shift+F2 to Preview"'] }, "{0} to Rename, {1} to Preview", (_a5 = this._keybindingService.lookupKeybinding(accept)) === null || _a5 === void 0 ? void 0 : _a5.getLabel(), (_b2 = this._keybindingService.lookupKeybinding(preview)) === null || _b2 === void 0 ? void 0 : _b2.getLabel());
      };
      updateLabel();
      this._disposables.add(this._keybindingService.onDidUpdateKeybindings(updateLabel));
      this._updateFont();
      this._updateStyles(this._themeService.getColorTheme());
    }
    return this._domNode;
  }
  _updateStyles(theme) {
    var _a5, _b2, _c2, _d2;
    if (!this._input || !this._domNode) {
      return;
    }
    const widgetShadowColor = theme.getColor(widgetShadow);
    this._domNode.style.backgroundColor = String((_a5 = theme.getColor(editorWidgetBackground)) !== null && _a5 !== void 0 ? _a5 : "");
    this._domNode.style.boxShadow = widgetShadowColor ? ` 0 0 8px 2px ${widgetShadowColor}` : "";
    this._domNode.style.color = String((_b2 = theme.getColor(inputForeground)) !== null && _b2 !== void 0 ? _b2 : "");
    this._input.style.backgroundColor = String((_c2 = theme.getColor(inputBackground)) !== null && _c2 !== void 0 ? _c2 : "");
    const border = theme.getColor(inputBorder);
    this._input.style.borderWidth = border ? "1px" : "0px";
    this._input.style.borderStyle = border ? "solid" : "none";
    this._input.style.borderColor = (_d2 = border === null || border === void 0 ? void 0 : border.toString()) !== null && _d2 !== void 0 ? _d2 : "none";
  }
  _updateFont() {
    if (!this._input || !this._label) {
      return;
    }
    const fontInfo = this._editor.getOption(43);
    this._input.style.fontFamily = fontInfo.fontFamily;
    this._input.style.fontWeight = fontInfo.fontWeight;
    this._input.style.fontSize = `${fontInfo.fontSize}px`;
    this._label.style.fontSize = `${fontInfo.fontSize * 0.8}px`;
  }
  getPosition() {
    if (!this._visible) {
      return null;
    }
    return {
      position: this._position,
      preference: [2, 1]
    };
  }
  afterRender(position) {
    if (!position) {
      this.cancelInput(true);
    }
  }
  acceptInput(wantsPreview) {
    if (this._currentAcceptInput) {
      this._currentAcceptInput(wantsPreview);
    }
  }
  cancelInput(focusEditor) {
    if (this._currentCancelInput) {
      this._currentCancelInput(focusEditor);
    }
  }
  getInput(where, value, selectionStart, selectionEnd, supportPreview, token) {
    this._domNode.classList.toggle("preview", supportPreview);
    this._position = new Position(where.startLineNumber, where.startColumn);
    this._input.value = value;
    this._input.setAttribute("selectionStart", selectionStart.toString());
    this._input.setAttribute("selectionEnd", selectionEnd.toString());
    this._input.size = Math.max((where.endColumn - where.startColumn) * 1.1, 20);
    const disposeOnDone = new DisposableStore();
    return new Promise((resolve) => {
      this._currentCancelInput = (focusEditor) => {
        this._currentAcceptInput = void 0;
        this._currentCancelInput = void 0;
        resolve(focusEditor);
        return true;
      };
      this._currentAcceptInput = (wantsPreview) => {
        if (this._input.value.trim().length === 0 || this._input.value === value) {
          this.cancelInput(true);
          return;
        }
        this._currentAcceptInput = void 0;
        this._currentCancelInput = void 0;
        resolve({
          newName: this._input.value,
          wantsPreview: supportPreview && wantsPreview
        });
      };
      token.onCancellationRequested(() => this.cancelInput(true));
      disposeOnDone.add(this._editor.onDidBlurEditorWidget(() => this.cancelInput(false)));
      this._show();
    }).finally(() => {
      disposeOnDone.dispose();
      this._hide();
    });
  }
  _show() {
    this._editor.revealLineInCenterIfOutsideViewport(this._position.lineNumber, 0);
    this._visible = true;
    this._visibleContextKey.set(true);
    this._editor.layoutContentWidget(this);
    setTimeout(() => {
      this._input.focus();
      this._input.setSelectionRange(parseInt(this._input.getAttribute("selectionStart")), parseInt(this._input.getAttribute("selectionEnd")));
    }, 100);
  }
  _hide() {
    this._visible = false;
    this._visibleContextKey.reset();
    this._editor.layoutContentWidget(this);
  }
};
RenameInputField = __decorate55([
  __param55(2, IThemeService),
  __param55(3, IKeybindingService),
  __param55(4, IContextKeyService)
], RenameInputField);

// node_modules/monaco-editor/esm/vs/editor/contrib/rename/rename.js
var __decorate56 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param56 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter40 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var RenameSkeleton = class {
  constructor(model, position) {
    this.model = model;
    this.position = position;
    this._providerRenameIdx = 0;
    this._providers = RenameProviderRegistry.ordered(model);
  }
  hasProvider() {
    return this._providers.length > 0;
  }
  resolveRenameLocation(token) {
    return __awaiter40(this, void 0, void 0, function* () {
      const rejects = [];
      for (this._providerRenameIdx = 0; this._providerRenameIdx < this._providers.length; this._providerRenameIdx++) {
        const provider = this._providers[this._providerRenameIdx];
        if (!provider.resolveRenameLocation) {
          break;
        }
        let res = yield provider.resolveRenameLocation(this.model, this.position, token);
        if (!res) {
          continue;
        }
        if (res.rejectReason) {
          rejects.push(res.rejectReason);
          continue;
        }
        return res;
      }
      const word = this.model.getWordAtPosition(this.position);
      if (!word) {
        return {
          range: Range.fromPositions(this.position),
          text: "",
          rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
        };
      }
      return {
        range: new Range(this.position.lineNumber, word.startColumn, this.position.lineNumber, word.endColumn),
        text: word.word,
        rejectReason: rejects.length > 0 ? rejects.join("\n") : void 0
      };
    });
  }
  provideRenameEdits(newName, token) {
    return __awaiter40(this, void 0, void 0, function* () {
      return this._provideRenameEdits(newName, this._providerRenameIdx, [], token);
    });
  }
  _provideRenameEdits(newName, i, rejects, token) {
    return __awaiter40(this, void 0, void 0, function* () {
      const provider = this._providers[i];
      if (!provider) {
        return {
          edits: [],
          rejectReason: rejects.join("\n")
        };
      }
      const result = yield provider.provideRenameEdits(this.model, this.position, newName, token);
      if (!result) {
        return this._provideRenameEdits(newName, i + 1, rejects.concat(localize("no result", "No result.")), token);
      } else if (result.rejectReason) {
        return this._provideRenameEdits(newName, i + 1, rejects.concat(result.rejectReason), token);
      }
      return result;
    });
  }
};
function rename(model, position, newName) {
  return __awaiter40(this, void 0, void 0, function* () {
    const skeleton = new RenameSkeleton(model, position);
    const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
    if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
      return { edits: [], rejectReason: loc.rejectReason };
    }
    return skeleton.provideRenameEdits(newName, CancellationToken.None);
  });
}
var RenameController = class RenameController2 {
  constructor(editor2, _instaService, _notificationService, _bulkEditService, _progressService, _logService, _configService) {
    this.editor = editor2;
    this._instaService = _instaService;
    this._notificationService = _notificationService;
    this._bulkEditService = _bulkEditService;
    this._progressService = _progressService;
    this._logService = _logService;
    this._configService = _configService;
    this._dispoableStore = new DisposableStore();
    this._cts = new CancellationTokenSource();
    this._renameInputField = this._dispoableStore.add(new IdleValue(() => this._dispoableStore.add(this._instaService.createInstance(RenameInputField, this.editor, ["acceptRenameInput", "acceptRenameInputWithPreview"]))));
  }
  static get(editor2) {
    return editor2.getContribution(RenameController2.ID);
  }
  dispose() {
    this._dispoableStore.dispose();
    this._cts.dispose(true);
  }
  run() {
    return __awaiter40(this, void 0, void 0, function* () {
      this._cts.dispose(true);
      if (!this.editor.hasModel()) {
        return void 0;
      }
      const position = this.editor.getPosition();
      const skeleton = new RenameSkeleton(this.editor.getModel(), position);
      if (!skeleton.hasProvider()) {
        return void 0;
      }
      this._cts = new EditorStateCancellationTokenSource(this.editor, 4 | 1);
      let loc;
      try {
        const resolveLocationOperation = skeleton.resolveRenameLocation(this._cts.token);
        this._progressService.showWhile(resolveLocationOperation, 250);
        loc = yield resolveLocationOperation;
      } catch (e) {
        MessageController.get(this.editor).showMessage(e || localize("resolveRenameLocationFailed", "An unknown error occurred while resolving rename location"), position);
        return void 0;
      }
      if (!loc) {
        return void 0;
      }
      if (loc.rejectReason) {
        MessageController.get(this.editor).showMessage(loc.rejectReason, position);
        return void 0;
      }
      if (this._cts.token.isCancellationRequested) {
        return void 0;
      }
      this._cts.dispose();
      this._cts = new EditorStateCancellationTokenSource(this.editor, 4 | 1, loc.range);
      let selection = this.editor.getSelection();
      let selectionStart = 0;
      let selectionEnd = loc.text.length;
      if (!Range.isEmpty(selection) && !Range.spansMultipleLines(selection) && Range.containsRange(loc.range, selection)) {
        selectionStart = Math.max(0, selection.startColumn - loc.range.startColumn);
        selectionEnd = Math.min(loc.range.endColumn, selection.endColumn) - loc.range.startColumn;
      }
      const supportPreview = this._bulkEditService.hasPreviewHandler() && this._configService.getValue(this.editor.getModel().uri, "editor.rename.enablePreview");
      const inputFieldResult = yield this._renameInputField.value.getInput(loc.range, loc.text, selectionStart, selectionEnd, supportPreview, this._cts.token);
      if (typeof inputFieldResult === "boolean") {
        if (inputFieldResult) {
          this.editor.focus();
        }
        return void 0;
      }
      this.editor.focus();
      const renameOperation = raceCancellation(skeleton.provideRenameEdits(inputFieldResult.newName, this._cts.token), this._cts.token).then((renameResult) => __awaiter40(this, void 0, void 0, function* () {
        if (!renameResult || !this.editor.hasModel()) {
          return;
        }
        if (renameResult.rejectReason) {
          this._notificationService.info(renameResult.rejectReason);
          return;
        }
        this.editor.setSelection(Range.fromPositions(this.editor.getSelection().getPosition()));
        this._bulkEditService.apply(ResourceEdit.convert(renameResult), {
          editor: this.editor,
          showPreview: inputFieldResult.wantsPreview,
          label: localize("label", "Renaming '{0}'", loc === null || loc === void 0 ? void 0 : loc.text),
          quotableLabel: localize("quotableLabel", "Renaming {0}", loc === null || loc === void 0 ? void 0 : loc.text)
        }).then((result) => {
          if (result.ariaSummary) {
            alert(localize("aria", "Successfully renamed '{0}' to '{1}'. Summary: {2}", loc.text, inputFieldResult.newName, result.ariaSummary));
          }
        }).catch((err) => {
          this._notificationService.error(localize("rename.failedApply", "Rename failed to apply edits"));
          this._logService.error(err);
        });
      }), (err) => {
        this._notificationService.error(localize("rename.failed", "Rename failed to compute edits"));
        this._logService.error(err);
      });
      this._progressService.showWhile(renameOperation, 250);
      return renameOperation;
    });
  }
  acceptRenameInput(wantsPreview) {
    this._renameInputField.value.acceptInput(wantsPreview);
  }
  cancelRenameInput() {
    this._renameInputField.value.cancelInput(true);
  }
};
RenameController.ID = "editor.contrib.renameController";
RenameController = __decorate56([
  __param56(1, IInstantiationService),
  __param56(2, INotificationService),
  __param56(3, IBulkEditService),
  __param56(4, IEditorProgressService),
  __param56(5, ILogService),
  __param56(6, ITextResourceConfigurationService)
], RenameController);
var RenameAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.rename",
      label: localize("rename.label", "Rename Symbol"),
      alias: "Rename Symbol",
      precondition: ContextKeyExpr.and(EditorContextKeys.writable, EditorContextKeys.hasRenameProvider),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 60,
        weight: 100
      },
      contextMenuOpts: {
        group: "1_modification",
        order: 1.1
      }
    });
  }
  runCommand(accessor, args) {
    const editorService = accessor.get(ICodeEditorService);
    const [uri, pos] = Array.isArray(args) && args || [void 0, void 0];
    if (URI.isUri(uri) && Position.isIPosition(pos)) {
      return editorService.openCodeEditor({ resource: uri }, editorService.getActiveCodeEditor()).then((editor2) => {
        if (!editor2) {
          return;
        }
        editor2.setPosition(pos);
        editor2.invokeWithinContext((accessor2) => {
          this.reportTelemetry(accessor2, editor2);
          return this.run(accessor2, editor2);
        });
      }, onUnexpectedError);
    }
    return super.runCommand(accessor, args);
  }
  run(accessor, editor2) {
    const controller = RenameController.get(editor2);
    if (controller) {
      return controller.run();
    }
    return Promise.resolve();
  }
};
registerEditorContribution(RenameController.ID, RenameController);
registerEditorAction(RenameAction);
var RenameCommand = EditorCommand.bindToContribution(RenameController.get);
registerEditorCommand(new RenameCommand({
  id: "acceptRenameInput",
  precondition: CONTEXT_RENAME_INPUT_VISIBLE,
  handler: (x) => x.acceptRenameInput(false),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: EditorContextKeys.focus,
    primary: 3
  }
}));
registerEditorCommand(new RenameCommand({
  id: "acceptRenameInputWithPreview",
  precondition: ContextKeyExpr.and(CONTEXT_RENAME_INPUT_VISIBLE, ContextKeyExpr.has("config.editor.rename.enablePreview")),
  handler: (x) => x.acceptRenameInput(true),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: EditorContextKeys.focus,
    primary: 1024 + 3
  }
}));
registerEditorCommand(new RenameCommand({
  id: "cancelRenameInput",
  precondition: CONTEXT_RENAME_INPUT_VISIBLE,
  handler: (x) => x.cancelRenameInput(),
  kbOpts: {
    weight: 100 + 99,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerModelAndPositionCommand("_executeDocumentRenameProvider", function(model, position, ...args) {
  const [newName] = args;
  assertType(typeof newName === "string");
  return rename(model, position, newName);
});
registerModelAndPositionCommand("_executePrepareRename", function(model, position) {
  return __awaiter40(this, void 0, void 0, function* () {
    const skeleton = new RenameSkeleton(model, position);
    const loc = yield skeleton.resolveRenameLocation(CancellationToken.None);
    if (loc === null || loc === void 0 ? void 0 : loc.rejectReason) {
      throw new Error(loc.rejectReason);
    }
    return loc;
  });
});
Registry.as(Extensions.Configuration).registerConfiguration({
  id: "editor",
  properties: {
    "editor.rename.enablePreview": {
      scope: 5,
      description: localize("enablePreview", "Enable/disable the ability to preview changes before renaming"),
      default: true,
      type: "boolean"
    }
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/wordSelections.js
var WordSelectionRangeProvider = class {
  provideSelectionRanges(model, positions) {
    const result = [];
    for (const position of positions) {
      const bucket = [];
      result.push(bucket);
      this._addInWordRanges(bucket, model, position);
      this._addWordRanges(bucket, model, position);
      this._addWhitespaceLine(bucket, model, position);
      bucket.push({ range: model.getFullModelRange() });
    }
    return result;
  }
  _addInWordRanges(bucket, model, pos) {
    const obj = model.getWordAtPosition(pos);
    if (!obj) {
      return;
    }
    let { word, startColumn } = obj;
    let offset = pos.column - startColumn;
    let start = offset;
    let end = offset;
    let lastCh = 0;
    for (; start >= 0; start--) {
      let ch = word.charCodeAt(start);
      if (start !== offset && (ch === 95 || ch === 45)) {
        break;
      } else if (isLowerAsciiLetter(ch) && isUpperAsciiLetter(lastCh)) {
        break;
      }
      lastCh = ch;
    }
    start += 1;
    for (; end < word.length; end++) {
      let ch = word.charCodeAt(end);
      if (isUpperAsciiLetter(ch) && isLowerAsciiLetter(lastCh)) {
        break;
      } else if (ch === 95 || ch === 45) {
        break;
      }
      lastCh = ch;
    }
    if (start < end) {
      bucket.push({ range: new Range(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end) });
    }
  }
  _addWordRanges(bucket, model, pos) {
    const word = model.getWordAtPosition(pos);
    if (word) {
      bucket.push({ range: new Range(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn) });
    }
  }
  _addWhitespaceLine(bucket, model, pos) {
    if (model.getLineLength(pos.lineNumber) > 0 && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0 && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {
      bucket.push({ range: new Range(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber)) });
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/smartSelect.js
var __awaiter41 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var SelectionRanges = class {
  constructor(index, ranges) {
    this.index = index;
    this.ranges = ranges;
  }
  mov(fwd) {
    let index = this.index + (fwd ? 1 : -1);
    if (index < 0 || index >= this.ranges.length) {
      return this;
    }
    const res = new SelectionRanges(index, this.ranges);
    if (res.ranges[index].equalsRange(this.ranges[this.index])) {
      return res.mov(fwd);
    }
    return res;
  }
};
var SmartSelectController = class {
  constructor(_editor) {
    this._editor = _editor;
    this._ignoreSelection = false;
  }
  static get(editor2) {
    return editor2.getContribution(SmartSelectController.ID);
  }
  dispose() {
    var _a5;
    (_a5 = this._selectionListener) === null || _a5 === void 0 ? void 0 : _a5.dispose();
  }
  run(forward) {
    return __awaiter41(this, void 0, void 0, function* () {
      if (!this._editor.hasModel()) {
        return;
      }
      const selections = this._editor.getSelections();
      const model = this._editor.getModel();
      if (!SelectionRangeRegistry.has(model)) {
        return;
      }
      if (!this._state) {
        yield provideSelectionRanges(model, selections.map((s) => s.getPosition()), this._editor.getOption(101), CancellationToken.None).then((ranges) => {
          var _a5;
          if (!isNonEmptyArray(ranges) || ranges.length !== selections.length) {
            return;
          }
          if (!this._editor.hasModel() || !equals(this._editor.getSelections(), selections, (a, b) => a.equalsSelection(b))) {
            return;
          }
          for (let i = 0; i < ranges.length; i++) {
            ranges[i] = ranges[i].filter((range) => {
              return range.containsPosition(selections[i].getStartPosition()) && range.containsPosition(selections[i].getEndPosition());
            });
            ranges[i].unshift(selections[i]);
          }
          this._state = ranges.map((ranges2) => new SelectionRanges(0, ranges2));
          (_a5 = this._selectionListener) === null || _a5 === void 0 ? void 0 : _a5.dispose();
          this._selectionListener = this._editor.onDidChangeCursorPosition(() => {
            var _a6;
            if (!this._ignoreSelection) {
              (_a6 = this._selectionListener) === null || _a6 === void 0 ? void 0 : _a6.dispose();
              this._state = void 0;
            }
          });
        });
      }
      if (!this._state) {
        return;
      }
      this._state = this._state.map((state) => state.mov(forward));
      const newSelections = this._state.map((state) => Selection.fromPositions(state.ranges[state.index].getStartPosition(), state.ranges[state.index].getEndPosition()));
      this._ignoreSelection = true;
      try {
        this._editor.setSelections(newSelections);
      } finally {
        this._ignoreSelection = false;
      }
    });
  }
};
SmartSelectController.ID = "editor.contrib.smartSelectController";
var AbstractSmartSelect = class extends EditorAction {
  constructor(forward, opts) {
    super(opts);
    this._forward = forward;
  }
  run(_accessor, editor2) {
    return __awaiter41(this, void 0, void 0, function* () {
      let controller = SmartSelectController.get(editor2);
      if (controller) {
        yield controller.run(this._forward);
      }
    });
  }
};
var GrowSelectionAction = class extends AbstractSmartSelect {
  constructor() {
    super(true, {
      id: "editor.action.smartSelect.expand",
      label: localize("smartSelect.expand", "Expand Selection"),
      alias: "Expand Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 17,
        mac: {
          primary: 2048 | 256 | 1024 | 17,
          secondary: [256 | 1024 | 17]
        },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "1_basic",
        title: localize({ key: "miSmartSelectGrow", comment: ["&& denotes a mnemonic"] }, "&&Expand Selection"),
        order: 2
      }
    });
  }
};
CommandsRegistry.registerCommandAlias("editor.action.smartSelect.grow", "editor.action.smartSelect.expand");
var ShrinkSelectionAction = class extends AbstractSmartSelect {
  constructor() {
    super(false, {
      id: "editor.action.smartSelect.shrink",
      label: localize("smartSelect.shrink", "Shrink Selection"),
      alias: "Shrink Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 512 | 15,
        mac: {
          primary: 2048 | 256 | 1024 | 15,
          secondary: [256 | 1024 | 15]
        },
        weight: 100
      },
      menuOpts: {
        menuId: MenuId.MenubarSelectionMenu,
        group: "1_basic",
        title: localize({ key: "miSmartSelectShrink", comment: ["&& denotes a mnemonic"] }, "&&Shrink Selection"),
        order: 3
      }
    });
  }
};
registerEditorContribution(SmartSelectController.ID, SmartSelectController);
registerEditorAction(GrowSelectionAction);
registerEditorAction(ShrinkSelectionAction);
SelectionRangeRegistry.register("*", new WordSelectionRangeProvider());
function provideSelectionRanges(model, positions, options, token) {
  return __awaiter41(this, void 0, void 0, function* () {
    const providers = SelectionRangeRegistry.all(model);
    if (providers.length === 1) {
      providers.unshift(new BracketSelectionRangeProvider());
    }
    let work = [];
    let allRawRanges = [];
    for (const provider of providers) {
      work.push(Promise.resolve(provider.provideSelectionRanges(model, positions, token)).then((allProviderRanges) => {
        if (isNonEmptyArray(allProviderRanges) && allProviderRanges.length === positions.length) {
          for (let i = 0; i < positions.length; i++) {
            if (!allRawRanges[i]) {
              allRawRanges[i] = [];
            }
            for (const oneProviderRanges of allProviderRanges[i]) {
              if (Range.isIRange(oneProviderRanges.range) && Range.containsPosition(oneProviderRanges.range, positions[i])) {
                allRawRanges[i].push(Range.lift(oneProviderRanges.range));
              }
            }
          }
        }
      }, onUnexpectedExternalError));
    }
    yield Promise.all(work);
    return allRawRanges.map((oneRawRanges) => {
      if (oneRawRanges.length === 0) {
        return [];
      }
      oneRawRanges.sort((a, b) => {
        if (Position.isBefore(a.getStartPosition(), b.getStartPosition())) {
          return 1;
        } else if (Position.isBefore(b.getStartPosition(), a.getStartPosition())) {
          return -1;
        } else if (Position.isBefore(a.getEndPosition(), b.getEndPosition())) {
          return -1;
        } else if (Position.isBefore(b.getEndPosition(), a.getEndPosition())) {
          return 1;
        } else {
          return 0;
        }
      });
      let oneRanges = [];
      let last;
      for (const range of oneRawRanges) {
        if (!last || Range.containsRange(range, last) && !Range.equalsRange(range, last)) {
          oneRanges.push(range);
          last = range;
        }
      }
      if (!options.selectLeadingAndTrailingWhitespace) {
        return oneRanges;
      }
      let oneRangesWithTrivia = [oneRanges[0]];
      for (let i = 1; i < oneRanges.length; i++) {
        const prev = oneRanges[i - 1];
        const cur = oneRanges[i];
        if (cur.startLineNumber !== prev.startLineNumber || cur.endLineNumber !== prev.endLineNumber) {
          const rangeNoWhitespace = new Range(prev.startLineNumber, model.getLineFirstNonWhitespaceColumn(prev.startLineNumber), prev.endLineNumber, model.getLineLastNonWhitespaceColumn(prev.endLineNumber));
          if (rangeNoWhitespace.containsRange(prev) && !rangeNoWhitespace.equalsRange(prev) && cur.containsRange(rangeNoWhitespace) && !cur.equalsRange(rangeNoWhitespace)) {
            oneRangesWithTrivia.push(rangeNoWhitespace);
          }
          const rangeFull = new Range(prev.startLineNumber, 1, prev.endLineNumber, model.getLineMaxColumn(prev.endLineNumber));
          if (rangeFull.containsRange(prev) && !rangeFull.equalsRange(rangeNoWhitespace) && cur.containsRange(rangeFull) && !cur.equalsRange(rangeFull)) {
            oneRangesWithTrivia.push(rangeFull);
          }
        }
        oneRangesWithTrivia.push(cur);
      }
      return oneRangesWithTrivia;
    });
  });
}
registerModelCommand("_executeSelectionRangeProvider", function(model, ...args) {
  const [positions] = args;
  return provideSelectionRanges(model, positions, { selectLeadingAndTrailingWhitespace: true }, CancellationToken.None);
});

// node_modules/monaco-editor/esm/vs/editor/contrib/tokenization/tokenization.js
var ForceRetokenizeAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.forceRetokenize",
      label: localize("forceRetokenize", "Developer: Force Retokenize"),
      alias: "Developer: Force Retokenize",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    if (!editor2.hasModel()) {
      return;
    }
    const model = editor2.getModel();
    model.resetTokenization();
    const sw = new StopWatch(true);
    model.forceTokenization(model.getLineCount());
    sw.stop();
    console.log(`tokenization took ${sw.elapsed()}`);
  }
};
registerEditorAction(ForceRetokenizeAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/toggleTabFocusMode/toggleTabFocusMode.js
var ToggleTabFocusModeAction = class extends EditorAction {
  constructor() {
    super({
      id: ToggleTabFocusModeAction.ID,
      label: localize({ key: "toggle.tabMovesFocus", comment: ["Turn on/off use of tab key for moving focus around VS Code"] }, "Toggle Tab Key Moves Focus"),
      alias: "Toggle Tab Key Moves Focus",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 2048 | 43,
        mac: { primary: 256 | 1024 | 43 },
        weight: 100
      }
    });
  }
  run(accessor, editor2) {
    const oldValue = TabFocus.getTabFocusMode();
    const newValue = !oldValue;
    TabFocus.setTabFocusMode(newValue);
    if (newValue) {
      alert(localize("toggle.tabMovesFocus.on", "Pressing Tab will now move focus to the next focusable element"));
    } else {
      alert(localize("toggle.tabMovesFocus.off", "Pressing Tab will now insert the tab character"));
    }
  }
};
ToggleTabFocusModeAction.ID = "editor.action.toggleTabFocusMode";
registerEditorAction(ToggleTabFocusModeAction);

// node_modules/monaco-editor/esm/vs/editor/contrib/unusualLineTerminators/unusualLineTerminators.js
var __decorate57 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param57 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter42 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var ignoreUnusualLineTerminators = "ignoreUnusualLineTerminators";
function writeIgnoreState(codeEditorService, model, state) {
  codeEditorService.setModelProperty(model.uri, ignoreUnusualLineTerminators, state);
}
function readIgnoreState(codeEditorService, model) {
  return codeEditorService.getModelProperty(model.uri, ignoreUnusualLineTerminators);
}
var UnusualLineTerminatorsDetector = class UnusualLineTerminatorsDetector2 extends Disposable {
  constructor(_editor, _dialogService, _codeEditorService) {
    super();
    this._editor = _editor;
    this._dialogService = _dialogService;
    this._codeEditorService = _codeEditorService;
    this._config = this._editor.getOption(113);
    this._register(this._editor.onDidChangeConfiguration((e) => {
      if (e.hasChanged(113)) {
        this._config = this._editor.getOption(113);
        this._checkForUnusualLineTerminators();
      }
    }));
    this._register(this._editor.onDidChangeModel(() => {
      this._checkForUnusualLineTerminators();
    }));
    this._register(this._editor.onDidChangeModelContent((e) => {
      if (e.isUndoing) {
        return;
      }
      this._checkForUnusualLineTerminators();
    }));
  }
  _checkForUnusualLineTerminators() {
    return __awaiter42(this, void 0, void 0, function* () {
      if (this._config === "off") {
        return;
      }
      if (!this._editor.hasModel()) {
        return;
      }
      const model = this._editor.getModel();
      if (!model.mightContainUnusualLineTerminators()) {
        return;
      }
      const ignoreState = readIgnoreState(this._codeEditorService, model);
      if (ignoreState === true) {
        return;
      }
      if (this._editor.getOption(80)) {
        return;
      }
      if (this._config === "auto") {
        model.removeUnusualLineTerminators(this._editor.getSelections());
        return;
      }
      const result = yield this._dialogService.confirm({
        title: localize("unusualLineTerminators.title", "Unusual Line Terminators"),
        message: localize("unusualLineTerminators.message", "Detected unusual line terminators"),
        detail: localize("unusualLineTerminators.detail", "The file '{0}' contains one or more unusual line terminator characters, like Line Separator (LS) or Paragraph Separator (PS).\n\nIt is recommended to remove them from the file. This can be configured via `editor.unusualLineTerminators`.", basename2(model.uri)),
        primaryButton: localize("unusualLineTerminators.fix", "Remove Unusual Line Terminators"),
        secondaryButton: localize("unusualLineTerminators.ignore", "Ignore")
      });
      if (!result.confirmed) {
        writeIgnoreState(this._codeEditorService, model, true);
        return;
      }
      model.removeUnusualLineTerminators(this._editor.getSelections());
    });
  }
};
UnusualLineTerminatorsDetector.ID = "editor.contrib.unusualLineTerminatorsDetector";
UnusualLineTerminatorsDetector = __decorate57([
  __param57(1, IDialogService),
  __param57(2, ICodeEditorService)
], UnusualLineTerminatorsDetector);
registerEditorContribution(UnusualLineTerminatorsDetector.ID, UnusualLineTerminatorsDetector);

// node_modules/monaco-editor/esm/vs/editor/contrib/viewportSemanticTokens/viewportSemanticTokens.js
var __decorate58 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param58 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var ViewportSemanticTokensContribution = class ViewportSemanticTokensContribution2 extends Disposable {
  constructor(editor2, _modelService, _themeService, _configurationService) {
    super();
    this._modelService = _modelService;
    this._themeService = _themeService;
    this._configurationService = _configurationService;
    this._editor = editor2;
    this._tokenizeViewport = new RunOnceScheduler(() => this._tokenizeViewportNow(), 100);
    this._outstandingRequests = [];
    this._register(this._editor.onDidScrollChange(() => {
      this._tokenizeViewport.schedule();
    }));
    this._register(this._editor.onDidChangeModel(() => {
      this._cancelAll();
      this._tokenizeViewport.schedule();
    }));
    this._register(this._editor.onDidChangeModelContent((e) => {
      this._cancelAll();
      this._tokenizeViewport.schedule();
    }));
    this._register(DocumentRangeSemanticTokensProviderRegistry.onDidChange(() => {
      this._cancelAll();
      this._tokenizeViewport.schedule();
    }));
    this._register(this._configurationService.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration(SEMANTIC_HIGHLIGHTING_SETTING_ID)) {
        this._cancelAll();
        this._tokenizeViewport.schedule();
      }
    }));
    this._register(this._themeService.onDidColorThemeChange(() => {
      this._cancelAll();
      this._tokenizeViewport.schedule();
    }));
  }
  _cancelAll() {
    for (const request of this._outstandingRequests) {
      request.cancel();
    }
    this._outstandingRequests = [];
  }
  _removeOutstandingRequest(req) {
    for (let i = 0, len = this._outstandingRequests.length; i < len; i++) {
      if (this._outstandingRequests[i] === req) {
        this._outstandingRequests.splice(i, 1);
        return;
      }
    }
  }
  _tokenizeViewportNow() {
    if (!this._editor.hasModel()) {
      return;
    }
    const model = this._editor.getModel();
    if (model.hasCompleteSemanticTokens()) {
      return;
    }
    if (!isSemanticColoringEnabled(model, this._themeService, this._configurationService)) {
      if (model.hasSomeSemanticTokens()) {
        model.setSemanticTokens(null, false);
      }
      return;
    }
    if (!hasDocumentRangeSemanticTokensProvider(model)) {
      if (model.hasSomeSemanticTokens()) {
        model.setSemanticTokens(null, false);
      }
      return;
    }
    const visibleRanges = this._editor.getVisibleRangesPlusViewportAboveBelow();
    this._outstandingRequests = this._outstandingRequests.concat(visibleRanges.map((range) => this._requestRange(model, range)));
  }
  _requestRange(model, range) {
    const requestVersionId = model.getVersionId();
    const request = createCancelablePromise((token) => Promise.resolve(getDocumentRangeSemanticTokens(model, range, token)));
    request.then((r) => {
      if (!r || !r.tokens || model.isDisposed() || model.getVersionId() !== requestVersionId) {
        return;
      }
      const { provider, tokens: result } = r;
      const styling = this._modelService.getSemanticTokensProviderStyling(provider);
      model.setPartialSemanticTokens(range, toMultilineTokens2(result, styling, model.getLanguageId()));
    }).then(() => this._removeOutstandingRequest(request), () => this._removeOutstandingRequest(request));
    return request;
  }
};
ViewportSemanticTokensContribution.ID = "editor.contrib.viewportSemanticTokens";
ViewportSemanticTokensContribution = __decorate58([
  __param58(1, IModelService),
  __param58(2, IThemeService),
  __param58(3, IConfigurationService)
], ViewportSemanticTokensContribution);
registerEditorContribution(ViewportSemanticTokensContribution.ID, ViewportSemanticTokensContribution);

// node_modules/monaco-editor/esm/vs/editor/contrib/wordHighlighter/wordHighlighter.js
var __decorate59 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param59 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var editorWordHighlight = registerColor("editor.wordHighlightBackground", { dark: "#575757B8", light: "#57575740", hc: null }, localize("wordHighlight", "Background color of a symbol during read-access, like reading a variable. The color must not be opaque so as not to hide underlying decorations."), true);
var editorWordHighlightStrong = registerColor("editor.wordHighlightStrongBackground", { dark: "#004972B8", light: "#0e639c40", hc: null }, localize("wordHighlightStrong", "Background color of a symbol during write-access, like writing to a variable. The color must not be opaque so as not to hide underlying decorations."), true);
var editorWordHighlightBorder = registerColor("editor.wordHighlightBorder", { light: null, dark: null, hc: activeContrastBorder }, localize("wordHighlightBorder", "Border color of a symbol during read-access, like reading a variable."));
var editorWordHighlightStrongBorder = registerColor("editor.wordHighlightStrongBorder", { light: null, dark: null, hc: activeContrastBorder }, localize("wordHighlightStrongBorder", "Border color of a symbol during write-access, like writing to a variable."));
var overviewRulerWordHighlightForeground = registerColor("editorOverviewRuler.wordHighlightForeground", { dark: "#A0A0A0CC", light: "#A0A0A0CC", hc: "#A0A0A0CC" }, localize("overviewRulerWordHighlightForeground", "Overview ruler marker color for symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var overviewRulerWordHighlightStrongForeground = registerColor("editorOverviewRuler.wordHighlightStrongForeground", { dark: "#C0A0C0CC", light: "#C0A0C0CC", hc: "#C0A0C0CC" }, localize("overviewRulerWordHighlightStrongForeground", "Overview ruler marker color for write-access symbol highlights. The color must not be opaque so as not to hide underlying decorations."), true);
var ctxHasWordHighlights = new RawContextKey("hasWordHighlights", false);
function getOccurrencesAtPosition(model, position, token) {
  const orderedByScore = DocumentHighlightProviderRegistry.ordered(model);
  return first(orderedByScore.map((provider) => () => {
    return Promise.resolve(provider.provideDocumentHighlights(model, position, token)).then(void 0, onUnexpectedExternalError);
  }), isNonEmptyArray);
}
var OccurenceAtPositionRequest = class {
  constructor(model, selection, wordSeparators) {
    this._wordRange = this._getCurrentWordRange(model, selection);
    this.result = createCancelablePromise((token) => this._compute(model, selection, wordSeparators, token));
  }
  _getCurrentWordRange(model, selection) {
    const word = model.getWordAtPosition(selection.getPosition());
    if (word) {
      return new Range(selection.startLineNumber, word.startColumn, selection.startLineNumber, word.endColumn);
    }
    return null;
  }
  isValid(model, selection, decorationIds) {
    const lineNumber = selection.startLineNumber;
    const startColumn = selection.startColumn;
    const endColumn = selection.endColumn;
    const currentWordRange = this._getCurrentWordRange(model, selection);
    let requestIsValid = Boolean(this._wordRange && this._wordRange.equalsRange(currentWordRange));
    for (let i = 0, len = decorationIds.length; !requestIsValid && i < len; i++) {
      let range = model.getDecorationRange(decorationIds[i]);
      if (range && range.startLineNumber === lineNumber) {
        if (range.startColumn <= startColumn && range.endColumn >= endColumn) {
          requestIsValid = true;
        }
      }
    }
    return requestIsValid;
  }
  cancel() {
    this.result.cancel();
  }
};
var SemanticOccurenceAtPositionRequest = class extends OccurenceAtPositionRequest {
  _compute(model, selection, wordSeparators, token) {
    return getOccurrencesAtPosition(model, selection.getPosition(), token).then((value) => value || []);
  }
};
var TextualOccurenceAtPositionRequest = class extends OccurenceAtPositionRequest {
  constructor(model, selection, wordSeparators) {
    super(model, selection, wordSeparators);
    this._selectionIsEmpty = selection.isEmpty();
  }
  _compute(model, selection, wordSeparators, token) {
    return timeout(250, token).then(() => {
      if (!selection.isEmpty()) {
        return [];
      }
      const word = model.getWordAtPosition(selection.getPosition());
      if (!word || word.word.length > 1e3) {
        return [];
      }
      const matches = model.findMatches(word.word, true, false, true, wordSeparators, false);
      return matches.map((m) => {
        return {
          range: m.range,
          kind: DocumentHighlightKind.Text
        };
      });
    });
  }
  isValid(model, selection, decorationIds) {
    const currentSelectionIsEmpty = selection.isEmpty();
    if (this._selectionIsEmpty !== currentSelectionIsEmpty) {
      return false;
    }
    return super.isValid(model, selection, decorationIds);
  }
};
function computeOccurencesAtPosition(model, selection, wordSeparators) {
  if (DocumentHighlightProviderRegistry.has(model)) {
    return new SemanticOccurenceAtPositionRequest(model, selection, wordSeparators);
  }
  return new TextualOccurenceAtPositionRequest(model, selection, wordSeparators);
}
registerModelAndPositionCommand("_executeDocumentHighlights", (model, position) => getOccurrencesAtPosition(model, position, CancellationToken.None));
var WordHighlighter = class {
  constructor(editor2, contextKeyService) {
    this.toUnhook = new DisposableStore();
    this.workerRequestTokenId = 0;
    this.workerRequestCompleted = false;
    this.workerRequestValue = [];
    this.lastCursorPositionChangeTime = 0;
    this.renderDecorationsTimer = -1;
    this.editor = editor2;
    this._hasWordHighlights = ctxHasWordHighlights.bindTo(contextKeyService);
    this._ignorePositionChangeEvent = false;
    this.occurrencesHighlight = this.editor.getOption(71);
    this.model = this.editor.getModel();
    this.toUnhook.add(editor2.onDidChangeCursorPosition((e) => {
      if (this._ignorePositionChangeEvent) {
        return;
      }
      if (!this.occurrencesHighlight) {
        return;
      }
      this._onPositionChanged(e);
    }));
    this.toUnhook.add(editor2.onDidChangeModelContent((e) => {
      this._stopAll();
    }));
    this.toUnhook.add(editor2.onDidChangeConfiguration((e) => {
      let newValue = this.editor.getOption(71);
      if (this.occurrencesHighlight !== newValue) {
        this.occurrencesHighlight = newValue;
        this._stopAll();
      }
    }));
    this._decorationIds = [];
    this.workerRequestTokenId = 0;
    this.workerRequest = null;
    this.workerRequestCompleted = false;
    this.lastCursorPositionChangeTime = 0;
    this.renderDecorationsTimer = -1;
  }
  hasDecorations() {
    return this._decorationIds.length > 0;
  }
  restore() {
    if (!this.occurrencesHighlight) {
      return;
    }
    this._run();
  }
  _getSortedHighlights() {
    return coalesce(this._decorationIds.map((id) => this.model.getDecorationRange(id)).sort(Range.compareRangesUsingStarts));
  }
  moveNext() {
    let highlights = this._getSortedHighlights();
    let index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));
    let newIndex = (index + 1) % highlights.length;
    let dest = highlights[newIndex];
    try {
      this._ignorePositionChangeEvent = true;
      this.editor.setPosition(dest.getStartPosition());
      this.editor.revealRangeInCenterIfOutsideViewport(dest);
      const word = this._getWord();
      if (word) {
        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = false;
    }
  }
  moveBack() {
    let highlights = this._getSortedHighlights();
    let index = highlights.findIndex((range) => range.containsPosition(this.editor.getPosition()));
    let newIndex = (index - 1 + highlights.length) % highlights.length;
    let dest = highlights[newIndex];
    try {
      this._ignorePositionChangeEvent = true;
      this.editor.setPosition(dest.getStartPosition());
      this.editor.revealRangeInCenterIfOutsideViewport(dest);
      const word = this._getWord();
      if (word) {
        const lineContent = this.editor.getModel().getLineContent(dest.startLineNumber);
        alert(`${lineContent}, ${newIndex + 1} of ${highlights.length} for '${word.word}'`);
      }
    } finally {
      this._ignorePositionChangeEvent = false;
    }
  }
  _removeDecorations() {
    if (this._decorationIds.length > 0) {
      this._decorationIds = this.editor.deltaDecorations(this._decorationIds, []);
      this._hasWordHighlights.set(false);
    }
  }
  _stopAll() {
    this._removeDecorations();
    if (this.renderDecorationsTimer !== -1) {
      clearTimeout(this.renderDecorationsTimer);
      this.renderDecorationsTimer = -1;
    }
    if (this.workerRequest !== null) {
      this.workerRequest.cancel();
      this.workerRequest = null;
    }
    if (!this.workerRequestCompleted) {
      this.workerRequestTokenId++;
      this.workerRequestCompleted = true;
    }
  }
  _onPositionChanged(e) {
    if (!this.occurrencesHighlight) {
      this._stopAll();
      return;
    }
    if (e.reason !== 3) {
      this._stopAll();
      return;
    }
    this._run();
  }
  _getWord() {
    let editorSelection = this.editor.getSelection();
    let lineNumber = editorSelection.startLineNumber;
    let startColumn = editorSelection.startColumn;
    return this.model.getWordAtPosition({
      lineNumber,
      column: startColumn
    });
  }
  _run() {
    let editorSelection = this.editor.getSelection();
    if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {
      this._stopAll();
      return;
    }
    let startColumn = editorSelection.startColumn;
    let endColumn = editorSelection.endColumn;
    const word = this._getWord();
    if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {
      this._stopAll();
      return;
    }
    const workerRequestIsValid = this.workerRequest && this.workerRequest.isValid(this.model, editorSelection, this._decorationIds);
    this.lastCursorPositionChangeTime = new Date().getTime();
    if (workerRequestIsValid) {
      if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {
        clearTimeout(this.renderDecorationsTimer);
        this.renderDecorationsTimer = -1;
        this._beginRenderDecorations();
      }
    } else {
      this._stopAll();
      let myRequestId = ++this.workerRequestTokenId;
      this.workerRequestCompleted = false;
      this.workerRequest = computeOccurencesAtPosition(this.model, this.editor.getSelection(), this.editor.getOption(116));
      this.workerRequest.result.then((data) => {
        if (myRequestId === this.workerRequestTokenId) {
          this.workerRequestCompleted = true;
          this.workerRequestValue = data || [];
          this._beginRenderDecorations();
        }
      }, onUnexpectedError);
    }
  }
  _beginRenderDecorations() {
    let currentTime = new Date().getTime();
    let minimumRenderTime = this.lastCursorPositionChangeTime + 250;
    if (currentTime >= minimumRenderTime) {
      this.renderDecorationsTimer = -1;
      this.renderDecorations();
    } else {
      this.renderDecorationsTimer = setTimeout(() => {
        this.renderDecorations();
      }, minimumRenderTime - currentTime);
    }
  }
  renderDecorations() {
    this.renderDecorationsTimer = -1;
    let decorations = [];
    for (const info of this.workerRequestValue) {
      if (info.range) {
        decorations.push({
          range: info.range,
          options: WordHighlighter._getDecorationOptions(info.kind)
        });
      }
    }
    this._decorationIds = this.editor.deltaDecorations(this._decorationIds, decorations);
    this._hasWordHighlights.set(this.hasDecorations());
  }
  static _getDecorationOptions(kind) {
    if (kind === DocumentHighlightKind.Write) {
      return this._WRITE_OPTIONS;
    } else if (kind === DocumentHighlightKind.Text) {
      return this._TEXT_OPTIONS;
    } else {
      return this._REGULAR_OPTIONS;
    }
  }
  dispose() {
    this._stopAll();
    this.toUnhook.dispose();
  }
};
WordHighlighter._WRITE_OPTIONS = ModelDecorationOptions.register({
  description: "word-highlight-strong",
  stickiness: 1,
  className: "wordHighlightStrong",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightStrongForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
WordHighlighter._TEXT_OPTIONS = ModelDecorationOptions.register({
  description: "selection-highlight",
  stickiness: 1,
  className: "selectionHighlight",
  overviewRuler: {
    color: themeColorFromId(overviewRulerSelectionHighlightForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
WordHighlighter._REGULAR_OPTIONS = ModelDecorationOptions.register({
  description: "word-highlight",
  stickiness: 1,
  className: "wordHighlight",
  overviewRuler: {
    color: themeColorFromId(overviewRulerWordHighlightForeground),
    position: OverviewRulerLane.Center
  },
  minimap: {
    color: themeColorFromId(minimapSelectionOccurrenceHighlight),
    position: MinimapPosition.Inline
  }
});
var WordHighlighterContribution = class WordHighlighterContribution2 extends Disposable {
  constructor(editor2, contextKeyService) {
    super();
    this.wordHighlighter = null;
    const createWordHighlighterIfPossible = () => {
      if (editor2.hasModel()) {
        this.wordHighlighter = new WordHighlighter(editor2, contextKeyService);
      }
    };
    this._register(editor2.onDidChangeModel((e) => {
      if (this.wordHighlighter) {
        this.wordHighlighter.dispose();
        this.wordHighlighter = null;
      }
      createWordHighlighterIfPossible();
    }));
    createWordHighlighterIfPossible();
  }
  static get(editor2) {
    return editor2.getContribution(WordHighlighterContribution2.ID);
  }
  saveViewState() {
    if (this.wordHighlighter && this.wordHighlighter.hasDecorations()) {
      return true;
    }
    return false;
  }
  moveNext() {
    if (this.wordHighlighter) {
      this.wordHighlighter.moveNext();
    }
  }
  moveBack() {
    if (this.wordHighlighter) {
      this.wordHighlighter.moveBack();
    }
  }
  restoreViewState(state) {
    if (this.wordHighlighter && state) {
      this.wordHighlighter.restore();
    }
  }
  dispose() {
    if (this.wordHighlighter) {
      this.wordHighlighter.dispose();
      this.wordHighlighter = null;
    }
    super.dispose();
  }
};
WordHighlighterContribution.ID = "editor.contrib.wordHighlighter";
WordHighlighterContribution = __decorate59([
  __param59(1, IContextKeyService)
], WordHighlighterContribution);
var WordHighlightNavigationAction = class extends EditorAction {
  constructor(next, opts) {
    super(opts);
    this._isNext = next;
  }
  run(accessor, editor2) {
    const controller = WordHighlighterContribution.get(editor2);
    if (!controller) {
      return;
    }
    if (this._isNext) {
      controller.moveNext();
    } else {
      controller.moveBack();
    }
  }
};
var NextWordHighlightAction = class extends WordHighlightNavigationAction {
  constructor() {
    super(true, {
      id: "editor.action.wordHighlight.next",
      label: localize("wordHighlight.next.label", "Go to Next Symbol Highlight"),
      alias: "Go to Next Symbol Highlight",
      precondition: ctxHasWordHighlights,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 65,
        weight: 100
      }
    });
  }
};
var PrevWordHighlightAction = class extends WordHighlightNavigationAction {
  constructor() {
    super(false, {
      id: "editor.action.wordHighlight.prev",
      label: localize("wordHighlight.previous.label", "Go to Previous Symbol Highlight"),
      alias: "Go to Previous Symbol Highlight",
      precondition: ctxHasWordHighlights,
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 1024 | 65,
        weight: 100
      }
    });
  }
};
var TriggerWordHighlightAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.wordHighlight.trigger",
      label: localize("wordHighlight.trigger.label", "Trigger Symbol Highlight"),
      alias: "Trigger Symbol Highlight",
      precondition: ctxHasWordHighlights.toNegated(),
      kbOpts: {
        kbExpr: EditorContextKeys.editorTextFocus,
        primary: 0,
        weight: 100
      }
    });
  }
  run(accessor, editor2, args) {
    const controller = WordHighlighterContribution.get(editor2);
    if (!controller) {
      return;
    }
    controller.restoreViewState(true);
  }
};
registerEditorContribution(WordHighlighterContribution.ID, WordHighlighterContribution);
registerEditorAction(NextWordHighlightAction);
registerEditorAction(PrevWordHighlightAction);
registerEditorAction(TriggerWordHighlightAction);
registerThemingParticipant((theme, collector) => {
  const selectionHighlight = theme.getColor(editorSelectionHighlight);
  if (selectionHighlight) {
    collector.addRule(`.monaco-editor .focused .selectionHighlight { background-color: ${selectionHighlight}; }`);
    collector.addRule(`.monaco-editor .selectionHighlight { background-color: ${selectionHighlight.transparent(0.5)}; }`);
  }
  const wordHighlight = theme.getColor(editorWordHighlight);
  if (wordHighlight) {
    collector.addRule(`.monaco-editor .wordHighlight { background-color: ${wordHighlight}; }`);
  }
  const wordHighlightStrong = theme.getColor(editorWordHighlightStrong);
  if (wordHighlightStrong) {
    collector.addRule(`.monaco-editor .wordHighlightStrong { background-color: ${wordHighlightStrong}; }`);
  }
  const selectionHighlightBorder = theme.getColor(editorSelectionHighlightBorder);
  if (selectionHighlightBorder) {
    collector.addRule(`.monaco-editor .selectionHighlight { border: 1px ${theme.type === "hc" ? "dotted" : "solid"} ${selectionHighlightBorder}; box-sizing: border-box; }`);
  }
  const wordHighlightBorder = theme.getColor(editorWordHighlightBorder);
  if (wordHighlightBorder) {
    collector.addRule(`.monaco-editor .wordHighlight { border: 1px ${theme.type === "hc" ? "dashed" : "solid"} ${wordHighlightBorder}; box-sizing: border-box; }`);
  }
  const wordHighlightStrongBorder = theme.getColor(editorWordHighlightStrongBorder);
  if (wordHighlightStrongBorder) {
    collector.addRule(`.monaco-editor .wordHighlightStrong { border: 1px ${theme.type === "hc" ? "dashed" : "solid"} ${wordHighlightStrongBorder}; box-sizing: border-box; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/contrib/wordOperations/wordOperations.js
var MoveWordCommand = class extends EditorCommand {
  constructor(opts) {
    super(opts);
    this._inSelectionMode = opts.inSelectionMode;
    this._wordNavigationType = opts.wordNavigationType;
  }
  runEditorCommand(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(116));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const result = selections.map((sel) => {
      const inPosition = new Position(sel.positionLineNumber, sel.positionColumn);
      const outPosition = this._move(wordSeparators, model, inPosition, this._wordNavigationType);
      return this._moveTo(sel, outPosition, this._inSelectionMode);
    });
    model.pushStackElement();
    editor2._getViewModel().setCursorStates("moveWordCommand", 3, result.map((r) => CursorState.fromModelSelection(r)));
    if (result.length === 1) {
      const pos = new Position(result[0].positionLineNumber, result[0].positionColumn);
      editor2.revealPosition(pos, 0);
    }
  }
  _moveTo(from, to, inSelectionMode) {
    if (inSelectionMode) {
      return new Selection(from.selectionStartLineNumber, from.selectionStartColumn, to.lineNumber, to.column);
    } else {
      return new Selection(to.lineNumber, to.column, to.lineNumber, to.column);
    }
  }
};
var WordLeftCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordOperations.moveWordLeft(wordSeparators, model, position, wordNavigationType);
  }
};
var WordRightCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordOperations.moveWordRight(wordSeparators, model, position, wordNavigationType);
  }
};
var CursorWordStartLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordStartLeft",
      precondition: void 0
    });
  }
};
var CursorWordEndLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordEndLeft",
      precondition: void 0
    });
  }
};
var CursorWordLeft = class extends WordLeftCommand {
  constructor() {
    var _a5;
    super({
      inSelectionMode: false,
      wordNavigationType: 1,
      id: "cursorWordLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a5 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a5 === void 0 ? void 0 : _a5.negate()),
        primary: 2048 | 15,
        mac: { primary: 512 | 15 },
        weight: 100
      }
    });
  }
};
var CursorWordStartLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordStartLeftSelect",
      precondition: void 0
    });
  }
};
var CursorWordEndLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordEndLeftSelect",
      precondition: void 0
    });
  }
};
var CursorWordLeftSelect = class extends WordLeftCommand {
  constructor() {
    var _a5;
    super({
      inSelectionMode: true,
      wordNavigationType: 1,
      id: "cursorWordLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a5 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a5 === void 0 ? void 0 : _a5.negate()),
        primary: 2048 | 1024 | 15,
        mac: { primary: 512 | 1024 | 15 },
        weight: 100
      }
    });
  }
};
var CursorWordAccessibilityLeft = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeft",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
var CursorWordAccessibilityLeftSelect = class extends WordLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeftSelect",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
var CursorWordStartRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordStartRight",
      precondition: void 0
    });
  }
};
var CursorWordEndRight = class extends WordRightCommand {
  constructor() {
    var _a5;
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordEndRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a5 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a5 === void 0 ? void 0 : _a5.negate()),
        primary: 2048 | 17,
        mac: { primary: 512 | 17 },
        weight: 100
      }
    });
  }
};
var CursorWordRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordRight",
      precondition: void 0
    });
  }
};
var CursorWordStartRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordStartRightSelect",
      precondition: void 0
    });
  }
};
var CursorWordEndRightSelect = class extends WordRightCommand {
  constructor() {
    var _a5;
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordEndRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ContextKeyExpr.and(EditorContextKeys.textInputFocus, (_a5 = ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)) === null || _a5 === void 0 ? void 0 : _a5.negate()),
        primary: 2048 | 1024 | 17,
        mac: { primary: 512 | 1024 | 17 },
        weight: 100
      }
    });
  }
};
var CursorWordRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordRightSelect",
      precondition: void 0
    });
  }
};
var CursorWordAccessibilityRight = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRight",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
var CursorWordAccessibilityRightSelect = class extends WordRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRightSelect",
      precondition: void 0
    });
  }
  _move(_, model, position, wordNavigationType) {
    return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue), model, position, wordNavigationType);
  }
};
var DeleteWordCommand = class extends EditorCommand {
  constructor(opts) {
    super(opts);
    this._whitespaceHeuristics = opts.whitespaceHeuristics;
    this._wordNavigationType = opts.wordNavigationType;
  }
  runEditorCommand(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(116));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const autoClosingBrackets = editor2.getOption(5);
    const autoClosingQuotes = editor2.getOption(8);
    const autoClosingPairs = LanguageConfigurationRegistry.getAutoClosingPairs(model.getLanguageId());
    const viewModel = editor2._getViewModel();
    const commands = selections.map((sel) => {
      const deleteRange = this._delete({
        wordSeparators,
        model,
        selection: sel,
        whitespaceHeuristics: this._whitespaceHeuristics,
        autoClosingDelete: editor2.getOption(6),
        autoClosingBrackets,
        autoClosingQuotes,
        autoClosingPairs,
        autoClosedCharacters: viewModel.getCursorAutoClosedCharacters()
      }, this._wordNavigationType);
      return new ReplaceCommand(deleteRange, "");
    });
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
var DeleteWordLeftCommand = class extends DeleteWordCommand {
  _delete(ctx, wordNavigationType) {
    let r = WordOperations.deleteWordLeft(ctx, wordNavigationType);
    if (r) {
      return r;
    }
    return new Range(1, 1, 1, 1);
  }
};
var DeleteWordRightCommand = class extends DeleteWordCommand {
  _delete(ctx, wordNavigationType) {
    let r = WordOperations.deleteWordRight(ctx, wordNavigationType);
    if (r) {
      return r;
    }
    const lineCount = ctx.model.getLineCount();
    const maxColumn = ctx.model.getLineMaxColumn(lineCount);
    return new Range(lineCount, maxColumn, lineCount, maxColumn);
  }
};
var DeleteWordStartLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 0,
      id: "deleteWordStartLeft",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordEndLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 2,
      id: "deleteWordEndLeft",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordLeft = class extends DeleteWordLeftCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 0,
      id: "deleteWordLeft",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 1,
        mac: { primary: 512 | 1 },
        weight: 100
      }
    });
  }
};
var DeleteWordStartRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 0,
      id: "deleteWordStartRight",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordEndRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: false,
      wordNavigationType: 2,
      id: "deleteWordEndRight",
      precondition: EditorContextKeys.writable
    });
  }
};
var DeleteWordRight = class extends DeleteWordRightCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 2,
      id: "deleteWordRight",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 2048 | 20,
        mac: { primary: 512 | 20 },
        weight: 100
      }
    });
  }
};
var DeleteInsideWord = class extends EditorAction {
  constructor() {
    super({
      id: "deleteInsideWord",
      precondition: EditorContextKeys.writable,
      label: localize("deleteInsideWord", "Delete Word"),
      alias: "Delete Word"
    });
  }
  run(accessor, editor2, args) {
    if (!editor2.hasModel()) {
      return;
    }
    const wordSeparators = getMapForWordSeparators(editor2.getOption(116));
    const model = editor2.getModel();
    const selections = editor2.getSelections();
    const commands = selections.map((sel) => {
      const deleteRange = WordOperations.deleteInsideWord(wordSeparators, model, sel);
      return new ReplaceCommand(deleteRange, "");
    });
    editor2.pushUndoStop();
    editor2.executeCommands(this.id, commands);
    editor2.pushUndoStop();
  }
};
registerEditorCommand(new CursorWordStartLeft());
registerEditorCommand(new CursorWordEndLeft());
registerEditorCommand(new CursorWordLeft());
registerEditorCommand(new CursorWordStartLeftSelect());
registerEditorCommand(new CursorWordEndLeftSelect());
registerEditorCommand(new CursorWordLeftSelect());
registerEditorCommand(new CursorWordStartRight());
registerEditorCommand(new CursorWordEndRight());
registerEditorCommand(new CursorWordRight());
registerEditorCommand(new CursorWordStartRightSelect());
registerEditorCommand(new CursorWordEndRightSelect());
registerEditorCommand(new CursorWordRightSelect());
registerEditorCommand(new CursorWordAccessibilityLeft());
registerEditorCommand(new CursorWordAccessibilityLeftSelect());
registerEditorCommand(new CursorWordAccessibilityRight());
registerEditorCommand(new CursorWordAccessibilityRightSelect());
registerEditorCommand(new DeleteWordStartLeft());
registerEditorCommand(new DeleteWordEndLeft());
registerEditorCommand(new DeleteWordLeft());
registerEditorCommand(new DeleteWordStartRight());
registerEditorCommand(new DeleteWordEndRight());
registerEditorCommand(new DeleteWordRight());
registerEditorAction(DeleteInsideWord);

// node_modules/monaco-editor/esm/vs/editor/contrib/wordPartOperations/wordPartOperations.js
var DeleteWordPartLeft = class extends DeleteWordCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 0,
      id: "deleteWordPartLeft",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 512 | 1 },
        weight: 100
      }
    });
  }
  _delete(ctx, wordNavigationType) {
    let r = WordPartOperations.deleteWordPartLeft(ctx);
    if (r) {
      return r;
    }
    return new Range(1, 1, 1, 1);
  }
};
var DeleteWordPartRight = class extends DeleteWordCommand {
  constructor() {
    super({
      whitespaceHeuristics: true,
      wordNavigationType: 2,
      id: "deleteWordPartRight",
      precondition: EditorContextKeys.writable,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 512 | 20 },
        weight: 100
      }
    });
  }
  _delete(ctx, wordNavigationType) {
    let r = WordPartOperations.deleteWordPartRight(ctx);
    if (r) {
      return r;
    }
    const lineCount = ctx.model.getLineCount();
    const maxColumn = ctx.model.getLineMaxColumn(lineCount);
    return new Range(lineCount, maxColumn, lineCount, maxColumn);
  }
};
var WordPartLeftCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordPartOperations.moveWordPartLeft(wordSeparators, model, position);
  }
};
var CursorWordPartLeft = class extends WordPartLeftCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 0,
      id: "cursorWordPartLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 512 | 15 },
        weight: 100
      }
    });
  }
};
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeft", "cursorWordPartLeft");
var CursorWordPartLeftSelect = class extends WordPartLeftCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 0,
      id: "cursorWordPartLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 512 | 1024 | 15 },
        weight: 100
      }
    });
  }
};
CommandsRegistry.registerCommandAlias("cursorWordPartStartLeftSelect", "cursorWordPartLeftSelect");
var WordPartRightCommand = class extends MoveWordCommand {
  _move(wordSeparators, model, position, wordNavigationType) {
    return WordPartOperations.moveWordPartRight(wordSeparators, model, position);
  }
};
var CursorWordPartRight = class extends WordPartRightCommand {
  constructor() {
    super({
      inSelectionMode: false,
      wordNavigationType: 2,
      id: "cursorWordPartRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 512 | 17 },
        weight: 100
      }
    });
  }
};
var CursorWordPartRightSelect = class extends WordPartRightCommand {
  constructor() {
    super({
      inSelectionMode: true,
      wordNavigationType: 2,
      id: "cursorWordPartRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.textInputFocus,
        primary: 0,
        mac: { primary: 256 | 512 | 1024 | 17 },
        weight: 100
      }
    });
  }
};
registerEditorCommand(new DeleteWordPartLeft());
registerEditorCommand(new DeleteWordPartRight());
registerEditorCommand(new CursorWordPartLeft());
registerEditorCommand(new CursorWordPartLeftSelect());
registerEditorCommand(new CursorWordPartRight());
registerEditorCommand(new CursorWordPartRightSelect());

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp.css";
var __decorate60 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param60 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE = new RawContextKey("accessibilityHelpWidgetVisible", false);
var AccessibilityHelpController = class AccessibilityHelpController2 extends Disposable {
  constructor(editor2, instantiationService) {
    super();
    this._editor = editor2;
    this._widget = this._register(instantiationService.createInstance(AccessibilityHelpWidget, this._editor));
  }
  static get(editor2) {
    return editor2.getContribution(AccessibilityHelpController2.ID);
  }
  show() {
    this._widget.show();
  }
  hide() {
    this._widget.hide();
  }
};
AccessibilityHelpController.ID = "editor.contrib.accessibilityHelpController";
AccessibilityHelpController = __decorate60([
  __param60(1, IInstantiationService)
], AccessibilityHelpController);
function getSelectionLabel(selections, charactersSelected) {
  if (!selections || selections.length === 0) {
    return AccessibilityHelpNLS.noSelection;
  }
  if (selections.length === 1) {
    if (charactersSelected) {
      return format(AccessibilityHelpNLS.singleSelectionRange, selections[0].positionLineNumber, selections[0].positionColumn, charactersSelected);
    }
    return format(AccessibilityHelpNLS.singleSelection, selections[0].positionLineNumber, selections[0].positionColumn);
  }
  if (charactersSelected) {
    return format(AccessibilityHelpNLS.multiSelectionRange, selections.length, charactersSelected);
  }
  if (selections.length > 0) {
    return format(AccessibilityHelpNLS.multiSelection, selections.length);
  }
  return "";
}
var AccessibilityHelpWidget = class AccessibilityHelpWidget2 extends Widget {
  constructor(editor2, _contextKeyService, _keybindingService, _openerService) {
    super();
    this._contextKeyService = _contextKeyService;
    this._keybindingService = _keybindingService;
    this._openerService = _openerService;
    this._editor = editor2;
    this._isVisibleKey = CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE.bindTo(this._contextKeyService);
    this._domNode = createFastDomNode(document.createElement("div"));
    this._domNode.setClassName("accessibilityHelpWidget");
    this._domNode.setDisplay("none");
    this._domNode.setAttribute("role", "dialog");
    this._domNode.setAttribute("aria-hidden", "true");
    this._contentDomNode = createFastDomNode(document.createElement("div"));
    this._contentDomNode.setAttribute("role", "document");
    this._domNode.appendChild(this._contentDomNode);
    this._isVisible = false;
    this._register(this._editor.onDidLayoutChange(() => {
      if (this._isVisible) {
        this._layout();
      }
    }));
    this._register(addStandardDisposableListener(this._contentDomNode.domNode, "keydown", (e) => {
      if (!this._isVisible) {
        return;
      }
      if (e.equals(2048 | 35)) {
        alert(AccessibilityHelpNLS.emergencyConfOn);
        this._editor.updateOptions({
          accessibilitySupport: "on"
        });
        clearNode(this._contentDomNode.domNode);
        this._buildContent();
        this._contentDomNode.domNode.focus();
        e.preventDefault();
        e.stopPropagation();
      }
      if (e.equals(2048 | 38)) {
        alert(AccessibilityHelpNLS.openingDocs);
        let url = this._editor.getRawOptions().accessibilityHelpUrl;
        if (typeof url === "undefined") {
          url = "https://go.microsoft.com/fwlink/?linkid=852450";
        }
        this._openerService.open(URI.parse(url));
        e.preventDefault();
        e.stopPropagation();
      }
    }));
    this.onblur(this._contentDomNode.domNode, () => {
      this.hide();
    });
    this._editor.addOverlayWidget(this);
  }
  dispose() {
    this._editor.removeOverlayWidget(this);
    super.dispose();
  }
  getId() {
    return AccessibilityHelpWidget2.ID;
  }
  getDomNode() {
    return this._domNode.domNode;
  }
  getPosition() {
    return {
      preference: null
    };
  }
  show() {
    if (this._isVisible) {
      return;
    }
    this._isVisible = true;
    this._isVisibleKey.set(true);
    this._layout();
    this._domNode.setDisplay("block");
    this._domNode.setAttribute("aria-hidden", "false");
    this._contentDomNode.domNode.tabIndex = 0;
    this._buildContent();
    this._contentDomNode.domNode.focus();
  }
  _descriptionForCommand(commandId, msg, noKbMsg) {
    let kb = this._keybindingService.lookupKeybinding(commandId);
    if (kb) {
      return format(msg, kb.getAriaLabel());
    }
    return format(noKbMsg, commandId);
  }
  _buildContent() {
    const options = this._editor.getOptions();
    const selections = this._editor.getSelections();
    let charactersSelected = 0;
    if (selections) {
      const model = this._editor.getModel();
      if (model) {
        selections.forEach((selection) => {
          charactersSelected += model.getValueLengthInRange(selection);
        });
      }
    }
    let text2 = getSelectionLabel(selections, charactersSelected);
    if (options.get(53)) {
      if (options.get(80)) {
        text2 += AccessibilityHelpNLS.readonlyDiffEditor;
      } else {
        text2 += AccessibilityHelpNLS.editableDiffEditor;
      }
    } else {
      if (options.get(80)) {
        text2 += AccessibilityHelpNLS.readonlyEditor;
      } else {
        text2 += AccessibilityHelpNLS.editableEditor;
      }
    }
    const turnOnMessage = isMacintosh ? AccessibilityHelpNLS.changeConfigToOnMac : AccessibilityHelpNLS.changeConfigToOnWinLinux;
    switch (options.get(2)) {
      case 0:
        text2 += "\n\n - " + turnOnMessage;
        break;
      case 2:
        text2 += "\n\n - " + AccessibilityHelpNLS.auto_on;
        break;
      case 1:
        text2 += "\n\n - " + AccessibilityHelpNLS.auto_off;
        text2 += " " + turnOnMessage;
        break;
    }
    if (options.get(129)) {
      text2 += "\n\n - " + this._descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOnMsg, AccessibilityHelpNLS.tabFocusModeOnMsgNoKb);
    } else {
      text2 += "\n\n - " + this._descriptionForCommand(ToggleTabFocusModeAction.ID, AccessibilityHelpNLS.tabFocusModeOffMsg, AccessibilityHelpNLS.tabFocusModeOffMsgNoKb);
    }
    const openDocMessage = isMacintosh ? AccessibilityHelpNLS.openDocMac : AccessibilityHelpNLS.openDocWinLinux;
    text2 += "\n\n - " + openDocMessage;
    text2 += "\n\n" + AccessibilityHelpNLS.outroMsg;
    this._contentDomNode.domNode.appendChild(renderFormattedText(text2));
    this._contentDomNode.domNode.setAttribute("aria-label", text2);
  }
  hide() {
    if (!this._isVisible) {
      return;
    }
    this._isVisible = false;
    this._isVisibleKey.reset();
    this._domNode.setDisplay("none");
    this._domNode.setAttribute("aria-hidden", "true");
    this._contentDomNode.domNode.tabIndex = -1;
    clearNode(this._contentDomNode.domNode);
    this._editor.focus();
  }
  _layout() {
    let editorLayout = this._editor.getLayoutInfo();
    let w = Math.max(5, Math.min(AccessibilityHelpWidget2.WIDTH, editorLayout.width - 40));
    let h = Math.max(5, Math.min(AccessibilityHelpWidget2.HEIGHT, editorLayout.height - 40));
    this._domNode.setWidth(w);
    this._domNode.setHeight(h);
    let top = Math.round((editorLayout.height - h) / 2);
    this._domNode.setTop(top);
    let left = Math.round((editorLayout.width - w) / 2);
    this._domNode.setLeft(left);
  }
};
AccessibilityHelpWidget.ID = "editor.contrib.accessibilityHelpWidget";
AccessibilityHelpWidget.WIDTH = 500;
AccessibilityHelpWidget.HEIGHT = 300;
AccessibilityHelpWidget = __decorate60([
  __param60(1, IContextKeyService),
  __param60(2, IKeybindingService),
  __param60(3, IOpenerService)
], AccessibilityHelpWidget);
var ShowAccessibilityHelpAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.showAccessibilityHelp",
      label: AccessibilityHelpNLS.showAccessibilityHelpAction,
      alias: "Show Accessibility Help",
      precondition: void 0,
      kbOpts: {
        primary: 512 | 59,
        weight: 100,
        linux: {
          primary: 512 | 1024 | 59,
          secondary: [512 | 59]
        }
      }
    });
  }
  run(accessor, editor2) {
    let controller = AccessibilityHelpController.get(editor2);
    if (controller) {
      controller.show();
    }
  }
};
registerEditorContribution(AccessibilityHelpController.ID, AccessibilityHelpController);
registerEditorAction(ShowAccessibilityHelpAction);
var AccessibilityHelpCommand = EditorCommand.bindToContribution(AccessibilityHelpController.get);
registerEditorCommand(new AccessibilityHelpCommand({
  id: "closeAccessibilityHelp",
  precondition: CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE,
  handler: (x) => x.hide(),
  kbOpts: {
    weight: 100 + 100,
    kbExpr: EditorContextKeys.focus,
    primary: 9,
    secondary: [1024 | 9]
  }
}));
registerThemingParticipant((theme, collector) => {
  const widgetBackground = theme.getColor(editorWidgetBackground);
  if (widgetBackground) {
    collector.addRule(`.monaco-editor .accessibilityHelpWidget { background-color: ${widgetBackground}; }`);
  }
  const widgetForeground = theme.getColor(editorWidgetForeground);
  if (widgetForeground) {
    collector.addRule(`.monaco-editor .accessibilityHelpWidget { color: ${widgetForeground}; }`);
  }
  const widgetShadowColor = theme.getColor(widgetShadow);
  if (widgetShadowColor) {
    collector.addRule(`.monaco-editor .accessibilityHelpWidget { box-shadow: 0 2px 8px ${widgetShadowColor}; }`);
  }
  const hcBorder = theme.getColor(contrastBorder);
  if (hcBorder) {
    collector.addRule(`.monaco-editor .accessibilityHelpWidget { border: 2px solid ${hcBorder}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard.css";
var IPadShowKeyboard = class extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this.widget = null;
    if (isIOS) {
      this._register(editor2.onDidChangeConfiguration(() => this.update()));
      this.update();
    }
  }
  update() {
    const shouldHaveWidget = !this.editor.getOption(80);
    if (!this.widget && shouldHaveWidget) {
      this.widget = new ShowKeyboardWidget(this.editor);
    } else if (this.widget && !shouldHaveWidget) {
      this.widget.dispose();
      this.widget = null;
    }
  }
  dispose() {
    super.dispose();
    if (this.widget) {
      this.widget.dispose();
      this.widget = null;
    }
  }
};
IPadShowKeyboard.ID = "editor.contrib.iPadShowKeyboard";
var ShowKeyboardWidget = class extends Disposable {
  constructor(editor2) {
    super();
    this.editor = editor2;
    this._domNode = document.createElement("textarea");
    this._domNode.className = "iPadShowKeyboard";
    this._register(addDisposableListener(this._domNode, "touchstart", (e) => {
      this.editor.focus();
    }));
    this._register(addDisposableListener(this._domNode, "focus", (e) => {
      this.editor.focus();
    }));
    this.editor.addOverlayWidget(this);
  }
  dispose() {
    this.editor.removeOverlayWidget(this);
    super.dispose();
  }
  getId() {
    return ShowKeyboardWidget.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 1
    };
  }
};
ShowKeyboardWidget.ID = "editor.contrib.ShowKeyboardWidget";
registerEditorContribution(IPadShowKeyboard.ID, IPadShowKeyboard);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/inspectTokens/inspectTokens.js
import "/workspace/Digital-Support-Notes/Presentations/ITQualifications/node_modules/monaco-editor/esm/vs/editor/standalone/browser/inspectTokens/inspectTokens.css";
var __decorate61 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param61 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var InspectTokensController = class InspectTokensController2 extends Disposable {
  constructor(editor2, standaloneColorService, modeService) {
    super();
    this._editor = editor2;
    this._modeService = modeService;
    this._widget = null;
    this._register(this._editor.onDidChangeModel((e) => this.stop()));
    this._register(this._editor.onDidChangeModelLanguage((e) => this.stop()));
    this._register(TokenizationRegistry.onDidChange((e) => this.stop()));
    this._register(this._editor.onKeyUp((e) => e.keyCode === 9 && this.stop()));
  }
  static get(editor2) {
    return editor2.getContribution(InspectTokensController2.ID);
  }
  dispose() {
    this.stop();
    super.dispose();
  }
  launch() {
    if (this._widget) {
      return;
    }
    if (!this._editor.hasModel()) {
      return;
    }
    this._widget = new InspectTokensWidget(this._editor, this._modeService);
  }
  stop() {
    if (this._widget) {
      this._widget.dispose();
      this._widget = null;
    }
  }
};
InspectTokensController.ID = "editor.contrib.inspectTokens";
InspectTokensController = __decorate61([
  __param61(1, IStandaloneThemeService),
  __param61(2, IModeService)
], InspectTokensController);
var InspectTokens = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.inspectTokens",
      label: InspectTokensNLS.inspectTokensAction,
      alias: "Developer: Inspect Tokens",
      precondition: void 0
    });
  }
  run(accessor, editor2) {
    let controller = InspectTokensController.get(editor2);
    if (controller) {
      controller.launch();
    }
  }
};
function renderTokenText(tokenText) {
  let result = "";
  for (let charIndex = 0, len = tokenText.length; charIndex < len; charIndex++) {
    let charCode = tokenText.charCodeAt(charIndex);
    switch (charCode) {
      case 9:
        result += "\u2192";
        break;
      case 32:
        result += "\xB7";
        break;
      default:
        result += String.fromCharCode(charCode);
    }
  }
  return result;
}
function getSafeTokenizationSupport(languageIdCodec, languageId) {
  const tokenizationSupport = TokenizationRegistry.get(languageId);
  if (tokenizationSupport) {
    return tokenizationSupport;
  }
  const encodedLanguageId = languageIdCodec.encodeLanguageId(languageId);
  return {
    getInitialState: () => NULL_STATE,
    tokenize: (line, hasEOL, state, deltaOffset) => nullTokenize(languageId, line, state, deltaOffset),
    tokenize2: (line, hasEOL, state, deltaOffset) => nullTokenize2(encodedLanguageId, line, state, deltaOffset)
  };
}
var InspectTokensWidget = class extends Disposable {
  constructor(editor2, modeService) {
    super();
    this.allowEditorOverflow = true;
    this._editor = editor2;
    this._modeService = modeService;
    this._model = this._editor.getModel();
    this._domNode = document.createElement("div");
    this._domNode.className = "tokens-inspect-widget";
    this._tokenizationSupport = getSafeTokenizationSupport(this._modeService.languageIdCodec, this._model.getLanguageId());
    this._compute(this._editor.getPosition());
    this._register(this._editor.onDidChangeCursorPosition((e) => this._compute(this._editor.getPosition())));
    this._editor.addContentWidget(this);
  }
  dispose() {
    this._editor.removeContentWidget(this);
    super.dispose();
  }
  getId() {
    return InspectTokensWidget._ID;
  }
  _compute(position) {
    let data = this._getTokensAtLine(position.lineNumber);
    let token1Index = 0;
    for (let i = data.tokens1.length - 1; i >= 0; i--) {
      let t = data.tokens1[i];
      if (position.column - 1 >= t.offset) {
        token1Index = i;
        break;
      }
    }
    let token2Index = 0;
    for (let i = data.tokens2.length >>> 1; i >= 0; i--) {
      if (position.column - 1 >= data.tokens2[i << 1]) {
        token2Index = i;
        break;
      }
    }
    let lineContent = this._model.getLineContent(position.lineNumber);
    let tokenText = "";
    if (token1Index < data.tokens1.length) {
      let tokenStartIndex = data.tokens1[token1Index].offset;
      let tokenEndIndex = token1Index + 1 < data.tokens1.length ? data.tokens1[token1Index + 1].offset : lineContent.length;
      tokenText = lineContent.substring(tokenStartIndex, tokenEndIndex);
    }
    reset(this._domNode, $("h2.tm-token", void 0, renderTokenText(tokenText), $("span.tm-token-length", void 0, `${tokenText.length} ${tokenText.length === 1 ? "char" : "chars"}`)));
    append(this._domNode, $("hr.tokens-inspect-separator", { "style": "clear:both" }));
    const metadata = (token2Index << 1) + 1 < data.tokens2.length ? this._decodeMetadata(data.tokens2[(token2Index << 1) + 1]) : null;
    append(this._domNode, $("table.tm-metadata-table", void 0, $("tbody", void 0, $("tr", void 0, $("td.tm-metadata-key", void 0, "language"), $("td.tm-metadata-value", void 0, `${metadata ? metadata.languageId : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "token type"), $("td.tm-metadata-value", void 0, `${metadata ? this._tokenTypeToString(metadata.tokenType) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "font style"), $("td.tm-metadata-value", void 0, `${metadata ? this._fontStyleToString(metadata.fontStyle) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "foreground"), $("td.tm-metadata-value", void 0, `${metadata ? Color.Format.CSS.formatHex(metadata.foreground) : "-?-"}`)), $("tr", void 0, $("td.tm-metadata-key", void 0, "background"), $("td.tm-metadata-value", void 0, `${metadata ? Color.Format.CSS.formatHex(metadata.background) : "-?-"}`)))));
    append(this._domNode, $("hr.tokens-inspect-separator"));
    if (token1Index < data.tokens1.length) {
      append(this._domNode, $("span.tm-token-type", void 0, data.tokens1[token1Index].type));
    }
    this._editor.layoutContentWidget(this);
  }
  _decodeMetadata(metadata) {
    let colorMap = TokenizationRegistry.getColorMap();
    let languageId = TokenMetadata.getLanguageId(metadata);
    let tokenType = TokenMetadata.getTokenType(metadata);
    let fontStyle = TokenMetadata.getFontStyle(metadata);
    let foreground2 = TokenMetadata.getForeground(metadata);
    let background = TokenMetadata.getBackground(metadata);
    return {
      languageId: this._modeService.languageIdCodec.decodeLanguageId(languageId),
      tokenType,
      fontStyle,
      foreground: colorMap[foreground2],
      background: colorMap[background]
    };
  }
  _tokenTypeToString(tokenType) {
    switch (tokenType) {
      case 0:
        return "Other";
      case 1:
        return "Comment";
      case 2:
        return "String";
      case 4:
        return "RegEx";
      default:
        return "??";
    }
  }
  _fontStyleToString(fontStyle) {
    let r = "";
    if (fontStyle & 1) {
      r += "italic ";
    }
    if (fontStyle & 2) {
      r += "bold ";
    }
    if (fontStyle & 4) {
      r += "underline ";
    }
    if (r.length === 0) {
      r = "---";
    }
    return r;
  }
  _getTokensAtLine(lineNumber) {
    let stateBeforeLine = this._getStateBeforeLine(lineNumber);
    let tokenizationResult1 = this._tokenizationSupport.tokenize(this._model.getLineContent(lineNumber), true, stateBeforeLine, 0);
    let tokenizationResult2 = this._tokenizationSupport.tokenize2(this._model.getLineContent(lineNumber), true, stateBeforeLine, 0);
    return {
      startState: stateBeforeLine,
      tokens1: tokenizationResult1.tokens,
      tokens2: tokenizationResult2.tokens,
      endState: tokenizationResult1.endState
    };
  }
  _getStateBeforeLine(lineNumber) {
    let state = this._tokenizationSupport.getInitialState();
    for (let i = 1; i < lineNumber; i++) {
      let tokenizationResult = this._tokenizationSupport.tokenize(this._model.getLineContent(i), true, state, 0);
      state = tokenizationResult.endState;
    }
    return state;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      position: this._editor.getPosition(),
      preference: [2, 1]
    };
  }
};
InspectTokensWidget._ID = "editor.contrib.inspectTokensWidget";
registerEditorContribution(InspectTokensController.ID, InspectTokensController);
registerEditorAction(InspectTokens);
registerThemingParticipant((theme, collector) => {
  const border = theme.getColor(editorHoverBorder);
  if (border) {
    let borderWidth = theme.type === ColorScheme.HIGH_CONTRAST ? 2 : 1;
    collector.addRule(`.monaco-editor .tokens-inspect-widget { border: ${borderWidth}px solid ${border}; }`);
    collector.addRule(`.monaco-editor .tokens-inspect-widget .tokens-inspect-separator { background-color: ${border}; }`);
  }
  const background = theme.getColor(editorHoverBackground);
  if (background) {
    collector.addRule(`.monaco-editor .tokens-inspect-widget { background-color: ${background}; }`);
  }
  const foreground2 = theme.getColor(editorHoverForeground);
  if (foreground2) {
    collector.addRule(`.monaco-editor .tokens-inspect-widget { color: ${foreground2}; }`);
  }
});

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/helpQuickAccess.js
var __decorate62 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param62 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var HelpQuickAccessProvider = class HelpQuickAccessProvider2 {
  constructor(quickInputService) {
    this.quickInputService = quickInputService;
    this.registry = Registry.as(Extensions2.Quickaccess);
  }
  provide(picker) {
    const disposables = new DisposableStore();
    disposables.add(picker.onDidAccept(() => {
      const [item] = picker.selectedItems;
      if (item) {
        this.quickInputService.quickAccess.show(item.prefix, { preserveValue: true });
      }
    }));
    disposables.add(picker.onDidChangeValue((value) => {
      const providerDescriptor = this.registry.getQuickAccessProvider(value.substr(HelpQuickAccessProvider2.PREFIX.length));
      if (providerDescriptor && providerDescriptor.prefix && providerDescriptor.prefix !== HelpQuickAccessProvider2.PREFIX) {
        this.quickInputService.quickAccess.show(providerDescriptor.prefix, { preserveValue: true });
      }
    }));
    const { editorProviders, globalProviders } = this.getQuickAccessProviders();
    picker.items = editorProviders.length === 0 || globalProviders.length === 0 ? [
      ...editorProviders.length === 0 ? globalProviders : editorProviders
    ] : [
      { label: localize("globalCommands", "global commands"), type: "separator" },
      ...globalProviders,
      { label: localize("editorCommands", "editor commands"), type: "separator" },
      ...editorProviders
    ];
    return disposables;
  }
  getQuickAccessProviders() {
    const globalProviders = [];
    const editorProviders = [];
    for (const provider of this.registry.getQuickAccessProviders().sort((providerA, providerB) => providerA.prefix.localeCompare(providerB.prefix))) {
      if (provider.prefix === HelpQuickAccessProvider2.PREFIX) {
        continue;
      }
      for (const helpEntry of provider.helpEntries) {
        const prefix = helpEntry.prefix || provider.prefix;
        const label = prefix || "\u2026";
        (helpEntry.needsEditor ? editorProviders : globalProviders).push({
          prefix,
          label,
          ariaLabel: localize("helpPickAriaLabel", "{0}, {1}", label, helpEntry.description),
          description: helpEntry.description
        });
      }
    }
    return { editorProviders, globalProviders };
  }
};
HelpQuickAccessProvider.PREFIX = "?";
HelpQuickAccessProvider = __decorate62([
  __param62(0, IQuickInputService)
], HelpQuickAccessProvider);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneHelpQuickAccess.js
Registry.as(Extensions2.Quickaccess).registerQuickAccessProvider({
  ctor: HelpQuickAccessProvider,
  prefix: "",
  helpEntries: [{ description: QuickHelpNLS.helpQuickAccessActionLabel, needsEditor: true }]
});

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/editorNavigationQuickAccess.js
var AbstractEditorNavigationQuickAccessProvider = class {
  constructor(options) {
    this.options = options;
    this.rangeHighlightDecorationId = void 0;
  }
  provide(picker, token) {
    var _a5;
    const disposables = new DisposableStore();
    picker.canAcceptInBackground = !!((_a5 = this.options) === null || _a5 === void 0 ? void 0 : _a5.canAcceptInBackground);
    picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
    const pickerDisposable = disposables.add(new MutableDisposable());
    pickerDisposable.value = this.doProvide(picker, token);
    disposables.add(this.onDidActiveTextEditorControlChange(() => {
      pickerDisposable.value = void 0;
      pickerDisposable.value = this.doProvide(picker, token);
    }));
    return disposables;
  }
  doProvide(picker, token) {
    const disposables = new DisposableStore();
    const editor2 = this.activeTextEditorControl;
    if (editor2 && this.canProvideWithTextEditor(editor2)) {
      const context = { editor: editor2 };
      const codeEditor = getCodeEditor(editor2);
      if (codeEditor) {
        let lastKnownEditorViewState = withNullAsUndefined(editor2.saveViewState());
        disposables.add(codeEditor.onDidChangeCursorPosition(() => {
          lastKnownEditorViewState = withNullAsUndefined(editor2.saveViewState());
        }));
        context.restoreViewState = () => {
          if (lastKnownEditorViewState && editor2 === this.activeTextEditorControl) {
            editor2.restoreViewState(lastKnownEditorViewState);
          }
        };
        disposables.add(once(token.onCancellationRequested)(() => {
          var _a5;
          return (_a5 = context.restoreViewState) === null || _a5 === void 0 ? void 0 : _a5.call(context);
        }));
      }
      disposables.add(toDisposable(() => this.clearDecorations(editor2)));
      disposables.add(this.provideWithTextEditor(context, picker, token));
    } else {
      disposables.add(this.provideWithoutTextEditor(picker, token));
    }
    return disposables;
  }
  canProvideWithTextEditor(editor2) {
    return true;
  }
  gotoLocation({ editor: editor2 }, options) {
    editor2.setSelection(options.range);
    editor2.revealRangeInCenter(options.range, 0);
    if (!options.preserveFocus) {
      editor2.focus();
    }
  }
  getModel(editor2) {
    var _a5;
    return isDiffEditor(editor2) ? (_a5 = editor2.getModel()) === null || _a5 === void 0 ? void 0 : _a5.modified : editor2.getModel();
  }
  addDecorations(editor2, range) {
    editor2.changeDecorations((changeAccessor) => {
      const deleteDecorations = [];
      if (this.rangeHighlightDecorationId) {
        deleteDecorations.push(this.rangeHighlightDecorationId.overviewRulerDecorationId);
        deleteDecorations.push(this.rangeHighlightDecorationId.rangeHighlightId);
        this.rangeHighlightDecorationId = void 0;
      }
      const newDecorations = [
        {
          range,
          options: {
            description: "quick-access-range-highlight",
            className: "rangeHighlight",
            isWholeLine: true
          }
        },
        {
          range,
          options: {
            description: "quick-access-range-highlight-overview",
            overviewRuler: {
              color: themeColorFromId(overviewRulerRangeHighlight),
              position: OverviewRulerLane.Full
            }
          }
        }
      ];
      const [rangeHighlightId, overviewRulerDecorationId] = changeAccessor.deltaDecorations(deleteDecorations, newDecorations);
      this.rangeHighlightDecorationId = { rangeHighlightId, overviewRulerDecorationId };
    });
  }
  clearDecorations(editor2) {
    const rangeHighlightDecorationId = this.rangeHighlightDecorationId;
    if (rangeHighlightDecorationId) {
      editor2.changeDecorations((changeAccessor) => {
        changeAccessor.deltaDecorations([
          rangeHighlightDecorationId.overviewRulerDecorationId,
          rangeHighlightDecorationId.rangeHighlightId
        ], []);
      });
      this.rangeHighlightDecorationId = void 0;
    }
  }
};

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/gotoLineQuickAccess.js
var AbstractGotoLineQuickAccessProvider = class extends AbstractEditorNavigationQuickAccessProvider {
  constructor() {
    super({ canAcceptInBackground: true });
  }
  provideWithoutTextEditor(picker) {
    const label = localize("cannotRunGotoLine", "Open a text editor first to go to a line.");
    picker.items = [{ label }];
    picker.ariaLabel = label;
    return Disposable.None;
  }
  provideWithTextEditor(context, picker, token) {
    const editor2 = context.editor;
    const disposables = new DisposableStore();
    disposables.add(picker.onDidAccept((event) => {
      const [item] = picker.selectedItems;
      if (item) {
        if (!this.isValidLineNumber(editor2, item.lineNumber)) {
          return;
        }
        this.gotoLocation(context, { range: this.toRange(item.lineNumber, item.column), keyMods: picker.keyMods, preserveFocus: event.inBackground });
        if (!event.inBackground) {
          picker.hide();
        }
      }
    }));
    const updatePickerAndEditor = () => {
      const position = this.parsePosition(editor2, picker.value.trim().substr(AbstractGotoLineQuickAccessProvider.PREFIX.length));
      const label = this.getPickLabel(editor2, position.lineNumber, position.column);
      picker.items = [{
        lineNumber: position.lineNumber,
        column: position.column,
        label
      }];
      picker.ariaLabel = label;
      if (!this.isValidLineNumber(editor2, position.lineNumber)) {
        this.clearDecorations(editor2);
        return;
      }
      const range = this.toRange(position.lineNumber, position.column);
      editor2.revealRangeInCenter(range, 0);
      this.addDecorations(editor2, range);
    };
    updatePickerAndEditor();
    disposables.add(picker.onDidChangeValue(() => updatePickerAndEditor()));
    const codeEditor = getCodeEditor(editor2);
    if (codeEditor) {
      const options = codeEditor.getOptions();
      const lineNumbers = options.get(59);
      if (lineNumbers.renderType === 2) {
        codeEditor.updateOptions({ lineNumbers: "on" });
        disposables.add(toDisposable(() => codeEditor.updateOptions({ lineNumbers: "relative" })));
      }
    }
    return disposables;
  }
  toRange(lineNumber = 1, column = 1) {
    return {
      startLineNumber: lineNumber,
      startColumn: column,
      endLineNumber: lineNumber,
      endColumn: column
    };
  }
  parsePosition(editor2, value) {
    const numbers = value.split(/,|:|#/).map((part) => parseInt(part, 10)).filter((part) => !isNaN(part));
    const endLine = this.lineCount(editor2) + 1;
    return {
      lineNumber: numbers[0] > 0 ? numbers[0] : endLine + numbers[0],
      column: numbers[1]
    };
  }
  getPickLabel(editor2, lineNumber, column) {
    if (this.isValidLineNumber(editor2, lineNumber)) {
      if (this.isValidColumn(editor2, lineNumber, column)) {
        return localize("gotoLineColumnLabel", "Go to line {0} and character {1}.", lineNumber, column);
      }
      return localize("gotoLineLabel", "Go to line {0}.", lineNumber);
    }
    const position = editor2.getPosition() || { lineNumber: 1, column: 1 };
    const lineCount = this.lineCount(editor2);
    if (lineCount > 1) {
      return localize("gotoLineLabelEmptyWithLimit", "Current Line: {0}, Character: {1}. Type a line number between 1 and {2} to navigate to.", position.lineNumber, position.column, lineCount);
    }
    return localize("gotoLineLabelEmpty", "Current Line: {0}, Character: {1}. Type a line number to navigate to.", position.lineNumber, position.column);
  }
  isValidLineNumber(editor2, lineNumber) {
    if (!lineNumber || typeof lineNumber !== "number") {
      return false;
    }
    return lineNumber > 0 && lineNumber <= this.lineCount(editor2);
  }
  isValidColumn(editor2, lineNumber, column) {
    if (!column || typeof column !== "number") {
      return false;
    }
    const model = this.getModel(editor2);
    if (!model) {
      return false;
    }
    const positionCandidate = { lineNumber, column };
    return model.validatePosition(positionCandidate).equals(positionCandidate);
  }
  lineCount(editor2) {
    var _a5, _b2;
    return (_b2 = (_a5 = this.getModel(editor2)) === null || _a5 === void 0 ? void 0 : _a5.getLineCount()) !== null && _b2 !== void 0 ? _b2 : 0;
  }
};
AbstractGotoLineQuickAccessProvider.PREFIX = ":";

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneGotoLineQuickAccess.js
var __decorate63 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param63 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneGotoLineQuickAccessProvider = class StandaloneGotoLineQuickAccessProvider2 extends AbstractGotoLineQuickAccessProvider {
  constructor(editorService) {
    super();
    this.editorService = editorService;
    this.onDidActiveTextEditorControlChange = Event.None;
  }
  get activeTextEditorControl() {
    return withNullAsUndefined(this.editorService.getFocusedCodeEditor());
  }
};
StandaloneGotoLineQuickAccessProvider = __decorate63([
  __param63(0, ICodeEditorService)
], StandaloneGotoLineQuickAccessProvider);
Registry.as(Extensions2.Quickaccess).registerQuickAccessProvider({
  ctor: StandaloneGotoLineQuickAccessProvider,
  prefix: StandaloneGotoLineQuickAccessProvider.PREFIX,
  helpEntries: [{ description: GoToLineNLS.gotoLineActionLabel, needsEditor: true }]
});
var GotoLineAction = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.gotoLine",
      label: GoToLineNLS.gotoLineActionLabel,
      alias: "Go to Line/Column...",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 37,
        mac: { primary: 256 | 37 },
        weight: 100
      }
    });
  }
  run(accessor) {
    accessor.get(IQuickInputService).quickAccess.show(StandaloneGotoLineQuickAccessProvider.PREFIX);
  }
};
registerEditorAction(GotoLineAction);

// node_modules/monaco-editor/esm/vs/base/common/fuzzyScorer.js
var NO_SCORE2 = [void 0, []];
function scoreFuzzy2(target, query, patternStart = 0, wordStart = 0) {
  const preparedQuery = query;
  if (preparedQuery.values && preparedQuery.values.length > 1) {
    return doScoreFuzzy2Multiple(target, preparedQuery.values, patternStart, wordStart);
  }
  return doScoreFuzzy2Single(target, query, patternStart, wordStart);
}
function doScoreFuzzy2Multiple(target, query, patternStart, wordStart) {
  let totalScore = 0;
  const totalMatches = [];
  for (const queryPiece of query) {
    const [score, matches] = doScoreFuzzy2Single(target, queryPiece, patternStart, wordStart);
    if (typeof score !== "number") {
      return NO_SCORE2;
    }
    totalScore += score;
    totalMatches.push(...matches);
  }
  return [totalScore, normalizeMatches(totalMatches)];
}
function doScoreFuzzy2Single(target, query, patternStart, wordStart) {
  const score = fuzzyScore(query.original, query.originalLowercase, patternStart, target, target.toLowerCase(), wordStart, true);
  if (!score) {
    return NO_SCORE2;
  }
  return [score[0], createMatches(score)];
}
var NO_ITEM_SCORE = Object.freeze({ score: 0 });
function normalizeMatches(matches) {
  const sortedMatches = matches.sort((matchA, matchB) => {
    return matchA.start - matchB.start;
  });
  const normalizedMatches = [];
  let currentMatch = void 0;
  for (const match of sortedMatches) {
    if (!currentMatch || !matchOverlaps(currentMatch, match)) {
      currentMatch = match;
      normalizedMatches.push(match);
    } else {
      currentMatch.start = Math.min(currentMatch.start, match.start);
      currentMatch.end = Math.max(currentMatch.end, match.end);
    }
  }
  return normalizedMatches;
}
function matchOverlaps(matchA, matchB) {
  if (matchA.end < matchB.start) {
    return false;
  }
  if (matchB.end < matchA.start) {
    return false;
  }
  return true;
}
function queryExpectsExactMatch(query) {
  return query.startsWith('"') && query.endsWith('"');
}
var MULTIPLE_QUERY_VALUES_SEPARATOR = " ";
function prepareQuery(original) {
  if (typeof original !== "string") {
    original = "";
  }
  const originalLowercase = original.toLowerCase();
  const { pathNormalized, normalized, normalizedLowercase } = normalizeQuery(original);
  const containsPathSeparator = pathNormalized.indexOf(sep) >= 0;
  const expectExactMatch = queryExpectsExactMatch(original);
  let values = void 0;
  const originalSplit = original.split(MULTIPLE_QUERY_VALUES_SEPARATOR);
  if (originalSplit.length > 1) {
    for (const originalPiece of originalSplit) {
      const expectExactMatchPiece = queryExpectsExactMatch(originalPiece);
      const { pathNormalized: pathNormalizedPiece, normalized: normalizedPiece, normalizedLowercase: normalizedLowercasePiece } = normalizeQuery(originalPiece);
      if (normalizedPiece) {
        if (!values) {
          values = [];
        }
        values.push({
          original: originalPiece,
          originalLowercase: originalPiece.toLowerCase(),
          pathNormalized: pathNormalizedPiece,
          normalized: normalizedPiece,
          normalizedLowercase: normalizedLowercasePiece,
          expectContiguousMatch: expectExactMatchPiece
        });
      }
    }
  }
  return { original, originalLowercase, pathNormalized, normalized, normalizedLowercase, values, containsPathSeparator, expectContiguousMatch: expectExactMatch };
}
function normalizeQuery(original) {
  let pathNormalized;
  if (isWindows) {
    pathNormalized = original.replace(/\//g, sep);
  } else {
    pathNormalized = original.replace(/\\/g, sep);
  }
  const normalized = stripWildcards(pathNormalized).replace(/\s|"/g, "");
  return {
    pathNormalized,
    normalized,
    normalizedLowercase: normalized.toLowerCase()
  };
}
function pieceToQuery(arg1) {
  if (Array.isArray(arg1)) {
    return prepareQuery(arg1.map((piece) => piece.original).join(MULTIPLE_QUERY_VALUES_SEPARATOR));
  }
  return prepareQuery(arg1.original);
}

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/gotoSymbolQuickAccess.js
var __awaiter43 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AbstractGotoSymbolQuickAccessProvider = class extends AbstractEditorNavigationQuickAccessProvider {
  constructor(options = Object.create(null)) {
    super(options);
    this.options = options;
    this.options.canAcceptInBackground = true;
  }
  provideWithoutTextEditor(picker) {
    this.provideLabelPick(picker, localize("cannotRunGotoSymbolWithoutEditor", "To go to a symbol, first open a text editor with symbol information."));
    return Disposable.None;
  }
  provideWithTextEditor(context, picker, token) {
    const editor2 = context.editor;
    const model = this.getModel(editor2);
    if (!model) {
      return Disposable.None;
    }
    if (DocumentSymbolProviderRegistry.has(model)) {
      return this.doProvideWithEditorSymbols(context, model, picker, token);
    }
    return this.doProvideWithoutEditorSymbols(context, model, picker, token);
  }
  doProvideWithoutEditorSymbols(context, model, picker, token) {
    const disposables = new DisposableStore();
    this.provideLabelPick(picker, localize("cannotRunGotoSymbolWithoutSymbolProvider", "The active text editor does not provide symbol information."));
    (() => __awaiter43(this, void 0, void 0, function* () {
      const result = yield this.waitForLanguageSymbolRegistry(model, disposables);
      if (!result || token.isCancellationRequested) {
        return;
      }
      disposables.add(this.doProvideWithEditorSymbols(context, model, picker, token));
    }))();
    return disposables;
  }
  provideLabelPick(picker, label) {
    picker.items = [{ label, index: 0, kind: 14 }];
    picker.ariaLabel = label;
  }
  waitForLanguageSymbolRegistry(model, disposables) {
    return __awaiter43(this, void 0, void 0, function* () {
      if (DocumentSymbolProviderRegistry.has(model)) {
        return true;
      }
      const symbolProviderRegistryPromise = new DeferredPromise();
      const symbolProviderListener = disposables.add(DocumentSymbolProviderRegistry.onDidChange(() => {
        if (DocumentSymbolProviderRegistry.has(model)) {
          symbolProviderListener.dispose();
          symbolProviderRegistryPromise.complete(true);
        }
      }));
      disposables.add(toDisposable(() => symbolProviderRegistryPromise.complete(false)));
      return symbolProviderRegistryPromise.p;
    });
  }
  doProvideWithEditorSymbols(context, model, picker, token) {
    const editor2 = context.editor;
    const disposables = new DisposableStore();
    disposables.add(picker.onDidAccept((event) => {
      const [item] = picker.selectedItems;
      if (item && item.range) {
        this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, preserveFocus: event.inBackground });
        if (!event.inBackground) {
          picker.hide();
        }
      }
    }));
    disposables.add(picker.onDidTriggerItemButton(({ item }) => {
      if (item && item.range) {
        this.gotoLocation(context, { range: item.range.selection, keyMods: picker.keyMods, forceSideBySide: true });
        picker.hide();
      }
    }));
    const symbolsPromise = this.getDocumentSymbols(model, token);
    let picksCts = void 0;
    const updatePickerItems = () => __awaiter43(this, void 0, void 0, function* () {
      picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);
      picker.busy = false;
      picksCts = new CancellationTokenSource(token);
      picker.busy = true;
      try {
        const query = prepareQuery(picker.value.substr(AbstractGotoSymbolQuickAccessProvider.PREFIX.length).trim());
        const items = yield this.doGetSymbolPicks(symbolsPromise, query, void 0, picksCts.token);
        if (token.isCancellationRequested) {
          return;
        }
        if (items.length > 0) {
          picker.items = items;
        } else {
          if (query.original.length > 0) {
            this.provideLabelPick(picker, localize("noMatchingSymbolResults", "No matching editor symbols"));
          } else {
            this.provideLabelPick(picker, localize("noSymbolResults", "No editor symbols"));
          }
        }
      } finally {
        if (!token.isCancellationRequested) {
          picker.busy = false;
        }
      }
    });
    disposables.add(picker.onDidChangeValue(() => updatePickerItems()));
    updatePickerItems();
    let ignoreFirstActiveEvent = true;
    disposables.add(picker.onDidChangeActive(() => {
      const [item] = picker.activeItems;
      if (item && item.range) {
        if (ignoreFirstActiveEvent) {
          ignoreFirstActiveEvent = false;
          return;
        }
        editor2.revealRangeInCenter(item.range.selection, 0);
        this.addDecorations(editor2, item.range.decoration);
      }
    }));
    return disposables;
  }
  doGetSymbolPicks(symbolsPromise, query, options, token) {
    return __awaiter43(this, void 0, void 0, function* () {
      const symbols = yield symbolsPromise;
      if (token.isCancellationRequested) {
        return [];
      }
      const filterBySymbolKind = query.original.indexOf(AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX) === 0;
      const filterPos = filterBySymbolKind ? 1 : 0;
      let symbolQuery;
      let containerQuery;
      if (query.values && query.values.length > 1) {
        symbolQuery = pieceToQuery(query.values[0]);
        containerQuery = pieceToQuery(query.values.slice(1));
      } else {
        symbolQuery = query;
      }
      const filteredSymbolPicks = [];
      for (let index = 0; index < symbols.length; index++) {
        const symbol = symbols[index];
        const symbolLabel = trim(symbol.name);
        const symbolLabelWithIcon = `$(symbol-${SymbolKinds.toString(symbol.kind) || "property"}) ${symbolLabel}`;
        const symbolLabelIconOffset = symbolLabelWithIcon.length - symbolLabel.length;
        let containerLabel = symbol.containerName;
        if (options === null || options === void 0 ? void 0 : options.extraContainerLabel) {
          if (containerLabel) {
            containerLabel = `${options.extraContainerLabel} \u2022 ${containerLabel}`;
          } else {
            containerLabel = options.extraContainerLabel;
          }
        }
        let symbolScore = void 0;
        let symbolMatches = void 0;
        let containerScore = void 0;
        let containerMatches = void 0;
        if (query.original.length > filterPos) {
          let skipContainerQuery = false;
          if (symbolQuery !== query) {
            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, Object.assign(Object.assign({}, query), { values: void 0 }), filterPos, symbolLabelIconOffset);
            if (typeof symbolScore === "number") {
              skipContainerQuery = true;
            }
          }
          if (typeof symbolScore !== "number") {
            [symbolScore, symbolMatches] = scoreFuzzy2(symbolLabelWithIcon, symbolQuery, filterPos, symbolLabelIconOffset);
            if (typeof symbolScore !== "number") {
              continue;
            }
          }
          if (!skipContainerQuery && containerQuery) {
            if (containerLabel && containerQuery.original.length > 0) {
              [containerScore, containerMatches] = scoreFuzzy2(containerLabel, containerQuery);
            }
            if (typeof containerScore !== "number") {
              continue;
            }
            if (typeof symbolScore === "number") {
              symbolScore += containerScore;
            }
          }
        }
        const deprecated = symbol.tags && symbol.tags.indexOf(1) >= 0;
        filteredSymbolPicks.push({
          index,
          kind: symbol.kind,
          score: symbolScore,
          label: symbolLabelWithIcon,
          ariaLabel: symbolLabel,
          description: containerLabel,
          highlights: deprecated ? void 0 : {
            label: symbolMatches,
            description: containerMatches
          },
          range: {
            selection: Range.collapseToStart(symbol.selectionRange),
            decoration: symbol.range
          },
          strikethrough: deprecated,
          buttons: (() => {
            var _a5, _b2;
            const openSideBySideDirection = ((_a5 = this.options) === null || _a5 === void 0 ? void 0 : _a5.openSideBySideDirection) ? (_b2 = this.options) === null || _b2 === void 0 ? void 0 : _b2.openSideBySideDirection() : void 0;
            if (!openSideBySideDirection) {
              return void 0;
            }
            return [
              {
                iconClass: openSideBySideDirection === "right" ? Codicon.splitHorizontal.classNames : Codicon.splitVertical.classNames,
                tooltip: openSideBySideDirection === "right" ? localize("openToSide", "Open to the Side") : localize("openToBottom", "Open to the Bottom")
              }
            ];
          })()
        });
      }
      const sortedFilteredSymbolPicks = filteredSymbolPicks.sort((symbolA, symbolB) => filterBySymbolKind ? this.compareByKindAndScore(symbolA, symbolB) : this.compareByScore(symbolA, symbolB));
      let symbolPicks = [];
      if (filterBySymbolKind) {
        let updateLastSeparatorLabel = function() {
          if (lastSeparator && typeof lastSymbolKind === "number" && lastSymbolKindCounter > 0) {
            lastSeparator.label = format(NLS_SYMBOL_KIND_CACHE[lastSymbolKind] || FALLBACK_NLS_SYMBOL_KIND, lastSymbolKindCounter);
          }
        };
        let lastSymbolKind = void 0;
        let lastSeparator = void 0;
        let lastSymbolKindCounter = 0;
        for (const symbolPick of sortedFilteredSymbolPicks) {
          if (lastSymbolKind !== symbolPick.kind) {
            updateLastSeparatorLabel();
            lastSymbolKind = symbolPick.kind;
            lastSymbolKindCounter = 1;
            lastSeparator = { type: "separator" };
            symbolPicks.push(lastSeparator);
          } else {
            lastSymbolKindCounter++;
          }
          symbolPicks.push(symbolPick);
        }
        updateLastSeparatorLabel();
      } else if (sortedFilteredSymbolPicks.length > 0) {
        symbolPicks = [
          { label: localize("symbols", "symbols ({0})", filteredSymbolPicks.length), type: "separator" },
          ...sortedFilteredSymbolPicks
        ];
      }
      return symbolPicks;
    });
  }
  compareByScore(symbolA, symbolB) {
    if (typeof symbolA.score !== "number" && typeof symbolB.score === "number") {
      return 1;
    } else if (typeof symbolA.score === "number" && typeof symbolB.score !== "number") {
      return -1;
    }
    if (typeof symbolA.score === "number" && typeof symbolB.score === "number") {
      if (symbolA.score > symbolB.score) {
        return -1;
      } else if (symbolA.score < symbolB.score) {
        return 1;
      }
    }
    if (symbolA.index < symbolB.index) {
      return -1;
    } else if (symbolA.index > symbolB.index) {
      return 1;
    }
    return 0;
  }
  compareByKindAndScore(symbolA, symbolB) {
    const kindA = NLS_SYMBOL_KIND_CACHE[symbolA.kind] || FALLBACK_NLS_SYMBOL_KIND;
    const kindB = NLS_SYMBOL_KIND_CACHE[symbolB.kind] || FALLBACK_NLS_SYMBOL_KIND;
    const result = kindA.localeCompare(kindB);
    if (result === 0) {
      return this.compareByScore(symbolA, symbolB);
    }
    return result;
  }
  getDocumentSymbols(document2, token) {
    return __awaiter43(this, void 0, void 0, function* () {
      const model = yield OutlineModel.create(document2, token);
      return token.isCancellationRequested ? [] : model.asListOfDocumentSymbols();
    });
  }
};
AbstractGotoSymbolQuickAccessProvider.PREFIX = "@";
AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX = ":";
AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY = `${AbstractGotoSymbolQuickAccessProvider.PREFIX}${AbstractGotoSymbolQuickAccessProvider.SCOPE_PREFIX}`;
var FALLBACK_NLS_SYMBOL_KIND = localize("property", "properties ({0})");
var NLS_SYMBOL_KIND_CACHE = {
  [5]: localize("method", "methods ({0})"),
  [11]: localize("function", "functions ({0})"),
  [8]: localize("_constructor", "constructors ({0})"),
  [12]: localize("variable", "variables ({0})"),
  [4]: localize("class", "classes ({0})"),
  [22]: localize("struct", "structs ({0})"),
  [23]: localize("event", "events ({0})"),
  [24]: localize("operator", "operators ({0})"),
  [10]: localize("interface", "interfaces ({0})"),
  [2]: localize("namespace", "namespaces ({0})"),
  [3]: localize("package", "packages ({0})"),
  [25]: localize("typeParameter", "type parameters ({0})"),
  [1]: localize("modules", "modules ({0})"),
  [6]: localize("property", "properties ({0})"),
  [9]: localize("enum", "enumerations ({0})"),
  [21]: localize("enumMember", "enumeration members ({0})"),
  [14]: localize("string", "strings ({0})"),
  [0]: localize("file", "files ({0})"),
  [17]: localize("array", "arrays ({0})"),
  [15]: localize("number", "numbers ({0})"),
  [16]: localize("boolean", "booleans ({0})"),
  [18]: localize("object", "objects ({0})"),
  [19]: localize("key", "keys ({0})"),
  [7]: localize("field", "fields ({0})"),
  [13]: localize("constant", "constants ({0})")
};

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneGotoSymbolQuickAccess.js
var __decorate64 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param64 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneGotoSymbolQuickAccessProvider = class StandaloneGotoSymbolQuickAccessProvider2 extends AbstractGotoSymbolQuickAccessProvider {
  constructor(editorService) {
    super();
    this.editorService = editorService;
    this.onDidActiveTextEditorControlChange = Event.None;
  }
  get activeTextEditorControl() {
    return withNullAsUndefined(this.editorService.getFocusedCodeEditor());
  }
};
StandaloneGotoSymbolQuickAccessProvider = __decorate64([
  __param64(0, ICodeEditorService)
], StandaloneGotoSymbolQuickAccessProvider);
Registry.as(Extensions2.Quickaccess).registerQuickAccessProvider({
  ctor: StandaloneGotoSymbolQuickAccessProvider,
  prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX,
  helpEntries: [
    { description: QuickOutlineNLS.quickOutlineActionLabel, prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX, needsEditor: true },
    { description: QuickOutlineNLS.quickOutlineByCategoryActionLabel, prefix: AbstractGotoSymbolQuickAccessProvider.PREFIX_BY_CATEGORY, needsEditor: true }
  ]
});
var GotoLineAction2 = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.quickOutline",
      label: QuickOutlineNLS.quickOutlineActionLabel,
      alias: "Go to Symbol...",
      precondition: EditorContextKeys.hasDocumentSymbolProvider,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 2048 | 1024 | 45,
        weight: 100
      },
      contextMenuOpts: {
        group: "navigation",
        order: 3
      }
    });
  }
  run(accessor) {
    accessor.get(IQuickInputService).quickAccess.show(AbstractGotoSymbolQuickAccessProvider.PREFIX);
  }
};
registerEditorAction(GotoLineAction2);

// node_modules/monaco-editor/esm/vs/base/common/errorMessage.js
function exceptionToErrorMessage(exception, verbose) {
  if (verbose && (exception.stack || exception.stacktrace)) {
    return localize("stackTrace.format", "{0}: {1}", detectSystemErrorMessage(exception), stackToString(exception.stack) || stackToString(exception.stacktrace));
  }
  return detectSystemErrorMessage(exception);
}
function stackToString(stack) {
  if (Array.isArray(stack)) {
    return stack.join("\n");
  }
  return stack;
}
function detectSystemErrorMessage(exception) {
  if (typeof exception.code === "string" && typeof exception.errno === "number" && typeof exception.syscall === "string") {
    return localize("nodeExceptionMessage", "A system error occurred ({0})", exception.message);
  }
  return exception.message || localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}
function toErrorMessage(error = null, verbose = false) {
  if (!error) {
    return localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
  }
  if (Array.isArray(error)) {
    const errors = coalesce(error);
    const msg = toErrorMessage(errors[0], verbose);
    if (errors.length > 1) {
      return localize("error.moreErrors", "{0} ({1} errors in total)", msg, errors.length);
    }
    return msg;
  }
  if (isString(error)) {
    return error;
  }
  if (error.detail) {
    const detail = error.detail;
    if (detail.error) {
      return exceptionToErrorMessage(detail.error, verbose);
    }
    if (detail.exception) {
      return exceptionToErrorMessage(detail.exception, verbose);
    }
  }
  if (error.stack) {
    return exceptionToErrorMessage(error, verbose);
  }
  if (error.message) {
    return error.message;
  }
  return localize("error.defaultMessage", "An unknown error occurred. Please consult the log for more details.");
}

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/pickerQuickAccess.js
var __awaiter44 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var TriggerAction;
(function(TriggerAction2) {
  TriggerAction2[TriggerAction2["NO_ACTION"] = 0] = "NO_ACTION";
  TriggerAction2[TriggerAction2["CLOSE_PICKER"] = 1] = "CLOSE_PICKER";
  TriggerAction2[TriggerAction2["REFRESH_PICKER"] = 2] = "REFRESH_PICKER";
  TriggerAction2[TriggerAction2["REMOVE_ITEM"] = 3] = "REMOVE_ITEM";
})(TriggerAction || (TriggerAction = {}));
function isPicksWithActive(obj) {
  const candidate = obj;
  return Array.isArray(candidate.items);
}
function isFastAndSlowPicks(obj) {
  const candidate = obj;
  return !!candidate.picks && candidate.additionalPicks instanceof Promise;
}
var PickerQuickAccessProvider = class extends Disposable {
  constructor(prefix, options) {
    super();
    this.prefix = prefix;
    this.options = options;
  }
  provide(picker, token) {
    var _a5;
    const disposables = new DisposableStore();
    picker.canAcceptInBackground = !!((_a5 = this.options) === null || _a5 === void 0 ? void 0 : _a5.canAcceptInBackground);
    picker.matchOnLabel = picker.matchOnDescription = picker.matchOnDetail = picker.sortByLabel = false;
    let picksCts = void 0;
    const picksDisposable = disposables.add(new MutableDisposable());
    const updatePickerItems = () => __awaiter44(this, void 0, void 0, function* () {
      const picksDisposables = picksDisposable.value = new DisposableStore();
      picksCts === null || picksCts === void 0 ? void 0 : picksCts.dispose(true);
      picker.busy = false;
      picksCts = new CancellationTokenSource(token);
      const picksToken = picksCts.token;
      const picksFilter = picker.value.substr(this.prefix.length).trim();
      const providedPicks = this._getPicks(picksFilter, picksDisposables, picksToken);
      const applyPicks = (picks, skipEmpty) => {
        var _a6;
        let items;
        let activeItem = void 0;
        if (isPicksWithActive(picks)) {
          items = picks.items;
          activeItem = picks.active;
        } else {
          items = picks;
        }
        if (items.length === 0) {
          if (skipEmpty) {
            return false;
          }
          if (picksFilter.length > 0 && ((_a6 = this.options) === null || _a6 === void 0 ? void 0 : _a6.noResultsPick)) {
            items = [this.options.noResultsPick];
          }
        }
        picker.items = items;
        if (activeItem) {
          picker.activeItems = [activeItem];
        }
        return true;
      };
      if (providedPicks === null) {
      } else if (isFastAndSlowPicks(providedPicks)) {
        let fastPicksApplied = false;
        let slowPicksApplied = false;
        yield Promise.all([
          (() => __awaiter44(this, void 0, void 0, function* () {
            yield timeout(PickerQuickAccessProvider.FAST_PICKS_RACE_DELAY);
            if (picksToken.isCancellationRequested) {
              return;
            }
            if (!slowPicksApplied) {
              fastPicksApplied = applyPicks(providedPicks.picks, true);
            }
          }))(),
          (() => __awaiter44(this, void 0, void 0, function* () {
            picker.busy = true;
            try {
              const awaitedAdditionalPicks = yield providedPicks.additionalPicks;
              if (picksToken.isCancellationRequested) {
                return;
              }
              let picks;
              let activePick = void 0;
              if (isPicksWithActive(providedPicks.picks)) {
                picks = providedPicks.picks.items;
                activePick = providedPicks.picks.active;
              } else {
                picks = providedPicks.picks;
              }
              let additionalPicks;
              let additionalActivePick = void 0;
              if (isPicksWithActive(awaitedAdditionalPicks)) {
                additionalPicks = awaitedAdditionalPicks.items;
                additionalActivePick = awaitedAdditionalPicks.active;
              } else {
                additionalPicks = awaitedAdditionalPicks;
              }
              if (additionalPicks.length > 0 || !fastPicksApplied) {
                let fallbackActivePick = void 0;
                if (!activePick && !additionalActivePick) {
                  const fallbackActivePickCandidate = picker.activeItems[0];
                  if (fallbackActivePickCandidate && picks.indexOf(fallbackActivePickCandidate) !== -1) {
                    fallbackActivePick = fallbackActivePickCandidate;
                  }
                }
                applyPicks({
                  items: [...picks, ...additionalPicks],
                  active: activePick || additionalActivePick || fallbackActivePick
                });
              }
            } finally {
              if (!picksToken.isCancellationRequested) {
                picker.busy = false;
              }
              slowPicksApplied = true;
            }
          }))()
        ]);
      } else if (!(providedPicks instanceof Promise)) {
        applyPicks(providedPicks);
      } else {
        picker.busy = true;
        try {
          const awaitedPicks = yield providedPicks;
          if (picksToken.isCancellationRequested) {
            return;
          }
          applyPicks(awaitedPicks);
        } finally {
          if (!picksToken.isCancellationRequested) {
            picker.busy = false;
          }
        }
      }
    });
    disposables.add(picker.onDidChangeValue(() => updatePickerItems()));
    updatePickerItems();
    disposables.add(picker.onDidAccept((event) => {
      const [item] = picker.selectedItems;
      if (typeof (item === null || item === void 0 ? void 0 : item.accept) === "function") {
        if (!event.inBackground) {
          picker.hide();
        }
        item.accept(picker.keyMods, event);
      }
    }));
    disposables.add(picker.onDidTriggerItemButton(({ button, item }) => __awaiter44(this, void 0, void 0, function* () {
      var _b2, _c2;
      if (typeof item.trigger === "function") {
        const buttonIndex = (_c2 = (_b2 = item.buttons) === null || _b2 === void 0 ? void 0 : _b2.indexOf(button)) !== null && _c2 !== void 0 ? _c2 : -1;
        if (buttonIndex >= 0) {
          const result = item.trigger(buttonIndex, picker.keyMods);
          const action = typeof result === "number" ? result : yield result;
          if (token.isCancellationRequested) {
            return;
          }
          switch (action) {
            case TriggerAction.NO_ACTION:
              break;
            case TriggerAction.CLOSE_PICKER:
              picker.hide();
              break;
            case TriggerAction.REFRESH_PICKER:
              updatePickerItems();
              break;
            case TriggerAction.REMOVE_ITEM:
              const index = picker.items.indexOf(item);
              if (index !== -1) {
                const items = picker.items.slice();
                const removed = items.splice(index, 1);
                const activeItems = picker.activeItems.filter((activeItem) => activeItem !== removed[0]);
                const keepScrollPositionBefore = picker.keepScrollPosition;
                picker.keepScrollPosition = true;
                picker.items = items;
                if (activeItems) {
                  picker.activeItems = activeItems;
                }
                picker.keepScrollPosition = keepScrollPositionBefore;
              }
              break;
          }
        }
      }
    })));
    return disposables;
  }
};
PickerQuickAccessProvider.FAST_PICKS_RACE_DELAY = 200;

// node_modules/monaco-editor/esm/vs/platform/quickinput/browser/commandsQuickAccess.js
var __decorate65 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param65 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter45 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var AbstractCommandsQuickAccessProvider = class AbstractCommandsQuickAccessProvider2 extends PickerQuickAccessProvider {
  constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {
    super(AbstractCommandsQuickAccessProvider2.PREFIX, options);
    this.instantiationService = instantiationService;
    this.keybindingService = keybindingService;
    this.commandService = commandService;
    this.telemetryService = telemetryService;
    this.dialogService = dialogService;
    this.commandsHistory = this._register(this.instantiationService.createInstance(CommandsHistory));
    this.options = options;
  }
  _getPicks(filter, disposables, token) {
    return __awaiter45(this, void 0, void 0, function* () {
      const allCommandPicks = yield this.getCommandPicks(disposables, token);
      if (token.isCancellationRequested) {
        return [];
      }
      const filteredCommandPicks = [];
      for (const commandPick of allCommandPicks) {
        const labelHighlights = withNullAsUndefined(AbstractCommandsQuickAccessProvider2.WORD_FILTER(filter, commandPick.label));
        const aliasHighlights = commandPick.commandAlias ? withNullAsUndefined(AbstractCommandsQuickAccessProvider2.WORD_FILTER(filter, commandPick.commandAlias)) : void 0;
        if (labelHighlights || aliasHighlights) {
          commandPick.highlights = {
            label: labelHighlights,
            detail: this.options.showAlias ? aliasHighlights : void 0
          };
          filteredCommandPicks.push(commandPick);
        } else if (filter === commandPick.commandId) {
          filteredCommandPicks.push(commandPick);
        }
      }
      const mapLabelToCommand = new Map();
      for (const commandPick of filteredCommandPicks) {
        const existingCommandForLabel = mapLabelToCommand.get(commandPick.label);
        if (existingCommandForLabel) {
          commandPick.description = commandPick.commandId;
          existingCommandForLabel.description = existingCommandForLabel.commandId;
        } else {
          mapLabelToCommand.set(commandPick.label, commandPick);
        }
      }
      filteredCommandPicks.sort((commandPickA, commandPickB) => {
        const commandACounter = this.commandsHistory.peek(commandPickA.commandId);
        const commandBCounter = this.commandsHistory.peek(commandPickB.commandId);
        if (commandACounter && commandBCounter) {
          return commandACounter > commandBCounter ? -1 : 1;
        }
        if (commandACounter) {
          return -1;
        }
        if (commandBCounter) {
          return 1;
        }
        return commandPickA.label.localeCompare(commandPickB.label);
      });
      const commandPicks = [];
      let addSeparator = false;
      for (let i = 0; i < filteredCommandPicks.length; i++) {
        const commandPick = filteredCommandPicks[i];
        const keybinding = this.keybindingService.lookupKeybinding(commandPick.commandId);
        const ariaLabel = keybinding ? localize("commandPickAriaLabelWithKeybinding", "{0}, {1}", commandPick.label, keybinding.getAriaLabel()) : commandPick.label;
        if (i === 0 && this.commandsHistory.peek(commandPick.commandId)) {
          commandPicks.push({ type: "separator", label: localize("recentlyUsed", "recently used") });
          addSeparator = true;
        }
        if (i !== 0 && addSeparator && !this.commandsHistory.peek(commandPick.commandId)) {
          commandPicks.push({ type: "separator", label: localize("morecCommands", "other commands") });
          addSeparator = false;
        }
        commandPicks.push(Object.assign(Object.assign({}, commandPick), { ariaLabel, detail: this.options.showAlias && commandPick.commandAlias !== commandPick.label ? commandPick.commandAlias : void 0, keybinding, accept: () => __awaiter45(this, void 0, void 0, function* () {
          this.commandsHistory.push(commandPick.commandId);
          this.telemetryService.publicLog2("workbenchActionExecuted", {
            id: commandPick.commandId,
            from: "quick open"
          });
          try {
            yield this.commandService.executeCommand(commandPick.commandId);
          } catch (error) {
            if (!isPromiseCanceledError(error)) {
              this.dialogService.show(severity_default.Error, localize("canNotRun", "Command '{0}' resulted in an error ({1})", commandPick.label, toErrorMessage(error)));
            }
          }
        }) }));
      }
      return commandPicks;
    });
  }
};
AbstractCommandsQuickAccessProvider.PREFIX = ">";
AbstractCommandsQuickAccessProvider.WORD_FILTER = or(matchesPrefix, matchesWords, matchesContiguousSubString);
AbstractCommandsQuickAccessProvider = __decorate65([
  __param65(1, IInstantiationService),
  __param65(2, IKeybindingService),
  __param65(3, ICommandService),
  __param65(4, ITelemetryService),
  __param65(5, IDialogService)
], AbstractCommandsQuickAccessProvider);
var CommandsHistory = class CommandsHistory2 extends Disposable {
  constructor(storageService, configurationService) {
    super();
    this.storageService = storageService;
    this.configurationService = configurationService;
    this.configuredCommandsHistoryLength = 0;
    this.updateConfiguration();
    this.load();
    this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration(() => this.updateConfiguration()));
  }
  updateConfiguration() {
    this.configuredCommandsHistoryLength = CommandsHistory2.getConfiguredCommandHistoryLength(this.configurationService);
    if (CommandsHistory2.cache && CommandsHistory2.cache.limit !== this.configuredCommandsHistoryLength) {
      CommandsHistory2.cache.limit = this.configuredCommandsHistoryLength;
      CommandsHistory2.saveState(this.storageService);
    }
  }
  load() {
    const raw = this.storageService.get(CommandsHistory2.PREF_KEY_CACHE, 0);
    let serializedCache;
    if (raw) {
      try {
        serializedCache = JSON.parse(raw);
      } catch (error) {
      }
    }
    const cache = CommandsHistory2.cache = new LRUCache(this.configuredCommandsHistoryLength, 1);
    if (serializedCache) {
      let entries;
      if (serializedCache.usesLRU) {
        entries = serializedCache.entries;
      } else {
        entries = serializedCache.entries.sort((a, b) => a.value - b.value);
      }
      entries.forEach((entry) => cache.set(entry.key, entry.value));
    }
    CommandsHistory2.counter = this.storageService.getNumber(CommandsHistory2.PREF_KEY_COUNTER, 0, CommandsHistory2.counter);
  }
  push(commandId) {
    if (!CommandsHistory2.cache) {
      return;
    }
    CommandsHistory2.cache.set(commandId, CommandsHistory2.counter++);
    CommandsHistory2.saveState(this.storageService);
  }
  peek(commandId) {
    var _a5;
    return (_a5 = CommandsHistory2.cache) === null || _a5 === void 0 ? void 0 : _a5.peek(commandId);
  }
  static saveState(storageService) {
    if (!CommandsHistory2.cache) {
      return;
    }
    const serializedCache = { usesLRU: true, entries: [] };
    CommandsHistory2.cache.forEach((value, key) => serializedCache.entries.push({ key, value }));
    storageService.store(CommandsHistory2.PREF_KEY_CACHE, JSON.stringify(serializedCache), 0, 0);
    storageService.store(CommandsHistory2.PREF_KEY_COUNTER, CommandsHistory2.counter, 0, 0);
  }
  static getConfiguredCommandHistoryLength(configurationService) {
    var _a5, _b2;
    const config = configurationService.getValue();
    const configuredCommandHistoryLength = (_b2 = (_a5 = config.workbench) === null || _a5 === void 0 ? void 0 : _a5.commandPalette) === null || _b2 === void 0 ? void 0 : _b2.history;
    if (typeof configuredCommandHistoryLength === "number") {
      return configuredCommandHistoryLength;
    }
    return CommandsHistory2.DEFAULT_COMMANDS_HISTORY_LENGTH;
  }
};
CommandsHistory.DEFAULT_COMMANDS_HISTORY_LENGTH = 50;
CommandsHistory.PREF_KEY_CACHE = "commandPalette.mru.cache";
CommandsHistory.PREF_KEY_COUNTER = "commandPalette.mru.counter";
CommandsHistory.counter = 1;
CommandsHistory = __decorate65([
  __param65(0, IStorageService),
  __param65(1, IConfigurationService)
], CommandsHistory);

// node_modules/monaco-editor/esm/vs/editor/contrib/quickAccess/commandsQuickAccess.js
var AbstractEditorCommandsQuickAccessProvider = class extends AbstractCommandsQuickAccessProvider {
  constructor(options, instantiationService, keybindingService, commandService, telemetryService, dialogService) {
    super(options, instantiationService, keybindingService, commandService, telemetryService, dialogService);
  }
  getCodeEditorCommandPicks() {
    const activeTextEditorControl = this.activeTextEditorControl;
    if (!activeTextEditorControl) {
      return [];
    }
    const editorCommandPicks = [];
    for (const editorAction of activeTextEditorControl.getSupportedActions()) {
      editorCommandPicks.push({
        commandId: editorAction.id,
        commandAlias: editorAction.alias,
        label: stripIcons(editorAction.label) || editorAction.id
      });
    }
    return editorCommandPicks;
  }
};

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/quickAccess/standaloneCommandsQuickAccess.js
var __decorate66 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param66 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter46 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var StandaloneCommandsQuickAccessProvider = class StandaloneCommandsQuickAccessProvider2 extends AbstractEditorCommandsQuickAccessProvider {
  constructor(instantiationService, codeEditorService, keybindingService, commandService, telemetryService, dialogService) {
    super({ showAlias: false }, instantiationService, keybindingService, commandService, telemetryService, dialogService);
    this.codeEditorService = codeEditorService;
  }
  get activeTextEditorControl() {
    return withNullAsUndefined(this.codeEditorService.getFocusedCodeEditor());
  }
  getCommandPicks() {
    return __awaiter46(this, void 0, void 0, function* () {
      return this.getCodeEditorCommandPicks();
    });
  }
};
StandaloneCommandsQuickAccessProvider = __decorate66([
  __param66(0, IInstantiationService),
  __param66(1, ICodeEditorService),
  __param66(2, IKeybindingService),
  __param66(3, ICommandService),
  __param66(4, ITelemetryService),
  __param66(5, IDialogService)
], StandaloneCommandsQuickAccessProvider);
Registry.as(Extensions2.Quickaccess).registerQuickAccessProvider({
  ctor: StandaloneCommandsQuickAccessProvider,
  prefix: StandaloneCommandsQuickAccessProvider.PREFIX,
  helpEntries: [{ description: QuickCommandNLS.quickCommandHelp, needsEditor: true }]
});
var GotoLineAction3 = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.quickCommand",
      label: QuickCommandNLS.quickCommandActionLabel,
      alias: "Command Palette",
      precondition: void 0,
      kbOpts: {
        kbExpr: EditorContextKeys.focus,
        primary: 59,
        weight: 100
      },
      contextMenuOpts: {
        group: "z_commands",
        order: 1
      }
    });
  }
  run(accessor) {
    accessor.get(IQuickInputService).quickAccess.show(StandaloneCommandsQuickAccessProvider.PREFIX);
  }
};
registerEditorAction(GotoLineAction3);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/referenceSearch/standaloneReferenceSearch.js
var __decorate67 = function(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param67 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var StandaloneReferencesController = class StandaloneReferencesController2 extends ReferencesController {
  constructor(editor2, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService) {
    super(true, editor2, contextKeyService, editorService, notificationService, instantiationService, storageService, configurationService);
  }
};
StandaloneReferencesController = __decorate67([
  __param67(1, IContextKeyService),
  __param67(2, ICodeEditorService),
  __param67(3, INotificationService),
  __param67(4, IInstantiationService),
  __param67(5, IStorageService),
  __param67(6, IConfigurationService)
], StandaloneReferencesController);
registerEditorContribution(ReferencesController.ID, StandaloneReferencesController);

// node_modules/monaco-editor/esm/vs/editor/standalone/browser/toggleHighContrast/toggleHighContrast.js
var ToggleHighContrast = class extends EditorAction {
  constructor() {
    super({
      id: "editor.action.toggleHighContrast",
      label: ToggleHighContrastNLS.toggleHighContrast,
      alias: "Toggle High Contrast Theme",
      precondition: void 0
    });
    this._originalThemeName = null;
  }
  run(accessor, editor2) {
    const standaloneThemeService = accessor.get(IStandaloneThemeService);
    if (this._originalThemeName) {
      standaloneThemeService.setTheme(this._originalThemeName);
      this._originalThemeName = null;
    } else {
      this._originalThemeName = standaloneThemeService.getColorTheme().themeName;
      standaloneThemeService.setTheme("hc-black");
    }
  }
};
registerEditorAction(ToggleHighContrast);
export {
  CancellationTokenSource2 as CancellationTokenSource,
  Emitter2 as Emitter,
  KeyCode,
  KeyMod,
  MarkerSeverity2 as MarkerSeverity,
  MarkerTag,
  Position2 as Position,
  Range2 as Range,
  Selection2 as Selection,
  SelectionDirection,
  Token,
  Uri,
  editor,
  languages
};
/*! @license DOMPurify 2.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.1/LICENSE */
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.31.1(337587859b1c171314b40503171188b6cea6a32a)
 * Released under the MIT license
 * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt
 *-----------------------------------------------------------------------------*/
//# sourceMappingURL=monaco-editor.js.map
