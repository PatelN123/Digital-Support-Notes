import {
  __commonJS,
  __filename,
  __require,
  __spreadProps,
  __spreadValues,
  __toModule,
  generateGoogleFontsUrl,
  init_esm_shims,
  resolveGlobalImportPath,
  resolveImportPath,
  stringifyMarkdownTokens,
  toAtFS
} from "./chunk-3LH2GTGU.mjs";

// ../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    init_esm_shims();
    module.exports = function equal2(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal2(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal2(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node/common.ts
init_esm_shims();
import { promises as fs, existsSync } from "fs";
import { join } from "path";
import { uniq } from "@antfu/utils";
async function getIndexHtml({ clientRoot, themeRoots, data, userRoot }) {
  var _a, _b;
  let main = await fs.readFile(join(clientRoot, "index.html"), "utf-8");
  let head = "";
  let body = "";
  head += `<link rel="icon" href="${data.config.favicon}">`;
  const roots = uniq([
    ...themeRoots,
    userRoot
  ]);
  for (const root of roots) {
    const path = join(root, "index.html");
    if (!existsSync(path))
      continue;
    const index = await fs.readFile(path, "utf-8");
    head += `
${(((_a = index.match(/<head>([\s\S]*?)<\/head>/im)) == null ? void 0 : _a[1]) || "").trim()}`;
    body += `
${(((_b = index.match(/<body>([\s\S]*?)<\/body>/im)) == null ? void 0 : _b[1]) || "").trim()}`;
  }
  if (data.features.tweet)
    body += '\n<script async src="https://platform.twitter.com/widgets.js"><\/script>';
  if (data.config.fonts.webfonts.length && data.config.fonts.provider !== "none")
    head += `
<link rel="stylesheet" href="${generateGoogleFontsUrl(data.config.fonts)}" type="text/css">`;
  main = main.replace("__ENTRY__", toAtFS(join(clientRoot, "main.ts"))).replace("<!-- head -->", head).replace("<!-- body -->", body);
  return main;
}

// node/plugins/windicss.ts
init_esm_shims();
import { resolve as resolve2, dirname } from "path";
import { existsSync as existsSync3 } from "fs";
import { slash, uniq as uniq2 } from "@antfu/utils";
import WindiCSS, { defaultConfigureFiles } from "vite-plugin-windicss";
import jiti2 from "jiti";

// node/plugins/setupNode.ts
init_esm_shims();
import { resolve } from "path";
import { existsSync as existsSync2 } from "fs-extra";
import { isObject } from "@antfu/utils";
import jiti from "jiti";
function deepMerge(a, b, rootPath = "") {
  a = __spreadValues({}, a);
  Object.keys(b).forEach((key) => {
    if (isObject(a[key]))
      a[key] = deepMerge(a[key], b[key], rootPath ? `${rootPath}.${key}` : key);
    else if (Array.isArray(a[key]))
      a[key] = [...a[key], ...b[key]];
    else
      a[key] = b[key];
  });
  return a;
}
async function loadSetups(roots, name, arg, initial, merge = true) {
  let returns = initial;
  for (const root of roots) {
    const path = resolve(root, "setup", name);
    if (existsSync2(path)) {
      const { default: setup } = jiti(__filename)(path);
      const result = await setup(arg);
      if (result !== null) {
        returns = merge ? deepMerge(returns, result) : result;
      }
    }
  }
  return returns;
}

// node/plugins/windicss.ts
async function createWindiCSSPlugin({ themeRoots, clientRoot, userRoot, roots, data }, { windicss: windiOptions }) {
  const configFiles = uniq2([
    ...defaultConfigureFiles.map((i) => resolve2(userRoot, i)),
    ...themeRoots.map((i) => `${i}/windi.config.ts`),
    resolve2(clientRoot, "windi.config.ts")
  ]);
  const configFile = configFiles.find((i) => existsSync3(i));
  let config = jiti2(__filename)(configFile);
  if (config.default)
    config = config.default;
  config = await loadSetups(roots, "windicss.ts", {}, config, true);
  return WindiCSS(__spreadValues({
    configFiles: [configFile],
    config,
    onConfigResolved(config2) {
      if (!config2.theme)
        config2.theme = {};
      if (!config2.theme.extend)
        config2.theme.extend = {};
      if (!config2.theme.extend.fontFamily)
        config2.theme.extend.fontFamily = {};
      const fontFamily = config2.theme.extend.fontFamily;
      fontFamily.sans || (fontFamily.sans = data.config.fonts.sans.join(","));
      fontFamily.mono || (fontFamily.mono = data.config.fonts.mono.join(","));
      fontFamily.serif || (fontFamily.serif = data.config.fonts.serif.join(","));
      return config2;
    },
    onOptionsResolved(config2) {
      themeRoots.forEach((i) => {
        config2.scanOptions.include.push(`${i}/components/*.{vue,ts}`);
        config2.scanOptions.include.push(`${i}/layouts/*.{vue,ts}`);
      });
      config2.scanOptions.include.push(`!${slash(resolve2(userRoot, "node_modules"))}`);
      config2.scanOptions.exclude.push(dirname(resolveImportPath("monaco-editor/package.json", true)));
      config2.scanOptions.exclude.push(dirname(resolveImportPath("katex/package.json", true)));
      config2.scanOptions.exclude.push(dirname(resolveImportPath("prettier/package.json", true)));
    }
  }, windiOptions));
}

// node/plugins/preset.ts
init_esm_shims();
import Vue from "@vitejs/plugin-vue";
import Icons from "unplugin-icons/vite";
import IconsResolver from "unplugin-icons/resolver";
import Components from "unplugin-vue-components/vite";
import RemoteAssets, { DefaultRules } from "vite-plugin-remote-assets";
import ServerRef from "vite-plugin-vue-server-ref";
import { notNullish as notNullish2 } from "@antfu/utils";

// node/drawings.ts
init_esm_shims();
import { dirname as dirname2, resolve as resolve3, join as join2, basename } from "path";
import fs2 from "fs-extra";
import fg from "fast-glob";
function resolveDrawingsDir(options) {
  return options.data.config.drawings.persist ? resolve3(dirname2(options.entry), options.data.config.drawings.persist) : void 0;
}
async function loadDrawings(options) {
  const dir = resolveDrawingsDir(options);
  if (!dir || !fs2.existsSync(dir))
    return {};
  const files = await fg("*.svg", {
    onlyFiles: true,
    cwd: dir,
    absolute: true
  });
  const obj = {};
  Promise.all(files.map(async (path) => {
    const num = +basename(path, ".svg");
    if (Number.isNaN(num))
      return;
    const content = await fs2.readFile(path, "utf8");
    const lines = content.split(/\n/g);
    obj[num.toString()] = lines.slice(1, -1).join("\n");
  }));
  return obj;
}
async function writeDarwings(options, drawing) {
  const dir = resolveDrawingsDir(options);
  if (!dir)
    return;
  const width = options.data.config.canvasWidth;
  const height = Math.round(width / options.data.config.aspectRatio);
  const SVG_HEAD = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">`;
  await fs2.ensureDir(dir);
  return Promise.all(Object.entries(drawing).map(async ([key, value]) => {
    if (!value)
      return;
    const svg = `${SVG_HEAD}
${value}
</svg>`;
    await fs2.writeFile(join2(dir, `${key}.svg`), svg, "utf-8");
  }));
}

// node/plugins/extendConfig.ts
init_esm_shims();
import { dirname as dirname4, join as join4 } from "path";
import { mergeConfig } from "vite";
import isInstalledGlobally from "is-installed-globally";
import { uniq as uniq3 } from "@antfu/utils";

// ../client/package.json
var dependencies = {
  "@antfu/utils": "^0.3.0",
  "@slidev/parser": "workspace:*",
  "@slidev/types": "workspace:*",
  "@vueuse/core": "^7.3.0",
  "@vueuse/head": "^0.7.4",
  "@vueuse/motion": "^2.0.0-beta.4",
  codemirror: "^5.64.0",
  drauu: "^0.2.1",
  "file-saver": "^2.0.5",
  "js-base64": "^3.7.2",
  "js-yaml": "^4.1.0",
  katex: "^0.15.1",
  mermaid: "8.13.0",
  "monaco-editor": "^0.31.0",
  nanoid: "^3.1.30",
  prettier: "^2.5.1",
  recordrtc: "^5.6.2",
  resolve: "^1.20.0",
  "vite-plugin-windicss": "^1.5.4",
  vue: "^3.2.26",
  "vue-router": "^4.0.12",
  windicss: "^3.3.0"
};

// node/vite/searchRoot.ts
init_esm_shims();
import fs3 from "fs";
import { dirname as dirname3, join as join3 } from "path";
var ROOT_FILES = [
  "pnpm-workspace.yaml"
];
function hasWorkspacePackageJSON(root) {
  const path = join3(root, "package.json");
  try {
    fs3.accessSync(path, fs3.constants.R_OK);
  } catch {
    return false;
  }
  const content = JSON.parse(fs3.readFileSync(path, "utf-8")) || {};
  return !!content.workspaces;
}
function hasRootFile(root) {
  return ROOT_FILES.some((file) => fs3.existsSync(join3(root, file)));
}
function hasPackageJSON(root) {
  const path = join3(root, "package.json");
  return fs3.existsSync(path);
}
function searchForPackageRoot(current, root = current) {
  if (hasPackageJSON(current))
    return current;
  const dir = dirname3(current);
  if (!dir || dir === current)
    return root;
  return searchForPackageRoot(dir, root);
}
function searchForWorkspaceRoot(current, root = searchForPackageRoot(current)) {
  if (hasRootFile(current))
    return current;
  if (hasWorkspacePackageJSON(current))
    return current;
  const dir = dirname3(current);
  if (!dir || dir === current)
    return root;
  return searchForWorkspaceRoot(dir, root);
}

// node/plugins/extendConfig.ts
var EXCLUDE = [
  "@slidev/shared",
  "@slidev/types",
  "@vueuse/core",
  "@vueuse/shared",
  "mermaid",
  "vite-plugin-windicss",
  "vue-demi"
];
function createConfigPlugin(options) {
  return {
    name: "slidev:config",
    config(config) {
      const injection = {
        define: getDefine(options),
        resolve: {
          alias: {
            "@slidev/client/": `${toAtFS(options.clientRoot)}/`
          }
        },
        optimizeDeps: {
          include: [
            ...Object.keys(dependencies).filter((i) => !EXCLUDE.includes(i)),
            "codemirror/mode/javascript/javascript",
            "codemirror/mode/css/css",
            "codemirror/mode/markdown/markdown",
            "codemirror/mode/xml/xml",
            "codemirror/mode/htmlmixed/htmlmixed",
            "codemirror/addon/display/placeholder",
            "prettier/esm/parser-babel",
            "prettier/esm/parser-html",
            "prettier/esm/parser-typescript",
            "mermaid/dist/mermaid.min",
            "vite-plugin-vue-server-ref/client"
          ],
          exclude: EXCLUDE
        },
        server: {
          fs: {
            strict: true,
            allow: uniq3([
              searchForWorkspaceRoot(options.userRoot),
              searchForWorkspaceRoot(options.cliRoot),
              ...isInstalledGlobally ? [dirname4(resolveGlobalImportPath("@slidev/client/package.json")), dirname4(resolveGlobalImportPath("katex/package.json"))] : []
            ])
          }
        }
      };
      if (isInstalledGlobally) {
        injection.cacheDir = join4(options.cliRoot, "node_modules/.vite");
        injection.publicDir = join4(options.userRoot, "public");
        injection.root = options.cliRoot;
        injection.resolve.alias.vue = `${resolveImportPath("vue/dist/vue.esm-browser.js", true)}`;
      }
      return mergeConfig(config, injection);
    },
    configureServer(server) {
      return () => {
        server.middlewares.use(async (req, res, next) => {
          if (req.url.endsWith(".html")) {
            res.setHeader("Content-Type", "text/html");
            res.statusCode = 200;
            res.end(await getIndexHtml(options));
            return;
          }
          next();
        });
      };
    }
  };
}
function getDefine(options) {
  return {
    __SLIDEV_CLIENT_ROOT__: JSON.stringify(toAtFS(options.clientRoot)),
    __SLIDEV_HASH_ROUTE__: JSON.stringify(options.data.config.routerMode === "hash"),
    __SLIDEV_FEATURE_DRAWINGS__: JSON.stringify(options.data.config.drawings.enabled === true || options.data.config.drawings.enabled === options.mode),
    __SLIDEV_FEATURE_DRAWINGS_PERSIST__: JSON.stringify(!!options.data.config.drawings.persist === true),
    __DEV__: options.mode === "dev" ? "true" : "false"
  };
}

// node/plugins/loaders.ts
init_esm_shims();
var import_fast_deep_equal = __toModule(require_fast_deep_equal());
import { basename as basename2, join as join5 } from "path";
import { isString, notNullish, objectMap, range, slash as slash2, uniq as uniq4 } from "@antfu/utils";
import fg2 from "fast-glob";
import fs4, { existsSync as existsSync4 } from "fs-extra";
import Markdown from "markdown-it";
import mila from "markdown-it-link-attributes";
import * as parser from "@slidev/parser/fs";
var regexId = /^\/\@slidev\/slide\/(\d+)\.(md|json)(?:\?import)?$/;
var regexIdQuery = /(\d+?)\.(md|json)$/;
function getBodyJson(req) {
  return new Promise((resolve5, reject) => {
    let body = "";
    req.on("data", (chunk) => body += chunk);
    req.on("error", reject);
    req.on("end", () => {
      try {
        resolve5(JSON.parse(body) || {});
      } catch (e) {
        reject(e);
      }
    });
  });
}
var md = Markdown({ html: true });
md.use(mila, {
  attrs: {
    target: "_blank",
    rel: "noopener"
  }
});
function prepareSlideInfo(data) {
  return __spreadProps(__spreadValues({}, data), {
    notesHTML: md.render((data == null ? void 0 : data.note) || "")
  });
}
function createSlidesLoader({ data, entry, clientRoot, themeRoots, userRoot, roots }, pluginOptions, serverOptions, VuePlugin, MarkdownPlugin) {
  const slidePrefix = "/@slidev/slides/";
  const hmrPages = /* @__PURE__ */ new Set();
  let server;
  let _layouts_cache_time = 0;
  let _layouts_cache = {};
  return [
    {
      name: "slidev:loader",
      configureServer(_server) {
        server = _server;
        updateServerWatcher();
        server.middlewares.use(async (req, res, next) => {
          var _a;
          const match = (_a = req.url) == null ? void 0 : _a.match(regexId);
          if (!match)
            return next();
          const [, no, type] = match;
          const idx = parseInt(no);
          if (type === "json" && req.method === "GET") {
            res.write(JSON.stringify(prepareSlideInfo(data.slides[idx])));
            return res.end();
          }
          if (type === "json" && req.method === "POST") {
            const body = await getBodyJson(req);
            const slide = data.slides[idx];
            hmrPages.add(idx);
            if (slide.source) {
              Object.assign(slide.source, body);
              await parser.saveExternalSlide(slide.source);
            } else {
              Object.assign(slide, body);
              await parser.save(data, entry);
            }
            res.statusCode = 200;
            res.write(JSON.stringify(prepareSlideInfo(slide)));
            return res.end();
          }
          next();
        });
      },
      async handleHotUpdate(ctx) {
        var _a;
        if (!data.entries.some((i) => slash2(i) === ctx.file))
          return;
        const newData = await parser.load(entry, data.themeMeta);
        const moduleIds = /* @__PURE__ */ new Set();
        if (data.slides.length !== newData.slides.length) {
          moduleIds.add("/@slidev/routes");
          range(newData.slides.length).map((i) => hmrPages.add(i));
        }
        if (!(0, import_fast_deep_equal.default)(data.headmatter.defaults, newData.headmatter.defaults)) {
          moduleIds.add("/@slidev/routes");
          range(data.slides.length).map((i) => hmrPages.add(i));
        }
        if (!(0, import_fast_deep_equal.default)(data.config, newData.config))
          moduleIds.add("/@slidev/configs");
        if (!(0, import_fast_deep_equal.default)(data.features, newData.features)) {
          setTimeout(() => {
            ctx.server.ws.send({ type: "full-reload" });
          }, 1);
        }
        const length = Math.max(data.slides.length, newData.slides.length);
        for (let i = 0; i < length; i++) {
          const a = data.slides[i];
          const b = newData.slides[i];
          if ((a == null ? void 0 : a.content.trim()) === (b == null ? void 0 : b.content.trim()) && (a == null ? void 0 : a.note) === (b == null ? void 0 : b.note) && (0, import_fast_deep_equal.default)(a.frontmatter, b.frontmatter))
            continue;
          ctx.server.ws.send({
            type: "custom",
            event: "slidev-update",
            data: {
              id: i,
              data: prepareSlideInfo(newData.slides[i])
            }
          });
          hmrPages.add(i);
        }
        (_a = serverOptions.onDataReload) == null ? void 0 : _a.call(serverOptions, newData, data);
        Object.assign(data, newData);
        const vueModules = (await Promise.all(Array.from(hmrPages).map(async (i) => {
          var _a2;
          const file = `${slidePrefix}${i + 1}.md`;
          try {
            const md2 = await transformMarkdown(MarkdownPlugin.transform((_a2 = newData.slides[i]) == null ? void 0 : _a2.content, file), i, newData);
            return await VuePlugin.handleHotUpdate(__spreadProps(__spreadValues({}, ctx), {
              modules: Array.from(ctx.server.moduleGraph.getModulesByFile(file) || []),
              file,
              read() {
                return md2;
              }
            }));
          } catch {
          }
        }))).flatMap((i) => i || []);
        hmrPages.clear();
        const moduleEntries = [
          ...vueModules,
          ...Array.from(moduleIds).map((id) => ctx.server.moduleGraph.getModuleById(id))
        ].filter(notNullish).filter((i) => {
          var _a2;
          return !((_a2 = i.id) == null ? void 0 : _a2.startsWith("/@id/@vite-icons"));
        });
        updateServerWatcher();
        return moduleEntries;
      },
      resolveId(id) {
        if (id.startsWith(slidePrefix) || id.startsWith("/@slidev/"))
          return id;
        return null;
      },
      load(id) {
        var _a;
        if (id === "/@slidev/routes")
          return generateRoutes();
        if (id === "/@slidev/layouts")
          return generateLayouts();
        if (id === "/@slidev/styles")
          return generateUserStyles();
        if (id === "/@slidev/monaco-types")
          return generateMonacoTypes();
        if (id === "/@slidev/configs")
          return generateConfigs();
        if (id === "/@slidev/global-components/top")
          return generateGlobalComponents("top");
        if (id === "/@slidev/global-components/bottom")
          return generateGlobalComponents("bottom");
        if (id.startsWith(slidePrefix)) {
          const remaning = id.slice(slidePrefix.length);
          const match = remaning.match(regexIdQuery);
          if (match) {
            const [, no, type] = match;
            const pageNo = parseInt(no) - 1;
            if (type === "md")
              return (_a = data.slides[pageNo]) == null ? void 0 : _a.content;
          }
          return "";
        }
      }
    },
    {
      name: "slidev:layout-transform:pre",
      enforce: "pre",
      async transform(code, id) {
        if (!id.startsWith(slidePrefix))
          return;
        const remaning = id.slice(slidePrefix.length);
        const match = remaning.match(regexIdQuery);
        if (!match)
          return;
        const [, no, type] = match;
        if (type !== "md")
          return;
        const pageNo = parseInt(no) - 1;
        return transformMarkdown(code, pageNo, data);
      }
    }
  ];
  function updateServerWatcher() {
    var _a;
    if (!server)
      return;
    server.watcher.add(((_a = data.entries) == null ? void 0 : _a.map(slash2)) || []);
  }
  async function transformMarkdown(code, pageNo, data2) {
    var _a, _b;
    const layouts = await getLayouts();
    const frontmatter = __spreadValues(__spreadValues({}, ((_a = data2.headmatter) == null ? void 0 : _a.defaults) || {}), ((_b = data2.slides[pageNo]) == null ? void 0 : _b.frontmatter) || {});
    const layoutName = (frontmatter == null ? void 0 : frontmatter.layout) || (pageNo === 0 ? "cover" : "default");
    if (!layouts[layoutName])
      throw new Error(`Unknown layout "${layoutName}"`);
    delete frontmatter.title;
    const imports = [
      `import InjectedLayout from "${toAtFS(layouts[layoutName])}"`,
      `const frontmatter = ${JSON.stringify(frontmatter)}`
    ];
    code = code.replace(/(<script setup.*>)/g, `$1
${imports.join("\n")}
`);
    const injectA = code.indexOf("<template>") + "<template>".length;
    const injectB = code.lastIndexOf("</template>");
    let body = code.slice(injectA, injectB).trim();
    if (body.startsWith("<div>") && body.endsWith("</div>"))
      body = body.slice(5, -6);
    code = `${code.slice(0, injectA)}
<InjectedLayout v-bind="frontmatter">
${body}
</InjectedLayout>
${code.slice(injectB)}`;
    return code;
  }
  async function getLayouts() {
    const now = Date.now();
    if (now - _layouts_cache_time < 2e3)
      return _layouts_cache;
    const layouts = {};
    const roots2 = uniq4([
      userRoot,
      ...themeRoots,
      clientRoot
    ]);
    for (const root of roots2) {
      const layoutPaths = await fg2("layouts/*.{vue,ts}", {
        cwd: root,
        absolute: true
      });
      for (const layoutPath of layoutPaths) {
        const layout = basename2(layoutPath).replace(/\.\w+$/, "");
        if (layouts[layout])
          continue;
        layouts[layout] = layoutPath;
      }
    }
    _layouts_cache_time = now;
    _layouts_cache = layouts;
    return layouts;
  }
  async function generateUserStyles() {
    const imports = [
      `import "${toAtFS(join5(clientRoot, "styles/vars.css"))}"`,
      `import "${toAtFS(join5(clientRoot, "styles/index.css"))}"`,
      `import "${toAtFS(join5(clientRoot, "styles/code.css"))}"`
    ];
    const roots2 = uniq4([
      ...themeRoots,
      userRoot
    ]);
    for (const root of roots2) {
      const styles = [
        join5(root, "styles", "index.ts"),
        join5(root, "styles", "index.js"),
        join5(root, "styles", "index.css"),
        join5(root, "styles.css"),
        join5(root, "style.css")
      ];
      for (const style of styles) {
        if (existsSync4(style)) {
          imports.push(`import "${toAtFS(style)}"`);
          continue;
        }
      }
    }
    if (data.features.katex)
      imports.push(`import "${toAtFS(resolveImportPath("katex/dist/katex.min.css", true))}"`);
    return imports.join("\n");
  }
  async function generateMonacoTypes() {
    return `void 0; ${parser.scanMonacoModules(data.raw).map((i) => `import('/@slidev-monaco-types/${i}')`).join("\n")}`;
  }
  async function generateLayouts() {
    const imports = [];
    const layouts = objectMap(await getLayouts(), (k, v) => {
      imports.push(`import __layout_${k} from "${toAtFS(v)}"`);
      return [k, `__layout_${k}`];
    });
    return [
      imports.join("\n"),
      `export default {
${Object.entries(layouts).map(([k, v]) => `"${k}": ${v}`).join(",\n")}
}`
    ].join("\n\n");
  }
  async function generateRoutes() {
    const imports = [];
    const layouts = await getLayouts();
    imports.push(`import __layout__end from '${layouts.end}'`);
    let no = 1;
    const routes = [
      ...data.slides.map((i, idx) => {
        var _a, _b;
        if ((_a = i.frontmatter) == null ? void 0 : _a.disabled)
          return void 0;
        imports.push(`import n${no} from '${slidePrefix}${idx + 1}.md'`);
        const additions = {
          slide: {
            start: i.start,
            end: i.end,
            note: i.note,
            filepath: ((_b = i.source) == null ? void 0 : _b.filepath) || entry,
            id: idx,
            no
          },
          __clicksElements: [],
          __preloaded: false
        };
        const meta = Object.assign({}, i.frontmatter, additions);
        const route = `{ path: '${no}', name: 'page-${no}', component: n${no}, meta: ${JSON.stringify(meta)} }`;
        no += 1;
        return route;
      }).filter(notNullish),
      `{ path: "${no}", component: __layout__end, meta: { layout: "end" } }`
    ];
    const routesStr = `export default [
${routes.join(",\n")}
]`;
    return [...imports, routesStr].join("\n");
  }
  function generateConfigs() {
    const config = __spreadValues({}, data.config);
    if (isString(config.title)) {
      const tokens = md.parseInline(config.title, {});
      config.title = stringifyMarkdownTokens(tokens);
    }
    if (isString(config.info))
      config.info = md.render(config.info);
    return `export default ${JSON.stringify(config)}`;
  }
  async function generateGlobalComponents(layer) {
    const components = roots.flatMap((root) => {
      if (layer === "top") {
        return [
          join5(root, "global.vue"),
          join5(root, "global-top.vue"),
          join5(root, "GlobalTop.vue")
        ];
      } else {
        return [
          join5(root, "global-bottom.vue"),
          join5(root, "GlobalBottom.vue")
        ];
      }
    }).filter((i) => fs4.existsSync(i));
    const imports = components.map((i, idx) => `import __n${idx} from '${toAtFS(i)}'`).join("\n");
    const render = components.map((i, idx) => `h(__n${idx})`).join(",");
    return `
${imports}
import { h } from 'vue'
export default {
  render() {
    return [${render}]
  }
}
`;
  }
}

// node/plugins/monacoTransform.ts
init_esm_shims();
import { join as join6 } from "path";
import { slash as slash3 } from "@antfu/utils";
import { resolvePackageData } from "vite";
function createMonacoTypesLoader() {
  return {
    name: "slidev:monaco-types-loader",
    resolveId(id) {
      if (id.startsWith("/@slidev-monaco-types/"))
        return id;
      return null;
    },
    load(id) {
      const match = id.match(/^\/\@slidev-monaco-types\/(.*)$/);
      if (match) {
        const pkg = match[1];
        const info = resolvePackageData(pkg, process.cwd());
        if (!info)
          return;
        const typePath = info.data.types || info.data.typings;
        if (!typePath)
          return "";
        return [
          "import * as monaco from 'monaco-editor'",
          `import Type from "${slash3(join6(info.dir, typePath))}?raw"`,
          ...Object.keys(info.data.dependencies || {}).map((i) => `import "/@slidev-monaco-types/${i}"`),
          `monaco.languages.typescript.typescriptDefaults.addExtraLib(\`declare module "${pkg}" { \${Type} }\`)`
        ].join("\n");
      }
    }
  };
}

// node/plugins/setupClient.ts
init_esm_shims();
import { existsSync as existsSync5 } from "fs";
import { join as join7, resolve as resolve4 } from "path";
import { slash as slash4, uniq as uniq5 } from "@antfu/utils";
function createClientSetupPlugin({ clientRoot, themeRoots, userRoot }) {
  const setupEntry = slash4(resolve4(clientRoot, "setup"));
  return {
    name: "slidev:setup",
    enforce: "pre",
    async transform(code, id) {
      if (id.startsWith(setupEntry)) {
        const name = id.slice(setupEntry.length + 1);
        const imports = [];
        const injections = [];
        const asyncInjections = [];
        const setups = uniq5([
          ...themeRoots,
          userRoot
        ]).map((i) => join7(i, "setup", name));
        setups.forEach((path, idx) => {
          if (!existsSync5(path))
            return;
          imports.push(`import __n${idx} from '${toAtFS(path)}'`);
          let fn = `__n${idx}`;
          let awaitFn = `await __n${idx}`;
          if (/\binjection_return\b/g.test(code)) {
            fn = `injection_return = ${fn}`;
            awaitFn = `injection_return = ${awaitFn}`;
          }
          if (/\binjection_arg\b/g.test(code)) {
            fn += "(injection_arg)";
            awaitFn += "(injection_arg)";
          } else {
            fn += "()";
            awaitFn += "()";
          }
          injections.push(`// ${path}`, fn);
          asyncInjections.push(`// ${path}`, awaitFn);
        });
        code = code.replace("/* __imports__ */", imports.join("\n"));
        code = code.replace("/* __injections__ */", injections.join("\n"));
        code = code.replace("/* __async_injections__ */", asyncInjections.join("\n"));
        return code;
      }
      return null;
    }
  };
}

// node/plugins/markdown.ts
init_esm_shims();
import Markdown2 from "vite-plugin-md";
import base64 from "js-base64";
import { slash as slash5 } from "@antfu/utils";
import mila2 from "markdown-it-link-attributes";
import mif from "markdown-it-footnote";
import * as Shiki from "shiki";
import { encode } from "plantuml-encoder";

// node/plugins/markdown-it-katex.ts
init_esm_shims();
import katex from "katex";
function isValidDelim(state, pos) {
  const max = state.posMax;
  let can_open = true;
  let can_close = true;
  const prevChar = pos > 0 ? state.src.charCodeAt(pos - 1) : -1;
  const nextChar = pos + 1 <= max ? state.src.charCodeAt(pos + 1) : -1;
  if (prevChar === 32 || prevChar === 9 || nextChar >= 48 && nextChar <= 57)
    can_close = false;
  if (nextChar === 32 || nextChar === 9)
    can_open = false;
  return {
    can_open,
    can_close
  };
}
function math_inline(state, silent) {
  let match, token, res, pos;
  if (state.src[state.pos] !== "$")
    return false;
  res = isValidDelim(state, state.pos);
  if (!res.can_open) {
    if (!silent)
      state.pending += "$";
    state.pos += 1;
    return true;
  }
  const start = state.pos + 1;
  match = start;
  while ((match = state.src.indexOf("$", match)) !== -1) {
    pos = match - 1;
    while (state.src[pos] === "\\")
      pos -= 1;
    if ((match - pos) % 2 === 1)
      break;
    match += 1;
  }
  if (match === -1) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (match - start === 0) {
    if (!silent)
      state.pending += "$$";
    state.pos = start + 1;
    return true;
  }
  res = isValidDelim(state, match);
  if (!res.can_close) {
    if (!silent)
      state.pending += "$";
    state.pos = start;
    return true;
  }
  if (!silent) {
    token = state.push("math_inline", "math", 0);
    token.markup = "$";
    token.content = state.src.slice(start, match);
  }
  state.pos = match + 1;
  return true;
}
function math_block(state, start, end, silent) {
  let firstLine;
  let lastLine;
  let next;
  let lastPos;
  let found = false;
  let pos = state.bMarks[start] + state.tShift[start];
  let max = state.eMarks[start];
  if (pos + 2 > max)
    return false;
  if (state.src.slice(pos, pos + 2) !== "$$")
    return false;
  pos += 2;
  firstLine = state.src.slice(pos, max);
  if (silent)
    return true;
  if (firstLine.trim().slice(-2) === "$$") {
    firstLine = firstLine.trim().slice(0, -2);
    found = true;
  }
  for (next = start; !found; ) {
    next++;
    if (next >= end)
      break;
    pos = state.bMarks[next] + state.tShift[next];
    max = state.eMarks[next];
    if (pos < max && state.tShift[next] < state.blkIndent) {
      break;
    }
    if (state.src.slice(pos, max).trim().slice(-2) === "$$") {
      lastPos = state.src.slice(0, max).lastIndexOf("$$");
      lastLine = state.src.slice(pos, lastPos);
      found = true;
    }
  }
  state.line = next + 1;
  const token = state.push("math_block", "math", 0);
  token.block = true;
  token.content = (firstLine && firstLine.trim() ? `${firstLine}
` : "") + state.getLines(start + 1, next, state.tShift[start], true) + (lastLine && lastLine.trim() ? lastLine : "");
  token.map = [start, state.line];
  token.markup = "$$";
  return true;
}
function math_plugin(md2, options) {
  options = options || {};
  const katexInline = function(latex) {
    options.displayMode = false;
    try {
      return katex.renderToString(latex, options);
    } catch (error) {
      if (options.throwOnError)
        console.warn(error);
      return latex;
    }
  };
  const inlineRenderer = function(tokens, idx) {
    return katexInline(tokens[idx].content);
  };
  const katexBlock = function(latex) {
    options.displayMode = true;
    try {
      return `<p>${katex.renderToString(latex, options)}</p>`;
    } catch (error) {
      if (options.throwOnError)
        console.warn(error);
      return latex;
    }
  };
  const blockRenderer = function(tokens, idx) {
    return `${katexBlock(tokens[idx].content)}
`;
  };
  md2.inline.ruler.after("escape", "math_inline", math_inline);
  md2.block.ruler.after("blockquote", "math_block", math_block, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  });
  md2.renderer.rules.math_inline = inlineRenderer;
  md2.renderer.rules.math_block = blockRenderer;
}

// node/plugins/markdown-it-prism.ts
init_esm_shims();
import Prism from "prismjs";
import loadLanguages from "prismjs/components/";
var DEFAULTS = {
  plugins: [],
  init: () => {
  },
  defaultLanguageForUnknown: void 0,
  defaultLanguageForUnspecified: void 0,
  defaultLanguage: void 0
};
function loadPrismLang(lang) {
  if (!lang)
    return void 0;
  let langObject = Prism.languages[lang];
  if (langObject === void 0) {
    loadLanguages([lang]);
    langObject = Prism.languages[lang];
  }
  return langObject;
}
function loadPrismPlugin(name) {
  try {
    __require(`prismjs/plugins/${name}/prism-${name}`);
  } catch (e) {
    throw new Error(`Cannot load Prism plugin "${name}". Please check the spelling.`);
  }
}
function selectLanguage(options, lang) {
  let langToUse = lang;
  if (langToUse === "" && options.defaultLanguageForUnspecified !== void 0)
    langToUse = options.defaultLanguageForUnspecified;
  let prismLang = loadPrismLang(langToUse);
  if (prismLang === void 0 && options.defaultLanguageForUnknown !== void 0) {
    langToUse = options.defaultLanguageForUnknown;
    prismLang = loadPrismLang(langToUse);
  }
  return [langToUse, prismLang];
}
function highlight(markdownit, options, text, lang) {
  const [langToUse, prismLang] = selectLanguage(options, lang);
  const code = text.trimEnd().split(/\r?\n/g).map((line) => prismLang ? Prism.highlight(line, prismLang, langToUse) : markdownit.utils.escapeHtml(line)).map((line) => `<span class="line">${line}</span>`).join("\n");
  const classAttribute = langToUse ? ` class="slidev-code ${markdownit.options.langPrefix}${markdownit.utils.escapeHtml(langToUse)}"` : "";
  return escapeVueInCode(`<pre${classAttribute}><code>${code}</code></pre>`);
}
function checkLanguageOption(options, optionName) {
  const language = options[optionName];
  if (language !== void 0 && loadPrismLang(language) === void 0)
    throw new Error(`Bad option ${optionName}: There is no Prism language '${language}'.`);
}
function markdownItPrism(markdownit, useroptions) {
  const options = Object.assign({}, DEFAULTS, useroptions);
  checkLanguageOption(options, "defaultLanguage");
  checkLanguageOption(options, "defaultLanguageForUnknown");
  checkLanguageOption(options, "defaultLanguageForUnspecified");
  options.defaultLanguageForUnknown = options.defaultLanguageForUnknown || options.defaultLanguage;
  options.defaultLanguageForUnspecified = options.defaultLanguageForUnspecified || options.defaultLanguage;
  options.plugins.forEach(loadPrismPlugin);
  options.init(Prism);
  markdownit.options.highlight = (text, lang) => highlight(markdownit, options, text, lang);
}

// node/plugins/markdown-it-shiki.ts
init_esm_shims();
function getThemeName(theme) {
  if (typeof theme === "string")
    return theme;
  return theme.name;
}
function resolveShikiOptions(options) {
  const themes = [];
  let darkModeThemes;
  if (!options.theme) {
    themes.push("nord");
  } else if (typeof options.theme === "string") {
    themes.push(options.theme);
  } else {
    if ("dark" in options.theme || "light" in options.theme) {
      darkModeThemes = options.theme;
      themes.push(options.theme.dark);
      themes.push(options.theme.light);
    } else {
      themes.push(options.theme);
    }
  }
  return __spreadProps(__spreadValues({}, options), {
    themes,
    darkModeThemes: darkModeThemes ? {
      dark: getThemeName(darkModeThemes.dark),
      light: getThemeName(darkModeThemes.light)
    } : void 0
  });
}
function trimEndNewLine(code) {
  return code.replace(/\n$/, "");
}
var MarkdownItShiki = (markdownit, options = {}) => {
  const _highlighter = options.highlighter;
  const { darkModeThemes } = resolveShikiOptions(options);
  markdownit.options.highlight = (code, lang) => {
    if (darkModeThemes) {
      const trimmed = trimEndNewLine(code);
      const dark = _highlighter.codeToHtml(trimmed, lang || "text", darkModeThemes.dark).replace('<pre class="shiki"', '<pre class="slidev-code shiki shiki-dark"');
      const light = _highlighter.codeToHtml(trimmed, lang || "text", darkModeThemes.light).replace('<pre class="shiki"', '<pre class="slidev-code shiki shiki-light"');
      return escapeVueInCode(`<pre class="shiki-container">${dark}${light}</pre>`);
    } else {
      return escapeVueInCode(_highlighter.codeToHtml(code, lang || "text").replace('<pre class="shiki"', '<pre class="slidev-code shiki"'));
    }
  };
};
var markdown_it_shiki_default = MarkdownItShiki;

// node/plugins/markdown.ts
var DEFAULT_SHIKI_OPTIONS = {
  theme: {
    dark: "min-dark",
    light: "min-light"
  }
};
async function createMarkdownPlugin({ data: { config }, roots, mode, entry }, { markdown: mdOptions }) {
  const setups = [];
  const entryPath = slash5(entry);
  if (config.highlighter === "shiki") {
    const { getHighlighter } = await Promise.resolve().then(() => __toModule(__require("shiki")));
    const shikiOptions = await loadSetups(roots, "shiki.ts", Shiki, DEFAULT_SHIKI_OPTIONS, false);
    const { langs, themes } = resolveShikiOptions(shikiOptions);
    shikiOptions.highlighter = await getHighlighter({ themes, langs });
    setups.push((md2) => md2.use(markdown_it_shiki_default, shikiOptions));
  } else {
    setups.push((md2) => md2.use(markdownItPrism));
  }
  const KatexOptions = await loadSetups(roots, "katex.ts", {}, { strict: false }, false);
  return Markdown2(__spreadProps(__spreadValues({
    wrapperClasses: "",
    headEnabled: false,
    frontmatter: false,
    markdownItOptions: __spreadValues({
      quotes: `""''`,
      html: true,
      xhtmlOut: true,
      linkify: true
    }, mdOptions == null ? void 0 : mdOptions.markdownItOptions)
  }, mdOptions), {
    markdownItSetup(md2) {
      var _a;
      md2.use(mila2, {
        attrs: {
          target: "_blank",
          rel: "noopener"
        }
      });
      md2.use(mif);
      md2.use(math_plugin, KatexOptions);
      setups.forEach((i) => i(md2));
      (_a = mdOptions == null ? void 0 : mdOptions.markdownItSetup) == null ? void 0 : _a.call(mdOptions, md2);
    },
    transforms: {
      before(code, id) {
        if (id === entryPath)
          return "";
        const monaco = config.monaco === true || config.monaco === mode ? transformMarkdownMonaco : truncateMancoMark;
        code = transformSlotSugar(code);
        code = transformMermaid(code);
        code = transformPlantUml(code, config.plantUmlServer);
        code = monaco(code);
        code = transformHighlighter(code);
        code = transformPageCSS(code, id);
        return code;
      }
    }
  }));
}
function transformMarkdownMonaco(md2) {
  md2 = md2.replace(/^```(\w+?)\s*{monaco}\s*?({.*?})?\s*?\n([\s\S]+?)^```/mg, (full, lang = "ts", options = "{}", code) => {
    lang = lang.trim();
    options = options.trim() || "{}";
    const encoded = base64.encode(code, true);
    return `<Monaco :code="'${encoded}'" lang="${lang}" v-bind="${options}" />`;
  });
  return md2;
}
function truncateMancoMark(md2) {
  return md2.replace(/{monaco.*?}/g, "");
}
function transformSlotSugar(md2) {
  const lines = md2.split(/\r?\n/g);
  let prevSlot = false;
  const { isLineInsideCodeblocks } = getCodeBlocks(md2);
  lines.forEach((line, idx) => {
    if (isLineInsideCodeblocks(idx))
      return;
    const match = line.trimRight().match(/^::\s*(\w+)\s*::$/);
    if (match) {
      lines[idx] = `${prevSlot ? "\n\n</template>\n" : "\n"}<template v-slot:${match[1]}="slotProps">
`;
      prevSlot = true;
    }
  });
  if (prevSlot)
    lines[lines.length - 1] += "\n\n</template>";
  return lines.join("\n");
}
function transformHighlighter(md2) {
  return md2.replace(/^```(\w+?)\s*{([\d\w*,\|-]+)}\s*?({.*?})?\s*?\n([\s\S]+?)^```/mg, (full, lang = "", rangeStr, options = "", code) => {
    const ranges = rangeStr.split(/\|/g).map((i) => i.trim());
    code = code.trimEnd();
    options = options.trim() || "{}";
    return `
<CodeHighlightController v-bind="${options}" :ranges='${JSON.stringify(ranges)}'>

\`\`\`${lang}
${code}
\`\`\`

</CodeHighlightController>`;
  });
}
function getCodeBlocks(md2) {
  const codeblocks = Array.from(md2.matchAll(/^```[\s\S]*?^```/mg)).map((m) => {
    var _a, _b;
    const start = m.index;
    const end = m.index + m[0].length;
    const startLine = ((_a = md2.slice(0, start).match(/\n/g)) == null ? void 0 : _a.length) || 0;
    const endLine = ((_b = md2.slice(0, end).match(/\n/g)) == null ? void 0 : _b.length) || 0;
    return [start, end, startLine, endLine];
  });
  return {
    codeblocks,
    isInsideCodeblocks(idx) {
      return codeblocks.some(([s, e]) => s <= idx && idx <= e);
    },
    isLineInsideCodeblocks(line) {
      return codeblocks.some(([, , s, e]) => s <= line && line <= e);
    }
  };
}
function transformPageCSS(md2, id) {
  var _a;
  const page = (_a = id.match(/(\d+)\.md$/)) == null ? void 0 : _a[1];
  if (!page)
    return md2;
  const { isInsideCodeblocks } = getCodeBlocks(md2);
  const result = md2.replace(/(\n<style[^>]*?>)([\s\S]+?)(<\/style>)/g, (full, start, css, end) => {
    const index = md2.indexOf(full);
    if (index < 0 || isInsideCodeblocks(index))
      return full;
    if (!start.includes("scoped"))
      start = start.replace("<style", "<style scoped");
    return `${start}
${css}${end}`;
  });
  return result;
}
function transformMermaid(md2) {
  return md2.replace(/^```mermaid\s*?({.*?})?\n([\s\S]+?)\n```/mg, (full, options = "", code = "") => {
    code = code.trim();
    options = options.trim() || "{}";
    const encoded = base64.encode(code, true);
    return `<Mermaid :code="'${encoded}'" v-bind="${options}" />`;
  });
}
function transformPlantUml(md2, server) {
  return md2.replace(/^```plantuml\s*?({.*?})?\n([\s\S]+?)\n```/mg, (full, options = "", content = "") => {
    const code = encode(content.trim());
    options = options.trim() || "{}";
    return `<PlantUml :code="'${code}'" :server="'${server}'" v-bind="${options}" />`;
  });
}
function escapeVueInCode(md2) {
  return md2.replace(/{{(.*?)}}/g, "&lbrace;&lbrace;$1&rbrace;&rbrace;");
}

// node/plugins/patchTransform.ts
init_esm_shims();
import { objectEntries } from "@antfu/utils";
function createFixPlugins(options) {
  const define = objectEntries(getDefine(options));
  return [
    {
      name: "slidev:flags",
      enforce: "pre",
      transform(code, id) {
        if (id.endsWith(".vue")) {
          define.forEach(([from, to]) => {
            code = code.replace(new RegExp(from, "g"), to);
          });
          return code;
        }
      }
    }
  ];
}

// node/plugins/preset.ts
var customElements = /* @__PURE__ */ new Set([
  "annotation",
  "math",
  "mrow",
  "mcol",
  "mfrac",
  "mi",
  "mn",
  "mo",
  "mover",
  "mspace",
  "mtable",
  "mtd",
  "msup",
  "msqrt",
  "mtr",
  "semantics",
  "mstyle",
  "mtext"
]);
async function ViteSlidevPlugin(options, pluginOptions, serverOptions = {}) {
  const {
    vue: vueOptions = {},
    components: componentsOptions = {},
    icons: iconsOptions = {},
    remoteAssets: remoteAssetsOptions = {}
  } = pluginOptions;
  const {
    mode,
    themeRoots,
    clientRoot,
    data: { config }
  } = options;
  const VuePlugin = Vue(__spreadValues({
    include: [/\.vue$/, /\.md$/],
    exclude: [],
    template: __spreadValues({
      compilerOptions: {
        isCustomElement(tag) {
          return customElements.has(tag);
        }
      }
    }, vueOptions == null ? void 0 : vueOptions.template)
  }, vueOptions));
  const MarkdownPlugin = await createMarkdownPlugin(options, pluginOptions);
  const drawingData = await loadDrawings(options);
  return [
    await createWindiCSSPlugin(options, pluginOptions),
    MarkdownPlugin,
    VuePlugin,
    createSlidesLoader(options, pluginOptions, serverOptions, VuePlugin, MarkdownPlugin),
    Components(__spreadValues({
      extensions: ["vue", "md", "ts"],
      dirs: [
        `${clientRoot}/builtin`,
        `${clientRoot}/components`,
        ...themeRoots.map((i) => `${i}/components`),
        "src/components",
        "components"
      ],
      include: [/\.vue$/, /\.vue\?vue/, /\.md$/],
      exclude: [],
      resolvers: [
        IconsResolver({
          prefix: "",
          customCollections: Object.keys(iconsOptions.customCollections || [])
        })
      ]
    }, componentsOptions)),
    Icons(__spreadValues({
      defaultClass: "slidev-icon",
      autoInstall: true
    }, iconsOptions)),
    config.remoteAssets === true || config.remoteAssets === mode ? RemoteAssets(__spreadValues({
      rules: [
        ...DefaultRules,
        {
          match: /\b(https?:\/\/image.unsplash\.com.*?)(?=[`'")\]])/ig,
          ext: ".png"
        }
      ],
      resolveMode: (id) => id.endsWith("index.html") ? "relative" : "@fs",
      awaitDownload: mode === "build"
    }, remoteAssetsOptions)) : null,
    ServerRef({
      debug: process.env.NODE_ENV === "development",
      state: {
        sync: false,
        nav: {
          page: 0,
          clicks: 0
        },
        drawings: drawingData
      },
      onChanged(key, data, patch) {
        if (!options.data.config.drawings.persist)
          return;
        if (key === "drawings")
          writeDarwings(options, patch != null ? patch : data);
      }
    }),
    createConfigPlugin(options),
    createClientSetupPlugin(options),
    createMonacoTypesLoader(),
    createFixPlugins(options)
  ].flat().filter(notNullish2);
}

export {
  getIndexHtml,
  require_fast_deep_equal,
  createWindiCSSPlugin,
  ViteSlidevPlugin
};
