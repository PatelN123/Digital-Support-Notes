"use strict"; function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _chunkVN5XPBZOjs = require('./chunk-VN5XPBZO.js');






var _chunkXEDZVJCHjs = require('./chunk-XEDZVJCH.js');


var _chunk3ND6GSCFjs = require('./chunk-3ND6GSCF.js');




var _chunkRUL3XRPSjs = require('./chunk-RUL3XRPS.js');

// node/cli.ts
_chunkRUL3XRPSjs.init_cjs_shims.call(void 0, );
var import_fast_deep_equal = _chunkRUL3XRPSjs.__toModule.call(void 0, _chunk3ND6GSCFjs.require_fast_deep_equal.call(void 0, ));
var _path = require('path'); var _path2 = _interopRequireDefault(_path);
var _net = require('net'); var _net2 = _interopRequireDefault(_net);
var _os = require('os'); var _os2 = _interopRequireDefault(_os);
var _child_process = require('child_process');
var _readline = require('readline'); var readline = _interopRequireWildcard(_readline);
var _fsextra = require('fs-extra'); var _fsextra2 = _interopRequireDefault(_fsextra);
var _open = require('open'); var _open2 = _interopRequireDefault(_open);
var _yargs = require('yargs'); var _yargs2 = _interopRequireDefault(_yargs);
var _prompts = require('prompts'); var _prompts2 = _interopRequireDefault(_prompts);
var _kolorist = require('kolorist');
var _fs = require('@slidev/parser/fs'); var parser = _interopRequireWildcard(_fs);
var _isinstalledglobally = require('is-installed-globally'); var _isinstalledglobally2 = _interopRequireDefault(_isinstalledglobally);
var CONFIG_RESTART_FIELDS = [
  "highlighter",
  "monaco",
  "routerMode",
  "fonts"
];
var cli = _yargs2.default.scriptName("slidev").usage("$0 [args]").version(_chunkXEDZVJCHjs.version).strict().showHelpOnFail(false).alias("h", "help").alias("v", "version");
cli.command("* [entry]", "Start a local server for Slidev", (args) => commonOptions(args).option("port", {
  alias: "p",
  type: "number",
  describe: "port"
}).option("open", {
  alias: "o",
  default: false,
  type: "boolean",
  describe: "open in browser"
}).option("remote", {
  default: false,
  type: "boolean",
  describe: "listen public host and enable remote control"
}).option("log", {
  default: "warn",
  type: "string",
  choices: ["error", "warn", "info", "silent"],
  describe: "log level"
}).option("force", {
  alias: "f",
  default: false,
  type: "boolean",
  describe: "force the optimizer to ignore the cache and re-bundle  "
}).strict().help(), async ({ entry, theme, port: userPort, open, log, remote, force }) => {
  if (!_fsextra2.default.existsSync(entry) && !entry.endsWith(".md"))
    entry = `${entry}.md`;
  if (!_fsextra2.default.existsSync(entry)) {
    const { create } = await _prompts2.default.call(void 0, {
      name: "create",
      type: "confirm",
      initial: "Y",
      message: `Entry file ${_kolorist.yellow.call(void 0, `"${entry}"`)} does not exist, do you want to create it?`
    });
    if (create)
      await _fsextra2.default.copyFile(_path2.default.resolve(__dirname, "../template.md"), entry);
    else
      process.exit(0);
  }
  let server;
  let port = 3030;
  async function initServer() {
    if (server)
      await server.close();
    const options = await _chunkXEDZVJCHjs.resolveOptions.call(void 0, { entry, theme }, "dev");
    port = userPort || await findFreePort(3030);
    server = await _chunkVN5XPBZOjs.createServer.call(void 0, options, {
      server: {
        port,
        strictPort: true,
        open,
        host: remote ? "0.0.0.0" : "localhost",
        force
      },
      logLevel: log
    }, {
      onDataReload(newData, data) {
        if (!theme && _chunkXEDZVJCHjs.resolveThemeName.call(void 0, newData.config.theme) !== _chunkXEDZVJCHjs.resolveThemeName.call(void 0, data.config.theme)) {
          console.log(_kolorist.yellow.call(void 0, "\n  restarting on theme change\n"));
          initServer();
        } else if (CONFIG_RESTART_FIELDS.some((i) => !(0, import_fast_deep_equal.default)(newData.config[i], data.config[i]))) {
          console.log(_kolorist.yellow.call(void 0, "\n  restarting on config change\n"));
          initServer();
        }
      }
    });
    await server.listen();
    printInfo(options, port, remote);
  }
  const SHORTCUTS = [
    {
      name: "r",
      fullname: "restart",
      action() {
        initServer();
      }
    },
    {
      name: "o",
      fullname: "open",
      action() {
        _open2.default.call(void 0, `http://localhost:${port}`);
      }
    },
    {
      name: "e",
      fullname: "edit",
      action() {
        _child_process.exec.call(void 0, `code "${entry}"`);
      }
    }
  ];
  function bindShortcut() {
    process.stdin.resume();
    process.stdin.setEncoding("utf8");
    readline.emitKeypressEvents(process.stdin);
    if (process.stdin.isTTY)
      process.stdin.setRawMode(true);
    process.stdin.on("keypress", (str, key) => {
      if (key.ctrl && key.name === "c") {
        process.exit();
      } else {
        const [sh] = SHORTCUTS.filter((item) => item.name === str);
        if (sh) {
          try {
            sh.action();
          } catch (err) {
            console.error(`Failed to execute shortcut ${sh.fullname}`, err);
          }
        }
      }
    });
  }
  initServer();
  bindShortcut();
});
cli.command("build [entry]", "Build hostable SPA", (args) => commonOptions(args).option("watch", {
  alias: "w",
  default: false,
  describe: "build watch"
}).option("out", {
  alias: "o",
  type: "string",
  default: "dist",
  describe: "output dir"
}).option("base", {
  type: "string",
  describe: "output base"
}).option("download", {
  alias: "d",
  type: "boolean",
  describe: "allow download as PDF"
}).strict().help(), async ({ entry, theme, watch, base, download, out }) => {
  const { build } = await Promise.resolve().then(() => _chunkRUL3XRPSjs.__toModule.call(void 0, _chunkRUL3XRPSjs.__require.call(void 0, "./build-LK5RLV7L.js")));
  const options = await _chunkXEDZVJCHjs.resolveOptions.call(void 0, { entry, theme }, "build");
  if (download && !options.data.config.download)
    options.data.config.download = download;
  printInfo(options);
  await build(options, {
    base,
    build: {
      watch: watch ? {} : void 0,
      outDir: out
    }
  });
});
cli.command("format [entry]", "Format the markdown file", (args) => commonOptions(args).strict().help(), async ({ entry }) => {
  const data = await parser.load(entry);
  parser.prettify(data);
  await parser.save(data);
});
cli.command("theme [subcommand]", "Theme related operations", (command) => {
  return command.command("eject", "Eject current theme into local file system", (args) => commonOptions(args).option("dir", {
    type: "string",
    default: "theme"
  }), async ({ entry, dir, theme: themeInput }) => {
    const data = await parser.load(entry);
    const theme = _chunkXEDZVJCHjs.resolveThemeName.call(void 0, themeInput || data.config.theme);
    if (theme === "none") {
      console.error('Can not eject theme "none"');
      process.exit(1);
    }
    if (_chunkXEDZVJCHjs.isPath.call(void 0, theme)) {
      console.error("Theme is already ejected");
      process.exit(1);
    }
    const roots = _chunkXEDZVJCHjs.getThemeRoots.call(void 0, theme, entry);
    if (!roots.length) {
      console.error(`Does not found theme "${theme}"`);
      process.exit(1);
    }
    const root = roots[0];
    await _fsextra2.default.copy(root, _path2.default.resolve(dir), {
      filter: (i) => !/node_modules|.git/.test(_path2.default.relative(root, i))
    });
    const dirPath = `./${dir}`;
    data.slides[0].frontmatter.theme = dirPath;
    data.slides[0].raw = null;
    await parser.save(data);
    console.log(`Theme "${theme}" ejected successfully to "${dirPath}"`);
  });
}, () => {
  cli.showHelp();
  process.exit(1);
});
cli.command("export [entry]", "Export slides to PDF", (args) => commonOptions(args).option("output", {
  type: "string",
  describe: "path to the the port output"
}).option("format", {
  default: "pdf",
  type: "string",
  choices: ["pdf", "png"],
  describe: "output format"
}).option("timeout", {
  default: 100,
  type: "number",
  describe: "timeout for rendering each page"
}).option("range", {
  type: "string",
  describe: 'page ranges to export, for example "1,4-5,6"'
}).option("dark", {
  default: false,
  type: "boolean",
  describe: "export as dark theme"
}).option("with-clicks", {
  alias: "c",
  default: false,
  type: "boolean",
  describe: "export pages for every clicks"
}).strict().help(), async ({
  entry,
  theme,
  output,
  format,
  timeout,
  range,
  dark,
  "with-clicks": withClicks
}) => {
  output = output || `${_path2.default.basename(entry, ".md")}-export`;
  process.env.NODE_ENV = "production";
  const { exportSlides } = await Promise.resolve().then(() => _chunkRUL3XRPSjs.__toModule.call(void 0, _chunkRUL3XRPSjs.__require.call(void 0, "./export-FUMCNU5W.js")));
  const port = await findFreePort(12445);
  const options = await _chunkXEDZVJCHjs.resolveOptions.call(void 0, { entry, theme }, "build");
  const server = await _chunkVN5XPBZOjs.createServer.call(void 0, options, {
    server: { port },
    clearScreen: false
  });
  await server.listen(port);
  printInfo(options);
  parser.filterDisabled(options.data);
  const width = 1920;
  const height = Math.round(width / options.data.config.aspectRatio);
  output = await exportSlides({
    port,
    total: options.data.slides.length,
    range,
    format,
    output,
    timeout,
    dark,
    routerMode: options.data.config.routerMode,
    width,
    height,
    withClicks
  });
  console.log(`${_kolorist.green.call(void 0, "  \u2713 ")}${_kolorist.dim.call(void 0, "exported to ")}./${output}
`);
  server.close();
  process.exit(0);
});
cli.help().parse();
function commonOptions(args) {
  return args.positional("entry", {
    default: "slides.md",
    type: "string",
    describe: "path to the slides markdown entry"
  }).option("theme", {
    alias: "t",
    type: "string",
    describe: "override theme"
  });
}
function printInfo(options, port, remote) {
  console.log();
  console.log();
  console.log(`  ${_kolorist.cyan.call(void 0, "\u25CF") + _kolorist.blue.call(void 0, "\u25A0") + _kolorist.yellow.call(void 0, "\u25B2")}`);
  console.log(`${_kolorist.bold.call(void 0, "  Slidev")}  ${_kolorist.blue.call(void 0, `v${_chunkXEDZVJCHjs.version}`)} ${_isinstalledglobally2.default ? _kolorist.yellow.call(void 0, "(global)") : ""}`);
  console.log();
  console.log(_kolorist.dim.call(void 0, "  theme   ") + (options.theme ? _kolorist.green.call(void 0, options.theme) : _kolorist.gray.call(void 0, "none")));
  console.log(_kolorist.dim.call(void 0, "  entry   ") + _kolorist.dim.call(void 0, _path2.default.dirname(options.entry) + _path2.default.sep) + _path2.default.basename(options.entry));
  if (port) {
    const presenterPath = `${options.data.config.routerMode === "hash" ? "/#/" : "/"}presenter`;
    console.log();
    console.log(`${_kolorist.dim.call(void 0, "  slide show     ")} > ${_kolorist.cyan.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}/`)}`);
    console.log(`${_kolorist.dim.call(void 0, "  presenter mode ")} > ${_kolorist.blue.call(void 0, `http://localhost:${_kolorist.bold.call(void 0, port)}${presenterPath}`)}`);
    if (remote) {
      Object.values(_os2.default.networkInterfaces()).forEach((v) => (v || []).filter((details) => details.family === "IPv4" && !details.address.includes("127.0.0.1")).forEach(({ address }) => {
        console.log(`${_kolorist.dim.call(void 0, "  remote control ")} > ${_kolorist.blue.call(void 0, `http://${address}:${port}${presenterPath}`)}`);
      }));
    } else {
      console.log(`${_kolorist.dim.call(void 0, "  remote control ")} > ${_kolorist.dim.call(void 0, "pass --remote to enable")}`);
    }
    console.log();
    console.log(`${_kolorist.dim.call(void 0, "  shortcuts ")}      > ${_kolorist.underline.call(void 0, "r")}${_kolorist.dim.call(void 0, "estart | ")}${_kolorist.underline.call(void 0, "o")}${_kolorist.dim.call(void 0, "pen | ")}${_kolorist.underline.call(void 0, "e")}${_kolorist.dim.call(void 0, "dit")}`);
  }
  console.log();
  console.log();
}
function isPortFree(port) {
  return new Promise((resolve) => {
    const server = _net2.default.createServer((socket) => {
      socket.write("Echo server\r\n");
      socket.pipe(socket);
    });
    server.listen(port, "127.0.0.1");
    server.on("error", () => {
      resolve(false);
    });
    server.on("listening", () => {
      server.close();
      resolve(true);
    });
  });
}
async function findFreePort(start) {
  if (await isPortFree(start))
    return start;
  return findFreePort(start + 1);
}
