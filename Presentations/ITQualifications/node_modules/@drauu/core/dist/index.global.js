(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = typeof require !== "undefined" ? require : (x) => {
    throw new Error('Dynamic require of "' + x + '" is not supported');
  };
  var __reExport = (target, module, desc) => {
    if (module && typeof module === "object" || typeof module === "function") {
      for (let key of __getOwnPropNames(module))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module) => {
    return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", module && module.__esModule && "default" in module ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
  };

  // ../../node_modules/.pnpm/nanoevents@6.0.1/node_modules/nanoevents/index.js
  var createNanoEvents = () => ({
    events: {},
    emit(event, ...args) {
      ;
      (this.events[event] || []).forEach((i) => i(...args));
    },
    on(event, cb) {
      ;
      (this.events[event] = this.events[event] || []).push(cb);
      return () => this.events[event] = (this.events[event] || []).filter((i) => i !== cb);
    }
  });

  // src/models/stylus.ts
  var import_perfect_freehand = __toModule(__require("perfect-freehand"));

  // src/utils/index.ts
  function numSort(a, b) {
    return a - b;
  }
  function getSymbol(a) {
    if (a < 0)
      return -1;
    return 1;
  }
  function splitNum(a) {
    return [Math.abs(a), getSymbol(a)];
  }
  function guid() {
    const S4 = () => ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
    return `${S4() + S4()}-${S4()}-${S4()}-${S4()}-${S4()}${S4()}${S4()}`;
  }
  var DECIMAL = 2;
  var D = DECIMAL;

  // src/models/base.ts
  var BaseModel = class {
    constructor(drauu) {
      this.drauu = drauu;
      this.event = void 0;
      this.point = void 0;
      this.start = void 0;
      this.el = null;
    }
    onStart(point) {
      return void 0;
    }
    onMove(point) {
      return false;
    }
    onEnd(point) {
      return void 0;
    }
    get brush() {
      return this.drauu.brush;
    }
    get shiftPressed() {
      return this.drauu.shiftPressed;
    }
    get altPressed() {
      return this.drauu.altPressed;
    }
    getMousePosition(event) {
      var _a, _b;
      const el = this.drauu.el;
      const scale = (_a = this.drauu.options.coordinateScale) != null ? _a : 1;
      if (this.drauu.options.coordinateTransform === false) {
        const rect = this.drauu.el.getBoundingClientRect();
        return {
          x: (event.pageX - rect.left) * scale,
          y: (event.pageY - rect.top) * scale,
          pressure: event.pressure
        };
      } else {
        const point = this.drauu.svgPoint;
        point.x = event.clientX;
        point.y = event.clientY;
        const loc = point.matrixTransform((_b = el.getScreenCTM()) == null ? void 0 : _b.inverse());
        return {
          x: loc.x * scale,
          y: loc.y * scale,
          pressure: event.pressure
        };
      }
    }
    createElement(name, overrides) {
      var _a;
      const el = document.createElementNS("http://www.w3.org/2000/svg", name);
      const brush = overrides ? __spreadValues(__spreadValues({}, this.brush), overrides) : this.brush;
      el.setAttribute("fill", (_a = brush.fill) != null ? _a : "transparent");
      el.setAttribute("stroke", brush.color);
      el.setAttribute("stroke-width", brush.size.toString());
      el.setAttribute("stroke-linecap", "round");
      if (brush.dasharray)
        el.setAttribute("stroke-dasharray", brush.dasharray);
      return el;
    }
    attr(name, value) {
      this.el.setAttribute(name, typeof value === "string" ? value : value.toFixed(D));
    }
    _setEvent(event) {
      this.event = event;
      this.point = this.getMousePosition(event);
    }
    _eventDown(event) {
      this._setEvent(event);
      this.start = this.point;
      return this.onStart(this.point);
    }
    _eventMove(event) {
      this._setEvent(event);
      return this.onMove(this.point);
    }
    _eventUp(event) {
      this._setEvent(event);
      return this.onEnd(this.point);
    }
  };

  // src/models/stylus.ts
  var StylusModel = class extends BaseModel {
    constructor() {
      super(...arguments);
      this.points = [];
    }
    onStart(point) {
      this.el = document.createElementNS("http://www.w3.org/2000/svg", "path");
      this.points = [point];
      this.attr("fill", this.brush.color);
      this.attr("d", this.getSvgData(this.points));
      return this.el;
    }
    onMove(point) {
      if (!this.el)
        this.onStart(point);
      if (this.points[this.points.length - 1] !== point)
        this.points.push(point);
      this.attr("d", this.getSvgData(this.points));
      return true;
    }
    onEnd() {
      const path = this.el;
      this.el = null;
      if (!path)
        return false;
      return true;
    }
    getSvgData(points) {
      const stroke = (0, import_perfect_freehand.default)(points, __spreadValues({
        size: this.brush.size * 2,
        thinning: 0.9,
        simulatePressure: false,
        start: {
          taper: 5
        },
        end: {
          taper: 5
        }
      }, this.brush.stylusOptions));
      if (!stroke.length)
        return "";
      const d = stroke.reduce((acc, [x0, y0], i, arr) => {
        const [x1, y1] = arr[(i + 1) % arr.length];
        acc.push(x0, y0, (x0 + x1) / 2, (y0 + y1) / 2);
        return acc;
      }, ["M", ...stroke[0], "Q"]);
      d.push("Z");
      return d.map((i) => typeof i === "number" ? i.toFixed(2) : i).join(" ");
    }
  };

  // src/models/ellipse.ts
  var EllipseModel = class extends BaseModel {
    onStart(point) {
      this.el = this.createElement("ellipse");
      this.attr("cx", point.x);
      this.attr("cy", point.y);
      return this.el;
    }
    onMove(point) {
      if (!this.el || !this.start)
        return false;
      let [dx, sx] = splitNum(point.x - this.start.x);
      let [dy, sy] = splitNum(point.y - this.start.y);
      if (this.shiftPressed) {
        const d = Math.min(dx, dy);
        dx = d;
        dy = d;
      }
      if (this.altPressed) {
        this.attr("cx", this.start.x);
        this.attr("cy", this.start.y);
        this.attr("rx", dx);
        this.attr("ry", dy);
      } else {
        const [x1, x2] = [this.start.x, this.start.x + dx * sx].sort(numSort);
        const [y1, y2] = [this.start.y, this.start.y + dy * sy].sort(numSort);
        this.attr("cx", (x1 + x2) / 2);
        this.attr("cy", (y1 + y2) / 2);
        this.attr("rx", (x2 - x1) / 2);
        this.attr("ry", (y2 - y1) / 2);
      }
      return true;
    }
    onEnd() {
      const path = this.el;
      this.el = null;
      if (!path)
        return false;
      if (!path.getTotalLength())
        return false;
      return true;
    }
  };

  // src/utils/dom.ts
  function createArrowHead(id, fill) {
    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    const head = document.createElementNS("http://www.w3.org/2000/svg", "path");
    head.setAttribute("fill", fill);
    marker.setAttribute("id", id);
    marker.setAttribute("viewBox", "0 -5 10 10");
    marker.setAttribute("refX", "5");
    marker.setAttribute("refY", "0");
    marker.setAttribute("markerWidth", "4");
    marker.setAttribute("markerHeight", "4");
    marker.setAttribute("orient", "auto");
    head.setAttribute("d", "M0,-5L10,0L0,5");
    marker.appendChild(head);
    defs.appendChild(marker);
    return defs;
  }

  // src/models/line.ts
  var LineModel = class extends BaseModel {
    onStart(point) {
      this.el = this.createElement("line", { fill: "transparent" });
      this.attr("x1", point.x);
      this.attr("y1", point.y);
      this.attr("x2", point.x);
      this.attr("y2", point.y);
      if (this.brush.arrowEnd) {
        const id = guid();
        const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g.append(createArrowHead(id, this.brush.color));
        g.append(this.el);
        this.attr("marker-end", `url(#${id})`);
        return g;
      }
      return this.el;
    }
    onMove(point) {
      if (!this.el)
        return false;
      let { x, y } = point;
      if (this.shiftPressed) {
        const dx = point.x - this.start.x;
        const dy = point.y - this.start.y;
        if (dy !== 0) {
          let slope = dx / dy;
          slope = Math.round(slope);
          if (Math.abs(slope) <= 1) {
            x = this.start.x + dy * slope;
            y = this.start.y + dy;
          } else {
            x = this.start.x + dx;
            y = this.start.y;
          }
        }
      }
      if (this.altPressed) {
        this.attr("x1", this.start.x * 2 - x);
        this.attr("y1", this.start.y * 2 - y);
        this.attr("x2", x);
        this.attr("y2", y);
      } else {
        this.attr("x1", this.start.x);
        this.attr("y1", this.start.y);
        this.attr("x2", x);
        this.attr("y2", y);
      }
      return true;
    }
    onEnd() {
      const path = this.el;
      this.el = null;
      if (!path)
        return false;
      if (path.getTotalLength() < 5)
        return false;
      return true;
    }
  };

  // src/models/rect.ts
  var RectModel = class extends BaseModel {
    onStart(point) {
      this.el = this.createElement("rect");
      if (this.brush.cornerRadius) {
        this.attr("rx", this.brush.cornerRadius);
        this.attr("ry", this.brush.cornerRadius);
      }
      this.attr("x", point.x);
      this.attr("y", point.y);
      return this.el;
    }
    onMove(point) {
      if (!this.el || !this.start)
        return false;
      let [dx, sx] = splitNum(point.x - this.start.x);
      let [dy, sy] = splitNum(point.y - this.start.y);
      if (this.shiftPressed) {
        const d = Math.min(dx, dy);
        dx = d;
        dy = d;
      }
      if (this.altPressed) {
        this.attr("x", this.start.x - dx);
        this.attr("y", this.start.y - dy);
        this.attr("width", dx * 2);
        this.attr("height", dy * 2);
      } else {
        const [x1, x2] = [this.start.x, this.start.x + dx * sx].sort(numSort);
        const [y1, y2] = [this.start.y, this.start.y + dy * sy].sort(numSort);
        this.attr("x", x1);
        this.attr("y", y1);
        this.attr("width", x2 - x1);
        this.attr("height", y2 - y1);
      }
      return true;
    }
    onEnd() {
      const path = this.el;
      this.el = null;
      if (!path)
        return false;
      if (!path.getTotalLength())
        return false;
      return true;
    }
  };

  // src/utils/simplify.ts
  function getSqDist(p1, p2) {
    const dx = p1.x - p2.x;
    const dy = p1.y - p2.y;
    return dx * dx + dy * dy;
  }
  function getSqSegDist(p, p1, p2) {
    let x = p1.x;
    let y = p1.y;
    let dx = p2.x - x;
    let dy = p2.y - y;
    if (dx !== 0 || dy !== 0) {
      const t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);
      if (t > 1) {
        x = p2.x;
        y = p2.y;
      } else if (t > 0) {
        x += dx * t;
        y += dy * t;
      }
    }
    dx = p.x - x;
    dy = p.y - y;
    return dx * dx + dy * dy;
  }
  function simplifyRadialDist(points, sqTolerance) {
    let prevPoint = points[0];
    const newPoints = [prevPoint];
    let point;
    for (let i = 1, len = points.length; i < len; i++) {
      point = points[i];
      if (getSqDist(point, prevPoint) > sqTolerance) {
        newPoints.push(point);
        prevPoint = point;
      }
    }
    if (prevPoint !== point && point)
      newPoints.push(point);
    return newPoints;
  }
  function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    let maxSqDist = sqTolerance;
    let index = 0;
    for (let i = first + 1; i < last; i++) {
      const sqDist = getSqSegDist(points[i], points[first], points[last]);
      if (sqDist > maxSqDist) {
        index = i;
        maxSqDist = sqDist;
      }
    }
    if (maxSqDist > sqTolerance) {
      if (index - first > 1)
        simplifyDPStep(points, first, index, sqTolerance, simplified);
      simplified.push(points[index]);
      if (last - index > 1)
        simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
  }
  function simplifyDouglasPeucker(points, sqTolerance) {
    const last = points.length - 1;
    const simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);
    return simplified;
  }
  function simplify(points, tolerance, highestQuality = false) {
    if (points.length <= 2)
      return points;
    const sqTolerance = tolerance !== void 0 ? tolerance * tolerance : 1;
    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);
    return points;
  }

  // src/models/draw.ts
  var DrawModel = class extends BaseModel {
    constructor() {
      super(...arguments);
      this.points = [];
      this.count = 0;
    }
    onStart(point) {
      this.el = this.createElement("path", { fill: "transparent" });
      this.points = [point];
      if (this.brush.arrowEnd) {
        this.arrowId = guid();
        const head = createArrowHead(this.arrowId, this.brush.color);
        this.el.appendChild(head);
      }
      return this.el;
    }
    onMove(point) {
      if (!this.el)
        this.onStart(point);
      if (this.points[this.points.length - 1] !== point) {
        this.points.push(point);
        this.count += 1;
      }
      if (this.count > 5) {
        this.points = simplify(this.points, 1, true);
        this.count = 0;
      }
      this.attr("d", toSvgData(this.points));
      return true;
    }
    onEnd() {
      const path = this.el;
      this.el = null;
      if (!path)
        return false;
      path.setAttribute("d", toSvgData(simplify(this.points, 1, true)));
      if (!path.getTotalLength())
        return false;
      return true;
    }
  };
  function line(a, b) {
    const lengthX = b.x - a.x;
    const lengthY = b.y - a.y;
    return {
      length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),
      angle: Math.atan2(lengthY, lengthX)
    };
  }
  function controlPoint(current, previous, next, reverse) {
    const p = previous || current;
    const n = next || current;
    const smoothing = 0.2;
    const o = line(p, n);
    const angle = o.angle + (reverse ? Math.PI : 0);
    const length = o.length * smoothing;
    const x = current.x + Math.cos(angle) * length;
    const y = current.y + Math.sin(angle) * length;
    return { x, y };
  }
  function bezierCommand(point, i, points) {
    const cps = controlPoint(points[i - 1], points[i - 2], point);
    const cpe = controlPoint(point, points[i - 1], points[i + 1], true);
    return `C ${cps.x.toFixed(D)},${cps.y.toFixed(D)} ${cpe.x.toFixed(D)},${cpe.y.toFixed(D)} ${point.x.toFixed(D)},${point.y.toFixed(D)}`;
  }
  function toSvgData(points) {
    return points.reduce((acc, point, i, a) => i === 0 ? `M ${point.x.toFixed(D)},${point.y.toFixed(D)}` : `${acc} ${bezierCommand(point, i, a)}`, "");
  }

  // src/models/index.ts
  function createModels(drauu) {
    return {
      draw: new DrawModel(drauu),
      stylus: new StylusModel(drauu),
      line: new LineModel(drauu),
      rectangle: new RectModel(drauu),
      ellipse: new EllipseModel(drauu)
    };
  }

  // src/drauu.ts
  var Drauu = class {
    constructor(options = {}) {
      this.options = options;
      this.el = null;
      this.svgPoint = null;
      this.eventEl = null;
      this.shiftPressed = false;
      this.altPressed = false;
      this.drawing = false;
      this._emitter = createNanoEvents();
      this._models = createModels(this);
      this._undoStack = [];
      this._disposables = [];
      if (!this.options.brush)
        this.options.brush = { color: "black", size: 3, mode: "stylus" };
      if (options.el)
        this.mount(options.el, options.eventTarget);
    }
    get model() {
      return this._models[this.mode];
    }
    get mounted() {
      return !!this.el;
    }
    get mode() {
      return this.options.brush.mode || "stylus";
    }
    set mode(v) {
      this.options.brush.mode = v;
    }
    get brush() {
      return this.options.brush;
    }
    set brush(v) {
      this.options.brush = v;
    }
    resolveSelector(selector) {
      if (typeof selector === "string")
        return document.querySelector(selector);
      else
        return selector || null;
    }
    mount(el, eventEl) {
      if (this.el)
        throw new Error("[drauu] already mounted, unmount previous target first");
      this.el = this.resolveSelector(el);
      if (!this.el)
        throw new Error("[drauu] target element not found");
      if (this.el.tagName.toLocaleLowerCase() !== "svg")
        throw new Error("[drauu] can only mount to a SVG element");
      if (!this.el.createSVGPoint) {
        throw new Error("[drauu] SVG element must be create by document.createElementNS('http://www.w3.org/2000/sv', 'svg')");
      }
      this.svgPoint = this.el.createSVGPoint();
      const target = this.resolveSelector(eventEl) || this.el;
      const start = this.eventStart.bind(this);
      const move = this.eventMove.bind(this);
      const end = this.eventEnd.bind(this);
      const keyboard = this.eventKeyboard.bind(this);
      target.addEventListener("pointerdown", start, { passive: false });
      window.addEventListener("pointermove", move, { passive: false });
      window.addEventListener("pointerup", end, { passive: false });
      window.addEventListener("pointercancel", end, { passive: false });
      window.addEventListener("keydown", keyboard, false);
      window.addEventListener("keyup", keyboard, false);
      this._disposables.push(() => {
        target.removeEventListener("pointerdown", start);
        window.removeEventListener("pointermove", move);
        window.removeEventListener("pointerup", end);
        window.removeEventListener("pointercancel", end);
        window.removeEventListener("keydown", keyboard, false);
        window.removeEventListener("keyup", keyboard, false);
      });
      this._emitter.emit("mounted");
    }
    unmount() {
      this._disposables.forEach((fn) => fn());
      this._disposables.length = 0;
      this.el = null;
      this._emitter.emit("unmounted");
    }
    on(type, fn) {
      return this._emitter.on(type, fn);
    }
    undo() {
      const el = this.el;
      if (!el.lastElementChild)
        return false;
      this._undoStack.push(el.lastElementChild.cloneNode(true));
      el.lastElementChild.remove();
      this._emitter.emit("changed");
      return true;
    }
    redo() {
      if (!this._undoStack.length)
        return false;
      this.el.appendChild(this._undoStack.pop());
      this._emitter.emit("changed");
      return true;
    }
    canRedo() {
      return !!this._undoStack.length;
    }
    canUndo() {
      var _a;
      return !!((_a = this.el) == null ? void 0 : _a.lastElementChild);
    }
    eventMove(event) {
      if (!this.acceptsInput(event) || !this.drawing)
        return;
      if (this.model._eventMove(event)) {
        event.stopPropagation();
        event.preventDefault();
        this._emitter.emit("changed");
      }
    }
    eventStart(event) {
      if (!this.acceptsInput(event))
        return;
      event.stopPropagation();
      event.preventDefault();
      if (this._currentNode)
        this.cancel();
      this.drawing = true;
      this._emitter.emit("start");
      this._currentNode = this.model._eventDown(event);
      if (this._currentNode)
        this.el.appendChild(this._currentNode);
      this._emitter.emit("changed");
    }
    eventEnd(event) {
      if (!this.acceptsInput(event) || !this.drawing)
        return;
      const result = this.model._eventUp(event);
      if (!result) {
        this.cancel();
      } else {
        if (result instanceof Element && result !== this._currentNode)
          this._currentNode = result;
        this.commit();
      }
      this.drawing = false;
      this._emitter.emit("end");
      this._emitter.emit("changed");
    }
    acceptsInput(event) {
      return !this.options.acceptsInputTypes || this.options.acceptsInputTypes.includes(event.pointerType);
    }
    eventKeyboard(event) {
      if (this.shiftPressed === event.shiftKey && this.altPressed === event.altKey)
        return;
      this.shiftPressed = event.shiftKey;
      this.altPressed = event.altKey;
      if (this.model.point) {
        if (this.model.onMove(this.model.point))
          this._emitter.emit("changed");
      }
    }
    commit() {
      this._undoStack.length = 0;
      const node = this._currentNode;
      this._currentNode = void 0;
      this._emitter.emit("committed", node);
    }
    clear() {
      this._undoStack.length = 0;
      this.cancel();
      this.el.innerHTML = "";
      this._emitter.emit("changed");
    }
    cancel() {
      if (this._currentNode) {
        this.el.removeChild(this._currentNode);
        this._currentNode = void 0;
        this._emitter.emit("canceled");
      }
    }
    dump() {
      return this.el.innerHTML;
    }
    load(svg) {
      this.clear();
      this.el.innerHTML = svg;
    }
  };
  function createDrauu(options) {
    return new Drauu(options);
  }
})();
